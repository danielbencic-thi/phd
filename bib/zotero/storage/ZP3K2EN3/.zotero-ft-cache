IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Typesetting math: 100%

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

        Cart 
        Create Account
        Personal Sign In 

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Conferences > 2016 11th ACM/IEEE Internatio...
Homotopy-aware RRT: Toward human-robot topological path-planning
Publisher: IEEE
Cite This
PDF
Daqing Yi ; Michael A. Goodrich ; Kevin D. Seppi
All Authors
View Document
14
Paper
Citations
499
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Related Work
    III.
    Homotopic String Classes
    IV.
    Homotopy-Aware RRT*
    V.
    Experiments

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
More Like This

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: An important problem in human-robot interaction is for a human to be able to tell the robot go to a particular location with instructions on how to get there or what to a... View more
Metadata
Abstract:
An important problem in human-robot interaction is for a human to be able to tell the robot go to a particular location with instructions on how to get there or what to avoid on the way. This paper provides a solution to problems where the human wants the robot not only to optimize some objective but also to honor “soft” or “hard” topological constraints, i.e. “go quickly from A to B while avoiding C”. The paper presents the HARRT* (homotopy-aware RRT*) algorithm, which is a computationally scalable algorithm that a robot can use to plan optimal paths subject to the information provided by the human. The paper provides a theoretic justification for the key property of the algorithm, proposes a heuristic for RRT*, and uses a set of simulation case studies of the resulting algorithm to make a case for why these properties are compatible with the requirements of human-robot interactive path-planning.
Published in: 2016 11th ACM/IEEE International Conference on Human-Robot Interaction (HRI)
Date of Conference: 07-10 March 2016
Date Added to IEEE Xplore : 14 April 2016
ISBN Information:
Electronic ISSN: 2167-2148
INSPEC Accession Number: 15921883
DOI: 10.1109/HRI.2016.7451763
Publisher: IEEE
Conference Location: Christchurch, New Zealand
Contents
SECTION I.
Introduction

In search and rescue, police, and military applications of human-robot teaming, a human may want to tell a robot to go to a particular location while giving information that the robot should use to decide what path to take. This is a form of interaction that requires a robot to plan a path that honors the human's intent. In this paper, we focus on two useful elements of intent: the shape and quality of the planned path. Although algorithms exist to implement path properties like continuity and smoothness, there appears to be no algorithm that is computationally tractable while being powerful enough to honor both shape and quality aspects of a path. Such an algorithm would support human instructions like “go quickly around building A and then between the two trees while avoiding region C.” In this paper, we present an algorithm that optimizes path quality while allowing a human to specify regions to avoid, preferences for directions of traveling around obstacles, via-point/waypoint constraints, and reference path constraints [1] .

The contribution of this paper (a) is a computationally efficient algorithm for detecting when two paths are homotopic that (b) can be used as a heuristic for an RRT* planner to restrict search to a given homotopy class, where (c) the planning is done by the robot and (d) the optimization criteria and shape constraint is specified by the human. The specific contribution to human-robot interaction is that these properties, supported by simulation results, create a set of path affordances that allow a human to specify a wide range of shape constraints and objective preferences that the robot honors in path-planning.

The key to this algorithm is the topological concept of homotopy , which is a mathematical formalism of the inherent similarity or dissimilarity of two paths. Given two paths σ 1 and σ 2 with the same endpoints, if one can be continuously deformed into the other without encroaching any obstacle and without moving the endpoints then they are said to be homotopic [2] , [3] . We write this as σ 1 ≃ σ 2 . In a slight abuse of notation, we say that two sets of paths are homotopic Γ 1 ≃ Γ 2 if all paths in the sets are homotopic.

We restrict attention to paths that start at a given initial position x i n x t and end at a given terminal position x g o a l and group the set of all such possible paths into classes according to their shape properties. Formally, the set of paths that are homotopic to each other form a homotopy class , and the set of homotopy classes partition the set of all possible paths between any two positions x i n i t and x g o a l . In an environment containing obstacles, we argue that this homotopy partition, provides a mapping between a human-based or colloquial use of the term “shape” and the corresponding topological notion.

Theoretically, there exist infinite homotopy classes, because an obstacle can be encircled an arbitrary number of times. With some loss of generality, we impose the following:
Restriction 1

We consider only “simple paths”, that is, paths that do not form complete loops around obstacles .

We can now define the problem the algorithm must solve.
Definition 1 .
Homotopy-Based Optimal Path-Plan-nine

Let X ⊂ R d denote a bounded connected open set , X o b s ⊂ X an obstacle space , X f r e e = X ∖ X o b s the obstacle-free space , x i n i t an initial state, and x g o a l a goal state. Define a path in X as a continuous curve parameterized by s as σ ( s ) : [ 0 , 1 ] → X . Denote the monotonic increasing cost of the path as Cost ( σ ) . Let H H ( x i n i t , x g o a l ) denote the set of homotopy classes defined by x i n i t ∈ X f r e e and x g o a l ∈ X f r e e ,   H = h 1 , ⋯ , h N ⊆ H H a particular subset of homotopy classes, and h ( σ ) the homotopy class of σ . The goal is to find paths σ ∗ h i ∈ Σ ∗ , h i ∈ H such that ( a )   ∀ s ∈ [ 0 , 1 ] , σ ∗ ( s ) h i ∈ X f r e e ; ( b )   σ ∗ h i ( 0 ) = x i n i I and σ ∗ h i ( 1 ) = x g o a l ; and ( c )   ∀ h i   ∈ H , σ ∗ h i = arg min σ ∈ X f r e e ∧ h ( σ ) = h i . Cost ( σ ) .

Definition 1 says that, given a particular set of homotopy classes and a cost function, the planner should find paths that minimize the cost in the given homotopy classes.
SECTION II.
Related Work

From the human side of the HRI problem, many researchers have noted that humans often represent the world using topological rather than metric-based mental models [4] . Various methods have been used to create topological representations that can be used by path-planners for robots [5] , [6] , [7] , [8] . Because these planners represent the relationships between landmarks as a graph and then plan paths using a graph-search algorithm, they satisfy strict topological constraints but do not minimize Cost ( σ ) .

Homotopy-based path-planning should enable a combination of constraints and continuous objectives, but determining the homotopic equivalence of two paths is usually computationally expensive or not general. For example, the Voronoi diagram is used to identify a path from any homotopy class in [9] , but this algorithm has limitations when there are certain kinds of complex obstacles in the world. A so-called funnel algorithm in the universal covering space yields an improvement [10] , but complexity does not scale well when obstacles are not smooth and convex.

Other algorithms for finding homotopic equivalence include (a) using semi-algebraic cuts to convert a candidate path into a “word” [11] and (b) converting a plane into a complex plane and then finding invariant properties of the paths in this plane [2] . Unfortunately, their performance depends on how the map is discretized; computation cost expands greatly if the obstacles are reasonably approximated by a high resolution discretization.

Homotopies have been used in sampling-based algorithms. In a probabilistic road map structure, the paths can be categorized into homotopy classes using a method called homotopic redundancy [12] . Another approach is to divide the space using a set of reference frames crossing each obstacle [13] . This method is particularly relevant because, as we shall show, how a path crosses the reference frames can be represented as a canonical sequence and comparing the sequences allows homotopic equivalence to be determined. We extend the ideas in these algorithms to enable optimal path-planning within a more complete set of homotopic ally equivalent paths. To accomplish this, we use a variation of the bidirectional RRT* algorithm [14] , which is more efficient than the original [15] .
SECTION III.
Homotopic String Classes

This section shows how to create a string-based representation of any simple path, and then use the easy-to-compute strings to efficiently identify homotopic equivalence.
A. Generating String Representations

Strings are generated using an improved method of Jenkins' approach [16] to detecting homotopic equivalence of two paths by separating a map into disjoint subregions [17] . A reference frame segment, which Jenkins called a reference frame , is a line segment constructed from a center point and a point in a obstacle, extended to the map boundaries. The collection of reference frames created from a set of obstacles partition the map into disjoint subregions. Figure 1a shows an example of a map with two obstacles and two reference frames (blue and green dashed lines) - one for each obstacle. Strings will be constructed based on the simple idea that if two paths cross the same sequences of reference frames, then they belong to the same homotopy class.
Fig. 1: - Map with obstacles.
Fig. 1:

Map with obstacles.

Show All

In Algorithm 1 , the reference frames R R are created from a set of points that are generated as follows: In a map with a set of obstacle regions B B , an obstacle point b k is randomly sampled from each obstacle region B k ∈ B B . A center point c is then randomly sampled in the non-obstacle region X X f r e e = X X ∖ B B subject to the constraint that it is not in any line that connects two different b k . Connecting each b k with c creates a radial structure of reference frames that partition the map.
Algorithm 1 Initrefframes ( X X f r e e ,   B B )

Algorithm

The method Line ( p 1 , p 2 ) returns the line defined by p 1 and p 2 , and the method Intersect ( r ,   B B ,   c ) returns all segments of line r that don't intersect with an obstacle in B B or the center point c .

If we assign an ID character to each reference frame, then how a path sequentially crosses the reference frames can be converted into a string of ID characters. For example, in Figure 1a , the path that starts in subregion S 4 − 0 and ends in subregion S 1 − 1 . Sequentially visits the reference frames α 1 , 1 , α 2 , 2 , α 2 , 3 • Concatenating these characters yields the path string α 1 , 1 α 2 , 2 α 2 , 3 . A deterministic finite automata (DFA) formalizes this process; see Figure 1b .
Definition 2

Let M M = ( S S ,   R R ,   δ ,   S 0 ,   S T ) be a DFA that represents the string generation process from a path, where S S is a set of subregions , R R is a set of reference frames , S 0 ∈ S S is the start subregion , S T ∈ S S is the end subregion, and δ : S S × R R → S S is the transition function that defines how one subregion transitions to another subregion by crossing one reference frame in R . A string v is created as follows:

    v is initialized asan empty s t r i n g   ε ,

    The path starts at x i n i t ∈ S 0 and ends at x g o a l ∈ S T .

    When there is a transition across a reference frame r ∈ R R , v ← v r .

Thus, v is the string generated by a path through the map using M M . A string block Γ v is the set of all paths that generate string v . We now develop conditions under which a set of string blocks partition the set of all simple paths into a set of disjoint homotopy classes. We present these as a series of properties, lemmas, and theorems.

Recall that we are restricting attention to simple paths, and let Γ denote the set of all simple paths. We begin with properties of paths and the strings that they generate through M M . Property 1 states that there are a finite number of unique strings generated by M M that induce a partition over the Γ .
Property 1

Γ = ⋃ m i = 1 Γ v i and v i ≠ v j ⇒ Γ v i ∩ Γ v j = ∅ . The second property is that ≃ is an equivalence relation.
Property 2

≃ i n   Γ v i ≃ Γ v j is an equivalence relation .

Property 3 states that two paths are homotopic when they belong to the same string block Γ v . In other words, if σ i and σ j generate the same string v , σ i and σ j are homotopic.
Property 3

∀ σ i , σ j ∈ Γ v , σ i ≃ σ j ·

Property 4 states that if two touching paths σ i and σ j are concatenated together to form σ i   ∘   σ j then M M generates a string v i v j that is the concatenation of the strings generated by the two individual paths v i and v j .
Property 4

If σ i ∈ Γ v i , σ j ∈ Γ v j and σ i ( 1 ) = σ j ( 0 ) then , σ i   ∘   σ j ∈ Γ v i v j .

To determine the homotopic equivalence of two paths that belong to different string blocks, we remove an ambiguity from M . Observe that the reference frames form a radial structure emanating from the center point c . We denote the set of all reference frames segments between the center point c and an obstacle boundary by R R c and the set of subregions that connect with the center point c by S S c .
Property 5

A path segment that sequentially crosses several reference frames in R R c between two different subregions in S S c is homotopic to a path segment that crosses only the center point c .

For example, in Figure 2a , two paths with different strings α 2 , 0 α 1 , 0 and α 1 , 1 α 2 , 1 indicate two paths in the same homotopy class. By Property 5 , we have Γ α 2 , 0 α 1 , 0 ≃ Γ c ≃ Γ α 1 , 1 α 2 , 1 . Figure 2b illustrates a second example.

An important consequence of Property 5 is that paths that only go through regions S S c are homotopic to a simple path segment that starts and ends at the same position within S S c . Furthermore, all of these paths are homotopic to a path that generates the empty string. This means that we can merge all the subregions in S S c into a new Subregion S c ˆ . We can now create a new DFA, illustrated in Figure 1c , that removes the ambiguity associated with the center region.
Fig. 2: - Equivalence in homotopy.
Fig. 2:

Equivalence in homotopy.

Show All

Definition 3

Let M M h = ( S S h , R R h , δ h , S h 0 , S h T ) be a homotopic DFA that represents the string generation process from a path, where S S h = ( S S ∖ S S c ) ∪ { S c ˆ } is a set of subregions , R R h = R R ∖ R R c is a set of reference frames , S h 0 ∈ S S h is the start subregion , S h T ∈ S S h is the end subregion, and δ h : S S h × R R h → S h is the transition function that defines how one subregion transitions to another subregion along the path by reference frames in R h . Strings are generated as follows:

    v is initialized as an empty string ε ,

    The path starts at x i n i t ∈ S h 0 and ends at x g o a l ∈ S h T .

    When there is a transition across a reference frame r ∈ R R h ,   v ← v r .

    When there is transition R R c , v ← v ϵ = v .

Now that we have removed this ambiguity, we observe an important relationship between a simple path and the string that M M h generates from this path. Let v = M h ( σ ) denote the string generated from a path σ .
Property 6

A duplicate ID character in a string M M h ( σ ) indicates that σ has visited a subregion at least twice .

We call strings that don't have duplicate ID characters non-repeating strings v ∗ . Non-repeating strings can only be generated by simple paths that never leave a subregion by crossing a reference frame and then returning by recrossing that same reference frame. This implies the next property.
Property 7

In every simple homotopy class there exists a path σ such that M M h ( σ ) has no duplicate characters .

Consider a string constructed in the following manner: begin with the empty string ε and recursively insert a palindromic substring w w R , where the R operator reverses the characters in the string, into any position of a string. We denote a string made up of recursively embedded palindromic substrings an REP string . Note that ε and strings of the form w w R are REP strmgs.
Fig. 3: - Path deformation.
Fig. 3:

Path deformation.

Show All

We now present the culminating lemma of this subsection.
Lemma 1

If σ is a simple path segment that begins and ends in the same subregion and encloses no obstacle, then M M h ( σ ) is a REP string .
Proof

The proof is by induction on the number of subregions visited by a path.
• Base Case

If a simple path segment σ never leaves a subregion then M M h ( σ ) = ε .
• Induction Step

Assume a simple path segment σ that begins and ends in the same subregion, and M M h ( σ ) is a REP string. Deform the path segment σ into a different simple segment σ ′ by Crossing only one more reference frame with ID q , as illustrated in Figure 3 . M M h ( σ ′ ) is M M h ( σ ) embedded with q q , where q q = q q R is a palindromic substring. Thus, M M h ( σ ′ ) is also a REP strmg.
• Conclusion

Any simple path segment σ that begins and ends in the same subregion can be obtained by recursively applying deformation to a simple path that never leaves a subregion in the inductive step. □

A useful consequence of this Lemma is the following.
Corollary 1

All simple paths that begin and end in the same subregion and enclose no obstacle are homotopic to each other and to a path σ such that M M h ( σ ) = ∈ .
B. Identifying the Equivalence

Having characterized several relationships between a path σ and its corresponding string M M h ( σ ) , we now want to identify string properties that tell us when two paths are homotopic. Although Property 3 tells us that two paths are homotopic when they are in the same string block, we need more. Specifically, we also need to know when two paths from different string blocks are homotopic.

Write the set of all the simple paths as the union of several homotopy classes Γ = Γ h 1 ∪ Γ h 2 ⋯ ∪ Γ h g , in which Γ h i is the set of all the paths in homotopy class h i . By Property 1 and Property 3 , we know that each homotopy class is a union of several string blocks, that is Γ h i = ⋃ Γ v j i . Let V i denote the set of strings v j i associated with the homotopy class h i , and define Γ V i = ⋃ Γ v j i .

Property tells us that given a homotopy class h i and its corresponding V i , if M M h ( σ ) ∈ V i , then σ ∈ Γ h i , and vice versa.
Property 8

∀ Γ h i , ∃ V i = ∪ v j i , Γ h i = Γ V i = ∪ Γ v j i .

This induces a hierarchy of path partitions and their associated string patterns, as illustrated in Figure 4 .

This hierarchy tells us that we can identify the homotopy class of a path, σ ∈ Γ h i , by finding M M h ( σ ) ∈ V i .

We now show that we can use a non-repeating string v ∗ to determine whether M M h ( σ 1 ) and M M h ( σ 2 ) belong to the same V i . We begin with Lemma 2 , which shows that every path is homotopic to a path that generates a non-repeating string.
Fig. 4: - A hierarchy of path partitions.
Fig. 4:

A hierarchy of path partitions.

Show All

Lemma 2

∀ v , ∃ v ∗ , Γ v ≃ Γ v ∗
Proof

Every path in a homotopy class is homotopic to the shortest path in that same homotopy class. By Property 7 , the shortest path generates a non-repeating string v ∗ , which means Γ v ≃ Γ v ∗ . □

The next lemma states that any two different non-repeating string blocks are not homotopic.
Lemma 3

If v ∗ i ≠ v ∗ j then Γ v ∗ i ≄ Γ v ∗ j .
Proof

Assume that ∃ v ∗ i ≠ v ∗ j such that Γ v ∗ i ≃ Γ v ∗ j . Let σ i ∈ Γ v ∗ i and σ j ∈ Γ v ∗ j . Because σ i and σ j are homotopic to each other, we can assume without loss of generality that σ j and σ i end at the same point, σ i ( 1 ) = σ j ( 1 ) . Again because σ i ≃ σ j , the continuous path formed when we connect σ i to σ R j ( s ) = σ j ( 1 − s ) , a reversed version of σ j encloses no obstacle. By Lemma 1 , M M h ( σ i ∘ σ R j ) is a REP string. Observe that M M h ( σ i ∘ σ R j ) = v ∗ i v ∗ R j by construction. The only way to cut a REP string v into two non-repeating strings is that the number of any character in the REP string v is two and the REP string v is palindromic. Cutting the palindromic string v in the middle gets v 1 and v 2 , in which v 1 = v R 2 . But since v ∗ i ≠ v ∗ j then v ∗ i v ∗ R j cannot be a REP string. □

This implies that each V i associated with each homotopy class Γ h i contains only one non-repeating string.

Theorem 1 characterizes the relationship between V i and its one and only non-repeating string v ∗ i .
Theorem 1

For all V i there exists a unique non-repeating string v ∗ i ∈ V i , such that ∀ v j i ∈ V i , Γ v j i ≃ Γ v ∗ i .
Proof

Lemma 2 states that such a string much exist and Lemma 3 states that this string is unique. □

The next theorem gives us a construction by which we can identify the non-repeating string representative from for each V i .
Theorem 2

Removing all the REP substrings of M M h ( σ ) yields the v ∗ i   f o r which Γ M h ( σ ) ≃ Γ v ∗ t .
Proof

The differences between M M h ( σ ) and v ∗ i are the REP substrings M M h ( σ ) . The REP substrings are generated by adding a path segment that leaves a subregion by crossing one or more reference frames and then returning across the same reference frames in reverse order. By Lemma 1 , this path segment is homotopic to a path σ ∈ Γ ε (empty string). By Property 4 , we have Γ M h ( σ ) ≃ Γ v ∗ i .

This gives us a powerful tool for finding when two strings represent homotopic or non-homotopic paths. Consider Algorithm 2 , which removes REP substrings using the simple principle that if a character is on the top of the stack when you encounter the next one, you've found a REP substring and should eliminate it from the string.
Algorithm 2 REP Trim( v )

Algorithm

When combined with Theorem 2 , this has the marvelous effect of finding a non-repeating string called REPTrim( v ) such that Γ v ≃ Γ R E P T r i m ( v ) . This yields the following corollary.
Corollary 2

REPTrim ( M M h ( σ i ) ) = REPTrim ( M M h ( σ j ) ) iff σ i ≃ σ j .
SECTION IV.
Homotopy-Aware RRT*

Corollary 2 gives us a useful way to determine whether two paths belong to the same homotopy class, but it doesn't tell us anything about how to construct the path that minimizes the cost objective within that homotopy class. This section uses a heuristic based on the REP trim algorithm to restrict paths generated by RRT* to a desired homotopy class. Future work will explore improved heuristics and better variations of RRT* using the explicit REP Trim algorithm.

RRT* explores the map to generate an optimal tree structure based on the cost distribution on the map. While the tree structure explores the planning space, the DFA M M h can be used to generate the strings of the branches. The string of each branch indicates the homotopic information of the corresponding subpath. The resulting algorithm, Algorithm 3 , is called Homotopy-aware RRT* (HARRT*).
SECTION Algorithm 3
HARRT*( x i n i t , x g o a l )

Algorithm

The algorithm uses a bi-directional structure. There is a start tree T s = ( N s ,   E s ) , which is an RRT* structure from the start position for the optimal cost-to-arrive. N s is the set of vertices in T s , and E s is the set of edges in T s . Similarly, there is a goal tree T g = ( N g ,   E g ) , which is an RRT* structure from the goal position for the optimal cost-to-go.

In each iteration, a new vertex is created and added to each tree using Explore ( ) . Connect ( ) is then called to create a path with a vertex in the other tree. In order to guarantee optimality, a set of near vertices in T g is provided to find the best vertex to be connected with the new vertex x n e w s in T s , and vice versa. The created path will be compared with the current best path that belongs to the same string block. If it is a better one, the best path in this string block will be updated, which is implemented in Updatebestpathbyclass().
SECTION Algorithm 4
Explore ( t , i )

Algorithm

Algorithm 4 gives the exploration process of a tree structure and is similar with that used in RRT* [18] . The first difference is that the string associated with each branch is updated (implementing M M h on that branch) and the second difference is the use of the Stringcheck() method (implementing a heuristic version of the REP Trim algorithm) to check whether the string of a branch satisfies the string constraint. The methods in Algorithm 4 are defined as follows:
• Crf ( l )

Return the ID characters that represent the crossed reference frames of a line segment l if any.
• Str ( x )

Return the string that represents the crossed reference frames of the subpath from the root to the node x sequentially. This implements M M h .

We assume that a human has specified one or more homotopy classes, and therefore string blocks, as the constraint of the planned paths. Stringcheck() compares whether a string of a subpath is a substring of the strings generated by the human. In effect, this eliminates branches that deviate from the non-repeating string representation of the human constraint. It is a heuristic because it does not test whether a branch has a REP substring but rather prevents RRT* from exploring branches that might have such substrings. Notice that the goal tree T g compares the strings in a reversed order.

Because RRT* maintains a tree structure, each vertex has only one path to arrive from the root. This path, which starts from the root to the vertex, can be converted into a string of ID characters by M M h . The Stringcheck() guarantees that a new node is added or rewired so that all the branches of the tree structure are in the constraint of strings. For example, suppose we have a string constraint “ab”. A branch of the start tree T s with string “a” satisfies the constraint, because “a” can be extended into “ab” by concatenating a “b”. However, a branch beginning with string “b” cannot be extended into “ab”xs, and therefore does not satisfy the string constraint. It is similar for the goal tree T g but with reversed string order. Note that this is an early check of the homotopy class constraint and may eliminate some paths that would explore areas outside of the current subregion; we will say more about this in the results section.
Algorithm 5 Connect ( x n e w , T )

Algorithm

The methods in Algorithm 5 are defined as follows:
• Path ( v ,   T )

Return the path from the root of the tree T to the vertex v .
• Concatenate ( p a , p b )

Return a concatenated path of p a and p b . If p a and p b are from different directions, one of them will he reversed for the concatenation.

When the exploration process is finished, there is a set of the best paths of all the string blocks. By the REP Trim algorithm we can merge the optimal paths in the string blocks that belong to the same homotopy class. The Mergepaths() merges the equivalent string blocks into homotopy classes. Thus, the set of paths P will be updated.
SECTION V.
Experiments

Recall the following claim from the introduction: “The contribution of this paper is an algorithm that has guaranteed properties … [that] create a set of path affordances that allow a human to specify a wide range of hard and soft constraints that the robot is guaranteed to honor when it plans its path.” To this point in the paper, all the text has focused on either the theoretic analysis of Palindrome Trim algorithm or the heuristic implementation of this algorithm to help RRT* restrict exploration to a given homotopy class. This section provides evidence that the algorithm can support an important need in HRI.

Consider a path-planning problem where a human supervisor defines the task for a robot. Consider further different ways in which the human can express hard and soft constraints as well as performance objectives. The first two examples of human intent translate into homotopic path constraints over an optimization problem. Note that we use the word “quickly” to represent the optimization criterion; in practice, many possible criteria exist.
1) Quickly Go from Point a to Point b Through a Sequence of specific regions

Topologically, such a path is constrained to one homotopy class, so this homotopy class becomes the constraint of the optimization problem and “quickly” becomes the objective to optimize [10] .
2) Quickly Go from Point a to Point b Making Sure to Visit Some Regions and Avoid Other Regions

Topologically, such a path is constrained to be among the set of homotopy classes that include the desired regions and avoid the undesired regions. The corresponding homotopic constraint restricts the optimal path to the set of homotopy classes that satisfy the requirements.

The next example of human intent allow a human to express preference among different path shapes, but also allow the human to trade off between following a desired path shape and optimizing another performance objective.
3) In Quickly Going from Point a to Point B, i Prefer Some Types of Paths Over Others, but I Recognize that Tradeoffs May be Needed

This indicates that the human has preferences over different homotopy classes, and also acknowledges that certain homotopy classes may not allow an acceptable optimization of another task-based objective. If the preference on the homotopy classes can be modeled using an objective function, then non-dominant solutions over the task-based objective (e.g., “quickly”) and homotopic objective (e.g., “north of building A”) can be found, and the human can select one of these solutions by balancing tradeoffs.

Clearly, these examples do not cover the set of all possible ways a human can express intent, but they do represent an important (and we would argue a natural) subset of ways that a human can express intent.

In the results in this section, we use the Euclidean distance as the objective to minimize because optimality can easily be verified. The objective can be replaced with any other type.
A. Single Homotopy Class

This subsection considers the first way of expressing intent: Quickly go from point A to point B through a sequence of specific regions . In this case, the algorithm simply seeks to find the path that minimizes the Euclidean distance between two points subject to the path belonging to a homotopy class.
Fig. 5: - Optimal paths with hard constraints.
Fig. 5:

Optimal paths with hard constraints.

Show All

Figure 5 shows results for two different worlds. In Example A, the authors sketched the fuzzy red path, turned that path into a single homotopy constraint, and then used the HARRT* algorithm to find the shortest path that connected the points subject to the constraint. The green radial lines indicate the reference frames, the yellowish lines indicate the branches of the forward tree of the RRT, the turqoise lines indicate the backward tree of the RRT, and the orange line represents the path found by the algorithm. Inspection shows that that the path is indeed the shortest path within the homotopy class. Further inspection shows that the algorithm concentrated its search effort in the homotopy class, abandoning branches of the tree either when costs became high or when the path crossed a reference frame that deviated from the non-repeating string pattern. Example B shows a similar result but with the human input suppressed to help improve clarity.

Figure 5 also illustrates that the current implementation of HARRT* is an approximation. The theoretic results show that we can determine when any two paths are in the same homotopy class by removing REP substrings, but where we check for homotopic consistency in the RRT implementation has a big impact on how big the trees grow in the algorithm. At one extreme, future work should explore whether it is possible (a) to check the homotopy class of the path returned by the RRT-based exploration once a complete path from start to finish has been found and (b) to reject paths that do not satisfy the homotopy constraint. In the current version of HARRT ∗ , the Stringcheck() method prevents the extension of the branches into a string that does match the non-repeating string. This is an “early check” on the path that can reject potentially optimal paths within a homotopy class if the optimal path would naturally generate some REP substrings.

As illustrated by the simple examples in this section, this “early check” avoids exploring a lot of the state space, resulting in search efficiency and producing acceptable paths, but it is possible to construct examples where this early check would prevent the discovery of the optimal path. Future work should explore variations of the Stringcheck() method that allow a budgeted amount of deviation from a path that generates a non-repeating string. For example, the algorithm could allow a two character palindrome to be part of the string, allowing exploration of paths that leave a subregion to avoid an area of high cost and then return to the subregion once they have circumvented the high cost area. Certainly, this future work would need to explore tradeoffs in the deviation budget, the spacing of sample points that generate the radial structure, and the structure of the cost function.

We conclude this subsection with an example world that exposes a problem that is avoided by the bi -directional approach we have taken but which a single direction RRT encounters.
Fig. 6: - Search results from different structures.
Fig. 6:

Search results from different structures.

Show All

Figure 6 gives the results from the single directional and bidirectional tree structures for a problem where multiple homotopy classes are allowed. Each tree structure finds an optimal path in each of several homotopy classes (though the optimal path is shown for only one homotopy class) optimal paths in several homotopy classes but only one of them is illustrated, but the single directional tree structure could not find an optimal path that swings by the left side of the left-most obstacle; see Figure 6a . By contrast, the via-point constraints in the bidirectional tree structure enforce the exploration of all the possible homotopy classes; see Figure 6b .

Although this result is encouraging, it exposes a challenge in combining RRT* with the Palindrome Trim algorithm or a related heuristic. Stated simply, it is possible for RRT* to “rewire” nodes in such a way that homotopy constraints are violated. Using bidirectional search fixed the problem for this world, but it is easy to construct other worlds for which bidirectional search won't work. Future work will address this challenge.
B. Multiple Homotopy Classes

This section considers the second way of expressing intent: Quickly go from point A to point B making sure to visit some regions and avoid other regions . In this case, the set of regions to visit and regions to avoid create a set of possible homotopy classes.

This section gives an example of the kinds of possible solutions that can be generated when multiple homotopy classes are explored simultaneously. Figure 7 , which will be referenced again in the next section, shows the optimal solutions returned by HARRT* for six different homotopy classes. Observe that each path is optimal for the homotopy class given that the cost function is Euclidean distance. (As an aside, when the cost function is Euclidean distance the heuristic implementation of the REP trim algorithm won't cause problems since the shortest path is also a path that generates a non-repeating string.) For this second type of human intent expression, the path with the lowest cost would be returned.
Fig. 7: - Optimal paths in six homotopy classes.
Fig. 7:

Optimal paths in six homotopy classes.

Show All

C. Soft Constraint and Tradeoffs

This section considers the third way of expressing intent: In going from point A to point B , I prefer some types of paths over others, but I recognize that tradeoffs may be needed . This method is actually quite different than the two previous methods because it treats path shape not as a hard constraint but rather as an objective to be optimized. Fortunately, HARRT* can support a human trying to find tradeoffs between preferences among homotopy classes and the costs associated with choosing a path from a specific homotopy class.

The algorithm for finding these tradeoffs would use HARRT* to find the optimal path from the set of all relevant homotopy classes, as was done in the previous subsection. Recall that HARRT* can simultaneously search in different homotopy classes and returns the solutions in one run. The output of the algorithm would then change its what it presents to the human; rather than returning the best path across homotopy classes as in the previous subsection, the algorithm would find the minimum cost path for each homotopy class and then output both the path and the cost of the path for each homotopy class. This generates a tradeoff space that can be evaluated by the human.

For example, Figure 7 shows the optimal paths in six different homotopy classes found by HARRT*. Associated with each class/path pair is the cost of the optimal path. If the cost is displayed for each class/path pair, a human could determine which shape/cost pair provides the best tradeoff.
SECTION VI.
Conclusion and Future Work

It is possible to create a computationally efficient algorithm that uses strings to determine when two continuous paths are homotopic. This algorithm can be used as a heuristic in a bidirectional RRT* algorithm to prune paths from the search that are not compatible with an intended homotopy class. Furthermore, the algorithm seems compatible with various degrees of approximation, allowing for tradeoffs between computation speed and quality of the path found by the algorithm, but future work must confirm this.

The paper did not explore the usability, workload, or naturalness of the interactions between the human and the robot afforded by the algorithm. but the empirical results suggest that efficient interactions are plausible given the properties of the algorithm. Future work should explore how natural language or a graphical user interface can be combined with the algorithm, and whether resulting interactions are compatible with human workload bounds and situation awareness needs.

Finally, future work should explore how the homotopy-aware RRT* algorithm can be extended to problems with multiple performance objectives, enabling either hard shape constraints or tradeoffs between a set of objectives and the shape of the resulting path.

Authors
Figures
References
Citations
Keywords
Metrics
More Like This
Incorporating Novel Path Planning Method into Cognitive Vision System for Safe Human-Robot Interaction

2009 Computation World: Future Computing, Service Computation, Cognitive, Adaptive, Content, Patterns

Published: 2009
Human-Robot Interaction for Assisted Wayfinding of a Robotic Navigation Aid for the Blind

2019 12th International Conference on Human System Interaction (HSI)

Published: 2019
Show More
References
1.
D. Yi, M. Goodrich and K. Seppi, "Informative path planning with a human path constraint", Systems Man and Cybernetics (SMC) 2014 IEEE International Conference on , pp. 1752-1758, Oct 2014.
Show in Context CrossRef Google Scholar
2.
S. Bhattacharya, "Search-based path planning with homotopy class constraints", Twenty-Fourth AAAI Conference on Artificial Intelligence , 2010.
Show in Context Google Scholar
3.
A. Hatcher, "Algebraic topology. 2002", Cambridge Up Cambridge , vol. 606, no. 9.
Show in Context Google Scholar
4.
B. Kuipers, "The spatial semantic hierarchy", Tech. Rep. , vol. 29, pp. AI99-281, 1999.
Show in Context Google Scholar
5.
M. J. Mataric, "Integration of representation into goal-driven behavior-based robots", Robotics and Automation IEEE Transactions on , vol. 8, no. 3, pp. 304-312, 1992.
Show in Context View Article
Google Scholar
6.
S. Thrun, "Learning metric-topological maps for indoor mobile robot navigation", Artificial Intelligence , vol. 99, no. 1, pp. 21-71, 1998.
Show in Context CrossRef Google Scholar
7.
J. Fasola and M. J. Mataric, "Modeling dynamic spatial relations with global properties for natural language-based human-robot interaction", RO-MAN 2013 IEEE , pp. 453-460, 2013.
Show in Context View Article
Google Scholar
8.
D. C. Shah and M. E. Campbell, "A qualitative path planner for robot navigation using human-provided maps", The International Journal of Robotics Research , vol. 32, no. 13, pp. 1517-1535, 2013.
Show in Context CrossRef Google Scholar
9.
B. Banerjee and B. Chandrasekaran, "A framework of voronoi diagram for planning multiple paths in free space", Journal of Experimental & Theoretical Artificial Intelligence , vol. 25, no. 4, pp. 457-475, 2013.
Show in Context CrossRef Google Scholar
10.
J. Hershberger and J. Snoeyink, "Computing minimum length paths of a given homotopy class", Computational Geometry , vol. 4, no. 2, pp. 63-97, 1994.
Show in Context CrossRef Google Scholar
11.
D. Grigoriev and A. Slissenko, "Poly time algorithm for the shortest path in a homotopy class amidst semi -algebraic obstacles in the plane", Proceedings of the 1998 International Symposium on Symbolic and Algebraic Computation ser. ISSAC '98 , pp. 17-24, 1998.
Show in Context Google Scholar
12.
E. Schmitzberger, J. Bouchet, M. Dufaut, D. Wolf and R. Husson, "Capture of homotopy classes with probabilistic road map", Intelligent Robots and Systems 2002. IEEE/RSJ International Conference on , vol. 3, no. 3, pp. 2317-2322, 2002.
Show in Context View Article
Google Scholar
13.
E. Hernandez, M. Carreras and P. Ridao, "A comparison of homotopic path planning algorithms for robotic applications", Robotics and Autonomous Systems , vol. 64, no. 0, pp. 44-58, 2015.
Show in Context CrossRef Google Scholar
14.
J. Starek, E. Schmerling, L. Janson and M. Pavone, "Bidirectional fast marching trees: An optimal sampling-based algorithm for bidirectional motion planning", Workshop on Algorithmic Foundations of Robotics , 2014.
Show in Context Google Scholar
15.
M. Jordan and A. Perez, "Optimal bidirectional rapidly-exploring random trees", Computer Science and Artificial Intelligence Laboratory Massachusetts Institute of Technology Cambridge MA Tech. Rep. MIT-CSAIL-TR-2013–021 , August 2013.
Show in Context Google Scholar
16.
K. D. Jenkins, "The shortest path problem in the plane with obstacles: A graph modeling approach to producing finite search lists of homotopy classes", June 1991.
Show in Context Google Scholar
17.
E. Hernandez, M. Carreras, J. Antich, P. Ridao and A. Ortiz, "A topologically guided path planner for an AUV using homotopy classes", Robotics and Automation (ICRA) 2011 IEEE International Conference on , pp. 2337-2343, May 2011.
Show in Context View Article
Google Scholar
18.
S. Karaman and E. Frazzoli, "Incremental sampling-based algorithms for optimal motion planning", Proceedings of Robotics: Science and Systems , June 2010.
Show in Context CrossRef Google Scholar
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
