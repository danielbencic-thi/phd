IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 3, NO. 3, JULY 2018

2439

Search-Based Motion Planning for Aggressive Flight in SE(3)
Sikang Liu , Kartik Mohta , Nikolay Atanasov , and Vijay Kumar

Abstract—Quadrotors with large thrust-to-weight ratios are able to track aggressive trajectories with sharp turns and high accelerations. In this letter, we develop a search-based trajectory planning algorithm that exploits the quadrotor maneuverability to generate sequences of motion primitives in cluttered environments. We model the quadrotor body as an ellipsoid and compute its ﬂight attitude along trajectories in order to check for collisions against obstacles. The ellipsoid model allows the quadrotor to pass through gaps that are smaller than its diameter with nonzero pitch or roll angles. Without any prior information about the location of gaps and associated attitude constraints, our algorithm is able to ﬁnd a safe and optimal trajectory that guides the robot to its goal as fast as possible. To accelerate planning, we ﬁrst perform a lower dimensional search and use it as a heuristic to guide the generation of a ﬁnal dynamically feasible trajectory. We analyze critical discretization parameters of motion primitive planning and demonstrate the feasibility of the generated trajectories in various simulations and real-world experiments.
Index Terms—Motion and path planning, autonomous vehicle navigation, aerial systems: applications.
I. INTRODUCTION
M OTION planning, the problem of generating dynamically feasible trajectories that avoid obstacles in unstructured environments, for Micro Aerial Vehicles (MAVs), especially quadrotors, has attracted signiﬁcant attention recently [1]–[4]. When the MAV attitude and dynamics are taken into account, the problem is challenging because there are no simple geometric conditions for identifying collision-free conﬁgurations [5]. Existing planning approaches usually model the MAV as a sphere or prism, which allows obtaining a simple conﬁguration space (C-space) by inﬂating the obtacles with the robot size. As a result, the robot can be treated as a single point in C-space and the collision-checking even for trajectories that take dynamics into account is simpliﬁed. Even though this spherical model assumption is widely used in motion planing,
Manuscript received September 10, 2017; accepted January 15, 2018. Date of publication January 23, 2018; date of current version March 29, 2018. This letter was recommended for publication by Associate Editor S. Chakravorty and Editor N. Amato upon evaluation of the reviewers’ comments. This work was supported by in part by ARL under Grant W911NF-08-2-0004, in part by DARPA under Grants HR001151626 and HR0011516850, in part by ARO under Grant W911NF-13-1-0350, and in part by ONR under Grant N00014-071-0829. (Corresponding author: Sikang Liu.)
S. Liu, K. Mohta, and V. Kumar are with the GRASP Laboratory, University of Pennsylvania, Philadelphia, PA 19104 USA (e-mail: sikang@seas.upenn.edu; kmohta@seas.upenn.edu; kumar@cis.upenn.edu).
N. Atanasov is with the Department of Electrical and Computer Engineering, University of California, San Diego, La Jolla, CA 92093 USA (e-mail: natanasov@ucsd.edu).
Digital Object Identiﬁer 10.1109/LRA.2018.2795654

Fig. 1. By taking the shape and dynamics of a quadrotor into account, our planner is able to generate a trajectory that allows the quadrotor to pass through a door, narrower than robot’s diameter. In contrast, existing methods that model the quadrotor as a sphere (red circle) would not be able to ﬁnd a feasible path in this environment.
it is very conservative since it invalidates many trajectories whose feasbility depends on the robot attitude (see Fig. 1). Several prior works have demonstrated aggressive maneuvers for quadrotors that pass through narrow gaps [6]–[8] but, instead of solving the planning problem, those works focus on trajectory generation with given attitude constraints. Those constraints are often hand-picked beforehand or obtained using gap detection algorithms which only works for speciﬁc cases.
We are interested in designing a planner that considers the robot’s actual shape and dynamics in order to obtain aggressive trajectories in cluttered environments. Since quadrotors are under-actuated systems, they cannot translate and rotate independently. this letter builds on our previous search-based trajectory planning approach [9] that utilizes motion primitives to discretize the control space and obtain a dynamically feasible resolution-complete (i.e., optimal in the discretized space) trajectory in cluttered environments. We extend our previous work by explicitly computing the robot attitude along the motion primitives and using it to enforce collision constraints. Furthermore, to reduce computation time for searching in high-dimensional (velocity, acceleration, jerk, etc.) space, we propose a novel hierarchical planning process that reﬁnes a dynamically feasible trajectory from a prior trajectory in lower dimensional space. The paper makes the following contributions:
1) A graph search algorithm that uses motion primitives to take attitude constraints into account and compute a dynamically feasible resolution-complete trajectory for a quadrotor is developed.
2) A hierarchical reﬁnement process that uses prior lowerdimensional trajectories as heuristics to accelerate planning in higher dimensions is proposed.

2377-3766 © 2018 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications standards/publications/rights/index.html for more information.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on June 08,2022 at 09:52:46 UTC from IEEE Xplore. Restrictions apply.

2440

IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 3, NO. 3, JULY 2018

3) The effect of motion primitive discretization parameters on the computation time, smoothness, and optimality of the generated trajectories is analyzed.
The code used in this work is open-sourced at https://github. com/sikang/mpl_ros. Users can easily test our planner and benchmark the performance against other planning algorithms. In addition, a video clip of the simulation and experimental results is published on https://youtu.be/V4Mha-KPtwc.

III. MOTION PLANNING WITH ATTITUDE CONSTRAINTS
In this section, we introduce our trajectory planning framework based on motion primitives. While our previous work [9] guarantees safety, dynamical feasibility and optimality, it assumes a spherical robot body. Here, we introduce a way to account for the robot attitude during planning based on the desired acceleration and gravity. Since the quadrotor yaw is decoupled and does not affect system dynamics, we assume it remains constant during planning.

II. RELATED WORKS
Trajectories for MAVs or, more generally, differentially ﬂat systems are represented as piecewise polynomials whose derivatives can be used to obtain explicit expressions for the system states and control inputs [10]. When collision avoidance is taken into account, more constraints need to be added to guarantee safety either through anchoring waypoints as in [2], [11] or building up a safe ﬂight corridor as in [4], [12], [13]. These approaches require planning in a C-space in which the robot’s attitude does not affect collision checking. Conservative symmetrical approximations of the robot body may ignore trajectories whose feasibility depends on the robot attitude. Hence, planning in SE(3) is necessary in order to obtain agile trajectories in cluttered environments. Planning with 6 DOF has been addressed in several works [14], [15] via sampling techniques but these do not translate immediately to our problem, where the rotation and translation are coupled and a smooth, deterministic trajectory is desired. Methods based on motion primitives are a promising approach for planning dynamically feasible and collision-free trajectories. For example, lattice search with predeﬁned primitives [16], [17] may be used to plan trajectories for non-circular robots in obstacle cluttered environments. In our previous work [9], we developed an approach for quadrotors based on lattice search by using motion primitives generated via optimal control [18]. In this work, we extend [9] to account for attitude constraints by explicitly computing the robot attitude along the motion primitives based on the desired acceleration and gravity.
While randomized sampling approaches have been effective at solving very high dimensional planning problems, they take a long time to converge to an optimal solution [19] and intermediate solution quality might be unpredictable. Hence, randomized approaches are not suitable for fast navigation in unknown environments where frequent, predictable re-planning is necessary. Traditional graph search techniques are considered inefﬁcient in high dimensional spaces but appropriate heuristic design [20]– [22] may accelerate their speed. Using weighted heuristics, however, produces sub-optimal solutions and does not always reduce planning time [23]. An interesting, alternative idea for accelerating motion planning is based on adaptive dimensionality [24], which exploits preliminary search results in lower dimensions to accelerate the planning process in high dimensions. In this work, we use a hierarchical planning procedure—plan a trajectory in low dimensional space and use it as a heuristic to guide the search in high dimensional space—to improve the reﬁnement step in [9] which can potentially lead to unsafe and infeasible trajectories, while guaranteeing dynamical feasibility, safety, and resolution completeness.

A. System Dynamics in Planning

Before introducing the planning approach, we inspect the re-

lation between polynomial trajectories and system dynamics. The position x = [x, y, z]T in R3 of the quadrotor can be de-

ﬁned as a differentially ﬂat output as described in [11]. The

associated by taking

velocity v, derivatives

acceleration a and jerk j with respect to time as

cx˙a,nx¨b, e.x..obretasipneecd-

tively. The desired trajectory for the geometric SE(3) controller as described in [25] can be written as Φ(t) = [xTd , vdT, aTd , jTd ]T. According to [26], we assume the force and angular velocity are

our control inputs to the quadrotor. Ignoring feedback control

errors, the desired mass-normalized force in the inertial frame

can be obtained as

fd = ad + gzw .

(1)

where g is the gravitational acceleration and zw = [0, 0, 1]T is the z-axis of the inertial world frame. Similar to [25], given a

speciﬁc yaw ψ, the desired orientation in SO(3) can be written

as Rd = [r1 , r2 , r3 ] where

r3 = fd / fd ,

r1 =

r2c × r3 r2c × r3

,

r2 = r3 × r1

(2)

and

r2c = [− sin ψ, cos ψ, 0]T.

(3)

which is assumed to be not parallel to r3. The associated angular velocity in the inertial frame, R˙ d = [r˙ 1 , r˙2 , r˙3 ], can be calculated as

r˙ 3 = r3 ×

f˙d fd

× r3 ,

r˙ 1

=

r1

×

r˙ 2c

× r3 + r2c r2c × r3

× r˙ 3

× r1 ,

r˙ 2 = r˙ 3 × r1 + r3 × r˙ 1

(4)

where

r˙ 2c = [− cos ψ, − sin ψ, 0]Tψ˙, f˙d = jTd .

(5)

Therefore, the desired angular velocity wd in body frame is obtained as:

[wd ]× = RTd R˙ d .

(6)

Once the desired force fd , orientation Rd and angular velocity wd are deﬁned, it is straightforward to compute the desired control inputs for the quadrotor system. Notice that: 1) orientation is algebraically related to the desired acceleration and gravity and 2) angular velocity is algebraically related to the desired jerk.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on June 08,2022 at 09:52:46 UTC from IEEE Xplore. Restrictions apply.

LIU et al.: SEARCH-BASED MOTION PLANNING FOR AGGRESSIVE FLIGHT IN SE(3)

2441

B. Search-Based Planning Using Motion Primitives

As mentioned in the previous section, the desired trajectory can be deﬁned as

Φ(t) := [xT, x˙ T, x¨T, .x..T]T = [xT, vT, aT, jT]T

(7)

and each component of Φ(t) can be represented by a polynomial parameterized in time t. Position can be deﬁned as

x(t) :=

K

dk

tk k!

=

dK

tK K!

+...+

d1 t + d0

(8)

k=0

where dk ∈ R3 are the coefﬁcients. The corresponding velocity, acceleration and jerk can be obtained by taking the derivative of (8). A polynomial trajectory from one state to the other within a speciﬁed time duration is called a motion primitive. Our approach uses primitives generated as the solutions to an optimal control problem [9] to build a graph from an initial state to a goal state and search for the optimal sequence of primitives. Technical details and proof of optimality can be found in our previous work [9]. In this letter, we give the explicit solution for generating the optimal trajectory using jerk as the control input.
We deﬁne the state

s(t) := [x(t)T, x˙ (t)T, x¨(t)T]T = [pT, vT, aT]T

(9)

as a subset of the trajectory Φ(t) that excludes the jerk. From an

initial state s0 = [pT0 , v0T, aT0 ]T, we apply a constant jerk input um from a pre-deﬁned control set UM for a short duration τ > 0.
The resulting curve between s0 and the end state is a motion primitive such that for t ∈ [0, τ ] the system state s(t) can be

written as

s(t)

=

F

(um

,

s0

,

t)

:=

⎡ ⎢⎣

um

t3 6

+

a0

t2 2

+

um

t2 2

+ a0 t

v0 +

t+ v0

p0

⎤ ⎥⎦.

(10)

um t + a0

It has been shown in [18] and [9] that F (·) provides the minimum jerk trajectory between s0 and s(τ ).
The ﬁnite control input set UM and duration τ deﬁne a graph G(S, E), where S is the set of reachable states in R9 and E is the set of edges connecting those states. The states in S are generated by applying each element of UM at each state iteratively, and each element in E is a primitive as deﬁned in (10). A breadthﬁrst-search (BFS) of a ﬁnite horizon leads to the graphs shown
in Fig. 2. We are interested in ﬁnding a trajectory from s0 to sg that is
optimal in terms of total control effort J and time T taken to
reach the goal. According to [9], a desired optimal trajectory is
obtained as

T

Φ∗(t) = arg min J + ρT = arg min

j 2 dt + ρT

Φ(t)

Φ(t) 0

s.t. s0 ← Φ(0), sg ← Φ(T )

(11)

Fig. 2. Graph G(S, E) generated by applying BFS for a ﬁnite planning hori-
zon over a set of motion primitives UM with 9 elements (a) and 25 elements (b). Red dots represent states in S and magenta splines represent edges in E. (a) τ = 0.5, |UM | = 9, (b) τ = 0.5, |UM | = 25.

is deﬁned as

C(sn , um ) = C(um ) = ( um 2 + ρ)τ.

(12)

The cost of the individual primitive is independent of the current state and only depends on the set Um and τ . In addition, it can be shown by Pontryagin’ minimum principle that (10) is the op-
timal solution of (11). Details of the proof can be found in [9].
Therefore, search for an optimal trajectory of (11) is equiva-
lent to ﬁnd the optimal solution to the following deterministic
shortest path problem: Problem 1: Given an initial state s0 , a goal region X goal , a
free space X f ree and motion primitives based on a ﬁnite set of control inputs UM with duration τ > 0, choose a sequence of control inputs u0:N −1 of length N such that:

min
N ,u0 : N −1

N −1
un 2 + ρN τ
n=0

s.t. Fn (t) := F (un , sn , t), un ∈ UM

sn+1 = Fn (τ ) = Fn+1 (0), sN ∈ X goal

Fn (t) ⊂ X f ree

(13)

We are able to solve this problem through a graph search
algorithm like A*. The optimal trajectory Φ∗(t) can be recovered
by applying the optimal control solution u∗0:N −1 with (10) from the start s0 as

Φ∗(t) ← [s0 −u→∗0 s1 . . . u−∗N→−1 sN ].

(14)

When planning dynamic trajectories, traditional distancebased heuristics are not effective since short-distance trajectories may require sudden changes in velocity, acceleration or orientation. Instead, we use a heuristic, proposed in [9], which is based on the solution of a Linear Quadratic Minimum Time (LQMT) problem and takes trajectory smoothness into account. Given the current state s and the goal state sg , the LQMT solution provides an explicit formula for the H(s, sg ) as described in the appendix.

where ρ is the weight that decides the trade-off between effort
and time. For the primitive deﬁned in (10), J = um 2 τ and T = τ .
Thus, the cost of a primitive of applying um from state sn ∈ S

C. Feasibility Checking
When checking if a motion primitive is contained in the free space X f ree in Problem 1, we need to consider both dynamical

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on June 08,2022 at 09:52:46 UTC from IEEE Xplore. Restrictions apply.

2442

IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 3, NO. 3, JULY 2018

Fig. 3. A quadrotor can be modeled as an ellipsoid with radius r and height h. Its position and attitude can be estimated from the desired trajectory. A point cloud O is used to represent obstacles.

constraints that arise from system dynamics and geometric con-

straints due to physical obstacles.

1) Dynamically Feasible Primitives: The dynamical con-

straints on a quadrotor system are the min/max thrust and torques

that can be provided by the motors [18]. However, it is hard to

examine the true speciﬁcation for each quadrotor and apply cor-

rect non-linear constraints. In fact, it is reasonable to utilize the

property of differential ﬂatness and apply velocity, acceleration,

and jerk constraints on each axis independently. This leads to

componentwise inequalities of the form:

|x˙ (t)| vmax , |x¨(t)| amax , |.x..(t)| jmax .

(15)

Polynomial expressions for x˙ , x¨, .x.. allow us to check (15)

in closed-form for each axis by ﬁnding the min/max value

on time interval [0, τ ]. The latter is equivalent to ﬁnding the

roots of the corresponding derivatives. Thus, we can guaran-

tee that the planned trajectories always stay within the bounds

vmax , amax , jmax . More speciﬁcally, we deﬁne

vmax = vmax 1, amax = amax 1, jmax = jmax 1

(16)

2) Collision Free Primitives: As indicated in Section I, tra-
ditional collision checking though inﬂating obstacles is too con-
servative and not suitable for planning agile trajectories in clut-
tered environments since it fails to take the actual robot shape
and attitude into account. In this letter, we model the quadrotor as an ellipsoid ξ in R3 with radius r and height h and the obstacle map as a point cloud O ⊂ R3 (see Fig. 3). Given a quadrotor state s, its body conﬁguration ξ at s can be obtained as

ξ(s) := {p = Ep˜ + d | p˜ ≤ 1}

(17)

where

⎡ r

0

0⎤

d = x(t), E = R⎢⎣ 0 r 0 ⎥⎦RT

(18)

00h

and the orientation R can be calculated from x¨(t) and gravity as shown in (2).
Checking whether the quadrotor hits obstacles while following a trajectory is equivalent to checking if there is any obstacle inside the ellipsoid along the trajectory. In other words, we need to verify that the intersection between ξ and the point cloud O is empty:
O ∩ ξ = {o | E−1 (o − d) ≤ 1, ∀o ∈ O} = ∅ (19)

Instead of checking through every point in O, it is more efﬁcient
to use KD-tree [27] to crop a subset Or,d of O at ﬁrst and then check the intersection between ξ and obstacles inside Or,d . The

subset Or,d is created by looking for neighbor points around d within radius r, assuming r ≥ h.
Since the contour of an ellipsoid following a primitive is not
convex, we sample I states in time along a primitive Fn and consider the primitive Fn collision-free if

O ∩ ξ(si,n ) = ∅, ∀i = {0, 1, . . . , I − 1}

(20)

where si,n is the i-th sampled state on Fn .
In sum, the explicit formulation of the feasibility constraints Fn (t) ⊂ X f ree in Problem 1 is written as:

Fn (t) [vmT ax , aTmax , jTmax ]T,

(21)

O ∩ ξ(si,n ) = ∅, ∀i = {0, 1, . . . , I}.

IV. TRAJECTORY REFINEMENT
In the proposed planning approach, the dimension of the state space increases with increasing requirements on the continuity of the ﬁnal trajectory. More precisely, if C2 continuity is required for the ﬁnal trajectory, jerk should be used as a control input and the state space of the associated second order system would be R9 (position, velocity acceleration). Generally, planning in higher dimensional spaces (e.g., snap input) requires more time and memory to explore and store lattices/states. In this section, we introduce a hierarchical approach to planning a feasible trajectory in high dimensional space by utilizing guidance from a trajectory planned in lower dimensional space. We show that the overall computation time of this hierarchical planning is shorter than the total time it takes to plan a optimal trajectory directly. Due to the fact that the ﬁnal trajectory is calculated from a trajectory in lower dimensional space, similar to the reﬁnement process in [9], we call this hierarchical planning process as trajectory reﬁnement.

A. Trajectories Planned in Different Control Spaces

Denote the trajectories planned using velocity, acceleration or jerk inputs as Φj , j = 1, 2, 3 respectively. Given the same
start and goal, dynamics constraints and discretization, examples
of the optimal trajectories in each case are plotted in Fig. 4, where the control effort Jj , j = 1, 2, 3 of the whole trajectory
is measured as

T

Jj =

x(j) 2 dt.

(22)

0

Denote the execution and computation time of the trajectory as T j and tj , j = 1, 2, 3 accordingly. From the planning results
in Fig. 4, two conclusions can be drawn with increasing j: 1) The execution time increases, i.e., T 1 < T 2 < T 3 ; 2) The computation time increases, i.e., t1 < t2 < t3 .
Note that the computation time increases dramatically as j
increases.

B. Using Trajectories as Heuristics
The fact that searching a optimal trajectory in the lower dimensional space is much faster than in a higher dimensional space leads to the approach described in this subsection to speed up the planning speed for the actual MAV system.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on June 08,2022 at 09:52:46 UTC from IEEE Xplore. Restrictions apply.

LIU et al.: SEARCH-BASED MOTION PLANNING FOR AGGRESSIVE FLIGHT IN SE(3)

2443

Fig. 5. Search Φ2 (magenta) using Φ1 (blue) as the heurisric. Left ﬁgure plots the trajectories in x − y plane, the black arrows indicate the H1 . Right ﬁgure shows the corresponding x position with respect to time t along each trajectory, for states with the same subscript, they are at the same time Tn . (a) x − y plot. (b)t − x plot.

Fig. 4. Optimal trajectories planned using piecewise constant (a) velocity, (b) acceleration, (c) jerk from a start (blue dot) to a goal (red dot) state. Grey dots indicates explored states. (a) Φ1 : T 1 = 32 s, J 1 = 42, t1 = 2 ms. (b) Φ2 : T 2 = 33 s, J 2 = 2.25, t2 = 60 ms. (c) Φ3 : T 3 = 34 s, J 3 = 3.75, t3 = 1646 ms.

Denote the prior trajectory in lower dimensional space as Φp ,
we are searching for a trajectory in higher dimensional space Φq (q > p). Assume the duration of each primitive in Φq is τ , each lattice sqn in the graph is associated with a time Tn which is the minimum time it takes from the start to the current lattice.
Tn is an integer multiplication of τ . Instead of calculating the heuristic H(sqn ) from current state sqn to the goal sg directly as described in [9], we propose to use the intermediate goal spn = Φp (Tn ) evaluated from trajectory Φp at Tn such that the heuristic value is calculated as below:

H(sqn , Φp ) = H1 (sqn , spn ) + H2 (spn , sg ).

(23)

The ﬁrst term H1(·) on the RHS of (23) is proposed in the appendix where sqn is fully deﬁned but spn has undeﬁned states. The second term H2 (·) is given directly as the cost from spn to the goal by following Φp , to be more speciﬁc:

H2 (spn , sg ) = J q (spn , sg ) + ρ(T p − Tn )

(24)

where T p is execution time of Φp and Jq (spn , sg ) is the control effort from spn to sg along Φp as expressed in (22). This formu-
lation is consistent with the cost function deﬁned before in (11).
As the prior trajectory is in the lower dimensional space, Jq for Φp is always zero (e.g., for planning a optimal trajectory Φ2 that uses acceleration input, the corresponding control efforts of Φ1 is zero as there is no acceleration along Φ1 ). Thus H2 (·) turns out to be only the execution time between spn and goal:

H2 (spn , sg ) = ρ(T p − Tn ).

(25)

Fig. 5 shows an example of applying (23) to search a trajectory Φ2 using acceleration with a prior trajectory Φ1 planned using velocity. The new trajectory Φ2 tends to stick with the prior trajectory Φ1 due to the effect of H1 (·). H2(·) will push the searching moving forward towards the goal. In fact, the heuristic
function deﬁned in (23) is not admissible since it may not
necessarily be the under-estimation of the actual cost-to-goal.

Fig. 6. Trajectories (magenta) planned using Φ1 (black) as the heuristic. The computation time tq and the number of expanded nodes are much less than the searching results in Fig. 4. (a) Φ2 : T 2 = 35 s, J 2 = 3.0, t2 = 11 ms. (b) Φ3 : T 3 = 36 s, J 3 = 4.25, t3 = 98 ms.

However, we are able to search for trajectories in higher dimen-
sional space in a much faster speed by searching the neighboring
regions of the given trajectory instead of exploring the whole
state space with the same priority.
The results of applying (23) for the same planning tasks in Fig. 4 are shown in Fig. 6, in which Φ1 is used to plan for both trajectory Φ2 and Φ3 . Comparing Figs. 6 to 4, the total cost of control effort and execution time, namely Jq + ρT q , of the new trajectories Φq in Fig. 6 are greater than the optimal trajectories in Fig. 4, but the computation time tq and the number
of expanded nodes are much less.

V. EVALUATION

A. 2-D Planning

2-D planning is efﬁcient and useful in 2.5-D environments
where the obstacles are vertical to the ﬂoor. We start by showing
2-D planning tasks of ﬂying though gaps with different widths. In Fig. 7 shows how planned trajectories Φ3 using jerk as a
control input vary as the gap in a wall is shrinking (left wall
moves closer to the right wall from (a) to (f)). Accordingly,
the angle of the desired roll at the gap φgap increases. Assume the robot has radius r = 0.35 m, height h = 0.1 m, and the maximum acceleration in each axis is amax = g. Denoting the roll along trajectory as φ, according to (1) and (2), we have

− arctan amax ≤ φ ≤ arctan amax

(26)

g

g

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on June 08,2022 at 09:52:46 UTC from IEEE Xplore. Restrictions apply.

2444

IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 3, NO. 3, JULY 2018

Fig. 8. Trajectories generated through a rectangular hole of size 0.4 × 0.8 m oriented at different angles. A robot with radius r = 0.35 m needs to ﬂy through the hole with certain non-zero roll and pitch angles. The colored dots represent walls in the map that invalidate trajectories that go around the window. (a) φw in = 30◦. (b) φw in = 45◦. (c) φw in = 60◦.

Fig. 7. Trajectories through gaps with different widths: 0.75, 0.65, 0.55 m from (a) to (c) (2-D planning) and 0.55, 0.45, 0.35 m from (d) to (f) (3-D planning). φg a p indicates the maximum roll at the gap. Red dots show the start and goal. (a) φg a p = 0◦. (b) φg a p = 27◦. (c) φg a p = 45◦. (d) φg a p = 46◦. (e) φg a p = 73◦. (f) φg a p = 90◦.

Fig. 9. Generated trajectories in two different environments. The robot radius is r = 0.5 m, making its diameter much larger than the door width in (a). If the obstacles in these environments are inﬂated by r, no feasible paths exist. (a) Ofﬁce environment. (b) Unstructured environment.

since the desired acceleration in z-axis is zero. In other words, the smallest gap that the robot can pass through using 2-D planning is approximately equal to 2r cos θ (which is approximately equal to 0.525 m).

B. 3-D Planning

By adding control in the z-axis, we are able to plan in 3-D space and relax the constraint in (26) as follows:

− arctan

am a x g − amax

≤

φ

≤

arctan

g

am a x − amax

.

(27)

When

am a x

≥

g,

φ

∈

(−

π 2

,

π 2

]

can

be

arbitrary.

Letting

am a x

=

g, we are able to reduce the gap width even more as shown in

the following Fig. 7.

Another example of 3-D planning using a window with a

rectangular hole in the middle is considered. By modifying the

window’s inclination φwin , we are able to verify the planner’s capability to generate trajectories as shown in Fig. 8.

C. Parameters
There are a few parameters that signiﬁcantly affect the planning performance including computation time, resolution completeness, continuity and dynamics constraints. In this section, we analyze these relationships and provide a rough guidance on how to set the parameters in our planner. In the above examples of 2-D and 3-D planning, we used the following settings (here the control input is deﬁned as jerk such that umax = jmax ):

ρ 10000

τ 0.2 s

vm ax 7 m/s

am ax 10 m/s2

um ax 50 m/s3

du 12.5 m/s3

A larger ρ results in faster trajectories. The scale of ρ should be comparable to the scale of the associated control effort. Here we use ρ ≈ 4u2max . The motion primitive duration τ decided the density of the lattices and computation time, for moderate ﬂight speed (<10 m/s), we ﬁnd τ = 0.2 s to be a reasonable choice. A small τ makes the graph dense and requires more explorations to reach the goal, while a large τ may easily result in searching failure since the graph may be too sparse to cover the feasible region. The discretization in the control space UM also affects the density of the graph as shown in Fig. 2. Its effect is similar to τ – ﬁner discretization in UM leads to a slower but more complete search and smoother trajectories and vice versa. The maximum velocity and acceleration are limited by the system’s dynamics including thrust-to-weight ratio, max angular speed and air drag etc, but in many cases, we also want to limit the agility due to the space, state estimation and control limitations.
VI. EXPERIMENTS
A. Simulation Results
The proposed planner is used to generate trajectories in complicated environments as shown in Fig. 9. A geometric model of the environment is converted into a point cloud and used to construct an obstacle KD-tree with 5 cm resolution.
In general, ﬁnding the optimal trajectories in complicated environments like Fig. 9 is slow (Table I gives the computation time of trajectory planning on a moderate fast computer with an Intel i7 processor with clock rate of 3.4 GHz.). As proposed in Section IV, we plan trajectories Φ2 using acceleration control at ﬁrst, based on which we plan the trajectory Φ3∗ using jerk control. As shown in Table I, the computation time for hierarchical planning is much less than that for planning in the original 9 dimensional space with jerk input. We can also see in Fig. 10

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on June 08,2022 at 09:52:46 UTC from IEEE Xplore. Restrictions apply.

LIU et al.: SEARCH-BASED MOTION PLANNING FOR AGGRESSIVE FLIGHT IN SE(3)

2445

TABLE I EVALUATION: t REFERS TO THE COMPUTATION TIME, J IS THE TOTAL CONTROL
(JERK) EFFORT AND T IS THE TOTAL TRAJECTORY EXECUTION TIME

Ofﬁce

Unstructured 3-D

t(s) J (×103 ) T (s) t(s) J (×103 ) T (s)

Φ3 89.42

8.9

4.6 129.58

5.6

3.0

Φ2 9.34

0

4.4 21.64

0

3.6

Φ3∗ 2.03

11.1

5.0 24.02

15.1

4.8

Fig. 10. Comparison between the optimal method (left) and reﬁnement (right). The prior trajectory Φ2 is plotted in blue, while the white dots indicate explored states. It is clear that the reﬁnement explores fewer irrelevant regions but the generated trajectory is suboptimal.

Fig. 12. Plots of control errors, the blue curve is the command value while the green curve shows the actual robot state. Top ﬁgure shows vx − t, bottom ﬁgure shows φ − t. The red verticle line indicates the time when the robot pass through the gap.
trajectory planned using the snap as the control input is straightforward to solve following the same pipeline as proposed in this letter, which has also been implemented in our open-sourced planner.

Fig. 11. Quadrotor tracks the planned trajectory to ﬂy through a narrow gap. Top ﬁgures are the snapshots of the video, bottom ﬁgures are corresponding visualizations in ROS. Maximum roll angle at the gap is 40◦ as drawn in the top right ﬁgure.
that the reﬁnement process tends to explore fewer states. As expected, the reﬁned trajectory Φ3∗ has a higher cost compared to the optimal trajectory Φ3 .
B. Real World Experiments
The experiments is aiming to demonstrate the feasibility of planned trajectories on a real robot. We use AscTec Hummingbird as our quadrotor platform, we also use VICON motion capture system to localize the quadrotor and the obstacle map is obtained by depth sensor in advance to generate trajectories. The robot is able to avoid hitting obstacles by following the the control commands from extracting from the planned trajectory through wireless. Fig. 11 shows the ﬂight when the quadrotor needs to roll aggressively in order to pass through the gap between white boards.
The control errors in velocity and roll are plotted in Fig. 12. The commanded roll includes the feedback attitude errors such that it is not as smooth as the desired roll from the planned trajectory. The existed lag in the attitude is due to the fact that the actual robot is not able to achieve speciﬁed angular velocity instantly, however for a moderate angular speed, this assumption still holds valid. A more accurate model for the quadrotor should be using snap as the control input instead of the jerk. The

VII. CONCLUSION
In this work, we extend our previous motion-primitive-based planning algorithm [9] to enable aggressive ﬂight with attitude constraints in cluttered environments for an under-actuated quadrotor system. We also presented a hierarchical reﬁnement process that uses prior lower-dimensional trajectories to accelerate planning in higher dimensions. We believe that the proposed algorithm can be a foundation for future study of fast autonomous navigation of UAVs in cluttered environments.

APPENDIX LINEAR QUADRATIC MINIMUM TIME FOR JERK CONTROL
The heuristic function H(s, sg ) for graph search is an underestimation of actual cost from the state s to the goal sg by relaxing the dynamics and obstacles constraints. We try to ﬁnd a state-to-state optimal trajectory of Problem 2, whose cost serves as the heuristic H. The explicit solution for the optimal cost for velocity, acceleration control has been shown in [9], here we show the explicit solution for jerk control.
Problem 2: Given a current state s, the goal state sg , ﬁnd the optimal trajectory according to the cost function

T

c min

j 2 dt + ρT

(28)

j,T 0

Assume the initial state is given as s = [pT0 , v0T, aT0 ]T, the formulation of position of the optimal trajectory for (28) is
given from the Pontryagin’s minimum principle [18] as

p

=

d5 t5 120

+

d4 t4 24

+

d3 6

t3

+

a0 2

t2

+

v0 t

+

p0

(29)

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on June 08,2022 at 09:52:46 UTC from IEEE Xplore. Restrictions apply.

2446

IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 3, NO. 3, JULY 2018

The coefﬁcients {d5 , d4 , d3 } are deﬁned in [18] by s, sg and T . As a result, the total cost of (28) can be written as a function of time T as

T
C(T ) =
0

d5 2

t2

+

d4 t

+

d3

2
dt + ρT

=

d25 20

T

5

+

dT4 d5 4

T4

+

dT4 d4 + dT3 d5

3

3

T3

+ dT3 d4 T 2 + d23 T + ρT

(30)

The minimum of C(T ) can be derived by taking the derivative with respect to T and ﬁnding the root T ∗ of

dC dT

= c0 + . . . + c6 T −6

= 0,

T

∈ [0, ∞)

(31)

Therefore, H(s, sg ) = C(T ∗). The coefﬁcients in (31) are de-
rived as follows: (1) Fully Deﬁned sg = [pT1 , v1T, aT1 ]T

c0 = ρ, c1 = 0, c2 = −9a20 + 6aT0 a1 − 9a21 ,

c3 = − 144aT0 v0 − 96aT0 v1 + 96aT1 v0 + 144aT1 v1 ,

c4 = 360(a0 − a1 )T(p0 − p1 ) − 576v02

− 1008v0Tv1 − 576v12 ,

c5 = 2880(v0 + v1 )T(p0 − p1 ),

c6 = − 3600(p0 − p1 )2 .

(32)

(2) Partially Deﬁned sg = [pT1 , v1T]T c0 = ρ, c1 = 0, c2 = −8a20 ,

c3 = − 112aT0 v0 − 48aT0 v1 ,

c4 = 240aT0 (p0 − p1 ) − 384v02 − 432v0Tv1 − 144v12 ,

c5 = (1600v0 + 960v1 )T(p0 − p1 ),

c6 = − 1600(p0 − p1 )2 .

(33)

(3) Partially Deﬁned sg = p1 c0 = ρ, c1 = 0, c2 = −5a20 ,

c3 = − 40aT0 v0 ,

c4 = 60aT0 (p0 − p1 ) − 60v02 ,

c5 = 160v0T(p0 − p1 ),

c6 = − 100(p0 − p1 )2 .

(34)

REFERENCES
[1] S. Liu, M. Watterson, S. Tang, and V. Kumar, “High speed navigation for quadrotors with limited onboard sensing,” in Proc. IEEE Int. Conf. Robot. Autom., 2016, pp. 1484–1491.
[2] C. Richter, A. Bry, and N. Roy, “Polynomial trajectory planning for aggressive quadrotor ﬂight in dense indoor environments,” in Robotics Research. Berlin, Germany: Springer, 2016, pp. 649–666.

[3] H. Oleynikova, M. Burri, Z. Taylor, J. Nieto, R. Siegwart, and E. Galceran, “Continuous-time trajectory optimization for online UAV replanning,” in Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst., Oct. 2016, pp. 5332–5339.
[4] R. Deits and R. Tedrake, “Efﬁcient mixed-integer planning for UAVs in cluttered environments,” in Proc. IEEE Int. Conf. Robot. Autom., 2015, pp. 42–49.
[5] J. Canny, B. Donald, J. Reif, and P. Xavier, “On the complexity of kinodynamic planning,” in Proc. 29th Annu. Symp. Found. Comput. Sci., 1988, pp. 306–316.
[6] D. Falanga, E. Mueggler, M. Faessler, and D. Scaramuzza, “Aggressive quadrotor ﬂight through narrow gaps with onboard sensing and computing,” arXiv:1612.00291, 2016.
[7] G. Loianno, C. Brunner, G. McGrath, and V. Kumar, “Estimation, control, and planning for aggressive ﬂight with a small quadrotor with a single camera and IMU,” IEEE Robot. Autom. Lett., vol. 2, no. 2, pp. 404–411, Apr. 2017.
[8] T. Hirata and M. Kumon, “Optimal path planning method with attitude constraints for quadrotor helicopters,” in Proc. Int. Conf. Adv. Mechatronic Syst., 2014, pp. 377–381.
[9] S. Liu, N. Atanasov, K. Mohta, and V. Kumar, “Search-based motion planning for quadrotors using linear quadratic minimum time control,” in Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst., 2017, pp. 2872–2879.
[10] M. J. Van Nieuwstadt and R. M. Murray, “Real time trajectory generation for differentially ﬂat systems,” Int. J. Robust Nonlinear Control, vol. 8, no. 11, pp. 995–1020, 1998.
[11] D. Mellinger and V. Kumar, “Minimum snap trajectory generation and control for quadrotors,” in Proc. IEEE Int. Conf. Robot. Autom., 2011, pp. 2520–2525.
[12] S. Liu et al., “Planning dynamically feasible trajectories for quadrotors using safe ﬂight corridors in 3-D complex environments,” IEEE Robot. Autom. Lett., vol. 2, no. 3, pp. 1688–1695, Jul. 2017.
[13] J. Chen, T. Liu, and S. Shen, “Online generation of collision-free trajectories for quadrotor ﬂight in unknown cluttered environments,” in Proc. IEEE Int. Conf. Robot. Autom., 2016, pp. 1476–1483.
[14] J. Ichnowski and R. Alterovitz, “Fast nearest neighbor search in SE (3) for sampling-based motion planning,” in Algorithmic Foundations of Robotics XI. Berlin, Germany: Springer, 2015, pp. 197–214.
[15] N. Ratliff, M. Zucker, J. A. Bagnell, and S. Srinivasa, “Chomp: Gradient optimization techniques for efﬁcient motion planning,” in Proc. IEEE Int. Conf. Robot. Autom., 2009, pp. 489–494.
[16] M. Pivtoraiko, R. A. Knepper, and A. Kelly, “Differentially constrained mobile robot motion planning in state lattices,” J. Field Robot., vol. 26, no. 3, pp. 308–333, 2009.
[17] B. MacAllister, J. Butzke, A. Kushleyev, H. Pandey, and M. Likhachev, “Path planning for non-circular micro aerial vehicles in constrained environments,” in Proc. IEEE Int. Conf. Robot. Autom, 2013, pp. 3933–3940.
[18] M. Mueller, M. Hehn, and R. D’Andrea, “A computationally efﬁcient motion primitive for quadrocopter trajectory generation,” IEEE Trans. Robot, vol. 31, no. 6, pp. 1294–1310, Dec. 2015.
[19] S. Karaman and E. Frazzoli, “Sampling-based algorithms for optimal motion planning,” Int. J. Robot. Res., vol. 30, no. 7, pp. 846–894, 2011.
[20] E. A. Hansen and R. Zhou, “Anytime heuristic search,” J. Artif. Intell. Res., vol. 28, pp. 267–297, 2007.
[21] M. Likhachev, G. Gordon, and S. Thrun, “ARA*: Anytime A* with Provable Bounds on Sub-Optimality,” in Proc. Adv. Neural Inf. Process. Syst., 2004, pp. 767–774.
[22] S. Aine, S. Swaminathan, V. Narayanan, V. Hwang, and M. Likhachev, “Multi-heuristic A,” Int. J. Robot. Res., vol. 35, no. 1–3, pp. 224–243, 2016.
[23] C. M. Wilt and W. Ruml, “When does weighted A* fail?” in Proc. Annu. Symp. Combinatorial Search, 2012, pp. 137–144.
[24] K. Gochev, B. Cohen, J. Butzke, A. Safonova, and M. Likhachev, “Path planning with adaptive dimensionality,” in Proc. 4th Annu. Symp. Combinatorial Search, 2011.
[25] T. Lee, M. Leoky, and N. H. McClamroch, “Geometric tracking control of a quadrotor UAV on SE (3),” in Proc. 49th IEEE Conf. Decision Control, 2010, pp. 5420–5425.
[26] M. Hehn and R. D’Andrea, “Quadrocopter trajectory generation and control,” IFAC Proc. Volumes, vol. 44, no. 1, pp. 1485–1491, 2011.
[27] R. B. Rusu and S. Cousins, “3D is here: Point cloud library (PCL),” in Proc. IEEE Int. Conf. Robot. Autom., Shanghai, China, May 2011.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on June 08,2022 at 09:52:46 UTC from IEEE Xplore. Restrictions apply.

