IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Processing math: 0%

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Conferences > 2017 IEEE/RSJ International C...
Search-based motion planning for quadrotors using linear quadratic minimum time control
Publisher: IEEE
Cite This
PDF
  << Results   
Sikang Liu ; Nikolay Atanasov ; Kartik Mohta ; Vijay Kumar
All Authors
View Document
69
Paper
Citations
2238
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Problem Formulation
    III.
    Optimal Trajectory Planning
    IV.
    Trajectory Refinement
    V.
    Experimental Results

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
Media
More Like This
Footnotes

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: In this work, we propose a search-based planning method to compute dynamically feasible trajectories for a quadrotor flying in an obstacle-cluttered environment. Our appr... View more
Metadata
Abstract:
In this work, we propose a search-based planning method to compute dynamically feasible trajectories for a quadrotor flying in an obstacle-cluttered environment. Our approach searches for smooth, minimum-time trajectories by exploring the map using a set of short-duration motion primitives. The primitives are generated by solving an optimal control problem and induce a finite lattice discretization on the state space which can be explored using a graph-search algorithm. The proposed approach is able to generate resolution-complete (i.e., optimal in the discretized space), safe, dynamically feasibility trajectories efficiently by exploiting the explicit solution of a Linear Quadratic Minimum Time problem. It does not assume a hovering initial condition and, hence, is suitable for fast online re-planning while the robot is moving. Quadrotor navigation with online re-planning is demonstrated using the proposed approach in simulation and physical experiments and comparisons with trajectory generation based on state-of-art quadratic programming are presented.
Published in: 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)
Date of Conference: 24-28 September 2017
Date Added to IEEE Xplore : 14 December 2017
ISBN Information:
Electronic ISSN: 2153-0866
INSPEC Accession Number: 17428322
DOI: 10.1109/IROS.2017.8206119
Publisher: IEEE
Conference Location: Vancouver, BC, Canada
Contents
SECTION I.
Introduction

Smooth trajectories obtained by minimizing jerk or snap have been widely used to control differentially flat dynamical systems such as quadrotors [1] – [2] [3] . These trajectories are represented via time-parameterized polynomials, which converts the trajectory generation problem into one of finding polynomial coefficients that satisfy certain constraints. Recent work exploring time-optimal trajectory generation includes [4] , [5] . If additionally, obstacle avoidance is added as a consideration, the trajectory generation problem becomes more challenging. While mixed integer optimization techniques [6] , [7] handle collisions reliably, they suffer from high computational costs. Recent work demonstrated practical application of quadratic programming [8] – [9] [10] [11] to derive collision-free trajectories in real-time. These methods separate the trajectory generation problem in two parts: (i) planning a collision-free geometric path and (ii) optimizing it locally to obtain a dynamically-feasible time-parametrized trajectory. In this way, one can solve for a locally optimal trajectory with respect to a given time allocation . However, the prior geometric path restricts the generated trajectory to be inside a given homology class which may not contain a globally optimal (or even feasible) trajectory ( Fig. 1 ).

This paper proposes an approach for global trajectory optimization that obtains collision-free, dynamically-feasible, minimum-time, smooth trajectories in real time. Instead of using a geometric path as a prior, our approach explores the space of trajectories using a set of short-duration motion primitives generated by solving an optimal control problem. We prove that the primitives induce a finite lattice discretization on the state space, which can in turn be explored using a graph-search algorithm. It is well-known that the graph search in high-dimensional state spaces is not computationally efficient because there are many states to be explored. However, with the help of a tight lower bound (heuristic) on the optimal cost we can inform and significantly accelerate the search. The main contribution of this paper can be concluded as:

    generation of motion primitives that convert an optimal control problem to graph search

    a search heuristic(s) based on the explicit solution of a Linear Quadratic Minimum Time problem

Fig. 1:

Taking the quadrotor dynamics into account is important for obtaining a smooth trajectory (magenta) while flying at non-zero velocity towards a goal (red triangle). In contrast, existing methods generate a trajectory (red dashed curve) from a shortest path that ignores the system dynamics. Instead of relying on a prior shortest path, the approach proposed in this paper plans globally-optimal trajectories based on time and control efforts.

Show All

In contrast with previous works based on motion primitives like [12] – [13] [14] , our approach does not require a big precomputed look-up table to find connections between different graph nodes. To reduce the run time, we propose to plan a trajectory in a lower dimension state space and refine a final trajectory that is executable by quadrotors through an unconstrained quadratic programming. We also show that our method generates smoother trajectories compared to the traditional path-based trajectory generation approaches. We demonstrate that our approach can be used for online replanning during fast quadrotor navigation in various cluttered environments. The the code used in this work is open sourced on https://github.com/sikang/motion_primitive_library .
SECTION II.
Problem Formulation

Let x(t)\in \mathcal{X}\subset \mathbb{R}^{3n} be a dynamical system state, consisting of 3-D position and its (n-1) derivatives (velocity, acceleration, jerk, etc.). Let \mathcal{X}^{free} \subset \mathcal{X} denote free region of the state space that, in addition to capturing the obstacle-free positions \mathcal{P}^{free} , also specifies constraints \mathcal{D}^{fre{e}} on the system's dynamics, i.e., maximum velocity v_{max} , acceleration a_{max} , and higher order derivatives in each axis. Note that \mathcal{P}^{free} is bounded by the size of the map that we are planning in. Thus, \mathcal{X}^{free}: =\mathcal{P}^{free} \times \mathcal{D}^{free} = \mathcal{P}^{free}\times[-v_{max}, v_{max}]^{3}\times[-a_{max}, a_{max}]^{3}\times\ldots . Denote the obstacle region as \mathcal{X}^{obs}:=\mathcal{X}\backslash \mathcal{X}^{free} .

As described in [15] and many other related works, the differential flatness of quadrotor systems allow us to construct control inputs from I-D time-parametrized polynomial trajectories specified independently in each of the three position axes. Thus, we consider polynomial state trajectories x(t):=[p_{D}(t)^{\top},\dot{p}_{D}(t)^{\top}, \ldots, p_{D}^{(n-1)}(t)^{\top}]^{\top} , where \begin{equation*} p_{D}(t): =\sum\limits_{k=0}^{K}d_{k}\frac{t^{k}}{k!}=d_{K}\frac{t^{K}}{K!}+\ldots+d_{1}t+d_{0}\in \mathbb{R}^{3} \tag{1} \end{equation*} View Source \begin{equation*} p_{D}(t): =\sum\limits_{k=0}^{K}d_{k}\frac{t^{k}}{k!}=d_{K}\frac{t^{K}}{K!}+\ldots+d_{1}t+d_{0}\in \mathbb{R}^{3} \tag{1} \end{equation*} and D: = [d_{0}, \ldots, d_{K}] \in \mathbb{R}^{3\times(K+1)} , To simplify the notation, we denote the system's velocity by v(t):=\dot{p}_{D}^{\top}(t) , acceleration by a(t):=\ddot{p}_{D}^{\top}(t) , jerk by j(t):=\overset{\ldots}{p}_{D}^{\top}(t) , etc., and drop the subscript D where convenient. Polynomial trajectories of the form Eq. (1) can be generated by considering a linear time-invariant dynamical system p_{D}^{(n)}(t)=u(t) , where the control input is u(t)\in \mathcal{U}:=[-u_{max}, u_{max}]^{3}\subset \mathbb{R}^{3} . In state space form, we obtain a system as \begin{align*} &\dot{x}=Ax+Bu\\ &A=\begin{bmatrix} 0 & \mathbf{I}_{3} & 0 & \cdots & 0\\ 0 & 0 & \mathbf{I}_{3} & \cdots & 0\\ \vdots & \ddots & \ddots & \ddots & \vdots \\ 0 & \cdots & \cdots & 0 & \mathbf{I}_{3}\\ 0 & \cdots & \cdots & 0 & 0 \end{bmatrix},\quad B=\begin{bmatrix} 0\\ 0\\ \vdots \\ 0\\ \mathbf{I}_{3} \end{bmatrix}\tag{2} \end{align*} View Source \begin{align*} &\dot{x}=Ax+Bu\\ &A=\begin{bmatrix} 0 & \mathbf{I}_{3} & 0 & \cdots & 0\\ 0 & 0 & \mathbf{I}_{3} & \cdots & 0\\ \vdots & \ddots & \ddots & \ddots & \vdots \\ 0 & \cdots & \cdots & 0 & \mathbf{I}_{3}\\ 0 & \cdots & \cdots & 0 & 0 \end{bmatrix},\quad B=\begin{bmatrix} 0\\ 0\\ \vdots \\ 0\\ \mathbf{I}_{3} \end{bmatrix}\tag{2} \end{align*}

We are interested in planning state trajectories that are collision-free , respect the constraints on the dynamics, and are minimum-time and smooth . We define the smoothness or effort of a trajectory as the square L^{2} -norm of the control input u(t) : \begin{equation*} J(D): =\int\nolimits_{0}^{T}\Vert u(t)\Vert^{2}dt=\int\nolimits_{0}^{T}\left\Vert p_{D}^{(n)}(t)\right\Vert^{2}dt \tag{3} \end{equation*} View Source \begin{equation*} J(D): =\int\nolimits_{0}^{T}\Vert u(t)\Vert^{2}dt=\int\nolimits_{0}^{T}\left\Vert p_{D}^{(n)}(t)\right\Vert^{2}dt \tag{3} \end{equation*} and consider the following problem.
II.
Problem 1

Given an initial state x_{0}\in \mathcal{X}^{free} and a goal region \mathcal{X}^{goal} \subset \mathcal{X}^{free} , find a polynomial trajectory parametrization D\in \mathbb{R}^{3\times(K+1)} and a time T\geq 0 such that : \begin{equation*} \begin{split} &\qquad \min\limits_{D, T}\ J(D)+\rho T\\ s.t.\dot{x}(t)&=Ax(t)+Bu(t),\quad \forall t\in[0, T]\\ x(0)&=x_{0},\quad x(T)\in \mathcal{X}^{goal}\\ x(t)&\in \mathcal{X}^{free},\quad u(t)\in \mathcal{U},\quad \forall t\in[0, T] \end{split}\tag{4} \end{equation*} View Source \begin{equation*} \begin{split} &\qquad \min\limits_{D, T}\ J(D)+\rho T\\ s.t.\dot{x}(t)&=Ax(t)+Bu(t),\quad \forall t\in[0, T]\\ x(0)&=x_{0},\quad x(T)\in \mathcal{X}^{goal}\\ x(t)&\in \mathcal{X}^{free},\quad u(t)\in \mathcal{U},\quad \forall t\in[0, T] \end{split}\tag{4} \end{equation*} where the parameter \rho\geq 0 determines the relative importance of the trajectory duration {T} versus its smoothness J .
Fig. 2:

Three trajectories start from x(0) to x(T) . Blue and green rays indicate the magnitude of velocity and acceleration along trajectories respectively. If the effort J is disregarded, i.e. \rho\rightarrow\infty in eq. (4) , trajectories (a) and (b) have equivalent cost of T=4 . If the time T is not considered, i.e. \rho=0 . Trajectory (c) become optimal. Since we are interested in low-effort trajectories, p should not be infinite (so that (a) is preferable to (b)) but it should still be large enough to prioritize fast trajectories. Thus, in this comparison, (a) is preferable to both (b) and (c).

Show All

In the remainder, we denote the optimal cost from an initial state x_{0} to a goal region \mathcal{X}^{goal}\ \text{by}\ C^{\ast}(x_{0}, \mathcal{X}^{goal}) . The reason for choosing such an objective function is illustrated in Fig. 2 . This problem is a Linear Quadratic Minimum-Time problem [16] with state constraints, x(t)\in \mathcal{X}^{free} , and input constraints, u(t)\in \mathcal{U} . As the derivation in Sec III-D shows, if we drop the constraints x(t)\in \mathcal{X}^{f{ree}}, u(t)\in \mathcal{U} , the optimal solution can be obtained via Pontryagin's minimum principle [16] , [17] and the optimal choice of polynomial degree is K=2n-1 . The main challenge is the introduction of the constraints x(t)\in \mathcal{X}^{fr{e}e}, u(t)\in \mathcal{U} . In this paper, we show that these safety constraints can be handled by converting the problem to a deterministic shortest path problem [18, Ch.2] with a 3n dimensional state space \mathcal{X} and a 3 dimensional control space \mathcal{U} . Since the control space \mathcal{U} is always 3 dimensional, a search-based planning algorithm such as A^{\ast} [19] that discretizes \mathcal{U} motion primitives is efficient and resolution-complete (i.e., it can compute the optimal trajectory in the discretized space in finite-time, unlike sampling-based planners such as RRT [20] , [21] ).
SECTION III.
Optimal Trajectory Planning
A. Motion Primitives

First, we discuss the construction of motion primitives for the system in Eq. (2) that will allow us to convert Problem 1 from an optimal control problem to a graph-search problem. Instead of using the control set \mathcal{U} , we consider a lattice discretization [22] \mathcal{U}_{M}:=\{u_{1}, \ldots, u_{M}\}\subset \mathcal{U} , where each control u_{m}\in \mathbb{R}^{3} vector will define a motion of short duration for the system. One way to obtain the discretization \mathcal{U}_{M} is to choose a number of samples \mu\in \mathbb{Z}^{+} along each axis [0, u_{max}] , which defines a discretization step d_{u}:=\frac{u_{max}}{\mu} and results in M=(2\mu+1)^{3} motion primitives. Given an initial state x_{0}:=[p_{0}^{\top}, v_{0}^{\top}, a_{0}^{\top}, \ldots]^{\top} , we generate a motion primitive of duration \tau > 0 that applies a constant control input u(t)\equiv u_{m}\in \mathcal{U}_{M} for t\in[0,\tau] so that: \begin{equation*} u(t)=p_{D}^{(n)}(t)=\sum\limits_{k=0}^{K-n}d_{k+n}\frac{t^{k}}{k!}\equiv u_{m}. \end{equation*} View Source \begin{equation*} u(t)=p_{D}^{(n)}(t)=\sum\limits_{k=0}^{K-n}d_{k+n}\frac{t^{k}}{k!}\equiv u_{m}. \end{equation*}

The control input being constant, implies that all coefficients that involve time need to be identically zero, i.e.: \begin{equation*} d_{(n+1): K}=0\Longrightarrow u_{m}=d_{n} \end{equation*} View Source \begin{equation*} d_{(n+1): K}=0\Longrightarrow u_{m}=d_{n} \end{equation*}

Integrating the control expression u(t)=u_{m} with an initial condition x_{0} results in \begin{equation*} p_{D}(t)=u_{m}\frac{t^{n}}{n!}+\ldots+a_{0}\frac{t^{2}}{2}+v_{0}t+p_{0} \end{equation*} View Source \begin{equation*} p_{D}(t)=u_{m}\frac{t^{n}}{n!}+\ldots+a_{0}\frac{t^{2}}{2}+v_{0}t+p_{0} \end{equation*} or, equivalently, the resulting trajectory of the linear time-invariant system in Eq. (2) is: \begin{equation*} x(t)=\underbrace{e^{At}\ }_{F(t)}x_{0}+\underbrace{\left[\int\nolimits_{0}^{t}e^{A(t-\sigma)}Bd\sigma\right]}_{G(t)}u_{m} \end{equation*} View Source \begin{equation*} x(t)=\underbrace{e^{At}\ }_{F(t)}x_{0}+\underbrace{\left[\int\nolimits_{0}^{t}e^{A(t-\sigma)}Bd\sigma\right]}_{G(t)}u_{m} \end{equation*}

An example of the resulting system trajectories is given in Fig. 3 . Since both the duration \tau and the control input u_{m} are fixed, the cost of the motion primitive according to Eq. (4) is (\Vert u_{m}\Vert^{2}+\rho)\tau
Fig. 3:

Example of 9 planar motion primitives from initial state x_{0} for an acceleration-controlled (n=\ 2) system (left) and a jerk-controlled (n=3) system (right). The black arrow indicates correpsonding control input. The red boundary shows the feasible region for the end states (red squares), which is induced by the control limit u_{max} . The initial velocity and acceleration are v_{0}= [1,0,0]^{\top} and a_{0}=[0,1,0]^{\top} (only for the right figure).

Show All

B. Induced Space Discretization
Proposition 1

The motion primitives defined in the previous section induce a discretization on the state space \mathcal{X}
Proof

See App. A . □

This discretization of the state space allows us to construct a graph representation of the reachable system states by starting at x_{0} and applying all primitives to obtain the M possible states after a duration of \tau (see Fig. 3 and Alg. 1 ). Applying all possible primitives to each of the M states again, will result in M^{2} possible states at time 2\tau . Since the free space \mathcal{X}^{fr{e}e} is bounded and discretized, the set of reachable states \mathcal{S} is finite.

This defines a graph \mathcal{G}(\mathcal{S}, \mathcal{E}) , where \mathcal{S} is the discrete set of reachable system states and \mathcal{E} is the set of edges that connect states in the graph, each defined by a motion primitive e:= (u_{m}, \tau) . Let s_{0} be the state corresponding to x_{0}
Algorithm 1 Given s\in \mathcal{S} and a Motion Primitive set \mathcal{U}_{M} with Duration \tau , Find the States \mathcal{R}(s) that are Reachable from s in One Step and Their Associated Costs \mathcal{C}(s)

We use Algorithm 1 to explore the free state space \mathcal{X}^{free} and build the connected graph: in line 4, the primitive is calculated using the fully defined state s and a control input u_{m} given the constant time \tau ; line 5 checks the feasibility of the primitive, this step will be further discussed in Section. III-E ; in line 6, we evaluate the end state of a valid primitive and add it to the set of successors of the current node; in the meanwhile, we estimate the edge cost from the corresponding primitive. After checking through all the primitives in the finite control input set, we add the nodes in successor set \mathcal{R}(s) to the graph, and we continue expanding until we reach the goal region.
Proposition 2

The motion primitive u_{ij} \in \mathcal{U}_{M} which connects two consecutive states s_{i}, s_{j}\in \mathcal{S} with s_{j}\ = F(\tau)s_{{i}}+G(\tau)u_{ij} is optimal according to the cost function in Eq. ( 4 ) .
Proof

See App. B . □
C. Deterministic Shortest Trajectory

Given the set of motion primitives \mathcal{U}_{M} and the induced space discretization discussed in the previous section, we can re-formulate Problem 1 as a graph-search problem. This can be done by introducing additional constraints that stipulate that the control input u(t) in Eq. (4) is piecewise-constant over intervals of duration \tau . More precisely, we introduce an additional variable N\in \mathbb{Z}^{+} , such that T=N\tau , and u_{k}\in \mathcal{U}_{M} for k=0, \ldots, N-1 and a constraint in Eq. (4) : \begin{equation*} u(t)=\sum\limits_{k=0}^{N-1}u_{k}{1\!\ \!\!\text{l}}_{\{t\in[k\tau,(k+1)\tau)\}} \end{equation*} View Source \begin{equation*} u(t)=\sum\limits_{k=0}^{N-1}u_{k}{1\!\ \!\!\text{l}}_{\{t\in[k\tau,(k+1)\tau)\}} \end{equation*} that forces the control trajectory to be a composition of the motion primitives in \mathcal{U}_{M} . This leads to the following deterministic shortest path problem [18, Ch.2] .
Problem 2

Given an initial state x_{0}\in \mathcal{X}^{free} , a goal region \mathcal{X}^{goal} \subset \mathcal{X}^{free} , and a finite set of motion primitives \mathcal{U}_{M} with duration \tau > 0 , choose a sequence of motion primitives u_{0:N-1} of length N such that : \begin{equation*} \begin{split} &\qquad\ \ \min\limits_{N, u_{0:N-1}}\ \left(\sum\limits_{k=0}^{N-1}\Vert u_{k}\Vert^{2}+\rho N\right)\tau\\ s.t.&x_{k}(\tilde{t})=F(\tilde{t})s_{k}+G(\tilde{t})u_{k}\subset \mathcal{X}^{free},\quad \tilde{t}\in[0, \tau]\\ &x_{k}(\tilde{t})\subset \mathcal{X}^{free}\quad \forall k\in\{0, \ldots, N-1\}, \tilde{t}\in[0, \tau]\\ &s_{k+1}=x_{k}(\tau),\quad \forall k\in\{0, \ldots, N-1\}\\ &s_{0}=x_{0},\quad s_{N}\in \mathcal{X}^{goal}\\ &u_{k}\in \mathcal{U}_{M},\quad \forall k\in\{0, \ldots, N-1\} \end{split}\tag{5} \end{equation*} View Source \begin{equation*} \begin{split} &\qquad\ \ \min\limits_{N, u_{0:N-1}}\ \left(\sum\limits_{k=0}^{N-1}\Vert u_{k}\Vert^{2}+\rho N\right)\tau\\ s.t.&x_{k}(\tilde{t})=F(\tilde{t})s_{k}+G(\tilde{t})u_{k}\subset \mathcal{X}^{free},\quad \tilde{t}\in[0, \tau]\\ &x_{k}(\tilde{t})\subset \mathcal{X}^{free}\quad \forall k\in\{0, \ldots, N-1\}, \tilde{t}\in[0, \tau]\\ &s_{k+1}=x_{k}(\tau),\quad \forall k\in\{0, \ldots, N-1\}\\ &s_{0}=x_{0},\quad s_{N}\in \mathcal{X}^{goal}\\ &u_{k}\in \mathcal{U}_{M},\quad \forall k\in\{0, \ldots, N-1\} \end{split}\tag{5} \end{equation*}

The optimal cost of Problem 2 is an upper bound to the optimal cost of Problem 1 because Problem 2 is just a constrained version of Problem 1 . However, this reformulation to discrete control and state-spaces enables an efficient solution. Such problems can be solved via search-based [23] , [19] or sampling-based [20] , [21] , [24] motion planning algorithms. Since only the former guarantees finite-time (sub-)optimality, we use an A^{\ast} method and focus on the design of an accurate, consistent heuristic and efficient, guaranteed collision checking methods in following subsections.
D. Heuristic Function Design

Devising an efficient graph search for solving Problem 2 requires an approximation of the optimal cost function, i.e., a heuristic function, that is admissible 1 , informative (i.e., provides a tight approximation of the optimal cost), and consistent 2 (i.e., can be inflated in order to obtain solutions with bounded suboptimality very efficiently [19] ). Since by construction, the optimal cost of Problem 2 is bounded below by the optimal cost of Problem 1 , we can obtain a good heuristic function by solving a relaxed version of Problem 1 . Our idea is to replace constraints in Eq. (4) that are difficult to satisfy, namely, x(t)\in \mathcal{X}^{free} : and u(t)\in \mathcal{U} , with a constraint on the time T . In this section, we show that such a relaxation of Problem 1 can be solved optimally and efficiently.
1) Minimum Time Heuristic

Intuitively, the constraints on maximum velocity, acceleration, jerk, etc. due to \mathcal{X}^{obs} : and \mathcal{U} induce a lower bound \bar{T} on the minimum achievable time in (4) . For example, since the system's maximum velocity is bounded by v_{max} along each axis, the minimum time for reaching the closest state x_{f} in the goal region \mathcal{X}^{goal} is bounded below by \bar{T}_{v}:=\frac{\Vert p_{f}-p_{0}\Vert_{\infty}}{v_{max}} . Similarly, since the system's maximum acceleration is bounded by a_{max} , the state x_{f}:=[p_{f}^{\top}, v_{f}^{\top}]^{\top} cannot be reached faster than: \begin{align*} &\qquad\qquad \min\limits_{\bar{T}_{a}, a(t)}\bar{T}_{a}\\ \text{s. t}.\ \ &\Vert a(t)\Vert\leq a_{max},\quad \forall t\in[0, T]\\ &p(0)=p_{0},\ v(0)=v_{0}\\ &p(\bar{T}_{a})=p_{f},\ v(\bar{T}_{a})=v_{f} \end{align*} View Source \begin{align*} &\qquad\qquad \min\limits_{\bar{T}_{a}, a(t)}\bar{T}_{a}\\ \text{s. t}.\ \ &\Vert a(t)\Vert\leq a_{max},\quad \forall t\in[0, T]\\ &p(0)=p_{0},\ v(0)=v_{0}\\ &p(\bar{T}_{a})=p_{f},\ v(\bar{T}_{a})=v_{f} \end{align*}

The above is a minimum-time (Brachistochrone) optimal control problem with input constraints, which may be difficult to solve directly in 3-D [25] but can be solved in closed-form along individual axes [17, Ch.5] to obtain lower bounds \bar{T}{}_{a}^{x},\bar{T}{}_{a}^{y},\bar{T}{}_{a}^{z} . This procedure can be continued for the constraint on jerk j_{max} and those on higher-order derivatives but the problems become more complicated to solve and the computed times are less likely to provide better bounds the previous ones. Hence, we can define a lower bound on the minimum achievable time via \bar{T}:= \max\{\bar{T}_{v},\bar{T}{}_{a}^{x},\bar{T}{}_{a}^{y},\bar{T}{}_{a}^{z},\bar{T}_{j}, \ldots\} but for simplicity we use the easily computable but less tight bound \bar{T}=\bar{T}_{v} .

Hence, to find a heuristic function, we relax Problem 1 by replacing the state and input constraints, x(t)\in \mathcal{X}^{free} and u(t)\in \mathcal{U} , with the lower bound T\geq\bar{T}_{v} : \begin{equation*} \begin{split} &\qquad\quad\ \ \min\limits_{D, T}J(D)+\rho T\\ \text{s. t}.& \dot{x}(t)=Ax(t)+Bu(t),\quad \forall t\in[0, T]\\ &x(0)=x_{0},\quad x(T)\in \mathcal{X}^{goal}\\ &T\geq\bar{T} \end{split}\tag{6} \end{equation*} View Source \begin{equation*} \begin{split} &\qquad\quad\ \ \min\limits_{D, T}J(D)+\rho T\\ \text{s. t}.& \dot{x}(t)=Ax(t)+Bu(t),\quad \forall t\in[0, T]\\ &x(0)=x_{0},\quad x(T)\in \mathcal{X}^{goal}\\ &T\geq\bar{T} \end{split}\tag{6} \end{equation*}

Since J(D)\geq 0 , a straight-forward way to obtain a lower-bound on the optimal cost is: \begin{equation*} C^{\ast}(x_{0},\mathcal{X}^{goal})=J(D^{\ast})+\rho T^{\ast}\geq\rho\bar{T}_{v} \end{equation*} View Source \begin{equation*} C^{\ast}(x_{0},\mathcal{X}^{goal})=J(D^{\ast})+\rho T^{\ast}\geq\rho\bar{T}_{v} \end{equation*}

Hence, given nodes s_{0}, s_{{f}}\in \mathcal{S} in the discretized space, the following is an admissible heuristic function: \begin{equation*} h_{1}(s_{0})=\rho\bar{T}_{v}=\frac{\rho\Vert p_{f}-p_{0}\Vert_{\infty}}{v_{max}} \tag{7} \end{equation*} View Source \begin{equation*} h_{1}(s_{0})=\rho\bar{T}_{v}=\frac{\rho\Vert p_{f}-p_{0}\Vert_{\infty}}{v_{max}} \tag{7} \end{equation*} for Problem 2 . It is easy to see that it is also consistent due to the triangle inequality for distances.
2) Linear Quadratic Minimum Time

While the minimum-time heuristic is very easy to compute and takes velocity constraints into account, it is not a very tight lower bound on the optimal cost in Eq. (5) because it disregards the control effort. The reason is that instead of solving Eq. (6) , we simply found a lower bound in the previous subsection. An important observation is that after removing the constraints x(t)\in \mathcal{X}^{fre{e}} and u(t)\in \mathcal{U} , the relaxed problem Eq. (6) is in fact the classical Linear Quadratic Minimum-Time Problem [16] . The optimal solution to Eq. (6) can be obtained from [16, Thm.2.1] with a minor modification introducing the additional constraint on time T\geq\bar{T} .
Proposition 3

Let x_{{f}}\in \mathcal{X}^{goal} be a fixed final state and define \delta_{T}:=x_{f}-e^{AT}x_{0} and the controllability Gramian W_{T}: =\int\nolimits_{0}^{T}e^{At}BB^{\top}e^{A^{\top}t}dt . Then, the optimal time T in Eq . (6) is either the lower bound \bar{T} or the solution of following equation : \begin{equation*} -\frac{d}{dT}\{\delta_{T}^{\top}W_{T}^{-1}\delta_{T}\}=2x_{f}^{\top}A^{\top}W_{T}^{-1}\delta_{T}+\delta_{T}^{\top}W_{T}^{-1}BB^{\top}W_{T}^{-1}\delta_{T}=\rho \tag{8} \end{equation*} View Source \begin{equation*} -\frac{d}{dT}\{\delta_{T}^{\top}W_{T}^{-1}\delta_{T}\}=2x_{f}^{\top}A^{\top}W_{T}^{-1}\delta_{T}+\delta_{T}^{\top}W_{T}^{-1}BB^{\top}W_{T}^{-1}\delta_{T}=\rho \tag{8} \end{equation*}

The optimal control is : \begin{equation*} u^{\ast}(t):=B^{\top}e^{A^{\top}(T-t)}W_{T}^{-1}\delta_{T} \tag{9} \end{equation*} View Source \begin{equation*} u^{\ast}(t):=B^{\top}e^{A^{\top}(T-t)}W_{T}^{-1}\delta_{T} \tag{9} \end{equation*}

While the optimal cost is : \begin{equation*} h_{2}(x_{0})=\delta_{T}^{\top}W_{T}^{-1}\delta_{T}+\rho T \tag{10} \end{equation*} View Source \begin{equation*} h_{2}(x_{0})=\delta_{T}^{\top}W_{T}^{-1}\delta_{T}+\rho T \tag{10} \end{equation*}

The polynomial coefficients D\in \mathbb{R}^{3\times(2n)} in Eq . (1) are : \begin{equation*} d_{0:(n-1)}=x_{0},\qquad d_{n:(2n-1)}=\delta_{T}^{\top}W_{T}^{-\top}e^{AT}H^{\top} \end{equation*} View Source \begin{equation*} d_{0:(n-1)}=x_{0},\qquad d_{n:(2n-1)}=\delta_{T}^{\top}W_{T}^{-\top}e^{AT}H^{\top} \end{equation*} where H\in \mathbb{R}^{(3n)\times(3n)} with H_{ij}=\begin{cases} (-1)^{j},&i=j\\ 0,&i\neq j \end{cases} .

Thus, the optimal cost h_{2}(x_{0}) obtained in Prop. 3 is a better heuristic for Problem 2 than h_{1} because h_{2} takes the control efforts into account. It is also admissible by construction because the optimal cost of Problem 2 is lower bounded by the optimal cost of Problem 1 , which in turn is lower bounded by h_{2}(x_{0}) . Below, we give examples of the results in Prop. 3 for several practical cases with a given T .
a) Velocity Control

Let n=1 . so that \mathcal{X}\subset \mathbb{R}^{3} : is position space and \mathcal{U} is velocity space. Then, the optimal solution to Eq. (6) according to Prop. 3 is: \begin{align*} d_{1}=&\frac{1}{T}(p_{f}-p_{0})\\ x^{\ast}(t)=&d_{1}t+p_{0}, u^{\ast}(t)=d_{1}\\ C^{\ast}=&\frac{1}{T}\Vert p_{f}-p_{0}\Vert^{2}+\rho T \end{align*} View Source \begin{align*} d_{1}=&\frac{1}{T}(p_{f}-p_{0})\\ x^{\ast}(t)=&d_{1}t+p_{0}, u^{\ast}(t)=d_{1}\\ C^{\ast}=&\frac{1}{T}\Vert p_{f}-p_{0}\Vert^{2}+\rho T \end{align*}
b) Acceleration Control

Let n=2 so that \mathcal{X}\subset\mathbb{R}^{6} is position-velocity space and \mathcal{U} is acceleration space. Then, the optimal solution to Eq. (6) according to Prop. 3 is: \begin{align*} \begin{pmatrix} d_{3}\\ d_{2} \end{pmatrix}&=\begin{bmatrix} -\frac{12}{T^{3}} & \frac{6}{T^{2}}\\ \frac{6}{T^{2}} & -\frac{2}{T} \end{bmatrix}\begin{bmatrix} p_{f}-p_{0}-v_{0}T\\ v_{f}-v_{0} \end{bmatrix}\\ x^{\ast}(t)&=\begin{bmatrix} \frac{d_{3}}{6}t^{3}+\frac{d_{2}}{2}t^{2}+v_{0}t+x_{0}\\ \frac{d_{3}}{2}t^{3}+d_{2}t+v_{0} \end{bmatrix}, u^{\ast}(t)=d_{3}t+d_{2}\\ C^{\ast}&=\frac{12\Vert p_{f}-p_{0}\Vert^{2}}{T^{3}}-\frac{12(v_{0}+v_{f})\cdot(p_{f}-p_{0})}{T^{2}}+\\ &\frac{4(\Vert v_{0}\Vert^{2}+v_{0}\cdot v_{1}+\Vert v_{1}\Vert^{2})}{T}+\rho T \end{align*} View Source \begin{align*} \begin{pmatrix} d_{3}\\ d_{2} \end{pmatrix}&=\begin{bmatrix} -\frac{12}{T^{3}} & \frac{6}{T^{2}}\\ \frac{6}{T^{2}} & -\frac{2}{T} \end{bmatrix}\begin{bmatrix} p_{f}-p_{0}-v_{0}T\\ v_{f}-v_{0} \end{bmatrix}\\ x^{\ast}(t)&=\begin{bmatrix} \frac{d_{3}}{6}t^{3}+\frac{d_{2}}{2}t^{2}+v_{0}t+x_{0}\\ \frac{d_{3}}{2}t^{3}+d_{2}t+v_{0} \end{bmatrix}, u^{\ast}(t)=d_{3}t+d_{2}\\ C^{\ast}&=\frac{12\Vert p_{f}-p_{0}\Vert^{2}}{T^{3}}-\frac{12(v_{0}+v_{f})\cdot(p_{f}-p_{0})}{T^{2}}+\\ &\frac{4(\Vert v_{0}\Vert^{2}+v_{0}\cdot v_{1}+\Vert v_{1}\Vert^{2})}{T}+\rho T \end{align*}

Here the optimal cost C^{\ast} turns out to be a polynomial function of T , we are able to derive the optimal T^{\ast} by minimizing C^{\ast}(T) as \begin{align*} T^{\ast}&=\underset{T}{\arg\min}\ C^{\ast}(T)\\ s.t. T&\geq \bar{T} \end{align*} View Source \begin{align*} T^{\ast}&=\underset{T}{\arg\min}\ C^{\ast}(T)\\ s.t. T&\geq \bar{T} \end{align*} the solution of which is the positive real root of C^{\ast}(T)^{\prime}=0 . Furthermore, the optimal cost is C^{\ast}=C^{\ast}(T^{\ast}) .
E. Collision Checking

For a calculated edge e(t)=[p(t)^{\top}, v(t)^{\top}, a(t)^{\top}, \ldots]^{\top} in Alg. 1 , we need to check if e(t)\subset \mathcal{X}^{free} for t\in[0,\tau] . We check collisions in the geometric space \mathcal{P}^{free}\subset \mathbb{R}^{3} separately from enforcing the dynamic constraints \mathcal{D}^{free}\subset \mathbb{R}^{3(n-1)} . The edge e(t) is valid only if its geometric shape p(t)\subset \mathcal{P}^{free} and derivatives (v(t), a(t), \ldots)\subset \mathcal{D}^{free} , i.e., \begin{equation*} (v, a,\ldots)\subset \mathcal{D}^{free}\Leftrightarrow\begin{matrix} \Vert v\Vert_{\infty}\leq v_{max}, & \forall t\in[0,\tau]\\ \Vert a\Vert_{\infty}\leq a_{max}, & \forall t\in[0,\tau]\\ \vdots \qquad\qquad\quad\ \ \end{matrix} \tag{11} \end{equation*} View Source \begin{equation*} (v, a,\ldots)\subset \mathcal{D}^{free}\Leftrightarrow\begin{matrix} \Vert v\Vert_{\infty}\leq v_{max}, & \forall t\in[0,\tau]\\ \Vert a\Vert_{\infty}\leq a_{max}, & \forall t\in[0,\tau]\\ \vdots \qquad\qquad\quad\ \ \end{matrix} \tag{11} \end{equation*}

Since the derivatives u, a, \ldots are polynomials, we calculate their extrema within the time period [0,\tau] to compare with maximum bounds on velocity, acceleration, etc. For n\leq 3 , the order of these polynomials is less than 5, which means we can easily solve for the extrema in closed form.

The more challenging part is checking collisions in \mathcal{P}^{free} . In this work, we model \mathcal{P} as an Occupancy Grid Map . Other representations such as a Polyhedral Map are also possible but these are usually hard to obtain from real-world sensor data [9] , [26] and out of the scope of the discussion in this paper. Let P: =\{p(t_{i})\ \vert\ t_{i}\in[0, \tau], i=0, \ldots, I\} be a set of positions that the system traverses along the trajectory p(t) . To ensure a collision-free trajectory, we just need to show that p(t_{i})\in \mathcal{P}^{free} : for all i\in\{0, \ldots, I\} . Given a polynomial p(t), t\in[0,\tau] , the positions p(t_{i}) are sampled by defining: \begin{equation*} t_{i}: =\frac{i}{I}\tau\quad \text{such that}\quad \frac{\tau}{I}v_{max}\geq R. \tag{12} \end{equation*} View Source \begin{equation*} t_{i}: =\frac{i}{I}\tau\quad \text{such that}\quad \frac{\tau}{I}v_{max}\geq R. \tag{12} \end{equation*}

Here R is the occupancy grid resolution. The condition ensures that the maximum distance between two consecutive samples will not exceed the map resolution. It is an approximation, since it can miss cells that are traversed by p(t) with a portion of the curve within the cell shorter than R , but it prevents the trajectory from hitting obstacles.
SECTION IV.
Trajectory Refinement

A trapezoid velocity profile is widely used to describe the robot following a path, in which the robot is assumed to move as a particle that exactly tracks the path with defined velocity function. This model gives the so-called time allocation for a large group of trajectory optimization approaches described in [1] , [8] – [9] [10] and [11] . However, this approximation is naive and the resulting trajectory significantly deforms from the given path since the modeled particle is not obeying the expected dynamics.

In above section, we proposed the complete solution for planning a trajectory that is valid in control space. The resulting trajectory gives not only the collision-free path, but also the time for reaching those waypoints. Thus, we are able to use it as a prior to generate a smoother trajectory in higher dimension for controlling the actual robot. The refined trajectory x^{\ast}(t) is derived from solving an unconstrained QP with given initial and end states s_{0}, s_{g} and the intermediate waypoints p_{k}, k\in\{0, \ldots, N-1\} . \begin{equation*} \begin{split} &\qquad \min\limits_{D}\sum\limits_{k=0}^{N-1}\int\nolimits_{0}^{\tau_{k}}\left\Vert p_{Dk}^{(n)}(t)\right\Vert^{2}dt\\ \text{s. t}. &x_{0}(0)=s_{0},\quad x_{N-1}(\tau_{N-1})=s_{g}\\ &x_{k+1}(0)=x_{k}(\tau_{k}), k\in\{0,\ldots, N-2\}\\ &p_{Dk}(\tau_{k})=p_{k},\qquad k\in\{0,\ldots, N-1\} \end{split}\tag{13} \end{equation*} View Source \begin{equation*} \begin{split} &\qquad \min\limits_{D}\sum\limits_{k=0}^{N-1}\int\nolimits_{0}^{\tau_{k}}\left\Vert p_{Dk}^{(n)}(t)\right\Vert^{2}dt\\ \text{s. t}. &x_{0}(0)=s_{0},\quad x_{N-1}(\tau_{N-1})=s_{g}\\ &x_{k+1}(0)=x_{k}(\tau_{k}), k\in\{0,\ldots, N-2\}\\ &p_{Dk}(\tau_{k})=p_{k},\qquad k\in\{0,\ldots, N-1\} \end{split}\tag{13} \end{equation*}

The time for each trajectory segment \tau_{k} is also given from the prior trajectory. The solution for Eq. (13) is proposed in [1] . We ignore the mathematical details in this section and only show the trajectory refinement results in Fig. 4 .
Fig. 4:

Trajectories planned from start s to goal g with initial velocity (4m/s) . The blue/green lines show the speed/acceleration along trajectories respectively and the red points are the intermediate waypoints. (a) Shows the shortest path. The time is allocated using the trapezoid velocity profile for generating min-jerk trajectory in (b). The resulting trajectory has a large cost for efforts J . (c) Shows the trajectory planned using acceleration-controlled system. In this case, the acceleration is not continuous. In (d), we refine using a min-jerk trajectory which has continuous and smooth acceleration. (e) Shows the trajectory planned using jerk-controlled system. The acceleration is continuous but not smooth. In (f), the refined min-jerk trajectory has continuous and smooth acceleration.

Show All

It needs to be notified that even though the refinement step produces a smoother trajectory, the refined trajectory might be unsafe and infeasible.
SECTION V.
Experimental Results
A. Heuristic Function

We proposed two different heuristics in Sec. III-D : denote the first one that estimates the minimum time using the max speed constraint as h_{1} ; denote the other one estimates the minimum cost function using the dynamic constraints as h_{2} . The heuristic h_{1} is easier to compute, but it fails to take in to account of the system's dynamics; the heuristic h_{2} requires to solve for the real roots of a polynomial, but it reveals the lower bound of the cost regarding system's dynamics and thus it is a tighter underestimation of the actual cost. Here we compare the performance of the algorithm with respect to the two heuristics h_{1}, h_{2} . As a reference, by setting the heuristic function to zero changes the algorithm into Dijkstra search. Fig. 5 visualizes the expanded nodes while searching towards the goal from a state with initial velocity 3m/s in positive vertical direction.
Fig. 5:

Generated trajectories using different heuristics. The expanded nodes (small dots) are colored by the corresponding cost value of the heuristic function. Grey nodes have zero heuristic value, high cost nodes are colored red while low cost nodes are colored green. T_{p} and N_{p} shows the time for planning and number of expanded nodes respectively.

Show All

We can see that the Minimum Cost Heuristic h_{2} makes the searching faster as it expands less nodes without loss of optimality. However, when it comes to the system with higher dimension, calculating h_{2} becomes harder as one can not analytically find the roots for a polynomial with order greater than 4. As claimed in Sec. III-D , when the maximum velocity is low, h_{1} is efficient enough for any dynamic system.
B. Run Time Analysis

To evaluate the computational efficiency of the algorithm, we record the run time of generating hundreds of trajectories ( Fig. 6 ) using either acceleration-controlled or jerk-controlled system in both 2-D and 3-D environments. Table I shows the time it takes for each system. We can see that planning in 3-D takes more time than in 2-D; also, planning in jerk space is much slower (10 times) than in acceleration space.
Fig. 6:

Trajectories generated to sampled goals (small red balls). For 2-D case, we use 9 primitives while for 3-D case, the number is 27.

Show All
Table I: Trajectory generation run time

C. Re-Planning and Comparisons

Receding Horizon Control (RHC) has been widely used for navigating an aerial vehicle in unknown environments [27] , the frequently re-planning process allows the robot to keep moving with limited sensing range until it reaches the goal region. In this section, we show results of our navigation system that builds on the RHC framework with the proposed trajectory generation method. As a comparison, we also set up the system that utilizes the prior planned path as the guide for trajectory generation. To demonstrate the fully autonomous collision avoidance on a quadrotor, we use the AscTec Pelican platform with a Hokuyo laser range-finder. We run state estimation and obstacle detection (mapping) as described in [28] on an onboard Intel NUC-i7 computer. Fig. 7 shows the performance of using these two approaches to avoid an obstacle by re-planning at the circle position where the desired speed is non-zero. The traditional path-based approach in Fig. 7(b) leads to a sharp turn while our approach generates a smoother trajectory shown in Fig. 7(c) .

Fig. 8 shows the results in simulation where we set up a longer obstacle-cluttered corridor for testing. The re-planning is triggered constantly at 3Hz and the maximum speed is set to be 3m/s . Our method generates a better overall trajectory compared to the traditional method as it avoids sharp turns when avoiding obstacles.
SECTION VI.
Conclusion

Search-based planning is well-known to be inefficient for high dimensional planning due to the large number of nodes to expand. Even though lattice search techniques with motion primitives have been explored for ground vehicles, it is still a hard problem to consider the system's dynamics in planning phase. Using ideas from optimal control, we propose a solution that plan optimal trajectories in high dimensional spaces within a reasonable time. The experimental results reveal the success of using it as the foundation for a safe and fast navigation system for a quadrotor. The deterministic optimal trajectory helps in reducing errors in state estimation and control, saving system energy and making robot's motion predictable. We believe the basic approach proposed in this paper is valuable for planning optimal trajectories for any system that is differential flat, moreover, this generic framework can be integrated with other path planning technique like sampling-based methods to generate trajectories.
Proof of Prop. 1

Given an initial state x_{0} and a sequence of k inputs, u_{1}, \ldots, u_{k} , are applied each for time \tau . The final state after applying the k inputs is given by, \begin{gather*} x(k\tau)=F^{k}(\tau)x_{0}+\sum\limits_{i=0}^{k-1}F^{i}(\tau)G(\tau)u_{k-i}\\ F^{k}(\tau)=\begin{bmatrix} \mathbf{I}_{3} & k\tau\mathbf{I}_{3} & \cdots & \frac{(k\tau)^{n-1}}{(n-1)!}\mathbf{I}_{3}\\ 0 & \mathbf{I}_{3} & \cdots & \frac{(k\tau)^{n-2}}{(n-2)!}\mathbf{I}_{3}\\ \vdots & \ddots & \ddots & \vdots \\ 0 & \cdots & \mathbf{I}_{3} & k\tau\mathbf{I}_{3}\\ 0 & \cdots & 0 & \mathbf{I}_{3} \end{bmatrix}\\ F^{i}(\tau)G(\tau)=\begin{bmatrix} {[}(i+1)^{n}-i^{n}]\frac{\tau^{n}}{n!}\mathbf{I}_{3}\\ {[}(i+1)^{n-1}-i^{n-1}]\frac{\tau^{n-1}}{(n-1)!}\mathbf{I}_{3}\\ \vdots \\ {[}(i+1)^{2}-i^{2}]\frac{\tau^{2}}{2!}\mathbf{I}_{3}\\ \tau\mathbf{I}_{3} \end{bmatrix} \end{gather*} View Source \begin{gather*} x(k\tau)=F^{k}(\tau)x_{0}+\sum\limits_{i=0}^{k-1}F^{i}(\tau)G(\tau)u_{k-i}\\ F^{k}(\tau)=\begin{bmatrix} \mathbf{I}_{3} & k\tau\mathbf{I}_{3} & \cdots & \frac{(k\tau)^{n-1}}{(n-1)!}\mathbf{I}_{3}\\ 0 & \mathbf{I}_{3} & \cdots & \frac{(k\tau)^{n-2}}{(n-2)!}\mathbf{I}_{3}\\ \vdots & \ddots & \ddots & \vdots \\ 0 & \cdots & \mathbf{I}_{3} & k\tau\mathbf{I}_{3}\\ 0 & \cdots & 0 & \mathbf{I}_{3} \end{bmatrix}\\ F^{i}(\tau)G(\tau)=\begin{bmatrix} {[}(i+1)^{n}-i^{n}]\frac{\tau^{n}}{n!}\mathbf{I}_{3}\\ {[}(i+1)^{n-1}-i^{n-1}]\frac{\tau^{n-1}}{(n-1)!}\mathbf{I}_{3}\\ \vdots \\ {[}(i+1)^{2}-i^{2}]\frac{\tau^{2}}{2!}\mathbf{I}_{3}\\ \tau\mathbf{I}_{3} \end{bmatrix} \end{gather*}
Fig. 7:

Pelican experiments using different trajectory generation pipelines. The robot is initially following a trajectory (blue curve) and needs to re-plan at the end of this prior trajectory (circled) to go to the goal (red triangle). The state from which the robot re-plans is non-static and the speed is 2m/s in positive vertical direction. (b) Shows the result of using traditional path-based trajectory generation method, the shortest path (purple line segments in the left figure) leads to the final trajectory (yellow curve in the righ figure); (c) shows the result of using our trajectory generation method, the shortest trajectory (purple curve in the left figure) leads to the smoother final trajectory (yellow curve in the righ figure).

Show All
Fig. 8:

Re-planning with RHC in simulation using different trajecotry generation pipelines. The robot starts from the left (circled) and the goal is at the right side of the map (red triangle). Blue curves show the traversed trajectory. (b) Shows the re-planning processes using traditional path-based trajectory generation method. (c) Shows the re-planning processes using proposed method in this paper. We can see that the overall trajectories in (c) is smoother than in (b).

Show All

Our discretized inputs are of the form u_{i}=d_{u}\kappa_{i} where \kappa\in \mathbb{Z}^{3} leading to x(k\tau) being of the form \begin{equation*} x(k\tau)=F^{k}(\tau)x_{0}+\begin{bmatrix} (\sum\nolimits_{i=0}^{k-1}[(i+1)^{n}-i^{n}]\kappa_{k-i})d_{u}\frac{\tau^{n}}{n!}\\ (\sum\nolimits_{i=0}^{k-1}[(i+1)^{n-1}-i^{n-1}]\kappa_{k-i})d_{u}\frac{\tau^{n-1}}{(n-1)!}\\ \vdots\\ (\sum\nolimits_{i=0}^{k-1}\kappa_{k-i})d_{u}\tau \end{bmatrix} \end{equation*} View Source \begin{equation*} x(k\tau)=F^{k}(\tau)x_{0}+\begin{bmatrix} (\sum\nolimits_{i=0}^{k-1}[(i+1)^{n}-i^{n}]\kappa_{k-i})d_{u}\frac{\tau^{n}}{n!}\\ (\sum\nolimits_{i=0}^{k-1}[(i+1)^{n-1}-i^{n-1}]\kappa_{k-i})d_{u}\frac{\tau^{n-1}}{(n-1)!}\\ \vdots\\ (\sum\nolimits_{i=0}^{k-1}\kappa_{k-i})d_{u}\tau \end{bmatrix} \end{equation*}

Thus we can see that each term in the expression for x(k\tau) is a variable integer times a constant which means that our state space is discretized due to discretization of the inputs. □
Appendix B
Proof of Prop. 2

Since the trajectory connecting s_{i} and s_{j} is collision-free by construction of the graph \mathcal{G} (see Alg. 1 ), the optimal control from s_{i} to s_{j} according to the cost function in (4) has the form prescribed by Prop. 3 . In detail \begin{equation*} \delta_{\tau}=s_{j}-F(\tau)s_{i}=G(\tau)u_{ij} \end{equation*} View Source \begin{equation*} \delta_{\tau}=s_{j}-F(\tau)s_{i}=G(\tau)u_{ij} \end{equation*} and the optimal control is: \begin{align*} u^{\ast}(t)=&B^{\top}e^{A^{\top}(\tau-t)}W_{\tau}\delta_{\tau}\\ =&B^{\top}e^{A^{\top}(\tau-t)}\left(\int\nolimits_{0}^{\tau}e^{As}BB^{\top}e^{A^{\top}s}ds\right)^{-1}\int\nolimits_{0}^{\tau}e^{As}dsBu_{i} \end{align*} View Source \begin{align*} u^{\ast}(t)=&B^{\top}e^{A^{\top}(\tau-t)}W_{\tau}\delta_{\tau}\\ =&B^{\top}e^{A^{\top}(\tau-t)}\left(\int\nolimits_{0}^{\tau}e^{As}BB^{\top}e^{A^{\top}s}ds\right)^{-1}\int\nolimits_{0}^{\tau}e^{As}dsBu_{i} \end{align*}

Since only the bottom 3\times 3 block of B is non-zero and since the matrix e^{A^{\top}(\tau-t)}\left(\int\nolimits_{0}^{\tau}e^{As}BB^{\top}e^{A^{\top}s}ds\right)^{-1}\int\nolimits_{0}^{\tau}e^{As}ds has its bottom-right 3\times 3 block equal to I_{3\times 3} , we get: \begin{equation*} B^{\top}e^{A^{\top}(\tau-t)}\left(\int\nolimits_{0}^{\tau}e^{As}BB^{\top}e^{A^{\top}s}ds\right)^{-1}\int\nolimits_{0}^{\tau}e^{As}dsB=I_{3\times 3} \end{equation*} View Source \begin{equation*} B^{\top}e^{A^{\top}(\tau-t)}\left(\int\nolimits_{0}^{\tau}e^{As}BB^{\top}e^{A^{\top}s}ds\right)^{-1}\int\nolimits_{0}^{\tau}e^{As}dsB=I_{3\times 3} \end{equation*} which implies that u^{\ast}(t)\equiv u_{i{j}} . □

Authors
Figures
References
Citations
Keywords
Metrics
Media
Footnotes
   Back to Results   
More Like This
An optimal control strategy for collision avoidance of mobile robots in nonstationary environments

Proceedings of the 1991 IEEE International Symposium on Intelligent Control

Published: 1991
Distributed Optimal Formation Control with Collision Avoidance

2018 IEEE 4th Information Technology and Mechatronics Engineering Conference (ITOEC)

Published: 2018
Show More
References
References is not available for this document.
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
