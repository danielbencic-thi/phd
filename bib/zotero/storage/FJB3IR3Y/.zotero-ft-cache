ELSEVIER

Computational Geometry 4 (1994) 63-97

Computational
Geometry TheorayndApplications

Computing minimum length paths of a given homotopy class

John Hershberger a, Jack Snoeyink b,*9 ’

bDepartment

‘Mentor Graphics, 1001 Ridder Park Drive, San Jose, CA 95131, USA of Computer Science, University of British Columbia, 201-2366 Main Mall, Vancouver, B.C.,
Canada V6 T 124

Communicated by Leonidas Guibas; submitted 28 August 1991; accepted 20 September 1993

Abstract
In this paper, we show that the universal covering space of a surface can be used to unify previous results on computing paths in a simple polygon. We optimize a given path among obstacles in the plane under the Euclidean and link metrics and under polygonal convex distance functions. Besides revealing connections between the minimum paths under these three distance functions, the framework provided by the universal cover leads to simplified lineartime algorithms for shortest path trees, for minimum-link paths in simple polygons, and for paths restricted to c given orientations.
Key words: Euclidean shortest paths; Minimum-link paths; Universal covering space

1. Introduction
If a wire, a pipe, or a robot must traverse a path among obstacles in the plane, then one might ask what is the best route to take. For the wire, perhaps the shortest distance is best; for the pipe, perhaps the fewest straight-line segments. For the robot, either might be best depending on the relative costs of turning and moving.
In this paper, we find shortest paths and shortest closed curves that wind around the obstacles in a prescribed fashion--that have a certain homotopy type. We consider the Euclidean and link metrics for paths, and convex and link distance functions for paths that are restricted to use c given orientations, such as rectilinear paths. Our work presents these distance functions in a unifying framework, a

*Corresponding author. 1Portions of the second author’s research were performed at Stanford and Utrecht Universities.

09257721/94/$07.00

0 1994 Elsevier Science B.V. All rights reserved

SSDI 0925-7721(93)E0024-B

64

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-W

triangulation of the universal covering space. In this framework, we can generalize results for simple polygons to compute shortest paths of a given homotopy class. We also simplify proofs and replace complicated data structures such as finger search trees by simple arrays and stacks.
We organize the paper around four variants on shortest path problems: Euclidean shortest paths and shortest path trees in Section 3, minimum-link paths in Section 4, shortest closed loops in Section 5, and paths with restricted orientations in Section 6. In the remainder of this section we review previous results on these problems and summarize our results using the universal cover. Section 2 gives formal definitions of the universal covering space and of triangulated manifolds, homotopy classes, and distance metrics-the important topological tools for our algorithms.
I .I. Euclidean shortest paths

Many researchers have investigated the problems of finding Euclidean shortest paths in simple polygons. Chazelle [7] and Lee and Preparata [33] gave a funnel

algorithm that, in a triangulated polygon, computes the shortest Euclidean path

between two points in linear time.

The funnel algorithm has been extended to handle one of the tractable cases of river routing in VLSI. Cole and Siegel [lo], Leiserson and Maley [34], and Gao et al. [ 181

give algorithms for routing wires with fixed terminals among fixed obstacles when

a sketch of the wires is given-that

is, when a homotopy class is specified for each

wire. When no sketch is given or when the terminals are not fixed, the resulting

problems are usually NP-hard [35,42,45]. Leiserson and Maley and Gao et al. use the funnel algorithm to compute the rubber-band equivalent of each wire as a basic

preprocessing step.

In Section 3.1 we describe the application of the funnel algorithm in the universal

cover of a triangulated manifold. Then, in Section 3.2, we extend it to efficiently

maintain the shortest path homotopic to a path that is given on-line. Both of these

algorithms take time proportional to the time needed to trace the representative of the

path through the triangulation and both use simple data structures-arrays

and

stacks.

Guibas et al. [23] used finger-search trees to compute the tree of all shortest paths

from one polygon vertex to all other vertices in linear time; they use this as a pre-

processing step to solve several shortest path and visibility query problems. Our

on-line shortest path algorithm can compute this shortest path tree using simpler data

structures.

Finding minimum paths among obstacles when the homotopy class is not given is

a more difficult problem, and is one that we will not discuss. For the Euclidean metric,

one typically builds the visibility graph and searches it with Dijkstra’s algorithm

[16]; see Ghosh and Mount [21] and Kapoor and Maheshwari [31] for efficient

algorithms.

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

65

1.2. Link shortest paths

Researchers have also looked at finding minimum paths in simple polygons under the link metric, in which the length of a path is the number of its line segments. Suri [48] developed a linear time algorithm for computing the minimum path between two points in a simple polygon. Ghosh [19] recently gave a linear time algorithm as a consequence of his work on computing the visibility polygon from a convex set. Both algorithms are based on a triangulation and the shortest path tree algorithm of Guibas et al. [23]. We show how to extend our Euclidean minimum path algorithm to compute the minimum-link path in time proportional to the number of triangles that this path intersects. This gives yet another linear-time algorithm in a simple polygon, but one that is more direct and also has application to paths of given homotopy class among obstacles.
When the homotopy type is not specified, Mitchell, Rote and Woeginger [37] have given an algorithm that runs in O(Ea(n) log’ n), where n is the number of vertices, E is the size of the visibility graph, and a(n) is the inverse of Ackermann’s function. Other recent work has considered combining link and Euclidean metrics [2,36].

1.3. Shortest loops

There are special closed loops of interest to computational geometers that fit within the framework of this research. Under the Euclidean metric, the shortest loop enclosing a set of points or line segments is the convex hull of the set. The shortest loop enclosing a set and contained in the interior of a polygon is the relative convex hull of the set. Toussaint and others have studied relative convex hulls, also called geodesic hulls, in connection with the separability of polygons under translation [S, 12, 51-531. Czyzowicz et al. [11] have solved the “Aquarium Keeper’s Problem,” a generalization of the problem of computing the minimum perimeter polygon that touches each edge of a given convex polygon. Essentially, they use the reflection principle to convert this problem to one of computing the shortest loop around a triangulated annulus or Mobius strip. Our results on closed loops simplify these solutions and generalize them slightly.
Minimum-link loops enclosing a set and contained in a polygon separate the set and polygon using the smallest number of line segments. Aggarwal et al. [l] considered finding a minimum-link convex polygon separating two convex polygons with n total vertices. They obtained an O(nlog k) algorithm that finds the minimum polygon of k line segments. They also give a simple O(n) algorithm for finding a polygon with at most one segment more than the minimum. Wang and Chan [54,55] show that the algorithm of Aggarwal et al. can find the minimum-link convex polygon that encloses a convex polygon lying in the kernel of a star-shaped polygon. They reduce two polygons with a total of IZ vertices to this case in O(nlogn) time. Ghosh [19] computes the reduction in linear time, allowing the computation of the minimum-link convex separator in O(n log k) time. For non-convex polygons, Suri

66

J. Hershberger. J. Snoeyink/Computational

Geometry 4 (1994) 63-97

and O’Rourke [49] compute a minimum-link polygon separating an m-gon and its enclosing n-gon in O(mn) time; we note (as did Ghosh and Maheshwari [20]) that this is actually the easy case and can be solved in linear time.

1.4. Paths restricted to c orientations

In some applications, most notably VLSI, the orientations of paths are restricted. Rectilinear paths are the most important and, thus, the most studied.
For computing rectilinear shortest paths among rectilinear barriers under the Manhattan, or L1, metric, researchers have developed algorithms that work in simple polygons (e.g. [46]) and in the presence of obstacles [9, 15, 321. De Berg [13] has given an algorithm that finds a path that is both a minimum-link and an L1 shortest path in a simple polygon. He and others Cl43 give a quadratic algorithm for a combined link and L1 metric for paths among obstacles. The fastest algorithms for the (globally) shortest path among rectilinear obstacles have subquadratic worst-case complexity: O(nlogn) if the obstacles are disjoint [lS] and O(nlog’n) if they are not [9].
Giiting [29] defined c-oriented polygons as a generalization of rectangles; he and others [30,44,50] have looked at various geometry problems with restricted orientations. The recent survey of Nilsson et al. [40] summarizes many results.
We show that the universal cover is also a useful tool to compute shortest and minimum-link c-oriented paths of a given homotopy type. Specifically, we show (in Section 6.2) that the shortest Euclidean path, measured under a convex distance function, has the length of the shortest c-oriented path. In Section 6.3, we give an algorithm to compute minimum-link c-oriented paths and also show how to use it to compute a shortest c-oriented path from the shortest Euclidean path. We also look at conditions when a c-oriented path is simultaneously shortest and minimum-link (Section 6.4).

1.5. Improved data structures for simple polygons

The algorithms that we develop for the universal cover have implications in the special case of triangulated simple polygons. Section 3.2: By developing a dynamic version of the funnel algorithm, we obtain
a linear time algorithm for shortest path trees that uses only a fixed size deque (doubly-ended queue) and a stack for storage. Section 4: For minimum-link paths, where distance is measured by the number of line segments, we develop an output-sensitive algorithm that runs in linear time in a simple polygon and uses deques and stacks rather than visibility maps and shortest path trees. Section 5.1: By walking around a loop two or four times, we compute the Euclidean shortest loop in both orientable and non-orientable manifolds without using shortest path trees.

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

61

Section 6: We compute minimum length and/or link paths restricted to c orientations in O(nlogc) time.

2. Preliminaries
We begin by defining some important topological objects: triangulated manifolds, homotopy classes, metrics, and covering spaces.
2.1. Manifolds and simplicial complexes
Our results apply to boundary-triangulated 2-manifolds (BTMs), which we define below. BTMs are slightly more general than polygonal regions in the Euclidean plane. We consider them primarily because every BTM has a simply-connected covering BTM such that paths have a unique lift into the covering space.
First, recall that a two-dimensional manifold with boundary (a 2-manifold) is a topological space in which each point has an open neighborhood homeomorphic to a two-dimensional ball or half-ball. The former are interior points and the latter are boundary points.
A two-dimensional simplicial complex is a triangulated 2-manifold. Spelled out, a two-dimensional simplicial complex is a collection of triangles, edges, and vertices such that any two triangles either do not intersect, intersect at a vertex, or intersect at two vertices and their common edge; no other intersections are permitted. At most two triangles are incident to an edge; edges incident to a single triangle are boundary edges. Furthermore, all the triangles and edges incident to a vertex can be ordered so that boundary edges are adjacent to their triangles in the ordering. All vertices are either boundary vertices with two incident boundary edges, or interior vertices with none.
Finally, a boundary-triangulated 2-manifold or BTM is a simplicial complex in which all vertices are boundary vertices. Fig. 1 depicts two simplicial complexes; the second is a BTM. Because vertices are the only source of curvature in a piecewiselinear surface, this implies that a BTM is flat-the neighborhood of any point looks like a portion of the Euclidean plane [28, 411.
One can represent a BTM, or any other 2-d simplicial complex, in a computer using Guibas and Stolfi’s quad-edge structure [25], Baumgart’s winged-edge structure [4], or the dual graph of the simplicial complex. In our algorithms, we require that each triangle of M be able to access its incident edges and each edge of M its incident triangles in constant time. If a polygonal region R is given, we can triangulate R and construct one of the above representations of the triangulation in O(n log n) time by a sweepline algorithm [43] or, if R has a constant number of boundary components, in linear time by Chazelle’s algorithm [S].
A useful example of a BTM is a triangulated polygon region R in the Euclidean plane: a set bounded by n line segments with disjoint interiors. Informally, if one

68

J. Hershberger, J. Snoeyink / Computational Geometry 4 (1994) 63-97

a.

b.
Fig. 1. Two triangulated manifolds; the one on the right is a boundary-triangulated

2-manifold (BTM).

considers the line segments as obstacles and looks at paths avoiding the obstacles,
then one can form equivalence classes of paths by relating paths that can be deformed to each other within R-relating paths that are homotopic.

2.2. Homotopy classes

The topological concept of homotopy formally captures the notion of deforming

paths. Let CIand B be functions from a topological space X to a topological space

Y that are continuous; that is, the preimage CI- ’ (A) of an open set A c Y is open. Functions c( and /? are homotopic if there is a continuous function I-:X x [0, l] + Y

such that I-(x, 0) = CL(Xa)nd I-(x, 1) = p(x). One can see that homotopy is an equiva-

lence relation [3, 391.

In this paper, the range set Y is always a boundary-triangulated

2-manifold

M under the subspace topology. We specify the set X in two different ways.

J. Hershberger, J. Snoeyink/ Computational Geometry 4 (1994) 63-97

69

First and most importantly, we consider paths joining two given points, p and q: a path in M is the range of a continuous function M:[0, 11 -+ M. We set X = [0, 11 and require that the endpoints of a path CIbe fixed at a(O) = p and a(l) = 4. Two paths are path homotopic if one can be deformed to the other in it4 while keeping the endpoints fixed. Formally, paths CIand fi are path homotopic if there is a continuous map I’: [0, l] x [IO,l] + M such that F(x, 0) = x(x) and F(x, 1) = p(x), and F(0, y) = a(O) = /I(O) and F(1, y) = a(l) = p(1).
Second, we define a closed loop to be the image of a circle under a continuous map into M. Thus, we set X = S’: the unit circle under the standard topology. Two loops with maps c(and fi are homotopic if there is a continuous map I*:S” x [0, l] -+ M such that F(x, 0) = a(x) and F(x, 1) = p(x). We use this definition only in Section 5. (A closed loop is different from a path with the starting and ending points identified, because our definition of path homotopy never moves the endpoints of a path.)
One could go on to define homotopy in M for two subdivisions bl and P-indeed, we do so in a paper with Guibas and Mitchell 1271 and show that computing minimum-link subdivisions is NP-hard.
A homotopy relation partitions paths or closed loops into equivalence classes. Thus, we can describe a homotopy class by giving a representative path or loop a. Given CI,we seek to compute a minimum length representative of 01’sclass under the Euclidean and link metrics.
Let us look at one concrete example of a path homotopy. In a BTM, a path gives a sequence of triangulation edges; we can form a canonical path that visits the midpoints of triangulation edges in the same sequence. It is easy to see that a path is homotopic to its corresponding canonical path-at times we will find it convenient to use the canonical path as the representative of a homotopy class.
We can concatenate two paths if one ends where the other begins. The next theorem is a well-known tool for studying paths.
Theorem 2.1 ([3,39]). The operation of path concatenation has group properties: ussoe~fftiu~ty,identities, and inverses.

This has an easy corollary for simply-connected 2-manifolds, in which every loop is homotopic to a point.
Corollary 2.2. In a simply connected manifold, any two paths with the same starting and ending points are homotopic.

2.3. Path complexity and metrics
In computer applications, paths are most often specified as a sequence of line segments or pieces of low-degree polynomials. We define the complexity of a path a, denoted C,, to be the number of pieces that compose a. For a path CIin a BTM M we

70

J. Hershberger, J. Snoeyink / Computational Geometry 4 (1994) 63-97

also count A,, the number of times that CIcrosses a triangulation edge of M. For the canonical path defined above, we have C, = A,, but, in general, either one of the two quantities could be greater.
We assume that CYis represented in the computer in some form that can be traced through the BTM data structure in time proportional to C, + A,. For example, if a is piecewise linear, then for each segment in each triangle we can compute a constant number of segment/segment intersection points to determine whether we need to advance to the next segment or to the next triangle. Storing the vertices of c( in an array and the BTM M in any of the data structures mentioned above permits tracing M.in O(C, + A,) time.
We consider two metrics for unrestricted paths in a BTM: the Euclidean and link metrics. The Euclidean metric is the usual L2 metric; the length of a path or loop is the sum of the lengths of its pieces in all the triangles it intersects. In the link metric, the length of a path or loop is the number of its line segments. Because BTMs are flat, the minimum length paths under both metrics are composed of line segments.
In applying the link metric, we would like to consider two adjacent triangles of a BTM to be coplanar, even if they are not. Thus, contiguous “line segments” that would be collinear if the triangles they passed through were laid out flat in the plane are counted as a single segment. This unfolding process is what is used to find shortest paths on the surface of a polyhedron [38,47].
For some applications, such as VLSI, the paths constructed must use a constant number of fixed directions or orientations. Rectilinear paths with the four orientations of north, south, east and west are the most common. When paths are restricted, the link metric remains the number of line segment of a path. The Euclidean metric, however, should be replaced by a distance function that gives the length of the shortest restricted path between two points. We discuss this more fully in Section 6.

2.4. Covering spaces

Informally, a topological space U is a covering space of a space X if, at each point
u E U, there is a corresponding point x E X such that things around u and x look the
same in their respective spaces, but there may be many points of U mapping to the
same point x.
Formally, let p: U -+ X be a continuous and onto map between connected topologi-
cal spaces U and X. If every point x E X has an open neighborhood N where the inverse image p-i(N) is a union ui Ui of disjoint open sets of U and the restriction p Iui is a homeomorphism from Ui onto N, then p is a covering map and U is a covering space of X.
A space is always a covering space of itself under the identity map. For a more useful example, consider the covering space of a BTM M formed by the following procedure (see Fig. 2): Choose a base triangle of M, copy it, and make its edges active. Now, any triangle t with an active edge e is a copy of some triangle t’ E M and of an edge e’ oft’. There is another triangle u’ E M incident to e’-copy it,

J. Hershberger, J. Snoeyink j Computational Geometry 4 (1994) 63-97

71

Fig. 2. A portion of the universal cover

forming u, and attach u to t along edge e. Make edge e inactive and the other two

edges of u active. One can see that the function that sends the copy of a point to its original is a covering map. The covering space thus formed is the universal covering space of M.

The dual graph of the universal covering space, the graph with a node for each

triangle and an arc joining nodes that correspond to triangles that are incident to the

same edge, is an infinite tree rooted at a copy of the base triangle. One can show that

the dual graph, considered as an unrooted tree, is not affected by the base triangle

chosen, so the universal cover does not depend on the base triangle. Furthermore, the

universal cover is simply connected-it

has no holes.

Lemma 2.3. The universal covering space U of a BTM is simply connected.

Proof. Consider any path c1starting and ending at a point p in the universal covering space U of the BTM M. The path CIintersects some connected subset of the triangles of the covering space.
If CIintersects only one triangle, then CIcollapses to the point p by the homotopy f(t) = (1 - t)a + tp. Otherwise, we can consider the triangle containing p as the base triangle for the covering space. The dual graph of the space is a tree, so the dual of the
connected subset of triangles that CIintersects must also be a tree. In any leaf, subpaths of tl start and end at the same edge; we can deform these subpaths to the edge by an easy homotopy and trim the leaves. By induction, a can be contracted to p.
Thus, the universal covering space is simply connected. cl

Any path that begins in the base triangle has a unique lifting to the covering space, as indicated in Fig. 3. Formally, let p : U + M be a covering map. If a function f from a space W to the BTM M is one-to-one and continuous, then a lifting off is a map f^: W + U such that the composition pf^=f: When we lift a path CI,we use U, c U to

12

J. Hershberger. J. Smoeyinkl Computational Geometry 4 (1994) 63-97

Fig. 3. The lift of cc
denote the BTM composed of the triangles of the universal cover U that intersects the path c?.
One last lemma pulls all of the constructs in this section together.
Lemma 2.4. If Mis a path in a BTM, M, then we can construct U,, the portion of the universal covering space of M that contains the lift of a, in O(C, + A,) time.
Proof. The construction algorithm is simple: Begin with U, equal to a copy of the triangle of M that contains the starting point of the path u. Then trace a through M and, simultaneously, trace the lift of CIthrough the covering space-when u crosses a triangulation edge into a triangle of M, add a copy of the triangle to U, if the lift has never crossed the corresponding edge before. (Otherwise, the triangle is already present.) We can trace the path a through the triangles of M in the stated time bound. 0
3. The Euclidean metric
We begin by applying these topological tools to the funnel algorithm, developed by Lee and Preparata [33] and Chazelle [7] and used by many researchers to find shortest paths [lS, 23, 26, 343. Section 3.1 reviews this algorithm and remarks that it

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

13

can be used to find shortest paths between two points of a given homotopy type. Section 3.2 extends this algorithm to maintain the shortest path homotopic to a path that is given on-line. As a by-product, we can find shortest path trees in linear time without using finger search trees. This simplifies an important algorithm of Guibas et al. [23].

3.1. Funnels and the shortest path between two points

First we review funnels, defined by Lee and Preparata [33]. Let p be a point and uu be a line segment in a simply connected BTM. The shortest paths from p to u and from p to u may travel together for a while. At some point a they diverge and are concave until they reach u and v, as illustrated in Fig. 4. The region bounded by uu and the concave chains to a is called the funnel; a is the apex of the funnel. We store the vertices of a funnel in a double-ended queue, a deque.
Fig. 5 shows that the extensions of funnel edges define wedges. If we cross the segment Uv into a triangle A?ruvw,then we would like to obtain the shortest path to w to construct
the funnel for the segment uw or VW.To find the funnel for uw, we pop points from the u end of the deque until we reach b, the apex of the wedge that contains w, then we push w. If the apex of the previous funnel is popped during the process, then b becomes the new funnel apex. Notice that the edge bw is on the shortest path from p to w.
The shortest path algor-ithms of Chazelle [7] and Lee and Preparata [33] both look for a path in a sleeve polygon-a triangulated simple polygon whose dual tree is a simple path. We shall look for a path in a sleeue BTM.

Lemma 3.1. Let CIbe a path from p to q. One can compute, in O(C, + A,) time and space, a sleeve BTM that contains the Euclidean shortest path homotopic to CI.

Proof. Choose the triangle that contains p as the base triangle and construct U,, the portion of the universal cover that contains the lift of CI,according to Lemma 2.4.
In the dual tree of U,, there is a unique path to the triangle containing the lift of q; let a’ be the canonical path in U, that corresponds to this dual path. Since U, is simply connected, the lift of CIand a’ are homotopic (Corollary 2.2).
The BTM U,, z U, is a sleeve. A boundary edge e of U,, may separate the universal cover but can not separate p from q. Any path homotopic to ol’that crosses e does so twice and can be shortened by following e. Thus, the shortest path from p to q homotopic to E’ (and, under projection, to a) is contained in U,,. 0

Trace the canonical path a’ through U,, and maintain the funnel of the triangulation edges crossed. The set of all edge added to the funnel comprises the shortest path tree rooted at p, that is, the union of all shortest paths from p to vertices of U,, . From this tree it is easy to recover the shortest path from p to q. Thus, we have obtained the following.

14

J. Hershberger. J. Snoeyink/Computational

Geometry 4 (1994) 63-97

Fig. 5. Splitting a funnel about w.
Theorem 3.2. The Euclidean shortest path that is homotopic to a given path M.can be computed in O(C, + A,) time and 1U,I space.
3.2. On-line shortest paths and shortest path trees
In this section, we show how to maintain the deque that represents the funnel for a path tx that is given on-line. We wish to trace c1 through the universal cover in O(C, + A,) time, as above. Since, however, we do not know the entire path ahead of time, we must be able to handle doubling back over the same triangle edge many times: we cannot afford to do more than a constant amount of work to update the deque each time.

J. Hershberger, J. Snoeyink/ Computational Geometry 4 (1994) 63-97

15

Table 1 Code fragments for the front-of-deque operations

Length(deque) return last -first + 1

Add (f, deque, x)
decrement first push (add, f, deque [first]) set deque [ first] t x

to stack

Split (f, deque, i) check 0 < i < Length(deque)
push (split, f, last) to stack set last + i + jirst

Index(deque, i) check 0 < i < Length (deque) return deque [i + first]
Undo (deque)
if stack top is (add, f, x)
set deque [jrst] + x increment first else stack top is (split, f, i) set last t i

Besides being useful for interactive applications, this procedure can be adapted to

compute shortest path trees in a simply connected BTM. (The shortest path tree from

a point p is the union of all shortest paths from p to vertices of the BTM.) Guibas et al.

[23] compute the shortest path tree of any triangulated simple polygon by splitting

funnels-they use finger search trees to find the splitting vertices and split the funnels

efficiently. We find the shortest path tree by tracing the boundary and maintaining the

funnel; the edges added to the funnel compose the tree. Our algorithm uses arrays in

place of finger search trees and still runs in linear time. We describe first the data

structure and then the algorithm that uses it.

We use an array and a history stack to support five operations on a deque that

stores a funnel.

Length(deque)

Return the number of items in the deque.

Index (deque, i) Return the ith item in the deque.

Add(f, deque, x) Add the item x to the f = front (or b = back) of the deque.

Split(f, deque, i) Return the items in f = front (or b = back) of and including

item i and discard the other half of the deque.

Undo (deque)

Undo the most recent Add0 or Split() operation.

We store the deque in the entries of an array with indices from first through last.

When we perform an Add () or Split (), we record the previous values of changed array

entries and/or indices in a history stack so that the Undo0 operation can return the

array to the previous state. The code fragments in Table 1 indicate that the operations

can be implemented to run in constant time. If we begin with an empty deque, denoted

by indices jkst = n and lust = n - 1, and perform at most n Add( ) operations, then an

array of size 2n is sufficient to hold the deque.

Suppose the path CI begins at point p in a BTM M. The algorithm will trace

a through the universal cover according to Lemma 2.4-beginning

with the base

triangle that contains p. Notice that whenever the lift of a is in the base triangle, the

funnel deque should consist only of p. Whenever the lift of c( crosses an edge Uv out of

76

J. Hershberger, J. Snoeyink / Computational Geometry 4 (1994) 63-97

the base triangle, we add the endpoints to the funnel deque by Add(f, deque, u) and Add (b, deque, v).

Suppose the path a crosses an edge zlv into a new triangle Auvw that is added to U,.

If c(later leaves through one of the other edges of Auvw, then the current funnel is split

into the funnels defined by uw and by VWas illustrated in Fig. 5. The key observation is that whenever the lift of CIis in Auvw, the index i of where the deque is to split is the same. We use an increasing increment search to compute this index i: check the

extension of the lst, 2nd, 4th, 8th, etc., edge of the funnel until we pass the point w,

then perform binary search to find the wedge containing w. By searching from the

front and back simultaneously, we find the splitting index in O(logd) steps, where d = min {i, Length(deque) - i}. Finger search trees were used in [23] to implement

the simultaneous increasing-increment

search, but arrays avoid the extra pointer

complexity. We store this splitting index with Auvw in U,.

Now, consider the dual graph of U,-the triangles of the universal cover that

intersect the lift of a-as a tree rooted at and directed toward the base triangle. When

the path CIencounters a triangulation edge, tl is heading either away from or toward

the base triangle. If CIis heading away, then we perform a Split () indicated by the index

stored in the current triangle and Add0 the new triangle vertex to obtain the next

funnel. If tl is heading toward the base, then we Undo () the last two operations: usually

a split/add pair, but an add/add when CLis returning to the base triangle. Lemma 3.3

establishes that this on-line algorithm and the previous section’s off-line algorithm

compute the same funnel.

Lemma 3.3. For a curve c(from p to q in a BTM M, the on-line algorithm computes the funnel corresponding to the sleeve of the path from p to q in the universal cover of M.

Proof. We prove this lemma by induction on the number of triangulation edges that a crosses. The induction hypothesis is that the pairs of operations that have been placed on the history stack are exactly those that would be performed by the off-line algorithm. This is trivially true if CIis entirely contained in the base triangle.
Suppose the invariant holds for all paths crossing k triangulation edges, and let CIbe the concatenation of LX’w, hich crosses k triangulation edges, and CC”w, hich crosses one edge. If cl” traverses an edge away from the base triangle, then the sleeve of czis the sleeve of a’ with one new triangle added to the end. The split/add (or add/add) performed and put on the history stack establishes the hypothesis for CLO. therwise, CX” traverses an edge towards the base triangle. Since the sleeve of c1is the sleeve of tl’ minus the last triangle, undoing the last two operations performed and removing them from the history stack does the right thing. 0

Except for finding the splitting index-which one does once for each triangle of the universal cover U,-one does a constant amount of work when visiting a triangle. The analysis of Guibas et al. [23] can be applied here to show that the time to find the splitting indices is linear in Aa. In brief, the time to compute splitting indices for the

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

11

triangles of U, is bounded by T(A.) where

r(n) < max {T(i) + r(n - i) + log min {i, n - i} } .

Thus, we have established the following theorem.

Theorem 3.4. One can trace a path CI through the universal cover of a BTM and maintain the funnel in O(C, + A,) time and space.

If P is a triangulated simple polygon and CYis the path from a vertex p around

the boundary of P and back to p, then the algorithm computes the edges of the

shortest paths from p to each of the vertices of the polygon-that

is, the shortest path

tree of P.

4. The link metric
In this section we show how to compute the minimum-link path, a’, homotopic to a given path GIin time proportional to C, + Ad + A,, , the complexity of the path CIplus the number of triangles intersected by both paths. Our approach is inspired by Ghosh’s [19] observations about the relationship between minimum Euclidean and link paths in simple polygons. We compute the Euclidean shortest path and then use a greedy approach to minimize the number of line segments. Our algorithm is output-sensitive and is simpler than that of Ghosh in the simple polygon case; it avoids his middle step of computing a visibility polygon.
First, some definitions: Since we have enough time, O(C, + A,), to compute the Euclidean shortest path in the homotopy class of CI,we may assume that CYis the shortest path from p to q. (The shortest path has complexity at most AZ,, so we perform all remaining complexity analysis in terms of A,,.) As before, U is the universal covering space and U, consists of the triangles of U that intersect CI.
Traversing CIfrom p to q, we can label each vertex as a left or right turn. We call an edge tu of a an injection edge if the labels oft and u differ; edges incident to p and to q can also be called inflection edges. (Ghosh calls such edges eaves.) The extension of a line segment tU in U, denoted ext (tu), is the line segment, ray, or infinite line formed by extending irt until it hits boundary points of U. In a simple polygon, Ghosh observed that there is always a minimum-link path including one line segment from the extension of each inflection edge. This is also true in the universal cover:
Lemma 4.1. Zf E is an injection edge of a Euclidean shortest path LX,then a minimumlink path homotopic to CIcan be assumed to use a subsegment of ext (Ei).
Proof. Let s and u be the endpoints of the extension ext (tu) so that these points appear in order s, t, u, v. Each of the segments st, tu, and Uv separates p from q in the

78

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

Fig. 6. Extension ext (fii) separates U
universal covering space U, so any path from p to q must cross all three segments, as shown in Fig. 6. If a path M’from p to q intersects St at a and Uv at b, we can shortcut CX’ with the segment ab G ext (Z). Since some line segment of CI’intersected Iii, this shortcut does not increase the number of segments on the path. 0
Thus we can assume that any inflection edges are included in the minimum-link path. We have reduced our problem to one of finding the minimal link path from UU, a segment extending one inflection edge, to u’u’, a segment extending another, where the shortest path from u to U’ is concave; see Fig. 7.
If the extension segments UZIand u’zl’intersect in V,, then no additional segments are needed. Otherwise, consider the Euclidean shortest path y from v to u’ in U,; the path from u to U’ and y form what has been called the hourglass of Uv and ~‘0’. The path y helps find a segment of the minimum-link path.
Lemma 4.2. The minimum-link path joining iiZ and u’v’ either has zero or one segments or it can be chosen to include an injection edge of y, the shortest path from v to VI.
Proof. If y is concave, then the concave chains can be separated by a line; one segment can join Uu to u’v’.
Otherwise, y has an inflection edge. Let bc be the inflection edge closest to v as shown in Fig. 7. (We consider u to be labeled opposite u so that b may be u .) Because the paths from u to c and u to c are both concave, the extension of bc intersects uu at some point a. Let cd be the extension of bc through c in U,. Any path from Zcvto u’u’ must intersect both bc and cd. If we shortcut the path by following the subsegment of ad from a, through c, to the intersection of the path with cd, then we do not increase the number of line segments on the path. 0

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

19

Fig. 7. The path y has inflection edge z.
Finally, we discover the inflection edge bc, if it exists, in time proportional to the -.
number of triangles that UC intersects by the procedure outlined in Table 2 and described in the rest of this section.
Notice that aC is tangent to the concave chain. We find ac by moving the point a up the edge iE and maintaining the point c tangent to the chain. We stop the motion when one of three cases occurs:
(1) The tangent aC becomes a segment of u’v’: no extra segments are needed. (2) The moving point a reaches the polygon boundary, which implies that a = v: the segment iZ is the inflection edge of y. (3) The tangent aC encounters a point b between a and c: the segment bc is the inflection edge. The third case is the most difficult to detect; we use the following technical lemma.
Lemma 4.3. The point b jirst encountered by the sweeping tangent is the endpoint of a triangulation edge that crosses the segment Ua or the chain from u to c.
Proof. Because a triangulation has no reflex angles, the tangent segment Z must cross a triangulation edge incident to b before it touches b. Since the segments Gi and aC and the concave chain from u to c form a closed region, shown in Fig. 9, the lemma holds. Cl

80

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

Table 2 Computing Uv and ??

the minimum-link

path between inflection edges

Variables: Points a, c, cl: a sweeps “upward”

along segment au.

aC is tangent to the concave chain at c

Point c’ follows c on the concave chain

Edge e: the first (t-edge) hit by &

Data structure: (H, b,): the convex hull and the point

having a tangent of slope 0 (Fig. 8)

Description:

Uses Graham scan [22] to maintain the convex hull

of endpoints of triangulation edges (t-edges)

Operations: Add (p, for b): Add points to front or back of H Change slope(Q): Change slope to 0 and recalculate be

Initialize
a t u, e + next(a), and c’ + next(c) e + the first t-edge hit by tic for each t-edge crossing aC in order from a to c
if an endpoint p lies in ~vac then Add(p, b) be + the last point Add( )ed to H

repeat

Change Slope(slope of Zi?)

move a along Uv, rotating ac around c until

case 1: if SiF is part of u’u’

use Z as the last link in the path

exit program

case 2: a reaches u.

use W in the minimum-link path

exit loop case 3: Line segment ?iZ hits be

use Z? in the minimum-link path

exit loop case 4: slope of aC points into H at be

Change slope (slope of Zic)

case 5: a hits e if an endpoint p lies in ~uac then Add(p, f)

e + first t-edge hit by tic

case 6: a, c, and c’ become collinear

For each t-edge that hits z in order from c to c’ if an endpoint p lies in ~uac’ then Add( p, b)

change pivot c + c’, c’ + next(c’)

loop if c # a’, repeat program using ext (55) as Uv

Lemma 4.3 implies that we need look only at the convex hull of the endpoints of triangulation edges that we encounter during the sweep. These endpoints appear on the hull above aC in the same order as their edges appear along UC. Points are added only at the ends of the segment UC,so we can maintain the convex hull by a Graham

J. Hershberger, J. Snoeyink 1 Computational Geometry 4 (1994) 63-97

81

Fig. 8. The hull H used in the algorithm of Table 2.
a
u Fig. 9. The sweep stops at b
scan [22] in a deque. Furthermore, the slope of Z changes monotonically, so we can also main-tain be, the point of the hull having a tangent with this slope. When UChits be then bee is an inflection edge that Lemma 4.2 says can be used in a minimum-link path.
These arguments establish the correctness of the algorithm outlined in Table 2. To establish the running time, notice that the amount of work required to find a segment of the minimum-link path is proportional to the number of triangulation edges that intersect the region depicted in Fig. 9. Since this region is free of points, these edges must intersect either iiZ or aC. Since these segments are part of the minimum-link path,

82

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

A

n ,

A

I

Fig. 10. The k-link minimum path intersects O(kn) edges.
we can charge this work to the number of triangles crossed by the computed path and obtain Theorem 4.4.
Theorem 4.4. A minimum-link path c1’,homotopic to IX,can be computed in space and time proportional to O(C, + Aa + A,,).
In a simply connected BTM, a minimum-link path can cross any triangulation edge at most three times: any path that crosses a triangulation edge e four or more times can be shortcut by a portion of e, decreasing its length without changing its homotopy class since all paths with the same starting and ending point have the same homotopy class. Thus, the total time to compute minimum-link paths in simple polygons is linear. Among many obstacles, a minimumlink path with k segments can intersect @(kn) triangulation edges, as shown in Fig. 10.

5. Loops

The algorithms of the previous section can be used to find the shortest and

minimum-link closed path whose starting and ending points coincide-that

is, for

a loop that is pinned to the starting point. For completeness, we show how to use the

universal cover to help find shortest and minimum-link loops of a given homotopy

class that is not pinned to pass through any given point. We compute Euclidean

shortest loops in Section 5.1 by simply walking around the loop at most four

times; this can be applied to compute relative convex hulls [12, 51, 531 and minimum-perimeter inpolygons [l 11. For minimum-link loops, Section 5.2, we have

nothing new to add except the obvious generalizations from nested polygons to

BTMs.

J. Hershberger, J. Snoeyink / Computational Geometry 4 (1994) 63-97

83

5.1. Euclidean shortest loops

The funnel algorithm, outlined in Section 3.1, computed a shortest path in a sleeve polygon-a triangulated polygon whose dual was a path. For shortest loops, we define a band analogously as a BTM whose dual is a single cycle. In this section, we first reduce the problem of computing the shortest loop of a given homotopy type to the problem of finding the shortest loop around a band.
A band is orientable if and only if the boundaries of its triangles can be traversed so that each internal edge is traversed once in each direction. Orientable bands have two
boundary cyles and non-orientable bands have only one. Subsections 5.1.1 and 5.1.2
deal with the orientable and non-orientable cases of the reduced problem.

Lemma 5.1. In a BTM M with a loop CI,we can compute a band whose shortest loop is the lift of the shortest loop homotopic to a in M. Computation time and space is
0(4x).

Proof. Choose any point p on c(and find the sleeve of the path from p to p along CI.An initial sequence of triangles and triangulation edges of this sleeve will appear in reverse order at the end of the sleeve, as shown in Fig. 11. Remove all but the last of these common triangles, and glue those together. The result is either a single triangle, in which case o! is homotopic to a point, or else it is a 2-manifold M’ whose dual has a single cycle-M’ is a band. We must show that the band M’ contains the lift of the shortest loop homotopic to c(.
We can begin with the band and perform the universal cover construction to obtain a 2-manifold of genus one that contains the lift of LXS. uppose we remove an edge from this manifold. We either separate the manifold or, if the edge is an internal edge of the band, we reduce the genus to zero. This proves that edges internal to the band must be crossed an odd number of times and all other edges must be crossed an even number of time by any loop homotopic to CI.But, just as in Lemma 3.1, this implies that the shortest path crosses internal edges once and no other edges. Thus the band contains the shortest loop homotopic to cx. 0

Before we solve the problem of computing the shortest loop around a band, we define the concepts of turn angles and cut manifolds.
The turn angle (Fig. 12) of an oriented piecewise-linear path with given starting and ending points in a BTM M is measured by following the orientation of the path and

summing the angles of its turns. Each turn has an angle -Z < 8 < rr; (locally) right turns are negative and left are positive. The turn angle of a loop is the turn angle of the

path around the loop starting and ending at the orientation of some edge-which

edge is chosen does not affect the angle. If we cut a band M along any non-boundary
a simply connected manifold M,,, whose boundary

triangulation edge e, we obtain has two copies of e. The shortest

84

J. Hershberger, J. Snoeyink / Computational Geometry 4 (1994) 63-97

Fig. 11. Constructing a band.

Fig. 12. Turn angle.
loop around M becomes a shortest path in M,,, between two copies of a point p E e. (Czyzowicz et al. [11] show how to use shortest path maps to compute the shortest path between the two copies of e in linear time-we will use somewhat lighter artillery.) Around the boundary of MC”,, the copies of e have the same or opposite orientations, depending on whether the band M was orientable or non-orientable. We will handle these cases separately in the following two subsections.
5.1.1. Orientable bands In this section, we show how to find the shortest loop around an orientable band.
After defining the inner boundary of the band, we state a procedure using the funnel algorithm [33] to compute the shortest loop by walking around the inner boundary twice. We prove its correctness in the rest of the section.
The boundary of an orientable band M consists of two closed curves, CRto the right and crL to the left of M’s cycle. According to the next lemma, the turn angle of the shortest loop in an orientable band equals the turn angle of the canonical loop or either boundary curve.

J. Hershberger. J. Snoeyinkl Computational Geometry 4 (1994) 63-97

85

Fig. 13. Around the inner boundary.
Lemma 5.2. In an orientable BTM, two simple (i.e., non-self-intersecting) oriented loops that are homotopic have the same turn angle.
If the turn angle of M is negative, then we say that gR is the inner boundary, otherwise oL is the inner boundary. In the figures, the triangles are laid out flat in the plane, which would give turn angles of + 271. Manifolds that cannot be embedded in the plane give rise to other turn angles.
The following procedure computes the shortest loop.
1. Let Uv be a line segment of the inner boundary. 2. Use the funnel algorithm to compute the shortest path c( from u to o that winds
around the band twice. (See Fig. 13.) 3. Let p be a vertex that appears twice on the path; the subpath from p to p is the
shortest loop.
This algorithm is based on the fact that once we identify a point p on a shortest loop, we can compute the loop by computing the shortest path from p back around to p. Lemma 5.3 says that there is a shortest loop touching a vertex of the inner boundary.
Lemma 5.3. There is a shortest loop that touches a vertex of the inner boundary.
Proof. If the turn angle of a band M is positive, then the shortest loop must make a left turn. It can only do so by turning at a vertex of the left or inner boundary. The case of a negative turn angle is symmetric.
If the turn angle of the band M is zero then any shortest loop turns as much to the right as to the left. Thus, if it turns at all, it turns at vertices of both the inner and outer boundaries. If the shortest loop does not turn, then cut the band M along a triangulation edge e-the two copies of e are parallel and the shortest loop becomes a straight

86

J. Hershberger, J. Snoeyink / Computational Geometry 4 (1994) 63-97

line segment 1between corresponding points of the copies of e. Without changing the length of the segment 1, one can translate 1 to the left until it touches a vertex of the inner boundary. 0

With this lemma, we can prove correctness.

Theorem 5.4. Given an orientable band M composed of n triangles, the procedure above correctly computes the shortest loop around M in linear time.

Proof. Let p be the vertex on the inner boundary of some shortest loop whose
existence is proved by Lemma 5.3. The shortest path 2 from u starts on or inside this shortest loop and reaches p before going completely around the band. Similarly, the shortest path from v reaches p before going around the band in the other direction. Thus, p is reached twice.
The path a can thus be decomposed into three pieces: the shortest path from u to p,
denoted a,; the shortest loop around the band, denoted A; and the shortest path from p to v, denoted CC,.The vertices of A are obviously the vertices of the shortest loop.
Together CCa, nd a, compose the shortest path from u around to v-a vertex appears
on this path only once. Thus, any vertex that appears twice on a is on the shortest loop and can be used in place of p. 0

5.1.2. Non-orientable bands One might think that computing the shortest loop in a non-orientable band
would be more difficult. In this section, however, we show how to find the shortest loop that winds twice around the band by a reduction to an orientable band. We then show how to obtain the shortest loop from this curve. The result is Theorem 5.5.

Theorem 5.5. Given a non-orientable band M composed of n triangles, one can compute the shortest loop around M in linear time.

We can conceptually take two copies of M,,,, reverse one left-to-right, and paste them into a single band Mdouble, as shown in Fig. 14. The band Mdouble is

orientable and has turn angle zero: starting from triangulation edge e, you travel

through one copy of M,,, until you encounter the reversed copy, denoted eR. Then

you travel through the reversed copy of M,,, until you reach e again. The turn angles

in each copy of M,,, have opposite sign. We can use the procedure of the previous

section to find the shortest loop in Mdoublethat touches the left boundary-call

it A.

Notice that i is the shortest loop that winds around M twice, so its length is at most

double the length of the shortest loop in M. We shall see that the length is exactly double.

Suppose il intersects e at a point p. Then the shortest loop touching the right

boundary is the shortest path starting and ending at the corresponding point pR E pR. In other words, the shortest loop in Mdoubletouching the right boundary is AR-the

J. Hershberger, J. Snoeyink/ Computational Geometry 4 (1994) 63-97

87

Fig. 14. Cases for the shortest loop in Mdoublc,

loop 1 viewed from the perspective of edge eR. This should not be surprising as M has

only one boundary.

We now consider two cases depicted in Fig. 14. First, if the shortest loop 1 in M double makes any turns, then i makes turns on vertices of both the right and left boundaries. Since the shortest loop touching a given boundary is unique, both loops

2 and jlR are identical. Therefore, ;1 passes through the point PR E e,-that around the shortest loop in M twice.

is, 2 winds

Second, if the shortest loop /z makes no turns, then by cutting the manifold M double along e, we see that the loops touching the left and right boundaries, 1 and AR, form two parallel lines. If the intersections with e are points p on the left and q on the

right, as shown in Fig. 14b, then the intersections with eR are the corresponding

points qR on the left and PR on the right. The line 1’ parallel to il and AR and passing

through the midpoint of the segment p4 is also a shortest loop in Mdoubie. Moreover, 1

also passes through the midpoint of qRpR. But these two midpoints are just the

corresponding points on two copies of e. As a result, 2’ winds around the shortest loop in M twice.

5.2. Minimum-link loops

As in Section 5.1, if we know a vertex or edge of a minimum-link loop, we can use the path algorithm to compute it. When a minimum-link loop is convex, however, it seems difficult to find such a vertex or edge.
Because of the algorithm of Section 5.1, we can assume that our loop CYis the minimum Euclidean curve of its homotopy class. If CIhas an inflection edge, then we can use the path algorithm of Table 2 to find the paths between inflection edges-a

88

J. Hershberger, J. Snoeyinkl Computarional Geometry 4 (1994) 63-97

fact that has also been noted by Ghosh and Maheswari [20]. Lemma 4.1 implies that the resulting loop is a minimum-link curve.
If CIhas no inflection edges, then all minimum-link loops are convex. One can use the technique of Aggarwal et al. [l] as extended by Wang [54] and Ghosh [19] to find a minimum-link loop. Briefly, one finds an initial loop finding a minimum-link path from p around to p; the resulting path has at most one segment more than the minimum. One then rotates this loop, keeping track of its points of contact with the inner and outer chains, to see if one can shorten the loop. The algorithm finds a minimum-link loop with k line segments in O(n log k) time. It would be interesting to discover a matching lower bound.

6. Paths with restricted orientations
For some applications, such as VLSI, the paths are restricted to c fixed directions; we call such paths c-oriented. Rectilinear paths with the four orientations of north, south, east and west are the most common. In this section, we show that the universal cover is also a good tool for finding minimal c-oriented paths of a given homotopy class.
First, in Section 6.1, we define convex polygon distance functions appropriate to a given set of orientations. Then we show in Section 6.2 that the length, under a convex distance function, of the Euclidean shortest path computed in Section 3.1 equals the length of the shortest c-oriented path. Section 6.3 shows how to modify the minimum-link algorithm of Section 4 to compute minimum-link c-oriented paths. Finally, Section 6.4 shows that for paths restricted to three directions and for rectilinear paths, each homotopy class has a shortest path that is also a minimum-link path. Mark de Berg [13] has independently noted this fact for rectilinear paths in simple polygons.
In each of the following sections, when we wish to construct paths restricted to c orientations explicitly, then we also restrict the boundary of the obstacles to the same set of c orientations. With such a restriction, there is always a path with at most O(n) segments that follows obstacle boundaries. Without such a restriction, one can construct examples where any c-oriented path joining a given pair of points has infinitely many line segments.
6.1. Metrics versus distance functions
When paths are restricted, the link metric remains the number of line segments of a path. We can replace the Euclidean metric, however, by a distance function that gives the length of the shortest restricted path between two points. The Manhattan or L1 metric, in which the length of a vector v is the sum of the lengths of the projections of u on the horizontal and vertical axes, is an example of a distance function for rectilinear paths.

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

89

More generally, we can use Minkowski’s convex distance functions [6]. Let A be a convex set whose interior contains the origin. The length of a vector v with respect to A is the amount that A must be scaled to include a; that is, 1v1 IIA = inf (2 3 0: v E AA}. The distance from point I to s is I/s - r IIA. The distance function need not induce a metric because it need not be symmetric: I/v IIA may not equal 11-v llA. It does, however, satisfy the triangle inequality [6]: if u + v = w then
IIdA + IId. 3 IIWIIA.
The points of the boundary of A are precisely the unit vectors of the distance function I/- lIA. Choosing A to be the unit circle gives the Euclidean metric; choosing A to be the diamond defined by the four unit vectors in the axial directions gives the L, metric. For a c-oriented path, which is a path restricted to follow the orientations of c unit-length basis vectors ul, u2, . . . , uC, we choose A to be the convex hull of NY ur, . , u,}. We assume that the Ui appear on A in the order listed.
As an aside, if the origin b is on the boundary of A then vectors that are not contained in the angle formed by the boundary of A at b have infinite length. They cannot be reached by a c-oriented path because they cannot be expressed as a positive linear combination of the basis vectors.
A path that follows c chosen orientations has the same length under the Euclidean metric and under the associated convex distance function. More importantly, a vector v measured under a convex distance function has the length of the shortest c-oriented path from the origin to v-we show this in the next lemma.

Lemma 6.1. Let A be the convex hull of{uI, u2, . . . , u,}, a circularly-ordered set of basis vectors and let v be a vector in the wedge defined by adjacent basis vectors ui and ui+ 1. Vector v = aUi + bui+ 1 ifs // v IIA = a + b.

Proof. This is true for the unit vectors of the distance function 1v1 lIA = 1, which are on

segments,

(1 - c(Ui +

cI)Ui+l

for 0 < c( d 1, that join adjacent basis vectors on the

boundary of the convex hull. Since length scales with the vector, it remains true for

arbitrary vectors v. 0

6.2. Shortest paths under a convex distance function

We use Lemma 6.1 to find the length of the shortest path of a given homotopy type under a convex distance function. As before, we first compute the Euclidean shortest path a from p to 4 and use it as the representative of the homotopy class. This takes O(C, + A,) time.
The proofs leading to Theorem 3.2 use only the triangle inequality to show that the path computed in Section 3.1 is minimum under the Euclidean metric. But this implies the following.

Theorem 6.2. The Euclidean shortest path computed in Section 3.1 is a shortest path under any convex distance function.

90

J. Hershberger. J. Snoeyink/ Computational Geometry 4 (1994) 63-97

Lemma 6.1 implies that if we replace each segment of the Euclidean shortest path by a “zig-zag” or ‘staircase” made from the two adjacent basis vectors, then we will have a c-oriented path of the same (minimum) length. By cutting the Euclidean shortest path at all points with tangent vectors that are among the c basis vectors and computing c-oriented “staircases” for the resulting pieces we will find a shortest c-oriented path that has the fewest possible links.

Lemma 6.3. Let t be a point of the Euclidean shortest path a having a basis vector u as a tangent vector. Any minimum length path under the convex distance function goes through t.

Proof. Slice the universal cover into three pieces by a line segment through t and parallel to u. Any path from p to q first crosses this segment at or before t and last crosses it at or after t. By applying Lemma 6.1 to the wedge containing u alone, we see that the shortest path under the convex distance function is inside this segment from the first to last crossing and therefore passes through t. 0

We can perform this cutting by simply traversing the Euclidean path-think

of

driving a car along the path, as in Guibas, Ramshaw, and Stolfi’s kinetic framework

for computational geometry [24]-and cutting it whenever the direction of travel is

one of the c basis vectors. (If c is not considered a constant, then we can use binary

search to find the wedges that contain the slopes of edges. The time complexity

becomes O(C, log c).

The slopes on each resulting path lie in a wedge defined by two adjacent basis

vectors. Thus, by Lemma 6.1, each path should be replaced by a path using only those

two orientations. If we are unconcerned about the number of links, then, using the two

orientations, we can remain within an arbitrarily small neighborhood of the Euclidean

shortest path. More likely, however, one would want to construct a shortest c-

oriented path using the smallest number of links. The next section develops an

algorithm for the more general problem of computing minimum-link c-oriented paths.

Section 6.4 mentions how this algorithm can be simplified when there are only two

directions of interest and also discusses when a minimum link path can also be

a shortest path under the convex distance function.

6.3. Minimum-link c-oriented paths

This section develops a greedy algorithm to compute a minimum-link c-oriented path homotopic to a path c1from p to q: Each link (line segment) reaches as far as possible towards q, guided by the Euclidean shortest path. Define the i-link region of p, denoted R,(p), to be the set of all points of the universal cover that can be reached by a c-oriented path of i links from p. If q is not in Ri(p) then we shall find two c-oriented segments on the boundary a(Ri(p)) with adjacent orientations that separate

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

91

p from q in the universal cover. We compute the two segments of d(Ri+i(p)) that separate p from q from the two segments of a(Ri(p)).
Section 4 used essentially this greedy approach to compute an unrestricted minimum-link path. In that case, however, the boundary of the i-link region is a single line segment and one can compute the links of the path in time proportional to the number of triangles that the path crosses. In this section we will have to explore two possible ways to reach the goal q. This difficulty arises already in rectilinear paths, where one must decide whether to begin with a horizontal or a vertical step. (It is interesting that, even with more allowed orientations, no more than two paths need be considered at any time.) The time required by our algorithm will therefore be proportional to the number of triangles explored, which may be greater than the number of triangles intersected by the final path. The worst-case bounds are similar to those of Section 4: If c is a constant, O(nk) time is sufficient to construct a k link path of a given homotopy class and O(n + k) time is sufficient in a simple polygon. If c is not a constant but the basis vector directions are initially sorted, then the algorithm can be implemented to run in O(nklog c) and O(n + klogc) time, respectively.

Lemma 6.4. Let CIbe a Euclidean shortest path from p to q in a BTM M, and let U be the universal covering space of M. Suppose Q is the connected component of U - Ri(p) that contains q. Then a(Q) - a(U) consists of at most two segments from a point r that have adjacent orientations u and v.

Proof. We prove this by induction. The l-link region R,(p) consists of maximal length segments radiating out from p in the permitted orientations. If we cut the universal cover U along these segments and look at the component Q that contains q, we find that a(Q) contains a portion of one of these segments in degenerate cases or two adjacent segments meeting at p in non-degenerate cases.
Now, assume that the i-link region has boundary segments rUand r, that come from
the point r in directions u and v, as depicted in Fig. 15. Without loss of generality, we
can assume that u is clockwise of v and that the Euclidean path a turns to the right.
Any minimum-link c-oriented path p that is homotopic to c1must cross one of the segments r,, or r,; by cutting the path p at this crossing point and replacing the initial portion with an i link path, we can assume that p uses part r,, of r, as its ith link.
There are two cases to consider when extending the path p by one link, depending on whether there is some c-oriented segment from rU or r, that is tangent to the
Euclidean shortest path CIor not.
Suppose, first, that there is no such tangent, as in Fig. 15a. Imagine drawing maximal length segments in Q from rv in direction u; there will be some segment s that is the last one crossed by CIenroute to q. Similarly, draw the segment t from r, in direction v that is last crossed by CC.
We notice that segments s and t intersect: If LYhits s after t, as in Fig. 15a, then r,,, rv, s and tl bound a simply connected region in U that t enters by crossing CC.Since

92

J. Hershberger, J. Snoeyink/ Computational Geometry 4 (1994) 63-97

V
* u
orientations

Fig. 15. Computing part of 8(&+1(p)) from a@,(p)), shaded.
t cannot cross r,, or I, or recross ~1,t must cross s. Let Y’= s n t. The (i + 1)-link region is bounded by the portions of s and t in the directions of u and v from Y’because they are the extremal segments in the directions of u and v and segments in other orientations cannot reach from r, or rv to the segments from r’. This establishes the lemma for the first case.
Second, suppose that there is a c-oriented tangent to 01 from r,. Let t be the c-oriented tangent furthest clockwise from v, as shown in Fig. 15b. Tangent t c U has an end on I,, is tangent to a at b, and has maximal length. Now, draw segments from r, in the next orientation clockwise from the orientation of t and let s be the last segment crossed by GLL. et r’ = s n t. If r’ lies between r, and b on t, and the (i + 1)-link region is bounded by the segment of t following b. Otherwise, r’ follows b on t and the (i + 1)-link region is bounded by the two segments from r’ in the directions of s and t. q
This lemma and its proof indicate a way to start from p and obtain a sequence of points, each of which a minimum-link c-oriented path can pass through in one of two adjacent directions. if we can compute these points and directions, then we can

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

93

construct the minimum-link path as follows: Begin at r = p with the at most two

candidate paths whose initial orientations delimit the smallest wedge containing the

orientation of the first segment of the Euclidean shortest path a. Obtain the next point r’ and the pair of directions, which come from non-tangents in the first case of Lemma

6.4 and from a tangent and a non-tangent in the second case. In the first case, both

candidate paths are extended by one link. In the second, the candidate path that

cannot be extended by a tangent is discarded and the path up through r is fixed. Then

new candidate paths are begun that pass through I’ in two directions and the process

continues. The algorithm stops with a minimum-link c-oriented path when one of the

candidate paths reaches q-a fact that can be detected by the tangent-finding

algorithm.

To compute the sequence of points and directions we need to find extreme

c-oriented tangents to CCi,f they exist, and find extreme segments of fixed orientations

that connect the old link region boundary to CCB. oth of these tasks can be performed

by a modification of the minimum-link path algorithm presented in Table 2. Since this

algorithm finds the extreme tangent by sweeping a tangent segment and recording in

a convex hull the endpoints of triangulation edges that cross the sweep, there is little

modification required to find an extreme c-oriented tangent. In Fig. 15a, the sweep would begin at the intersection of c(and r, and maintain a tangent segment to CIas the other endpoint moved up to r and then along rv. When the extreme tangent is found,

the extreme c-oriented tangent, if any, can be reported by searching the list of

orientations.

The same idea-sweeping

a segment and maintaining the endpoints of triangula-

tion edges that cross the sweep-applies to find the extreme segment with a given

orientation. Since the orientation is fixed, one does not need to record the convex hull

of the endpoints ahead of the sweep. Storing the first endpoint that will be encoun-

tered is sufficient.

The extra exploring means that we do not have output-sensitive bounds for

c-oriented paths.

Theorem 6.5. One can construct a minimum-link c-oriented path homotopic to CYin time and space proportional to the number of triangles that contain candidate segments for the minimum-link path.

If the c allowed orientations are initially sorted, then the worst-case time bound to compute a k-link path in a BTM with n triangles is O(nk log c). This analysis can be sharpened for a simply connected BTM if there are two opposite basis vectors. If we use the algorithm of Fournier and Montuno [17] to change the triangulation to a trapezoidation with sides parallel to these basis vectors, then c-oriented paths can follow the edges of the trapezoids. Any trapezoid edge that intersected more than three edges of a path could be used to shorten the path. Thus, each trapezoid is explored a constant number of times. The running time of the algorithm in this case is O(n + k loge).

94

J. Hershberger. J. Snoeyinkl Computational Geometry 4 (1994) 63-97

6.4. Simultaneous minimization of length and links

In the c-oriented case, as in the unrestricted case, a minimum-link path is usually

not the shortest path and vice versa. A “long” straight detour can generally save

several turns. In this section we remark that a simplified version of the minimum-link

path algorithm can compute the path with fewest links of all shortest c-oriented paths.

For rectilinear paths and paths restricted to three directions, we prove that this path is

also a minimum-link path-that length and links are minimized simultaneously.

Section 6.2 showed that the shortest c-oriented path under a convex distance

function can be obtained by breaking the Euclidean shortest path at all vertices with

basis vector tangents and approximating each piece by a path that follows two

adjacent orientations. But this breaking implies that only the first case for extending

a path can arise in Lemma 6.4. Therefore, we can compute such paths entirely by

sweeping segments with fixed orientations-we

need not maintain convex hulls to

determine where the sweep ends. We do need to try both candidate paths, however,

and merge collinear segments from separate pieces to compute the shortest c-oriented

path with the fewest links.

To determine when this path is also a minimum-link path, we make the following

definition. A member u of a set of basis vectors B satisfies the ha&lane condition if

there is a halfplane that contains all of B except U. Now, consider driving along the

Euclidean shortest path, moving and turning in accordance to Guibas, Ramshaw, and

Stolfi’s kinetic framework for computational geometry [24], and noting in which basis

vector orientations you face during a turn about a vertex. If the basis vector tangent at

a vertex has the halfplane condition, then shortest and minimum-link paths can both

pass through that vertex in the direction of the basis vector.

Lemma 6.6. If a tangent basis vector, u, of a point t on the Euclidean shortest path CIsatisjes the halfplane condition, then a minimum-link c-oriented path homotopic to a has an edge passing through t in direction u.

Proof. Cut the universal cover through t along a line that defines a halfplane containing all the basis vectors except U, as illustrated in Fig. 16. If any c-oriented path crosses this cut at t, then it must do so in direction ZJby the halfplane condition and the fact that u is a tangent basis vector.
If the crossing is not as t, then we can move it to t without increasing the number of links as follows. Because of the halfplane condition, a c-oriented path must cross the cut using an edge e that is parallel to U. Separate the universal cover into three pieces by a line segment through t and parallel to u. We can shorten the path by a portion of this line segment; the number of links does not increase because edge e is cut off the path. 0
For rectilinear paths and any convex distance function defined by three vectors, all vectors satisfy the halfplane condition and Lemma 6.6 implies that a minimum-link

J. Hershberger. J. Snoeyinkl Computational Geometry 4 (1994) 63-97

95

a--..*

..-.-..

:

-..._.-*

: *.*

:

:

%___/-.

:

:

:

:

: :

basis vectors

.

-.....,~~----------...~

:

Fig. 16. The halfplane condition.

--.a___.-- {a.

path goes through all the points with tangents that are basis vectors. To compute the minimum-link c-oriented path, we could cut the Euclidean shortest path at all these points and compute the path greedily. This, however, is precisely the computation of the shortest path with fewest links-the path computed is minimum with respect to the convex distance function and the link metric simultaneously.

7. Conclusions
We have shown that the universal covering space of a triangulated region gives a useful framework for optimizing paths in the region under the Euclidean and link metrics. We have given simple, direct algorithms for Euclidean shortest path trees and minimum-link paths that use arrays in place of finger search trees. We have also given new algorithms for computing minimum length and minimum link c-oriented paths.

Acknowledgements
We would like to thank Joseph Mitchell and Leonidas Guibas for discussions on these and related problems, and the referees for their comments. This research has been supported by Digital Equipment Corporation, ESPRIT Basic Research Action No. 3075 (project ALCOM) and an NSERC Research Grant (Canada).

References
[l] A. Aggarwal, H. Booth, J. O’Rourke, S. Suri and C. K. Yap, Finding minimal convex nested polygons, Inform. and Comput. 83 (1989) 98&110.
[2] E.M. Arkin, J.S.B. Mitchell and C.D. Piatko, Bicriteria shortest path problems in the plane, in: Proceedings of the Third Canadian Conference on Computational Geometry (Simon Fraser University, Vancouver, 1991) 153-156.
[S] M.A. Armstrong, Basic Topology (McGraw-Hill, London, 1979).

96

J. Hershberger, J. SnoeyinklComputational

Geometry 4 (1994) 63-V

[4] B. Baumgart, A polyhedral representation for computer vision, in: Proceedings of the AFIPS National Computer Conference (1975) 5899596.
[S] B. Bhattacharya and G.T. Toussaint, A linear algorithm for determining translation separability of two simple polygons, Technical Report SOCS-86.1, School of Computer Science, McGill University, Montreal, 1986.
[6] J.W.S. Cassels, An Introduction to the Geometry of Numbers (Springer, Berlin, 1959). [7] B. Chazelle, A theorem on polygon cutting with applications, in: Proceedings of the 23rd IEEE
Symposium on Foundations of Computer Science (1982) 339-349. [8] B. Chazelle, Triangulating a simple polygon in linear time, Discrete Comput. Geom. 6 (1991) 485-524. [9] K.L. Clarkson, S. Kapoor and P.M. Vaidya, Rectilinear shortest paths through polygonal obstacles in
O(n log* n) time, in: Proceedings of the Third Annual ACM Symposium on Computational Geometry (1987) 251-257. [lo] R. Cole and A. Siegel, River routing every which way, but loose, in: Proceedings of the 25th IEEE Symposium on Foundations of Computer Science (1984) 65-73. [11] J. Czyzowicz, P. Egyed, H. Everett, D. Rappaport, T. Shermer, D. Souvaine, G. Toussaint and J. Urrutia, The aquarium keeper’s problem, in: Second Annual ACM-SIAM Symposium on Discrete Algorithms (1991) 459-464. [12] M. de Berg, Translating polygons with applications to hidden surface removal, in: SWAT 90: Second Scandinavian Workshop on Algorithm Theory, Lecture Notes in Computer Science, Vol. 447 (Springer, Berlin, 1990) 60-70. [13] M. de Berg, On rectilinear link distance, Comput. Geom. Theory Appl. (1991) 13-34. [14] M. de Berg, M. van Kreveld, M. Overmars and B. Nilsson, Finding shortest paths in the presence of orthogonal obstacles using a combined L, and link metric, in SWAT 90: Second Scandinavian Workshop on Algorithm Theory, Vol. 447 (Springer, Berlin, 1990) 21 l-224. [15] P. J. de Rezende, D.T. Lee and Y.F. Wu, Rectilinear shortest paths with rectangular barriers, Discrete Comput. Geom. (1989) 41-53. [16] E. Dijkstra, A note on two problems in connection with graphs, Numer. Math. (1959) 2699271. [17] A. Fournier and D.Y. Montuno, Triangulating simple polygons and equivalent problems, ACM Trans. Graphics 3 (1984) 153-174. [18] S. Gao, M. Jerrum, M. Kaufmann, K. Mehlhorn, W. Riilling and C. Storb, On continuous homotopic one layer routing, in: Proceedings of the Third Annual ACM Symposium on Computational Geometry (1987) 392-402. [19] S.K. Ghosh, Computing the visibility polygon from a convex set and related problems, J. Algorithms 12 (1991) 75-95. [20] S. K. Ghosh and A. Maheshwari, An optimal algorithm for computing a minimum nested nonconvex polygon, Inform. Process. Lett. 36 (1990) 277-280. [21] SK. Ghosh and D.M. Mount, An output sensitive algorithm for computing visibility graphs, SIAM J. Comput. 20 (1991) 888-910. [22] R. Graham, An efficient algorithm for determining the convex hull of a finite planar set, Inform. Process. Lett. (1972) 132-133. [23] L. Guibas, J. Hershberger, D. Leven, M. Sharir and R. Tarjan, Linear time algorithms for visibility and shortest path problems inside triangulated simple polygons, Algorithmica 2 (1987) 2099233. [24] L. Guibas, L. Ramshaw and J. Stolfi, A kinetic framework for computational geometry, in: Proceedings of the 24th IEEE Symposium on Foundations of Computer Science (1983) 100-l 11. [25] L. Guibas and J. Stolfi, Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams, ACM Trans. Graphics 4 (1985) 74-123. [26] L.J. Guibas and J. Hershberger, Optimal shortest path queries in a simple polygon, J. Comput. System Sci. 39 (1989) 126-152. [27] L.J. Guibas, J.E. Hershberger, J.S.B. Mitchell and J.S. Snoeyink, Minimum-link approximation of polygons and subdivisions, in: W.L. Hsu and R.C.T. Lee, eds., ISA ‘91 Algorithms, number 557 in Lecture Notes in Computer Science, Vol. 557 (Springer, Berlin, 1991) 151-162. [28] V.W. Guillemin and A. Pollack, Differential Topology (Prentice Hall, Englewood Cliffs, NJ, 1974). [29] R.H. Giiting, Conquering Contours: Efficient Algorithms for Computational Geometry, Ph.D. Thesis, Dortmund, 1983.

J. Hershberger, J. Snoeyinkl Computational Geometry 4 (1994) 63-97

97

[30] R.H. Gutting and T. Ottmann, New algorithms for special cases of hidden line elimination problem,

Computer Vision, Graphics, and Image Process. 40 (1987) 1888204.

[31] S. Kapoor and S.N. Maheshwari, Efficient algorithms for Euclidean shortest path and visibility

problems with polygonal obstacles, in: Proceedings of the Fourth Annual ACM Symposium on

Computational Geometry (1988) 172-182.

[32] R.C. Larson and V.O. Li, Finding minimum rectilinear paths in the presence of barriers, Networks 11

(1981) 2855304.

[33] D.T. Lee and F.P. Preparata, Euclidean shortest paths in the presence of rectilinear barriers,

Networks 14 (1984) 393-410.

[34] C.E. Leiserson and F.M. Maley, Algorithms for routing and testing routability of planar VLSI

layouts, in: Proceedings of the 17th Annual ACM Symposium on Theory of Computing (1985) 69-78.

[35] C.E. Leiserson and R.Y. Pinter, Optimal placement for river routing, SIAM J. Comput. 12 (1983)

4477462.

[36] J.S.B. Mitchell, C. Piatko and E.M. Arkin, Computing a shortest k-link path in a polygon, in:

Proceedings of the 33rd IEEE Symposium on Foundations of Computer Science (1992) 573-582.

[37] J.S.B. Mitchell, G. Rote and G. Woeginger, Minimum-link paths among obstacles in the plane, in:

Proceedings of the Sixth Annual ACM Symposium on Computational Geometry (1990) 63-72.

[38] D.M. Mount, The number of shortest paths on the surface of a polyhedron, SIAM J. Comput. 19

(1990) 593-611.

[39] J.R. Munkres, Topology: A First Course (Prentice-Hall, Englewood Cliffs, NJ, 1975).

[40] B. Nilsson, T. Ottmann, S. Schuierer and C. Icking, Restricted orientation computational geometry,

in: Data structures and efficient algorithms, Lecture Notes in Computer Science, Vol. 594 (Springer,

Berlin, 1992) 1488185.

[41] B. O’Neill, Elementary Differential Geometry (Academic Press, New York, 1966).

[42] R.Y. Pinter, River routing: Methodology and analysis, in: R. Bryant, ed., The Third Caltech Confer-

ence on Very Large Scale Integration (Computer Science Press, Rockville, MD 1983).

[43] F.P. Preparata and M.I. Shamos, Computational Geometry-An

Introduction. (Springer, Berlin,

New York, 1985).

[44] G.J.E. Rawlins and D. Wood, Optimal computation of finitely oriented convex hulls, Inform.

Comput. 72 (1987) 150-166.

[45] D. Richards, Complexity of single-layer routing, IEEE Trans. Comput. 33 (1984) 2866288.

[46] J.-R. Sack, Rectilinear Computational Geometry, Ph.D. Thesis, McGill University, 1984.

[47] M. Sharir and A. Schorr, On shortest paths in polyhedral spaces, SIAM J. Comput. 15 (1986) 193-215.

[48] S. Suri, A linear time algorithm for minimum link paths inside a simple polygon, Computer Vision,

Graphics Image Process. 35 (1986) 999110.

[49] S. Suri and J.O’Rourke, Finding minimal nested polygons, in: Proceedings of the 23rd Annual

Allerton Conference on Communication, Control and Computing (1985) 470-479.

[SO] X.-H. Tan, T. Hirata and Y. Inagaki, The intersection searching problem for c-oriented polygons,

Inform. Process, Lett. 37 (1991) 201-204.

[Sl] G. Toussaint, On separating two simple polygons by a single translation, Discrete Comput. Geom.

(1989) 2655278.

[52] G.T. Toussaint, Movable separability of sets, in: G.T. Toussaint, ed., Computational Geometry

(North-Holland, Amsterdam, 1985) 335-376.

[53] G.T. Toussaint, Computing geodesic properties inside a simple polygon, Revue ISIntelligence

Artificielle 3 (1989) 9942; also available as technical report SOCS 88.20, School of Computer Science,

McGill University.

[54] C.A. Wang, Finding minimal nested polygons, BIT 31 (1991) 230-236.

[55] C.A. Wang and E.P.F. Chan, Finding the minimum visible vertex distance between two nonintersect-

ing simple polygons, in: Proceedings of the Second Annual ACM Symposium on Computational

Geometry (1986) 34442.

