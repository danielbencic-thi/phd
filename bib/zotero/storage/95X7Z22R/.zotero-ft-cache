IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Typesetting math: 100%

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Journals & Magazines > IEEE Robotics and Automation ... > Volume: 4 Issue: 4
Robust and Efficient Quadrotor Trajectory Generation for Fast Autonomous Flight
Publisher: IEEE
Cite This
PDF
  << Results   
Boyu Zhou ; Fei Gao ; Luqi Wang ; Chuhao Liu ; Shaojie Shen
All Authors
View Document
85
Paper
Citations
8969
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Related Work
    III.
    Kinodynamic Path Searching
    IV.
    B-Spline Trajectory Optimization
    V.
    Time Adjustment

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
Media
More Like This
Footnotes

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: In this letter, we propose a robust and efficient quadrotor motion planning system for fast flight in three-dimensional complex environments. We adopt a kinodynamic path ... View more
Metadata
Abstract:
In this letter, we propose a robust and efficient quadrotor motion planning system for fast flight in three-dimensional complex environments. We adopt a kinodynamic path searching method to find a safe, kinodynamic feasible, and minimum-time initial trajectory in the discretized control space. We improve the smoothness and clearance of the trajectory by a B-spline optimization, which incorporates gradient information from a Euclidean distance field and dynamic constraints efficiently utilizing the convex hull property of B-spline. Finally, by representing the final trajectory as a non-uniform B-spline, an iterative time adjustment method is adopted to guarantee dynamically feasible and non-conservative trajectories. We validate our proposed method in various complex simulational environments. The competence of the method is also validated in challenging real-world tasks. We release our code as an open-source package.
Published in: IEEE Robotics and Automation Letters ( Volume: 4 , Issue: 4 , Oct. 2019 )
Page(s): 3529 - 3536
Date of Publication: 10 July 2019
ISSN Information:
INSPEC Accession Number: 18847875
DOI: 10.1109/LRA.2019.2927938
Publisher: IEEE
Funding Agency:
Contents
SECTION I.
Introduction

Unmanned aerial vehicles (UAVs) are recently involved in more and more applications, such as industrial inspection, search-and-rescue and package delivery. To achieve full autonomy in these scenarios, the motion planning module plays an essential role in generating safe and smooth motions.

Although plenty of works on quadrotor trajectory generation have been proposed, there are still two critical unsolved issues. Firstly, given limited time and onboard computing resources, no existing works guarantee to generate safe and kinodynamic feasible trajectory at a high success rate. However, the efficiency and robustness of the trajectory generation are essential. In many circumstances, such as a quadrotor flying at high speed in unknown environments, trajectories should be re-generated constantly in a very short time to avoid emergent threats. Secondly, to ensure the kinodynamic feasibility of the generated motions, constraints on velocity and acceleration are often enforced conservatively. As a result, the aggressiveness of the generated trajectories are often hard to be tuned to satisfy applications where a high flight speed is preferable.

In this letter, we propose a complete and robust online trajectory generation method to address these two issues systematically. A kinodynamic path searching based on heuristic search and linear quadratic minimum-time control is adopted. It searches efficiently for a safe, feasible and minimum-time initial path in the discretized control space. The initial path is then refined in a carefully designed B-spline optimization, which utilizes B-spline's convex hull property to incorporate gradient information and dynamic constraints. It improves the initial path and converges quickly to a smooth, safe and dynamically feasible trajectory. Finally, the trajectory is represented as a non-uniform B-spline, for which we investigate the relations between the control points of derivatives and time allocation. Based on the relations, an iterative time adjustment method is adopted to squeeze infeasible velocity and acceleration out from the profiles while avoiding constraining them conservatively.

Compared to existing works, our proposed method is able to generate high-quality trajectories in cluttered environments in a much shorter time with a higher success rate. It can generate aggressive motion under the premise of dynamic feasibility. We show the efficiency and robustness of our method in numerous simulational complex environments. We also demonstrate that our method is competent even for challenging fast flight when trajectories should be re-generated repeatedly in a very short time by real-world experiments. We summarize our contributions as follows:

    We propose a robust and efficient systematic method, incorporating kinodynamic path searching, B-spline optimization and time adjustment, where safety, dynamic feasibility and aggressiveness are built from bottom-up.

    We present an optimization formulation based on the convex hull property of B-splines that delicately incorporates gradient information and dynamic constraints, which converges quickly to generate smooth, safe and dynamically feasible trajectories.

    We investigate the relations between the control points of derivatives and the time allocation of non-uniform B-splines. A time adjustment method based on the relations is applied to guarantee feasible and non-conservative motion.

    We present extensive simulation and real-world evaluation of our proposed method. The source code is released as a ros-package.

SECTION II.
Related Work
A. Hard-Constrained Methods

The problems of trajectory generation have been addressed by some work recently. Hard-constrained methods are pioneered by minimum-snap trajectory generation [1] , in which trajectories are represented as piecewise polynomials and generated by solving a quadratic programming(QP) problem. [2] shows that minimum snap trajectories can be obtained in closed form, in which the safety of the trajectories is ensured by iteratively adding intermediate waypoints. Works [3] – [4] [5] [6] [7] generate trajectories in a two-step pipeline. Free space represented by a sequence of cubes [3] , [8] , spheres [4] , [9] or polyhedrons [5] is firstly extracted, which is followed by convex optimization, which generates smooth trajectory within the feasible space. [6] , [7] proposed a B-spline-based kinodynamic search to find an initial trajectory which is then refined by an elastic band optimization approach. The use of uniform B-spline ensures dynamic feasibility but could generate conservative motion. One common drawback of these methods is that the time allocation of the trajectory is given by naive heuristics. However, a poorly chosen time allocation significantly reduce the quality of the trajectory. Besides, a feasible solution can only be obtained by iteratively adding more constraints and solving the quadratic programming problem, which is undesirable for real-time application. To address these problems, [8] proposed a method to search for a path with well-allocated time and guarantee the safety and kinodynamic feasibility of trajectory through optimization. Hard-constrained methods ensure global optimality by the convex formulation. However, distance to obstacles in the free space is ignored, which often results in trajectories being close to obstacles. Besides, the kinodynamic constraints are conservative, making the trajectory's speed deficient for fast flight.
B. Soft-Constrained Methods

There are also methods formulating trajectory generation as a non-linear optimization problem that takes smoothness and safety into account. [10] generates discrete-time trajectories by minimizing its smoothness and collision costs using gradient descent methods. [11] has similar problem formulation, but the optimization is solved by a gradient-free sampling method. [12] extended them to continuous-time polynomial trajectories. Since the time parameterization is continuous, it avoids numeric differentiation errors and is more accurate to represent the motions of quadrotors. However, it suffers from a low success rate. To solve this problem, [13] finds a collision-free initial path firstly using an informed sampling-based path searching method. This path serves as a higher quality initial guess of non-linear optimization and thus improve the success rate. In [14] , the trajectory is parameterized as a uniform B-spline. Since a B-spline is continuous by nature, there is no need to enforce continuity explicitly, which reduce the number of constraints. It is also particularly useful for local replanning thanks to its property of locality. Soft-constrained methods utilize gradient information to push trajectory far from obstacles, but suffer from local minima and having no strong guarantee of success rate and kinodynamic feasibility. Our optimization method also utilizes gradient information to improve the safety of the trajectory. However, unlike previous methods in which computational expensive line integrals along the trajectory are calculated, the formulation is redesigned to be simpler based on the convex hull property of B-spline. It greatly improves the computation efficiency as well as the convergent rate.
SECTION III.
Kinodynamic Path Searching

Our front-end kinodynamic path searching module is originated from the hybrid-state A* search first proposed for autonomous vehicle [15] . It searches for a safe and kinodynamic feasible trajectory that is minimal with respect to time duration and control cost in a voxel grid map. As shown in Alg. 1 and in Fig. 2 , the searching loop is similar to the standard A* algorithm, where P and C refer to the open and closed set. Instead of straight lines, motion primitives respecting the quadrotor dynamic are used as graph edge. A structure Node is used to record a primitive, the voxel the primitives ends in and the g c and f c cost (Sect. III-B ). Primitives Expand () the voxel grid map iteratively and those ending up in the same voxel except the one with the smallest f c are pruned ( Prune ()). Then CheckFeasible () checks the safety and dynamic feasibility of the remained primitives. This process continues until any primitive reach goal or the AnalyticExpand() (Sect. III-C ) succeeds.
Fig. 1. - Our proposed method tested on a fully autonomous quadrotor in (a), and on extremely challenging fast replanning with indoor external feedback in (b). Experimental details are given in Sect. VII. Video is available at https://www.youtube.com/watch?v=GIYGAjOeeI8&feature=youtu.be.
Fig. 1.

Our proposed method tested on a fully autonomous quadrotor in (a), and on extremely challenging fast replanning with indoor external feedback in (b). Experimental details are given in Sect. VII . Video is available at https://www.youtube.com/watch?v=GIYGAjOeeI8&feature=youtu.be .

Show All
Fig. 2. - An illustration of the mechanism of the kinodynamic path searching. Red curves indicate the motion primitives generated by Equ.3. The purple curve is the analytic expansion explained in Sect. III-C.
Fig. 2.

An illustration of the mechanism of the kinodynamic path searching. Red curves indicate the motion primitives generated by Equ. 3 . The purple curve is the analytic expansion explained in Sect. III-C .

Show All
III.

Algorithm
A. Primitives Generation

We first discuss the generation of motion primitives used in Expand (). The differential flatness of quadrotor systems allows us to represent the trajectory by three independent 1-D time-parameterized polynomial functions [1] :
p ( t ) : = [ p x ( t ) , p y ( t ) , p z ( t ) ] ⊤ , p μ ( t ) = ∑ k = 0 K a k t k (1)
View Source Right-click on figure for MathML and additional features. \begin{equation*} \mathbf {p}(t):=\left[ p_{x}(t), p_{y}(t), p_{z}(t) \right]^{\top },\quad p_{\mu }(t) = \sum _{k=0}^{K} a_{k} t^{k} \tag{1} \end{equation*} where μ ∈ { x , y , z } . From the view of quadrotor systems, it corresponds to a linear time-invariant (LTI) system. Let x ( t ) : = [ p ( t ) ⊤ , p ˙ ( t ) ⊤ , … , p ( n − 1 ) ( t ) ⊤ ] ⊤ ∈ X ⊂ R 3 n be the state vector. Let u ( t ) : = p ( n ) ( t ) ∈ U : = [ − u max , u max ] 3 ⊂ R 3 be the control input. The state space model can be defined as:
x ˙ A = A x + B u = ⎡ ⎣ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ 0 0 ⋮ 0 0 I 3 0 ⋮ ⋯ ⋯ 0 I 3 ⋮ ⋯ ⋯ ⋯ ⋯ ⋱ 0 0 0 0 ⋮ I 3 0 ⎤ ⎦ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ , B = ⎡ ⎣ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ ⎢ 0 0 ⋮ 0 I 3 ⎤ ⎦ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ ⎥ (2)
View Source Right-click on figure for MathML and additional features. \begin{align*} \dot{\mathbf {x}} &= \mathbf {A}\mathbf {x}+\mathbf {B}\mathbf {u} \nonumber \\ \mathbf {A} &= \left[ \begin{array}{ccccc}\mathbf {0} & \mathbf {I}_{3} & \mathbf {0} & \cdots & \mathbf {0} \\ \mathbf {0} & \mathbf {0} & \mathbf {I}_{3} & \cdots & \mathbf {0} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ \mathbf {0} & \cdots & \cdots & \mathbf {0} & \mathbf {I}_{3} \\ \mathbf {0} & \cdots & \cdots & \mathbf {0} & \mathbf {0} \end{array} \right], \quad \mathbf {B} = \left[ \begin{array}{c}\mathbf {0} \\ \mathbf {0} \\ \vdots \\ \mathbf {0} \\ \mathbf {I}_{3} \end{array} \right]\tag{2} \end{align*} The complete solution for the state equation is expressed as:
x ( t ) = e A t x ( 0 ) + ∫ t 0 e A ( t − τ ) B u ( τ )   d τ (3)
View Source Right-click on figure for MathML and additional features. \begin{equation*} \mathbf {x}(t) = e^{\mathbf {A}t}\mathbf {x}(0) + \int _{0}^{t}e^{\mathbf {A}(t-\tau)}\mathbf {B}\mathbf {u}(\tau) \ d\tau \tag{3} \end{equation*} which gives the trajectory of the quadrotor system whose initial state is x ( 0 ) and control input is u ( t ) .

In Expand (), given the current state of the quadrotor, a set of discretized control inputs U D ⊂ U is applied for duration τ . In practice, we select n = 2 , which corresponds to a double integrator. Each axis [ − u max , u max ] is discretized uniformly as { − u max , − r − 1 r u max , … , r − 1 r u max ,   u max } , which results in ( 2 r + 1 ) 3 primitives.
B. Actual Cost and Heuristic Cost

As we aim to find a trajectory that is optimal in time and control cost, we define the cost of a trajectory as:
J ( T ) = ∫ T 0 ∥ u ( t ) ∥ 2 d t + ρ T (4)
View Source Right-click on figure for MathML and additional features. \begin{equation*} \mathcal {J}(T) = \int _{0}^{T} \Vert \mathbf {u}(t) \Vert ^{2} dt + \rho T \tag{4} \end{equation*} Under this definition, EdgeCost () calculates the cost of a motion primitive generated with the discretized input u ( t ) = u d and duration τ as e c = ( ∥ u d ∥ 2 + ρ ) τ .

Following the terminology of A*, we use g c to represent the actual cost of an optimal path from the start state x s to the current state x c . Let this optimal path consists of J primitives, g c is calculated as: g c = ∑ J j = 1 ( ∥ u d j ∥ 2 + ρ ) τ .

An admissible and informative heuristic is essential to speed up the searching as in A*. Hence, we also design a Heuristic (). We compute a closed form trajectory that minimizes J ( T ) from x c to the goal state x g by applying the Pontryagins minimum principle [16] :
p ∗ μ ( t ) [ α μ β μ ] J ∗ ( T ) = 1 6 α μ t 3 + 1 2 β μ t 2 + v μ c + p μ c = 1 T 3 [ − 12 6 T 6 T − 2 T 2 ] [ p μ g − p μ c − v μ c T v μ g − v μ c ] = ∑ μ ∈ { x , y , z } ( 1 3 α 2 μ T 3 + α μ β μ T 2 + β 2 μ T ) (5)
View Source Right-click on figure for MathML and additional features. \begin{align*} p_{\mu }^{*}(t) &= \frac{1}{6}\alpha _{\mu } t^{3} + \frac{1}{2}\beta _{\mu } t^{2} + v_{\mu c} + p_{\mu c} \nonumber \\ \left[ \begin{array}{c}\alpha _{\mu } \\ {\beta _{\mu }} \end{array}\right] &= \frac{1}{T^{3}} \left[ \begin{array}{cc}-12 & {6 T} \\ {6 T} & {-2 T^{2}}\end{array}\right] \left[ \begin{array}{c}p_{\mu g}-p_{\mu c}-v_{\mu c} T \\ {v_{\mu g}-v_{\mu c}}\end{array}\right] \nonumber \\ \mathcal {J}^{*}(T) &= \sum _{\mu \in \lbrace x,y,z\rbrace }\left(\frac{1}{3}\alpha _{\mu }^{2}T^{3} + \alpha _{\mu } \beta _{\mu } T^{2} + \beta _{\mu }^{2} T\right)\tag{5} \end{align*} where p μ c , v μ c , p μ g , v μ g are the current and goal position and velocity. J ∗ ( T ) is the cost defined by Equ. 4 . To find the optimal time T that minimize the cost, we substitute α μ , β μ into J ∗ ( T ) and find the roots of ∂ J ∗ ( T ) ∂ T = 0 . The root making a minimum cost m i n   J ∗ and feasible trajectory is selected and denoted as T h . We use J ∗ ( T h ) as the heuristic h c . Finally, f c is defined as: f c = g c + h c = g c + J ∗ ( T h ) .

C. Analytic Expansion

Due to the discretized control input, it is difficult to have a primitive end exactly in the goal state. To compensate for it and also to speed up the searching, we induce an analytic expansion scheme. When a node is popped from the open set, a trajectory from x c to x g is computed using the same approach in Sect. III-B . If it passes the safety and dynamic feasibility check, the searching is terminated in advance. This strategy is effective for improving efficiency especially in sparse environments, since it has a higher success rate and terminates the searching earlier.
D. Optimality and Completeness

Theoretically, we can not guarantee the optimality and completeness of the path searching. However, the practical performance is satisfactory. For the optimality, evaluation (Sect. VII-A1 ) shows that the sacrifice of optimality is acceptable and adjustable. Besides, provided the initial path lies near the optimum, our optimization (Sect. IV ) will find that optimum. For the completeness, evaluation (Sect. VII-A1 ) indicates that in practice it can find a feasible solution in most case. Also, our method can be extended to support variable-duration primitives and a variable-resolution voxel grid as described by [15] to make stronger completeness guarantees.
SECTION IV.
B-Spline Trajectory Optimization

As mentioned in Sect. III-D , the path produced by the path searching can be suboptimal. In addition, this path is often close to obstacle since distance information in the free space is ignored ( Fig. 5 ). Therefore, we improve the smoothness and clearance of the path in the proposed B-spline optimization. The convex hull property of uniform B-splines are utilized to incorporate gradient information from the Euclidean distance field and dynamic constraints, for which it converges within a very short duration to generate smooth, safe and dynamically feasible trajectories.
A. Uniform B-Splines

A B-spline is a piecewise polynomial uniquely determined by its degree p b , a set of N + 1 control points { Q 0 , Q 1 , … , Q N } and a knot vector [ t 0 , t 1 , … , t M ] , in which Q i ∈ R 3 , t m ∈ R and M = N + p b + 1 . A B-spline trajectory is parameterized by time t , where t ∈ [ t p b , t M − p b ] . For a uniform B-spline, each knot span Δ t m = t m + 1 − t m has identical value Δ t . To evaluate the position at time t ∈ [ t m , t m + 1 ) ⊂ [ t p b , t M − p b ] , we first normalize t as s ( t ) = ( t − t m ) / Δ t . Then the position can be evaluated using the matrix representation [17] :
p ( s ( t ) ) = s ( t ) = q m = s ( t ) ⊤ M p b + 1 q m [ 1 s ( t ) s 2 ( t ) ⋯ s p b ( t ) ] ⊤ [ Q m − p b Q m − p b + 1 Q m − p b + 2 ⋯ Q m ] ⊤ (6)
View Source Right-click on figure for MathML and additional features. \begin{align*} \mathbf {p}(s(t)) =& \mathbf {s}(t)^{\top } \mathbf {M}_{p_b+1} \mathbf {q}_m \\ \mathbf {s}(t) =& \left[ {\begin{array}{ccccc}1 & s(t) & s^{2}(t) & \cdots & s^{p_b}(t) \end{array}} \right]^{\top } \\ \mathbf {q}_m =& \left[ {\begin{array}{ccccc}\mathbf {Q}_{m-p_b} & \mathbf {Q}_{m-p_b+1}& \mathbf {Q}_{m-p_b+2} & \cdots & \mathbf {Q}_{m} \end{array}} \right]^{\top }\tag{6} \end{align*} here M p b + 1 is a constant matrix determined by p b . In our implementation, p b is set as 3 . The evaluation of the derivatives is exactly the same, since the derivative of a B-spline is also a B-spline.

The convex hull property of B-splines ( Fig. 3 ) is essential for designing our optimization formulation. We show in Sect. IV-B that it is extremely useful for ensuring the dynamic feasibility and safety of the entire trajectory.
Fig. 3. - (a) A trajectory is represented by a B-spline ($ p_b = 3$). Each segment is bounded by the corresponding convex hull of the control points (example convex hulls and segments are shown in green and orange). (b) The first order derivative (velocity) is also a B-spline, thus it has the same property. The control points of the derivatives can be calculated by Equ.7.
Fig. 3.

(a) A trajectory is represented by a B-spline ( p b = 3 ). Each segment is bounded by the corresponding convex hull of the control points (example convex hulls and segments are shown in green and orange). (b) The first order derivative (velocity) is also a B-spline, thus it has the same property. The control points of the derivatives can be calculated by Equ. 7 .

Show All
B. Convex Hull Property

The convex hull property ( Fig. 3 ) is used extensively in our method to ensure both dynamic feasibility and safety.

For the dynamic feasibility, it suffices to constrain all velocity and acceleration control points { V 0 , V 1 , … , V N − 1 } and { A 0 , A 1 , … , A N − 2 } so that V i ∈ [ − v max , v max ] 3 and A i ∈ [ − a max , a max ] 3 . V i and A i are calculated by Equ. 7 , where Δ t is the knot span:
V i = 1 Δ t ( Q i + 1 − Q i ) , A i = 1 Δ t ( V i + 1 − V i ) (7)
View Source Right-click on figure for MathML and additional features. \begin{equation*} \mathbf {V}_{i} = \frac{1}{\Delta t}(\mathbf {Q}_{i+1}-\mathbf {Q}_{i}), \quad \mathbf {A}_{i} = \frac{1}{\Delta t}(\mathbf {V}_{i+1}-\mathbf {V}_{i}) \tag{7} \end{equation*} For the safety of the B-spline, we need to ensure that all its convex hulls are collision-free. Equivalently, we need to ensure that d h > 0 , where d h is the distance between any one occupied voxel and any one point Q h in the convex hull ( Fig. 4 ). By the triangle inequality, we have d h > d c − r h , where d c is the distance between the voxel and any one control point. We also have r h ≤ r 12 + r 23 + r 34 , since Q h is inside the convex hull. Combining them, d h > d c − ( r 12 + r 23 + r 34 ) is always valid. Therefore, if we ensure:
d c > 0 , r j , j + 1 < d c / 3     ( j ∈ { 1 , 2 , 3 } ) (8)
View Source Right-click on figure for MathML and additional features. \begin{equation*} d_{c} > 0, \quad r_{j,j+1} < d_{c}/3 \ \ (j \in \lbrace 1,2,3 \rbrace) \tag{8} \end{equation*} then the convex hull is guaranteed to be collision-free.

Fig. 4. - Illustration of ensuring that a convex hull of the B-spline ($ p_b = 3$) is collision-free.
Fig. 4.

Illustration of ensuring that a convex hull of the B-spline ( p b = 3 ) is collision-free.

Show All
Fig. 5. - Using gradient-based numeric optimization to deform the trajectory. The red and the green curves are the initial path and the B-spline after the optimization. Yellow dots stand for the control points of the B-spline. The initial path is close to the obstacles since distance information is ignored, while the B-spline is pushed away by the gradient-based optimization.
Fig. 5.

Using gradient-based numeric optimization to deform the trajectory. The red and the green curves are the initial path and the B-spline after the optimization. Yellow dots stand for the control points of the B-spline. The initial path is close to the obstacles since distance information is ignored, while the B-spline is pushed away by the gradient-based optimization.

Show All
C. Problem Formulation

For a p b degree B-spline trajectory defined by N + 1 control points { Q 0 , Q 1 , … , Q N } , we optimize the subset of N + 1 − 2 p b control points { Q p b , Q p b + 1 , … , Q N − p b } . The first and last p b control points should not be changed because they determine the boundary state. The overall cost function is defined as:
f t o t a l = λ 1 f s + λ 2 f c + λ 3 ( f v + f a ) (9)
View Source Right-click on figure for MathML and additional features. \begin{equation*} f_{total} = \lambda _{1} f_{s} + \lambda _{2} f_{c} + \lambda _{3} (f_{v} + f_{a}) \tag{9} \end{equation*} where f s and f c are smoothness and collision cost. f v and f a are soft limits on velocity and acceleration. λ 1 , λ 2 and λ 3 trade off the smoothness, safety and dynamic feasibility.

We define the smoothness cost f s by a function that captures the geometric information of the trajectory and does not depend on time allocation, unlike many recent works that use integral of the squared snap or jerk. The reason is that after optimization the time allocation may be adjusted (Sect. V ). This will change the derivatives of the trajectory and make the optimized snap (jerk) less meaningful. We use an elastic band cost function 2 [18] , [19] :
f s = ∑ i = p b − 1 N − p b + 1 ∥ ( Q i + 1 − Q i )              F i + 1 , i   +   ( Q i − 1 − Q i )              F i − 1 , i ∥ 2 (10)
View Source Right-click on figure for MathML and additional features. \begin{equation*} f_{s} = \sum \limits _{i=p_b-1}^{N-p_b+1} \Vert \underbrace{(\mathbf {Q}_{i+1}-\mathbf {Q}_{i})}_{\mathbf {F}_{i+1,i}} \ + \ \underbrace{(\mathbf {Q}_{i-1}-\mathbf {Q}_{i})}_{\mathbf {F}_{i-1,i}} \Vert ^{2} \tag{10} \end{equation*} From a physical standpoint, this formulation view a trajectory as an elastic band, where each term F i + 1 , i = Q i + 1 − Q i and F i − 1 , i = Q i − 1 − Q i is the joint force of two springs connecting the nodes Q i + 1 , Q i and Q i − 1 , Q i respectively. If all terms equal to zero, all the control points would uniformly distribute in a straight line, which is ideally smooth.

Similarly, the collision cost is formulated as the repulsive force of the obstacles acting on each control point:
f c = ∑ i = p b N − p b F c ( d ( Q i ) ) (11)
View Source Right-click on figure for MathML and additional features. \begin{equation*} f_{c} = \sum \limits _{i=p_b}^{N-p_b} F_{c}(d(\mathbf {Q}_{i})) \tag{11} \end{equation*} where d ( Q i ) is the distance between Q i and the closet obstacle. F c is a differentiable potential cost function with d t h r specifying the threshold of obstacle clearance:
F c ( d ( Q i ) ) = { ( d ( Q i ) − d t h r ) 2 0 d ( Q i ) ≤ d t h r d ( Q i ) > d t h r (12)
View Source Right-click on figure for MathML and additional features. \begin{equation*} F_{c}(d(\mathbf {Q}_{i})) = \left\lbrace \begin{array}{ll}(d(\mathbf {Q}_{i})-d_{thr})^{2} & d(\mathbf {Q}_{i}) \leq d_{thr} \\ 0 & d(\mathbf {Q}_{i}) > d_{thr} \end{array} \right. \tag{12} \end{equation*}

As shown in Sect. IV-B , Equ. 8 must be satisfied so that the trajectory is collision-free. Since the collision cost pushes the control points away from obstacles, d c > 0 is apparent. Also, r j , j + 1 are tunable parameters depend solely on the parameterization of the B-spline. In practice, as long as we select r j , j + 1 , ( j ∈ { 0 , 1 , … , N } ) that are significantly small (in our implementation r j , j + 1 < 0.2 ), the trajectory is safe in most cases. This may be invalid in extreme cases, for instance, the environment is very cluttered. Even so, we can re-parameterize the B-spline to select smaller r j , j + 1 , after which Equ. 8 will still be satisfied.

We penalize velocity or acceleration along the trajectory exceeding maximum allowable value v max and a max with a cost similar to Equ. 12 . The penalty for 1-D velocity v μ is:
F v ( v μ ) = { ( v 2 μ − v 2 max ) 2 0 v 2 μ > v 2 max v 2 μ ≤ v 2 max (13)
View Source Right-click on figure for MathML and additional features. \begin{equation*} F_{v}(v_{\mu }) = \left\lbrace \begin{array}{ll}(v_{\mu }^{2} - v_{\max}^{2})^{2} & v_{\mu }^{2} > v_{\max}^{2} \\ 0 & v_{\mu }^{2} \leq v_{\max}^{2} \end{array} \right. \tag{13} \end{equation*} where μ ∈ { x , y , z } . The acceleration penalty has identical form. Applying the convex hull property ( Fig. 3 ), we define f v and f a so that infeasible velocity and acceleration control points are penalized:
f v = ∑ μ ∈ { x , y , z } ∑ i = p b − 1 N − p b F v ( V i μ ) , f a = ∑ μ ∈ { x , y , z } ∑ i = p b − 2 N − p b F a ( A i μ ) (14)
View Source Right-click on figure for MathML and additional features. \begin{equation*} f_{v} = \sum \limits _{{{\scriptstyle {{{\mu \in} \atop{\lbrace x,y,z \rbrace}} }}}} \sum \limits _{i=p_b-1}^{N-p_b} F_{v}(V_{i\mu }), \quad f_{a} = \sum \limits _{{{\scriptstyle {{\mu \in} \atop{\lbrace x,y,z \rbrace}}}}} \sum \limits _{i=p_b-2}^{N-p_b} F_{a}(A_{i\mu }) \tag{14} \end{equation*}

SECTION V.
Time Adjustment

Although we constrain kinodynamic feasibility in the path searching and optimization, sometimes we get infeasible trajectories. The basic reason is that gradient information tends to lengthen the overall trajectory while pushing it far from obstacles. Consequently, the quadrotor has to fly more aggressively in order to travel longer distance within the same time, which unavoidably causes over aggressive motion if the original motion is already near to the physical limits.

To guarantee dynamic feasibility, we adopt a time adjustment method based on the relations between the derivatives control points and the time allocation (knot spans) of the non-uniform B-spline. Thanks to the relations, we can change the flight aggressiveness as we expected by adjusting the associated time allocation. Thus dynamic feasibility can be ensured without over-conservative constraints.

We first introduce the mathematic fundament of the time adjustment. Then the Alg. 2 is presented to tackle over-aggressive trajectories.
A. Non-Uniform B-Spline

Non-uniform B-spline is a more general kind of B-spline. The only difference to uniform B-spline is that each of its knot span Δ t m = t m + 1 − t m is independent to others. The control points of a non-uniform B-spline's first and second order derivatives V ′ i and \mathbf {A}_{i}^{^{\prime }} can be computed by: \begin{equation*} \mathbf {V}_{i}^{^{\prime }} = \frac{p_b(\mathbf {Q}_{i+1}-\mathbf {Q}_{i})}{t_{i+p_b+1}-t_{i+1}}, \ \ \mathbf {A}_{i}^{^{\prime }} = \frac{(p_b-1)(\mathbf {V}_{i+1}^{^{\prime }}-\mathbf {V}_{i}^{^{\prime }})}{t_{i+p_b+1}-t_{i+2}} \tag{15} \end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*} \mathbf {V}_{i}^{^{\prime }} = \frac{p_b(\mathbf {Q}_{i+1}-\mathbf {Q}_{i})}{t_{i+p_b+1}-t_{i+1}}, \ \ \mathbf {A}_{i}^{^{\prime }} = \frac{(p_b-1)(\mathbf {V}_{i+1}^{^{\prime }}-\mathbf {V}_{i}^{^{\prime }})}{t_{i+p_b+1}-t_{i+2}} \tag{15} \end{equation*} By the convex hull property ( Fig. 3 ), to enforce the dynamic feasibility of a trajectory represented by a non-uniform B-spline, it suffices to enforce all control points of the first and second order derivatives within the feasible domain. We show that this can be achieved by changing the corresponding knot spans of the infeasible control points in Sect. V-B .

B. Knot Spans Adjustment

Let \mathbf {V}_{i}^{^{\prime }} = [ V_{i,x}^{^{\prime }}, V_{i,y}^{^{\prime }}, V_{i,z}^{^{\prime }} ]^{\top } be an infeasible control point of velocity. Let V_{i,\mu }^{^{\prime }} be the largest infeasible component and \mid V_{i,\mu }^{^{\prime }} \mid = v_m . From Equ. 15 we know that V_{i,\mu }^{^{\prime }} is influenced by the duration t_{i+p_b+1} - t_{i+1} . If we change this duration to \hat{t}_{i+p_b+1} - \hat{t}_{i+1} = \mu _v (t_{i+p_b+1} - t_{i+1}) , then V_{i,\mu }^{^{\prime }} changes to: \begin{align*} \hat{V}_{i,\mu } &= \frac{p_b}{\hat{t}_{i+p_b+1}-\hat{t}_{i+1}} (Q_{i+1,\mu }-Q_{i,\mu }) \nonumber \\ &= \frac{1}{\mu _{v}} \frac{p_b}{t_{i+p_b+1}-t_{i+1}} (Q_{i+1,\mu }-Q_{i,\mu }) = \frac{1}{\mu _{v}} {V}_{i,\mu }^{^{\prime }}\tag{16} \end{align*}
View Source Right-click on figure for MathML and additional features. \begin{align*} \hat{V}_{i,\mu } &= \frac{p_b}{\hat{t}_{i+p_b+1}-\hat{t}_{i+1}} (Q_{i+1,\mu }-Q_{i,\mu }) \nonumber \\ &= \frac{1}{\mu _{v}} \frac{p_b}{t_{i+p_b+1}-t_{i+1}} (Q_{i+1,\mu }-Q_{i,\mu }) = \frac{1}{\mu _{v}} {V}_{i,\mu }^{^{\prime }}\tag{16} \end{align*} Therefore, if we set \mu _{v} = \frac{v_{m}}{v_{\max}} , then the velocity is feasible, because \mid \hat{V}_{i,\mu } \mid = \frac{v_{\max}}{v_{m}} \mid {V}_{i,\mu }^{^{\prime }} \mid = v_{\max} \in [ -v_{\max}, v_{\max}] .

The enforcement of acceleration feasibility is similar. 3 We know that A_{i,\mu }^{^{\prime }} is actually influenced by t_{i+p_b+2} - t_{i+1} since it is coupled with V_{i,\mu }^{^{\prime }} and V_{i+1,\mu }^{^{\prime }} . We change \Delta t_m = t_{m+1} - t_{m} to \Delta \hat{t}_{m} = \mu _a \Delta t_m for m \in \lbrace i+1,i+2, \ldots, i+p_b+1 \rbrace and we get: \begin{align*} \hat{A}_{i,\mu } &= \frac{p_b-1}{\hat{t}_{i+p_b+1}-\hat{t}_{i+2}} (\hat{V}_{i+1,\mu }- \hat{V}_{i,\mu }) \nonumber \\ & = \frac{1}{\mu _a} \frac{p_b-1}{t_{i+p_b+1}-t_{i+2}} \left(\frac{1}{\mu _a} V_{i+1,\mu }^{^{\prime }} - \frac{1}{\mu _a} V_{i,\mu }^{^{\prime }} \right) \\ \nonumber & = \frac{1}{\mu _{a}^{2}} \frac{p_b-1}{{t}_{i+p_b+1}-{t}_{i+2}} ({V}_{i+1,\mu }^{^{\prime }} - {V}_{i,\mu }^{^{\prime }}) = \frac{1}{\mu _{a}^{2}} A_{i,\mu }^{^{\prime }}\tag{17} \end{align*}
View Source Right-click on figure for MathML and additional features. \begin{align*} \hat{A}_{i,\mu } &= \frac{p_b-1}{\hat{t}_{i+p_b+1}-\hat{t}_{i+2}} (\hat{V}_{i+1,\mu }- \hat{V}_{i,\mu }) \nonumber \\ & = \frac{1}{\mu _a} \frac{p_b-1}{t_{i+p_b+1}-t_{i+2}} \left(\frac{1}{\mu _a} V_{i+1,\mu }^{^{\prime }} - \frac{1}{\mu _a} V_{i,\mu }^{^{\prime }} \right) \\ \nonumber & = \frac{1}{\mu _{a}^{2}} \frac{p_b-1}{{t}_{i+p_b+1}-{t}_{i+2}} ({V}_{i+1,\mu }^{^{\prime }} - {V}_{i,\mu }^{^{\prime }}) = \frac{1}{\mu _{a}^{2}} A_{i,\mu }^{^{\prime }}\tag{17} \end{align*} Similarly, let \mu _{a} = (\frac{a_m}{a_{\max}})^{\frac{1}{2}} , then \mid \hat{A}_{i,\mu } \mid = \frac{a_{\max}}{a_{m}} \mid A_{i,\mu }^{^{\prime }} \mid = a_{\max} \in [ -a_{\max}, a_{\max} ] .

C. Iterative Time Adjustment

Based on the derivation in Sect. V-B , Alg. 2 is adopted to enforce dynamic feasibility. It iteratively finds the infeasible velocity and acceleration control points \mathcal {V} and \mathcal {A} of the trajectory (Line 2) and adjust the corresponding knot spans (Lines 3-10). Because a knot span \Delta t_{m} influences a few control points and vice versa, bounding \mu _{v}^{^{\prime }} and \mu _{a}^{{\prime }} with two constant \alpha _v and \alpha _a slightly larger than 1 (Line 5, 9) prevents any time span from being extended excessively.

Algorithm
SECTION VI.
Implementation Details
A. Experiment Settings

The motion planning method proposed in this letter is implemented in C++11 with a general non-linear optimization solver NLopt. 4 We set r=2, \tau = 0.5 for the path searching, \lambda _1 = 10.0, \lambda _2 = 0.8, \lambda _3 = 0.01 for the optimization and \alpha _a = \alpha _v = 1.1 for the time adjustment in all experiments. We present two sets of real-world experiments to validate our proposed planning method.

Firstly, we conduct fast autonomous flight experiments in unknown cluttered environments (Sect. VII-B ). We use a self-developed quadrotor platform ( Fig. 6(a) ) equipped with a Velodyne VLP-16 3-D LiDAR. LOAM [20] is adopted to estimate the pose of the quadrotor and generate a dense point cloud map. To obtain high-rate state estimation for feedback control, we fused the laser-based estimation with IMU and sonar measurements by the extended Kalman filter (EKF). All modules including motion planning, state estimation, mapping and control run on a dual-core 3.00 GHz Intel i7-5500U processor, which has 8 GB RAM and 256 GB SSD.
Fig. 6. - Quadrotor platforms used in (a) fully autonomous flight and (b) aggressive kinodynamic replanning.
Fig. 6.

Quadrotor platforms used in (a) fully autonomous flight and (b) aggressive kinodynamic replanning.

Show All

Then, in Sect. VII-C , we focus on testing the fast-replanning capability of our proposed method in aggressive flight, for which we use a more light-weight and agile quadrotor platform ( Fig. 6(b) ). To eliminate uncertainties introduced by onboard sensings, accurate pose feedback is provided by the motion capture system OptiTrack 5 and the map of the environment is pre-built. The motion planning and control modules run onboard on an Nvidia TX2 computer.
B. Re-Planning Strategy
1) Receding-Horizon Local Planning

When the quadrotor flies in an unknown environment, it has to re-plan its trajectory frequently due to the limited sensing range. To improve efficiency, we adopt a receding-horizon planning scheme, in which trajectories are generated only within the known space ( Fig. 7 ). The path searching is terminated once a motion primitive ends outside this range and is followed by the optimization and time adjustment. Planning in the unknown space is often useless, thus such efforts can be saved.
Fig. 7. - The local planning strategy for a limited sensing range. The red curve and the yellow curve are the trajectories before and after the optimization. Opaque and transparent obstacles are known and unknown ones.
Fig. 7.

The local planning strategy for a limited sensing range. The red curve and the yellow curve are the trajectories before and after the optimization. Opaque and transparent obstacles are known and unknown ones.

Show All
2) Re-Planning Triggering Mechanism

The re-planning is triggered in two situations. Firstly, it is triggered if the current trajectory collides with newly emergent obstacles, 6 which ensures that a new safe trajectory is available as soon as any collision is detected. Secondly, the planner is called at fixed intervals of time. It updates the trajectory periodically using the most up-to-date environmental information.
C. Euclidean Distance Field

We maintain an EDF of the voxel grid map for our optimization, which is computed by an efficient O(n) algorithm [21] , where n = N^{3} is the number of updated voxel grids. To compensate for the discretized error of the EDF introduced by the voxel grid map and benefit the numeric optimization, trilinear interpolation is used to improve the accuracy of the distance and gradient information [14] . Global update of the EDF is very costly and can block the planning module that is crucial for fast autonomous flight. To address this issue, we only update the voxel grids within the sensing range using an incremental update strategy [22] .
SECTION VII.
Results
A. Analysis and Comparisons
1) Comparison of Path Searching

We compare our path searching with method [23] , both of which use the time-optimal control formulation to generate primitives. The comparison is done on a \text{40}\times \text{40}\times \text{5 m} map randomly deployed with 100 obstacles and the maximum velocity and acceleration limits are set as \text{3 m/s} and \text{2m/s}^{2} respectively. Since the resolution of voxel grids is a critical factor for the performance of our proposed method, different resolutions are used for comprehensive evaluation ( Table I , column 1, rows 3-5). For a fair comparison, we use the open source implementation of [23] . Results are listed in Table I .
TABLE I Comparison of Path Searching
Table I- Comparison of Path Searching

As is shown in statics, both methods generate kinodynamic feasible trajectories. Our method is faster with one order of magnitude and tends to generate a path with a shorter duration. However, the control cost for it is slightly higher. As the voxel girds get coarser, the efficiency of our method increases at the expense of higher control cost and lower success rate. This trend is expected because pruning primitives with coarser voxel grids results in lower searching complexity, whereas more feasible (and maybe superior) paths are lost.
2) Comparison of Optimization

For the back-end trajectory optimization, we conduct a comparison against our previous work [13] . Both of our previous method and the proposed method utilize the EDF for non-linear optimization. For fairness, we use the same path given by our path searching as the initial value. Firstly, we compare the costs of the objective function with respect to time for both methods ( Fig. 8(a) ). Obviously, the cost of the proposed method drops rapidly within the first few milliseconds, while the other one decreases much slower. Secondly, comparison of smoothness (integral of the squared jerk) is conducted as shown in Fig. 8(b) and Table II . Even though less time is given for the proposed method, the resulting trajectories are smoother.
Fig. 8. - Comparing our proposed optimization method with gradient-based optimization method [13] in random cluttered environments.
Fig. 8.

Comparing our proposed optimization method with gradient-based optimization method [13] in random cluttered environments.

Show All
TABLE II Comparison of Trajectory Optimization
Table II- Comparison of Trajectory Optimization
B. Onboard Autonomous Flight

We conducted fully autonomous fast flight experiments in a challenging unknown environment ( Fig. 9(a) ). To further challenge our method, we prune the global map using a sphere with a radius of \text{5 m} that centered on the quadrotor and only use the map within this sphere for trajectory generation ( Fig. 9(b) – 9(d) ) which is much smaller than our real perception range. The unstructured environment, limited perception range as well as the high flying speed pose a challenge to the motion planning module, as it should re-generate trajectory continually and rapidly upon sudden appearing of new threats. We refer the readers to the video attachment for more detailed information.
Fig. 9. - Fully autonomous flight in an unknown cluttered environment. Only the colored map is known by the motion planning module. In this confined environment, the maximum and average speed of flight 1-3 reach up to $ \text{1.7 m/s}$ and $ \text{1.3 m/s}^2$ respectively.
Fig. 9.

Fully autonomous flight in an unknown cluttered environment. Only the colored map is known by the motion planning module. In this confined environment, the maximum and average speed of flight 1-3 reach up to \text{1.7 m/s} and \text{1.3 m/s}^2 respectively.

Show All
C. Aggressive Flight

The aggressive flight experiment is done in the environment depicted in Fig. 10 . In the experiment, the goals of the quadrotor are changed constantly and arbitrarily by a human. As soon as a new goal is set, a new trajectory is re-planned and executed immediately. The maximum velocity and acceleration are set as \text{2.5 m/s} and \text{1.5 m/s}^2 respectively. This task is challenging in several aspects. Since the flight is aggressive and the changes in the goals are abrupt, the motion planning module should generate new trajectories in considerably short time to quickly react to the changes, so that the motion of the quadrotor is continuous and smooth. Also, as the environment is confined and cluttered, it is difficult to generate smooth, safe and dynamically feasible trajectories in a very short time. This experiment validates that our method can generate aggressive motion under the premise of feasibility. It also shows that our method can quickly generate a new trajectory in complex environments even if the goal is changed suddenly during the aggressive flight. More details are also included in the video.
Fig. 10. - Aggressive flight test. The goals are changed arbitrarily and new trajectories are replanned during the aggressive flight.
Fig. 10.

Aggressive flight test. The goals are changed arbitrarily and new trajectories are replanned during the aggressive flight.

Show All
SECTION VIII.
Conclusion

In this letter, we propose a novel online motion planning method for quadrotor autonomous navigation. We decouple the online fast motion planning problem as a front-end kinodynamic path searching and a back-end nonlinear trajectory optimization. We adopt a kinodynamic path searching to find a safe, kinodynamic feasible and minimum-time initial path, which is further improved in smoothness and clearance by a gradient-based optimization. By utilizing the convex hull property of B-spline, we significantly improve the efficiency and convergent rate of the optimization compared to previous gradient-based planning methods. Finally, by representing the trajectory as a non-uniform B-spline, we adjust the time allocation according to a given expected flight aggressiveness. We validate our proposed method in various complex environments and the simulation. The competence of the method is also validated in challenging real-world tasks.

In the future, we plan to challenge our quadrotor system in extreme situations such as large-scale or dynamic environments. Furthermore, we will extend our trajectory optimization method to swarm problems.

Authors
Figures
References
Citations
Keywords
Metrics
Media
Footnotes
   Back to Results   
More Like This
Remote path planning and motion control of mobile robot within indoor maze environment

2014 IEEE International Symposium on Intelligent Control (ISIC)

Published: 2014
Robot path planning based on four Point-EGSOR iterative method

2010 IEEE Conference on Robotics, Automation and Mechatronics

Published: 2010
Show More
References
1. D. Mellinger and V. Kumar, "Minimum snap trajectory generation and control for quadrotors", Proc. IEEE Int. Conf. Robot. Autom. , pp. 2520-2525, May 2011.
Show in Context View Article Full Text: PDF (1980) Google Scholar
2. C. Richter, A. Bry and N. Roy, "Polynomial trajectory planning for aggressive quadrotor flight in dense indoor environments", Proc. Int. Symp. Robot. Res. , pp. 649-666, Dec. 2013.
Show in Context CrossRef Google Scholar
3. J. Chen, K. Su and S. Shen, "Real-time safe trajectory generation for quadrotor flight in cluttered environments", Proc. IEEE Int. Conf. Robot. Biomimetics , pp. 1678-1685, Aug. 2015.
Show in Context View Article Full Text: PDF (1658) Google Scholar
4. F. Gao and S. Shen, "Online quadrotor trajectory generation and autonomous navigation on point clouds", Proc. IEEE Int. Symp. Saf. Secur. Rescue Robot. , pp. 139-146, 2016.
Show in Context View Article Full Text: PDF (2389) Google Scholar
5. et al., "Planning dynamically feasible trajectories for quadrotors using safe flight corridors in 3-d complex environments", IEEE Robot. Autom. Lett. , vol. 2, no. 3, pp. 1688-1695, Jul. 2017.
Show in Context View Article Full Text: PDF (1559) Google Scholar
6. W. Ding, W. Gao, K. Wang and S. Shen, "Trajectory replanning for quadrotors using kinodynamic search and elastic optimization", Proc. IEEE Int. Conf. Robot. Autom. , pp. 7595-7602, 2018.
Show in Context View Article Full Text: PDF (1729) Google Scholar
7. W. Ding, W. Gao, K. Wang and S. Shen, "An efficient b-spline-based kinodynamic replanning framework for quadrotors", arXiv:1906.09785 , 2019.
Show in Context Google Scholar
8. F. Gao, W. Wu, Y. Lin and S. Shen, "Online safe trajectory generation for quadrotors using fast marching method and Bernstein basis polynomial", Proc. IEEE Int. Conf. Robot. Autom. , pp. 344-351, May 2018.
Show in Context View Article Full Text: PDF (1955) Google Scholar
9. F. Gao, W. Wu, W. Gao and S. Shen, "Flying on point clouds: Online trajectory generation and autonomous navigation for quadrotors in cluttered environments", J. Field Robot. , 2018, [online] Available: https://onlinelibrary.wiley.com/doi/abs/10.1002/rob.21842.
Show in Context Google Scholar
10. M. Zucker et al., "CHOMP: Covariant hamiltonian optimization for motion planning", Int. J. Robot. Res. , vol. 32, no. 9/10, pp. 1164-1193, 2013.
Show in Context CrossRef Google Scholar
11. M. Kalakrishnan, S. Chitta, E. Theodorou, P. Pastor and S. Schaal, "STOMP: Stochastic trajectory optimization for motion planning", Proc. IEEE Int. Conf. Robot. Autom. , pp. 4569-4574, 2011.
Show in Context View Article Full Text: PDF (3679) Google Scholar
12. H. Oleynikova, M. Burri, Z. Taylor, J. Nieto, R. Siegwart and E. Galceran, "Continuous-time trajectory optimization for online UAV replanning", Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. , pp. 5332-5339, Oct. 2016.
Show in Context View Article Full Text: PDF (2218) Google Scholar
13. F. Gao, Y. Lin and S. Shen, "Gradient-based online safe trajectory generation for quadrotor flight in complex environments", Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. , pp. 3681-3688, Sep. 2017.
Show in Context View Article Full Text: PDF (5136) Google Scholar
14. V. Usenko, L. von Stumberg, A. Pangercic and D. Cremers, "Real-time trajectory replanning for MAVs using uniform b-splines and a 3d circular buffer", Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. , pp. 215-222, 2017.
Show in Context View Article Full Text: PDF (5698) Google Scholar
15. D. Dolgov, S. Thrun, M. Montemerlo and J. Diebel, "Path planning for autonomous vehicles in unknown semi-structured environments", Int. J. Robot. Res. , vol. 29, no. 5, pp. 485-501, 2010.
Show in Context CrossRef Google Scholar
16. M. W. Mueller, M. Hehn and R. D’Andrea, "A computationally efficient motion primitive for quadrocopter trajectory generation", IEEE Trans. Robot. , vol. 31, no. 6, pp. 1294-1310, Dec. 2015.
Show in Context View Article Full Text: PDF (1006) Google Scholar
17. K. Qin, "General matrix representations for b-splines", Visual Comput. , vol. 16, no. 3, pp. 177-186, 2000.
Show in Context CrossRef Google Scholar
18. S. Quinlan and O. Khatib, "Elastic bands: Connecting path planning and control", Proc. IEEE Int. Conf. Robot. Autom. , pp. 802-807, 1993.
Show in Context View Article Full Text: PDF (515) Google Scholar
19. Z. Zhu, E. Schmerling and M. Pavone, "A convex optimization approach to smooth trajectories for motion planning with car-like robots", Proc. 54th IEEE Conf. Decis. Control , pp. 835-842, 2015.
Show in Context Google Scholar
20. J. Zhang and S. Singh, "LOAM: Lidar odometry and mapping in real-time", Proc. Robot. Sci. Syst. , pp. 109-111, Jul. 2014.
Show in Context CrossRef Google Scholar
21. P. F. Felzenszwalb and D. P. Huttenlocher, "Distance transforms of sampled functions", Theory Comput. , vol. 8, no. 1, pp. 415-428, 2012.
Show in Context CrossRef Google Scholar
22. T. Schouten and E. L. van den Broek, "Incremental distance transforms (IDT)", Proc. 20th Int. Conf. Pattern Recognit. , pp. 237-240, 2010.
Show in Context View Article Full Text: PDF (423) Google Scholar
23. S. Liu, N. Atanasov, K. Mohta and V. Kumar, "Search-based motion planning for quadrotors using linear quadratic minimum time control", Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. , pp. 2872-2879, Sep. 2017.
Show in Context View Article Full Text: PDF (3361) Google Scholar
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
