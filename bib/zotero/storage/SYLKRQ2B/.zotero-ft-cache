IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Processing math: 0%

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Journals & Magazines > IEEE Transactions on Robotics > Volume: 31 Issue: 6
A Computationally Efficient Motion Primitive for Quadrocopter Trajectory Generation
Publisher: IEEE
Cite This
PDF
  << Results   
Mark W. Mueller ; Markus Hehn ; Raffaello D'Andrea
All Authors
View Document
151
Paper
Citations
5509
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    System Dynamics and Problem Statement
    III.
    Motion Primitive Generation
    IV.
    Determining Feasibility
    V.
    Choice of Coordinate System

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
Media
More Like This

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: A method is presented for the rapid generation and feasibility verification of motion primitives for quadrocopters and similar multirotor vehicles. The motion primitives ... View more
Metadata
Abstract:
A method is presented for the rapid generation and feasibility verification of motion primitives for quadrocopters and similar multirotor vehicles. The motion primitives are defined by the quadrocopter's initial state, the desired motion duration, and any combination of components of the quadrocopter's position, velocity, and acceleration at the motion's end. Closed-form solutions for the primitives are given, which minimize a cost function related to input aggressiveness. Computationally efficient tests are presented to allow for rapid feasibility verification. Conditions are given under which the existence of feasible primitives can be guaranteed a priori . The algorithm may be incorporated in a high-level trajectory generator, which can then rapidly search over a large number of motion primitives which would achieve some given high-level goal. It is shown that a million motion primitives may be evaluated and compared per second on a standard laptop computer. The motion primitive generation algorithm is experimentally demonstrated by tasking a quadrocopter with an attached net to catch a thrown ball, evaluating thousands of different possible motions to catch the ball.
Published in: IEEE Transactions on Robotics ( Volume: 31 , Issue: 6 , Dec. 2015 )
Page(s): 1294 - 1310
Date of Publication: 16 October 2015
ISSN Information:
INSPEC Accession Number: 15647698
DOI: 10.1109/TRO.2015.2479878
Publisher: IEEE
Funding Agency:
Contents
SECTION I.
Introduction

Quadrocopters offer exceptional agility, with typically high thrust-to-weight ratios, and large potential for angular acceleration due to the outward mounting of the propellers. This allows them to perform complex and highly dynamic tasks, for example, aerial manipulation  [1] and cooperative aerial acrobatics  [2] . The ability to hover and the safety offered by small rotors storing relatively little energy  [3] make quadrocopters attractive platforms for aerial robotic tasks that involve the navigation of tight cluttered environments (see, for example,  [4] , [5] ).

A key feature required for the use of these vehicles under complex conditions is a trajectory generator. The trajectory generator is tasked with computing flight paths that achieve the task objective, while respecting the quadrocopter dynamics. The trajectory must also be collision-free, and there could be additional requirements imposed on the motion by the sensing modalities (for example, limits on the quadrocopter velocity imposed by an onboard camera). This trajectory planning problem is complicated by the underactuated and nonlinear nature of the quadrocopter dynamics, as well as potentially complex task constraints that may consist of variable manoeuvre durations, partially constrained final states, and nonconvex state constraints. In addition, dynamic environments or large disturbances may require the recomputation or adaptation of trajectories in real time, thus limiting the time available for computation.

Active research in this field has yielded numerous trajectory generation algorithms, focusing on different tradeoffs between computational complexity, the agility of the possible motions, the level of detail in which manoeuvre constraints can be specified, and the ability to handle complex environments.

Broadly speaking, a first group of algorithms handles the trajectory generation problem by decoupling geometric and temporal planning: In a first step, a geometric trajectory without time information is constructed, for example, using lines  [6] , polynomials  [7] , or splines  [8] . In a second step, the geometric trajectory is parameterized in time in order to guarantee feasibility with respect to the dynamics of quadrocopters.

A second group of algorithms exploits the differential flatness of the quadrocopter dynamics in order to derive constraints on the trajectory and then solves an optimization problem over a class of trajectories, for example, minimum snap  [9] , minimum time  [10] , shortest path under uncertain conditions  [11] , or combinations of position derivatives  [5] . In  [12] , a search over parameters is proposed for quadrocopter motion planning, including trajectories where the position is described by polynomials in time. A dynamic inversion-based controller is proposed in  [13] to directly control a quadrocopter's position and orientation, and this controller is exploited in  [14] . For a broader discussion of differential flatness, see, e.g.,  [15] , [16] , and, e.g.,  [17] , [18] for generic trajectory generation methods for differentially flat systems.

A common property of these methods is that they impose a rigid structure on the end state, for example, fixing the final state and allowing a fixed or varying manoeuvre duration, or by specifying the goal state with convex inequalities. Many quadrocopter applications do not, however, impose such structured constraints; instead, the set of states that achieve the application might be nonconvex, or even disjoint. Furthermore, the conditions on the final state necessary to achieve a task may be time dependent (for example, when the task objective involves interaction with a dynamic environment). Methods relying on convex optimization, furthermore, require the construction of (conservative) convex approximations of constraints, potentially significantly reducing the space of feasible trajectories.

This paper attempts a different approach to multicopter trajectory generation, where the constraints are not explicitly encoded at the planning stage. Instead, the focus is on developing a computationally light-weight and easy-to-implement motion primitive, which can be easily tested for constraints violation, and allows significant flexibility in defining initial and final conditions for the quadrocopter. The low computational cost may then be exploited by searching over a multitude of primitives to achieve some goal. Each primitive is characterized by the quadrocopter's initial state, a duration, and a set of constraints on the quadrocopter's position, velocity, and/or acceleration at the end of the primitive.

The approach is illustrated in  Fig. 1 . The high-level trajectory generator is tasked with evaluating motion primitives, and specifically with defining the constraints on the motion primitives to solve the given high-level goal. The high-level trajectory generator must also encode the behavior for dealing with infeasible motion primitives. As an example, the high-level trajectory generator may generate a large number of motion primitives, with varying durations and end variables, to increase the probability of finding a feasible motion primitive. These motion primitives are generated in a two-step approach: First, a state-to-state planner is used to generate a motion while disregarding feasibility constraints. In the second step, this trajectory is checked for feasibility. The first step is solved for in closed form, while a computationally efficient recursive test is designed for the feasibility tests of the second step.
Fig. 1.

Presented algorithm aims to provide computationally inexpensive motion primitives, which may then be incorporated by a high-level trajectory generator. The focus of this paper is on the right-hand-side (unshaded) part of this diagram.

Show All

The state-to-state motion primitives generated in the first step are closely related to other algorithms exploiting the differential flatness of the quadrocopter dynamics to plan position trajectories that are polynomials in time (see, e.g.,  [5] , [9] , [12] ). In this paper, an optimal control problem is solved, whose objective function is related to minimizing an upper bound of the product of the quadrocopter inputs, to yield position trajectories characterized by fifth-order polynomials in time. A key property that is then exploited is that the specific polynomials allow for the rapid verification of constraints on the system's inputs, and constraints on the position, velocity, and/or acceleration.

The benefits of this approach are twofold: First, a unified framework is given to generate trajectories for arbitrary manoeuvre duration and end state constraints, resulting in an algorithm which can be easily implemented across a large range of trajectory generation problems. Second, the computational cost of the approach is shown to be very low, such that on the order of one million motion primitives per second can be generated and tested for feasibility on a laptop computer with an unoptimized implementation.

The algorithm, therefore, lends itself to problems with significant freedom in the end state. In this situation, the designer can apply the presented approach to rapidly search over the space of end states and trajectory durations which would achieve the high level goal. This ability to quickly evaluate a vast number of candidate trajectories is achieved at the expense of not directly considering the feasibility constraints in the trajectory generation phase, but rather verifying feasibility a posteriori .

For certain classes of trajectories, explicit guarantees can be given on the existence of feasible motion primitives as a function of the problem data. Specifically, for rest-to-rest manoeuvres, a bound on the motion primitive duration is explicitly calculated as a function of the distance to be translated and the system's input constraints. Furthermore, bounds on the velocity during the rest-to-rest manoeuvre are explicitly calculated, and it is shown that the position feasibility of rest-to-rest trajectories can be directly asserted if the allowable flight space is convex.

An experimental demonstration of the algorithm is presented where the motion primitive generator is encapsulated in a high-level trajectory generation algorithm. The goal is for a quadrocopter with an attached net to catch a thrown ball. The catching trajectories must be generated in real time, because the ball's flight is not repeatable. Furthermore, for a given ball trajectory, the ball can be caught in many different ways (quadrocopter positions and orientations). The computational efficiency of the presented approach is exploited to do an exhaustive search over these possibilities in real time.

An implementation of the algorithm presented in this paper in both C++ and Python is made available in  [19] .

This paper follows on previous work presented at conferences  [20] , [21] . A related cost function, the same dynamics model, and a related decoupled planning approach were presented in  [20] . Preliminary results of the fundamental state-to-state motion primitive generation algorithm were presented in  [21] . This paper extends these previous results by presenting the following:

    conditions under which primitives are guaranteed to be feasible;

    an investigation into the completeness of the approach, by comparing rest-to-rest trajectories to the time optimal rest-to-rest trajectories;

    a challenging novel demonstration to show the capabilities of the approach.

The remainder of this paper is organized as follows: The quadrocopter model and problem statement are given in Section  II , with the motion primitive generation scheme presented in Section  III . A computationally efficient algorithm to determine feasibility of generated trajectories is presented in Section  IV . The choice of coordinate system is discussed in Section  V . In Section  VI , classes of problems are discussed where the existence of feasible trajectories can be guaranteed. The performance of the presented approach is compared with the system's physical limits in Section VII . The computational cost of the algorithm is measured in Section  VIII , and the demonstration of catching a ball is presented in Section  IX . A conclusion is given in Section  X .
SECTION II.
System Dynamics and Problem Statement

This section describes the dynamic model used to describe the quadrocopter's motion, including constraints on the quadrocopter inputs. A formal statement of the problem to be solved in this paper is then given, followed by an overview of the solution approach.
A. Quadrocopter Dynamic Model

The quadrocopter is modeled as a rigid body with six degrees of freedom: linear translation along the orthogonal inertial axes,  {\bm x}=\left(x_1,x_2,x_3 \right) , and three degrees of freedom describing the rotation of the frame attached to the body with respect to the inertial frame, defined by the proper orthogonal matrix  \mathbf {R} . Note that the notation  {\bm x}=(x_1, x_2, x_3) is used throughout this paper to compactly express the elements of a column vector.

The control inputs to the system are taken as the scalar total thrust produced  f , for simplicity normalized by the vehicle mass and thus having units of acceleration, and the body rates expressed in the body-fixed frame as  {\bm \omega }=(\omega _1, \omega _2, \omega _3) , as are illustrated in Fig. 2 . It is assumed that high-bandwidth controllers are used to track these angular rate commands. Then, by separation of timescales, because of the vehicles' low rotational inertia and their ability to produce large torques, it is assumed that the angular rate commands are tracked perfectly and that angular dynamics may be neglected. The quadrocopter's state is thus 9-D and consists of the position, velocity, and orientation.
Fig. 2.

Dynamic model of a quadrocopter, acted upon by gravity  {\bm g} , a thrust force  f pointing along the (body-fixed) axis  {\bm e}_3 , and rotating with angular rate  {\bm \omega }=\left(\omega _1,\omega _2,\omega _3 \right) , with its position in inertial space given as  \left(x_1,x_2,x_3 \right) .

Show All

Although more complex quadrocopter models exist that incorporate, for example, aerodynamic drag  [22] or propeller speeds  [23] , the preceding model captures the most relevant dynamics and yields tractable solutions to the trajectory generation problem. Furthermore, in many applications (for example, model predictive control), such a simple model is sufficient, with continuous replanning compensating for modeling inaccuracies.

The differential equations governing the flight of the quadrocopter are now taken as those of a rigid body  [24] \begin{align} \ddot{{\bm x}} &= \mathbf {R}\; {\bm e}_3f+ {\bm g} \\ \dot{\mathbf {R}}&= \mathbf {R}\; [[ {{\bm \omega } \times }]] \end{align} View Source \begin{align} \ddot{{\bm x}} &= \mathbf {R}\; {\bm e}_3f+ {\bm g} \\ \dot{\mathbf {R}}&= \mathbf {R}\; [[ {{\bm \omega } \times }]] \end{align} with  {\bm g} being the acceleration due to gravity as expressed in the inertial coordinate frame, and  {\bm e}_3=\left(0,0,1 \right) a constant vector in the body-fixed frame, as illustrated in Fig. 2 . Finally,  [[ {{\bm \omega } \times }]] is the skew-symmetric matrix form of the vector cross product such that \begin{align} [[ {{\bm \omega } \times }]] = {\left[\begin{array}{lcc}0 & -\omega _3 & \omega _2 \\ \omega _3 & 0 & -\omega _1\\ -\omega _2 & \omega _1 &0 \end{array}\right]}. \end{align} View Source \begin{align} [[ {{\bm \omega } \times }]] = {\left[\begin{array}{lcc}0 & -\omega _3 & \omega _2 \\ \omega _3 & 0 & -\omega _1\\ -\omega _2 & \omega _1 &0 \end{array}\right]}. \end{align}

It should be noted that the preceding model may also be applied to other multirotor vehicles, such as hexa- and octocopters. This is because the high-bandwidth angular rate controller that maps angular velocity errors to motor forces effectively hides the number and locations of the propellers.
1) Feasible inputs

The achievable thrust  f produced by the vehicle lies in the range \begin{equation} 0 \le f_{\min } \le f \le f_{\max } \end{equation} View Source \begin{equation} 0 \le f_{\min } \le f \le f_{\max } \end{equation} where  f_{\min } is nonnegative because of the fixed sense of rotation of the fixed-pitch propellers. The magnitude of the angular velocity command is taken to be constrained to lie within a ball: \begin{align} \left\Vert {\bm \omega } \right\Vert \le \omega _{\max } \end{align} View Source \begin{align} \left\Vert {\bm \omega } \right\Vert \le \omega _{\max } \end{align} with \left\Vert \cdot \right\Vert being the Euclidean norm. This limit could be due, for example, to saturation limits of the rate gyroscopes, or motion limits of cameras mounted on the vehicle. Alternatively, a designer may use this value as a tuning factor to encode the dynamic regime where the low-order dynamics of  (1) and (2) effectively describe the true quadrocopter. The Euclidean norm is chosen for computational convenience, specifically invariance under rotation.
B. Problem Statement

Define  \sigma (t) to be translational variables of the quadrocopter, consisting of its position, velocity, and acceleration, such that \begin{align} \sigma (t) = \left({\bm x}(t), \dot{{\bm x}}(t), \ddot{{\bm x}}(t) \right) \in \mathbb {R}^9. \end{align} View Source \begin{align} \sigma (t) = \left({\bm x}(t), \dot{{\bm x}}(t), \ddot{{\bm x}}(t) \right) \in \mathbb {R}^9. \end{align}

Let T be the goal duration of the motion, and let \hat{\sigma }_i be components of desired translational variables at the end of the motion, for some {i \in \mathcal {I} \subseteq \left\lbrace 1,2, \ldots, 9 \right\rbrace } . Let the trajectory goal be achieved if \begin{align} \sigma _i(T) = \hat{\sigma }_i\quad \ \forall i \in \mathcal {I}. \end{align} View Source \begin{align} \sigma _i(T) = \hat{\sigma }_i\quad \ \forall i \in \mathcal {I}. \end{align}

Furthermore, the quadrocopter is subject to  N_c translational constraints of the form \begin{align} a_j^T \sigma (t) \le b_j \text{ for } t\in \left[ 0,T \right],\quad \ \; j = 1, 2, \ldots, N_c. \end{align} View Source \begin{align} a_j^T \sigma (t) \le b_j \text{ for } t\in \left[ 0,T \right],\quad \ \; j = 1, 2, \ldots, N_c. \end{align} An interpretation of these translational constraints is given at the end of this section.

The problem addressed in this paper is to find quadrocopter inputs f(t) ,  {\bm \omega }(t) over  [0,T] , for a quadrocopter starting at some initial state consisting of position, velocity, and orientation, at time  {t=0} to an end state at time  T satisfying  (7) , while satisfying throughout the trajectory:

    the vehicle dynamics  (1) , (2) ;

    the input constraints  (4) , (5) ;

    the  N_c affine translational constraints  (8) .

Discussion

It should be noted that the nine quadrocopter state variables as described in Section II-A (three each for position, velocity, and orientation) are not the nine translational variables. Only eight components of the state are encoded in the translational variables, consisting of the quadrocopter's position, its velocity, and two components of the orientation (which are encoded through the acceleration). These two orientation components are those that determine the direction of the quadrocopter's thrust vector—given an acceleration value, the quadrocopter's thrust direction  \mathbf {R}{\bm e}_3 can be recovered through  (1) . These are the same components encoded by the Euler roll and pitch angles. The translational variables do not encode the quadrocopter's rotation about the thrust axis (the Euler yaw angle).

These variables are chosen because they are computationally convenient, while still being useful to encode many realistic problems. Two example problems are given as follows:

1) To-rest manoeuvre: Let the goal be to arrive at some point in space, at rest, at time  T . Then, all nine translational variables will be specified in  (7) , with specifically the components corresponding to velocity and acceleration set to zero. Similarly, if the goal is simply to arrive at a point in space, but the final velocity and acceleration do not matter, only the first three components of  \hat{\sigma } are specified.

2) Landing on a moving platform: To land the quadrocopter on a moving, possibly slanted platform, the goal end position and velocity are set equal to those of the platform at time  T . The end acceleration is specified to be such that the quadrocopter's thrust vector  {\bm e}_3 is parallel to the normal vector of the landing platform. Then, the quadrocopter will arrive with zero relative speed at the platform and touch down flatly with respect to the platform.

The affine translational constraints of  (8) are also chosen for computational convenience. They allow to encode, for example, that the position may not intersect a plane (such as the ground, or a wall), or specify a box constraint on the vehicle velocity. Constraints on the acceleration, in conjunction with  (4) , can be interpreted as limiting the tilt of the quadrocopter, by  (1) .
SECTION III.
Motion Primitive Generation

Given an end time  T and goal translational variables  \hat{\sigma }_i , the dynamic model of Section II-A is used to generate motion primitives guiding the quadrocopter from some initial state to a state achieving the goal translational variables. The input constraints, and the affine state constraints, are ignored at this stage, and the motion primitives are generated in the quadrocopter's jerk. Each of the three spatial axes is solved for independently. The generated motion primitive minimizes a cost value for each axis independently of the other axes, but the total cost is shown to be representative of the aggressiveness of the true system inputs. Constraints on the input and state are considered in Sections  IV and  VI .
A. Formulating the Dynamics in Jerk

We follow  [10] in planning the motion of the quadrocopter in terms of the jerk along each of the axes, allowing the system to be considered as a triple integrator in each axis. By ignoring the input constraints, the axes can be decoupled, and motions generated for each axis separately. These decoupled axes are then recombined in later sections when considering feasibility. This section will describe how to recover the thrust and body rates inputs from such a thrice differentiable trajectory.

Given a thrice differentiable motion  {\bm x}(t) , the jerk is written as  {\bm j}= \dddot{{\bm x}} = \left(\dddot{x}_1,\dddot{x}_2,\dddot{x}_3 \right) . The input thrust  f is computed by applying the Euclidean norm to  (1) : \begin{equation} f= \left\Vert \ddot{{\bm x}} - {\bm g} \right\Vert. \end{equation} View Source \begin{equation} f= \left\Vert \ddot{{\bm x}} - {\bm g} \right\Vert. \end{equation}

Taking the first derivative of  (1) and  (9) yields \begin{align} {\bm j} &= \mathbf {R}[[ {{\bm \omega } \times }]] {\bm e}_3 f+ \mathbf {R}{\bm e}_3 \dot{f} \\ \dot{f} &= {\bm e}_3^T \mathbf {R}^{-1} {\bm j}. \end{align} View Source \begin{align} {\bm j} &= \mathbf {R}[[ {{\bm \omega } \times }]] {\bm e}_3 f+ \mathbf {R}{\bm e}_3 \dot{f} \\ \dot{f} &= {\bm e}_3^T \mathbf {R}^{-1} {\bm j}. \end{align}

After substitution and evaluating the product  [[ {{\bm \omega } \times }]] {\bm e}_3 , it can be seen that the jerk  {\bm j} and thrust  f fix two components of the body rates: \begin{align} {\left[\begin{array}{c}\omega _2\\ -\omega _1\\ 0 \end{array}\right]} = \frac{1}{f} {\left[\begin{array}{lcc}1&0&0\\ 0&1&0\\ 0&0&0 \end{array}\right]} \mathbf {R}^{-1} {\bm j}. \end{align} View Source \begin{align} {\left[\begin{array}{c}\omega _2\\ -\omega _1\\ 0 \end{array}\right]} = \frac{1}{f} {\left[\begin{array}{lcc}1&0&0\\ 0&1&0\\ 0&0&0 \end{array}\right]} \mathbf {R}^{-1} {\bm j}. \end{align} Note that  \omega _3 does not affect the linear motion and is, therefore, not specified. Throughout the rest of the paper, it will be taken as  \omega _3=0 .
B. Cost Function

The goal of the motion primitive generator is to compute a thrice differentiable trajectory which guides the quadrocopter from an initial state to a (possibly only partially defined) final state in a final time  T , while minimizing the cost function \begin{equation} J_\Sigma = \frac{1}{T} \int _{0}^{T} {\left\Vert {\bm j}(t) \right\Vert ^2} \, {dt}. \end{equation} View Source \begin{equation} J_\Sigma = \frac{1}{T} \int _{0}^{T} {\left\Vert {\bm j}(t) \right\Vert ^2} \, {dt}. \end{equation}

This cost function has an interpretation as an upper bound on the average of a product of the inputs to the (nonlinear, coupled) quadrocopter system: rewriting  (12) and taking  {\omega _3=0} gives \begin{align} f^2\left\Vert {\bm \omega } \right\Vert ^2 &=\left\Vert f {\left[\begin{array}{c}\omega _2\\ -\omega _1\\ 0 \end{array}\right]} \right\Vert ^2 = \left\Vert {\left[\begin{array}{lcc}1&0&0\\ 0&1&0\\ 0&0&0 \end{array}\right]} \mathbf {R}^{-1} {\bm j} \right\Vert ^2\nonumber \\ &\le \left\Vert {\bm j} \right\Vert ^2 \end{align} View Source \begin{align} f^2\left\Vert {\bm \omega } \right\Vert ^2 &=\left\Vert f {\left[\begin{array}{c}\omega _2\\ -\omega _1\\ 0 \end{array}\right]} \right\Vert ^2 = \left\Vert {\left[\begin{array}{lcc}1&0&0\\ 0&1&0\\ 0&0&0 \end{array}\right]} \mathbf {R}^{-1} {\bm j} \right\Vert ^2\nonumber \\ &\le \left\Vert {\bm j} \right\Vert ^2 \end{align} so that \begin{equation} \frac{1}{T} \int _{0}^{T} {f(t)^2 \left\Vert {\bm \omega }(t) \right\Vert ^2} \, {dt} \le J_{\Sigma}. \end{equation} View Source \begin{equation} \frac{1}{T} \int _{0}^{T} {f(t)^2 \left\Vert {\bm \omega }(t) \right\Vert ^2} \, {dt} \le J_{\Sigma}. \end{equation} If multiple motion primitives exist that all achieve some high-level goal, this cost function may thus be used to rank the input aggressiveness of the primitives. The cost function is also computationally convenient, and closed-form solutions for the optimal trajectories are given below.
C. Axes Decoupling and Trajectory Generation

The nonlinear trajectory generation problem is simplified by decoupling the dynamics into three orthogonal inertial axes and treating each axis as a triple integrator with jerk used as control input. The true control inputs  f and  {\bm \omega } are then recovered from the jerk inputs using  (9) and  (12) . The final state is determined from the goal end state components  \hat{\sigma }_i relevant to each axis, and the duration  T is given.

The cost function of the 3-D motion,  J_\Sigma , is decoupled into a per-axis cost  J_k by expanding the integrand in  (13) : \begin{align} J_\Sigma &= \sum \limits _{k=1}^{3} {J_k},\;\; \text{ where } J_k = \frac{1}{T} \int _{0}^{T} { j_k(t)^2 } \, {dt}. \end{align} View Source \begin{align} J_\Sigma &= \sum \limits _{k=1}^{3} {J_k},\;\; \text{ where } J_k = \frac{1}{T} \int _{0}^{T} { j_k(t)^2 } \, {dt}. \end{align}

For each axis  k , the state  s_k = \left(p_k,v_k,a_k \right) is introduced, consisting of the scalars position, velocity, and acceleration. The jerk  j_k is taken as input, such that \begin{align} \dot{s}_k &= f_s(s_k,j_k) = \left(v_k,a_k,j_k \right). \end{align} View Source \begin{align} \dot{s}_k &= f_s(s_k,j_k) = \left(v_k,a_k,j_k \right). \end{align}

Note again that the input constraints of Section  II-A are not considered here, during the planning stage, but are deferred to Sections  IV and  VI .

For the sake of readability, the axis subscript  k will be discarded for the remainder of this section where only a single axis is considered. The time argument  t will similarly be neglected where it is considered unambiguous.

The optimal state trajectory can be solved straightforwardly with Pontryagin's minimum principle (see, e.g.,  [25] ) by introducing the costate  \lambda = \left(\lambda _1,\lambda _2,\lambda _3 \right) and defining the Hamiltonian function  H(s,j,\lambda) : \begin{align} H(s,j,\lambda) &= \frac{1}{T} j^2 + \lambda ^T f_s(s,j) \nonumber \\ &= \frac{1}{T} j^2 + \lambda _1 v + \lambda _2 a + \lambda _3 j\\ \dot{\lambda } &= -\nabla _sH(s^*, j^*, \lambda) = \left(0,-\lambda _1,-\lambda _2 \right) \end{align} View Source \begin{align} H(s,j,\lambda) &= \frac{1}{T} j^2 + \lambda ^T f_s(s,j) \nonumber \\ &= \frac{1}{T} j^2 + \lambda _1 v + \lambda _2 a + \lambda _3 j\\ \dot{\lambda } &= -\nabla _sH(s^*, j^*, \lambda) = \left(0,-\lambda _1,-\lambda _2 \right) \end{align} where  j_k^* and  s_k^* represent the optimal input and state trajectories, respectively.

The costate differential (19) is easily solved, and for later convenience, the solution is written in the constants  \alpha ,  \beta , and  \gamma , such that \begin{equation} \lambda (t) = \frac{1}{T}{\left[\begin{array}{c}-2\alpha \\ 2\alpha t+2\beta \\ -\alpha t^2 -2\beta t -2\gamma \end{array}\right]}. \end{equation} View Source \begin{equation} \lambda (t) = \frac{1}{T}{\left[\begin{array}{c}-2\alpha \\ 2\alpha t+2\beta \\ -\alpha t^2 -2\beta t -2\gamma \end{array}\right]}. \end{equation}

The optimal input trajectory is solved for as \begin{align} j^*(t) &= \arg \underset{j(t)}{\min }\, H(s^*(t), j(t), \lambda (t))\nonumber \\ &= \frac{1}{2}\alpha t^2 + \beta t + \gamma \end{align} View Source \begin{align} j^*(t) &= \arg \underset{j(t)}{\min }\, H(s^*(t), j(t), \lambda (t))\nonumber \\ &= \frac{1}{2}\alpha t^2 + \beta t + \gamma \end{align} from which the optimal state trajectory follows from integration of  (17) : \begin{align} s^*(t) = {\left[\begin{array}{c}\frac{\alpha }{120}t^5 + \frac{\beta }{24} t^4 + \frac{\gamma }{6} t^3 + \frac{a_0}{2} t^2 + v_0 t + p_0\\ \frac{\alpha }{24}t^4 + \frac{\beta }{6} t^3 + \frac{\gamma }{2} t^2 + a_0 t + v_0\\ \frac{\alpha }{6}t^3 + \frac{\beta }{2} t^2 + \gamma t + a_0 \end{array}\right]} \end{align} View Source \begin{align} s^*(t) = {\left[\begin{array}{c}\frac{\alpha }{120}t^5 + \frac{\beta }{24} t^4 + \frac{\gamma }{6} t^3 + \frac{a_0}{2} t^2 + v_0 t + p_0\\ \frac{\alpha }{24}t^4 + \frac{\beta }{6} t^3 + \frac{\gamma }{2} t^2 + a_0 t + v_0\\ \frac{\alpha }{6}t^3 + \frac{\beta }{2} t^2 + \gamma t + a_0 \end{array}\right]} \end{align} with the integration constants set to satisfy the initial condition  s(0)=\left(p_0,v_0,a_0 \right) .

The remaining unknowns  \alpha , \beta , and  \gamma are solved for as a function of the desired end translational variable components  \hat{\sigma }_i as given in  (7) .
1) Fully Defined End Translational State

Let the desired end position, velocity, and acceleration along this axis be  s(T)=\left(p_f,v_f,a_f \right) , given by the components  \hat{\sigma }_i . Then, the unknowns  \alpha ,  \beta , and  \gamma are isolated by reordering  (22) : \begin{equation} {\left[\begin{array}{lcc}\frac{1}{120} T^{5} & \frac{1}{24} T^{4} & \frac{1}{6 } T^{3}\\ \frac{1}{24} T^{4} & \frac{1}{6} T^{3} & \frac{1}{2} T^{2}\\ \frac{1}{ 6} T^{3} & \frac{1}{2} T^{2} & T \end{array}\right]} {\left[\begin{array}{c}\alpha \\ \beta \\ \gamma \end{array}\right]} = {\left[\begin{array}{c}\Delta p\\ \Delta v\\ \Delta a \end{array}\right]} \end{equation} View Source \begin{equation} {\left[\begin{array}{lcc}\frac{1}{120} T^{5} & \frac{1}{24} T^{4} & \frac{1}{6 } T^{3}\\ \frac{1}{24} T^{4} & \frac{1}{6} T^{3} & \frac{1}{2} T^{2}\\ \frac{1}{ 6} T^{3} & \frac{1}{2} T^{2} & T \end{array}\right]} {\left[\begin{array}{c}\alpha \\ \beta \\ \gamma \end{array}\right]} = {\left[\begin{array}{c}\Delta p\\ \Delta v\\ \Delta a \end{array}\right]} \end{equation} where \begin{equation} {\left[\begin{array}{c}\Delta p\\ \Delta v\\ \Delta a \end{array}\right]} = {\left[\begin{array}{c}p_f-p_0-v_0 T - \frac{1}{2}a_0 T^2\\ v_f-v_0-a_0T\\ a_f-a_0 \end{array}\right]}. \end{equation} View Source \begin{equation} {\left[\begin{array}{c}\Delta p\\ \Delta v\\ \Delta a \end{array}\right]} = {\left[\begin{array}{c}p_f-p_0-v_0 T - \frac{1}{2}a_0 T^2\\ v_f-v_0-a_0T\\ a_f-a_0 \end{array}\right]}. \end{equation}

Solving for the unknown coefficients yields \begin{equation} {\left[\begin{array}{c}\alpha \\ \beta \\ \gamma \end{array}\right]} = \frac{1}{T^5}{\left[\begin{array}{lcc}720 & - 360 T & 60 T^{2}\\ - 360 T & 168 T^{2} & - 24 T^{3}\\ 60 T^{2} & - 24 T^{3} & 3 T^{4} \end{array}\right]} {\left[\begin{array}{c}\Delta p\\ \Delta v\\ \Delta a \end{array}\right]}. \end{equation} View Source \begin{equation} {\left[\begin{array}{c}\alpha \\ \beta \\ \gamma \end{array}\right]} = \frac{1}{T^5}{\left[\begin{array}{lcc}720 & - 360 T & 60 T^{2}\\ - 360 T & 168 T^{2} & - 24 T^{3}\\ 60 T^{2} & - 24 T^{3} & 3 T^{4} \end{array}\right]} {\left[\begin{array}{c}\Delta p\\ \Delta v\\ \Delta a \end{array}\right]}. \end{equation} Thus, generating a motion primitive only requires evaluating the above matrix multiplication for each axis, after which the state along the primitive is found by evaluating  (22) .
2) Partially Defined End Translational State

Components of the final state may be left free by  \hat{\sigma } . These states may correspondingly be specified as free when solving the optimal input trajectory, by noting that the corresponding costates must equal zero at the end time  [25] . The closed-form solutions to the six different combinations of partially defined end states are given in Appendix A —in each case, solving the coefficients reduces to evaluating a matrix product.
3) Motion Primitive Cost

The per-axis cost value of  (16) can be explicitly calculated as follows. This is useful if multiple different candidate motion primitives are evaluated to achieve some higher level goal. In this case, the primitive with the lowest cost can be taken as the “least aggressive” in the sense of  (14) \begin{equation} \begin{split} J = &\gamma ^2 + \beta \gamma T + \frac{1}{3}\beta ^2 T^2 + \frac{1}{3} \alpha \gamma T^2 \\ &+ \frac{1}{4} \alpha \beta T^3 + \frac{1}{20} \alpha ^2 T^4. \end{split} \end{equation} View Source \begin{equation} \begin{split} J = &\gamma ^2 + \beta \gamma T + \frac{1}{3}\beta ^2 T^2 + \frac{1}{3} \alpha \gamma T^2 \\ &+ \frac{1}{4} \alpha \beta T^3 + \frac{1}{20} \alpha ^2 T^4. \end{split} \end{equation}

Note that this cost holds for all combinations of end translational variables.
SECTION IV.
Determining Feasibility

The motion primitives generated in the previous section did not take the input feasibility constraints of Section II-A1 into account—this section revisits these and provides computationally inexpensive tests for the feasibility/infeasibility of a given motion primitive with respect to the input constraints of  (4) and  (5) . This section also provides a computationally inexpensive method to calculate the extrema of an affine combination of the translational variables along the primitive, allowing to test constraints of the form  (8) . In Section VI , conditions are given under which feasible motion primitives are guaranteed to exist.
A. Input Feasibility

Given some time interval  \mathcal {T} = [\tau _1,\tau _2] \subseteq [0,T] and three triple integrator trajectories of the form (22) with their corresponding jerk inputs  j_k(t) , the goal is to determine whether corresponding inputs to the true system  f and  {\bm \omega } , as used in (1) and (2) , satisfy feasibility requirements of Section II-A1 . The choice of  \mathcal {T} is revisited when describing the recursive implementation, below. The tests are designed with a focus on computational speed and provide sufficient, but not necessary, conditions for both feasibility and infeasibility—meaning that some motion primitives will be indeterminable with respect to these tests.
1) Thrust

The interval  \mathcal {T} is feasible with respect to the thrust limits  (4) if and only if \begin{align} \underset{t\in \mathcal {T}}{\max } \; f(t)^2 &\le f_{\max }^2 \text{ and} \\ \underset{t\in \mathcal {T}}{\min } \; f(t)^2 &\ge f_{\min }^2. \end{align} View Source \begin{align} \underset{t\in \mathcal {T}}{\max } \; f(t)^2 &\le f_{\max }^2 \text{ and} \\ \underset{t\in \mathcal {T}}{\min } \; f(t)^2 &\ge f_{\min }^2. \end{align}

Squaring (9) yields \begin{equation} f^2 = \left\Vert \ddot{{\bm x}}-{\bm g} \right\Vert ^2 = \sum \limits _{k=1}^{3} {\left(\ddot{x}_k-g_k \right)^2} \end{equation} View Source \begin{equation} f^2 = \left\Vert \ddot{{\bm x}}-{\bm g} \right\Vert ^2 = \sum \limits _{k=1}^{3} {\left(\ddot{x}_k-g_k \right)^2} \end{equation} where  g_k is the component of gravity in axis  k . Combining  (27) – (29) , the thrust constraints can be interpreted as spherical constraints on the acceleration.

By taking the per-axis extrema of (29) , the below bounds follow: \begin{align} \underset{t\in \mathcal {T}}{\max } \; (\ddot{x}_k(t) -g_k)^2 &\le \underset{t\in \mathcal {T}}{\max } \; f(t)^2 \text{ for }k\in \lbrace 1,2,3\rbrace \\ \underset{t\in \mathcal {T}}{\max } \; f(t)^2 &\le \sum \limits _{k=1}^{3} {\underset{t\in \mathcal {T}}{\max } \; (\ddot{x}_k(t) -g_k)^2}\\ \underset{t\in \mathcal {T}}{\min } \; f(t)^2 &\ge \sum \limits _{k=1}^{3} {\underset{t\in \mathcal {T}}{\min } \; (\ddot{x}_k(t) -g_k)^2}. \end{align} View Source \begin{align} \underset{t\in \mathcal {T}}{\max } \; (\ddot{x}_k(t) -g_k)^2 &\le \underset{t\in \mathcal {T}}{\max } \; f(t)^2 \text{ for }k\in \lbrace 1,2,3\rbrace \\ \underset{t\in \mathcal {T}}{\max } \; f(t)^2 &\le \sum \limits _{k=1}^{3} {\underset{t\in \mathcal {T}}{\max } \; (\ddot{x}_k(t) -g_k)^2}\\ \underset{t\in \mathcal {T}}{\min } \; f(t)^2 &\ge \sum \limits _{k=1}^{3} {\underset{t\in \mathcal {T}}{\min } \; (\ddot{x}_k(t) -g_k)^2}. \end{align} These bounds will be used as follows: If the left-hand side of  (30) is greater than  f_{\max } , the interval is definitely infeasible, while if the right-hand side of  (31) is less than  f_{\max } and the right-hand side of  (32) is greater than  f_{\min } , the interval is definitely feasible with respect to the thrust constraints.

Note that the value  \ddot{x}_k-g_k as given by  (22) is a third-order polynomial in time, meaning that its maximum and minimum (denoted  \bar{\ddot{x}}_k and  \underline{\ddot{x}}_k , respectively) can be found in closed form by solving for the roots of a quadratic and evaluating  \ddot{x}_k-g_k at at most two points strictly inside  \mathcal {T} , and at the boundaries of  \mathcal {T} . The extrema of  \left(\ddot{x}_k-g_k \right)^2 then follow as \begin{align} \underset{t\in \mathcal {T}}{\max } \; (\ddot{x}_k(t) -g_k)^2 &= \max \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace \\ \underset{t\in \mathcal {T}}{\min } \; (\ddot{x}_k(t) -g_k)^2 &= \left\lbrace \begin{array}{ll}\min \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace, &\text{if } \bar{\ddot{x}}_k\cdot \underline{\ddot{x}}_k \ge 0 \\ 0, &\text{otherwise} \end{array}\right. \end{align} View Source \begin{align} \underset{t\in \mathcal {T}}{\max } \; (\ddot{x}_k(t) -g_k)^2 &= \max \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace \\ \underset{t\in \mathcal {T}}{\min } \; (\ddot{x}_k(t) -g_k)^2 &= \left\lbrace \begin{array}{ll}\min \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace, &\text{if } \bar{\ddot{x}}_k\cdot \underline{\ddot{x}}_k \ge 0 \\ 0, &\text{otherwise} \end{array}\right. \end{align} where  \bar{\ddot{x}}_k\cdot \underline{\ddot{x}}_k < 0 implies a sign change (and thus a zero crossing) of  \ddot{x}_k(t) -g_k in  \mathcal {T} .

Thus, from (30) , a sufficient criterion for input infeasibility of the section is if \begin{equation} \max \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace > f_{\max }. \end{equation} View Source \begin{equation} \max \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace > f_{\max }. \end{equation}

Similarly, from (31) and (32) , a sufficient criterion for feasibility is if both \begin{align} \sum \limits _{k=1}^{3} {\max \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace } & \le f_{\max }\; \text{ and} \\ \sum \limits _{k=1}^{3} {\min \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace } & \ge f_{\min } \end{align} View Source \begin{align} \sum \limits _{k=1}^{3} {\max \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace } & \le f_{\max }\; \text{ and} \\ \sum \limits _{k=1}^{3} {\min \;\lbrace \bar{\ddot{x}}_k^2,\underline{\ddot{x}}_k^2\rbrace } & \ge f_{\min } \end{align} hold. If neither criterion (35) nor (36) , (37) applies, the section is marked as indeterminate with respect to thrust feasibility.
2) Body Rates

The magnitude of the body rates can be bounded as a function of the jerk and thrust as follows: \begin{equation} \omega _1^2 + \omega _2^2 \le \frac{1}{f^2}\left\Vert j \right\Vert ^2. \end{equation} View Source \begin{equation} \omega _1^2 + \omega _2^2 \le \frac{1}{f^2}\left\Vert j \right\Vert ^2. \end{equation} This follows from squaring  (12) , and using the following induced norm: \begin{equation} \left\Vert {\left[\begin{array}{lcc}1&0&0\\ 0&1&0\\ 0&0&0 \end{array}\right]} \right\Vert \le 1. \end{equation} View Source \begin{equation} \left\Vert {\left[\begin{array}{lcc}1&0&0\\ 0&1&0\\ 0&0&0 \end{array}\right]} \right\Vert \le 1. \end{equation}

The right-hand side of  (38) can be bounded from above by  \bar{\omega }^2 , defined as follows, which then also provides an upper bound for the sum  \omega _1^2+\omega _2^2 . The terms in the denominator are evaluated as in  (34) \begin{align} \omega _1^2 + \omega _2^2 \le \frac{1}{f^2}\left\Vert j \right\Vert ^2 \le \bar{\omega }^2 = \frac{ {\sum} _{k=1}^{3} { \underset{t\in \mathcal {T}}{\max } \; j_k(t)^2}}{ {\sum} _{k=1}^{3} {\underset{t\in \mathcal {T}}{\min } \; (\ddot{x}_k(t) -g_k)^2}}. \end{align} View Source \begin{align} \omega _1^2 + \omega _2^2 \le \frac{1}{f^2}\left\Vert j \right\Vert ^2 \le \bar{\omega }^2 = \frac{ {\sum} _{k=1}^{3} { \underset{t\in \mathcal {T}}{\max } \; j_k(t)^2}}{ {\sum} _{k=1}^{3} {\underset{t\in \mathcal {T}}{\min } \; (\ddot{x}_k(t) -g_k)^2}}. \end{align}

Using the above equation, and assuming  \omega _3=0 , the time interval  \mathcal {T} can be marked as feasible w.r.t. the body rate input if  \bar{\omega }^2\le \omega _{\max }^2 ; otherwise, the section is marked as indeterminate.
3) Recursive Implementation

The feasibility of a given time interval  \mathcal {T} \subseteq [0,T] is tested by applying the above two tests on  \mathcal {T} . If both tests return feasible,  \mathcal {T} is input feasible and the algorithm terminates; if one of the tests returns infeasible, the algorithm terminates with the motion over  \mathcal {T} marked as input infeasible. Otherwise, the section is divided in half, such that \begin{align} \tau _{\frac{1}{2}} &= \frac{\tau _1+\tau _2}{2}\\ \mathcal {T}_1 &= [\tau _1, \tau _{\frac{1}{2}}],\;\;\; \mathcal {T}_2 = [\tau _{\frac{1}{2}}, \tau _2]. \end{align} View Source \begin{align} \tau _{\frac{1}{2}} &= \frac{\tau _1+\tau _2}{2}\\ \mathcal {T}_1 &= [\tau _1, \tau _{\frac{1}{2}}],\;\;\; \mathcal {T}_2 = [\tau _{\frac{1}{2}}, \tau _2]. \end{align}

If the time interval  \tau _\frac{1}{2}-\tau _1 is smaller than some user-defined minimum  \underline{\Delta \tau } , the algorithm terminates with the primitive marked indeterminable. Otherwise, the algorithm is recursively applied first to  \mathcal {T}_1 : If the result is feasible, the algorithm is recursively applied to  \mathcal {T}_2 . If  \mathcal {T}_2 also terminates as a feasible section, the entire primitive can be marked as feasible; otherwise, the primitive is rejected as infeasible/indeterminable. Thus, the test returns one of three outcomes.

    The inputs are provably feasible.

    The inputs are provably infeasible.

    The tests were indeterminate; feasibility could not be established.

Note that the interval upper bound of  (33) is monotonically nonincreasing with decreasing length of the interval  \mathcal {T} , and similarly, the lower bound of  (34) is monotonically nondecreasing.

Furthermore, note that as  {\tau _\frac{1}{2}-\tau _1} tends to zero, the right-hand sides of  (31) and (32) converge, and the thrust feasibility test becomes exact. This does not, however, apply to the body rate feasibility test due to the induced norm in (39) .

The recursive implementation of the sufficient thrust feasibility tests of (36) and (37) is visualized for an example motion primitive in Fig. 3 .
Fig. 3.

Visualization of the recursive implementation of the thrust feasibility test: The vehicle thrust limits  f_{ {\text{\rm min}} } and  f_{ {\text{max}} } are shown as dashed lines, and the thrust trajectory is the dotted curve. First, the minimum and maximum bounds of (36) and (37) are calculated for the entire motion primitive, shown as the dash-dotted lines in the top plot. Because these bounds exceed the vehicle limits, the section is halved, and the tests are applied to each half (second plot). The left-hand side section's bounds are now within the limits; therefore, this section is marked feasible with respect to the thrust bounds (shown shaded in the plot), while the second half is again indeterminate. This is halved again, in the third plot, and a section is yet again halved in the fourth plot. Now, all sections are feasible with respect to the thrust limits, and the test terminates. Note that, in the implementation, the thrust infeasibility test of (35) and the body rate feasibility test (40) will be done simultaneously.

Show All
4) Remark on Convex Approximations of Thrust-Feasible Region

The feasible acceleration space of the vehicle follows from  (27) – (29) and is nonconvex due to the positive minimum thrust value. This is visualized in Fig. 4 . Nonetheless, in the limit, the presented recursive thrust input test allows for testing feasibility over the entire thrust feasible space. This is an advantage when compared with approaches that require the construction of convex approximations of the feasible space (see, e.g.,  [20] ). Consider, for example, a trajectory that begins with zero acceleration and ends with a final acceleration of  -2{\bm g} (i.e., the quadrocopter is upside down at the end of the manoeuvre)—such an example is shown in Fig. 4 . The straight line connecting the initial and final accelerations crosses through the acceleration infeasible zone due to minimum thrust. Therefore, no convex approximation can be constructed in the acceleration space in which to evaluate this trajectory.
Fig. 4.

Example trajectory demonstrating nonconvexity of the feasible acceleration space. The trajectory moves an initially stationary quadrocopter  {10}\,{\rm m} horizontally, ending at zero velocity and with final acceleration  {\bm a}_f=-2{\bm g} in  {2}\,{\rm s} (i.e., the quadrocopter is upside down at the end). The left-most plot shows the position trajectory of the vehicle, and the middle plots show the inputs during the trajectory (with the shaded regions being infeasible). The right-hand side plot shows the acceleration trajectory in the acceleration space, where the two concentric circles represent the minimum and maximum thrust limits (and are centered at  {\bm g} ) for  \ddot{x}_2=0 . The axes are chosen such that  x_3 points opposite to gravity, and there is no motion along  x_2 . Note the nonconvexity of the feasible acceleration space.

Show All
B. Affine Translational Variable Constraints

Referring to (22) , it can be seen that calculating the range of some linear combination of the system's translational variables  \sigma (t) [of the form  (8) ] can be done by solving for the extrema of a polynomial of order at most 5. This involves finding the roots of its derivative (a polynomial of order at most 4) for which closed-form solutions exist  [26] .

This is useful, for example, to verify that the quadrocopter does not fly into the ground, or that the position of the quadrocopter remains within some allowable flight space. Specifically, any planar position constraint can be specified by specifying that the inner product of the quadrocopter's position with the normal of the plane is greater than some constant value. It can also be used to calculate a bound on the vehicle's maximum velocity, which could be useful in some computer vision applications (see, e.g.,  [27] ). Furthermore, an affine bound on the vehicle's acceleration can be interpreted as a bound on the tilt of the quadrocopter's  {\bm e}_3 axis, through  (1) .
SECTION V.
Choice of Coordinate System

Because the Euclidean norm used in the cost  (13) is invariant under rotation, the optimal primitive for some given problem will be the same when the problem is posed in any inertial frame, despite the axes being solved for independently of one another.

The Euclidean norm is also used in the feasibility tests of Section IV . In the limit, as the length of the time interval  \mathcal {T} tends to zero, both the thrust and body rates feasibility tests become invariant under rotation, and thus independent of the choice of coordinate system. The affine constraints of Section IV-B can be trivially transformed from one coordinate system to another, such that there exists no preferred coordinate system for a set of constraints. This allows the designer the freedom to pose the motion primitive generation problem in the most convenient inertial coordinate system.
SECTION VI.
Guaranteeing Feasibility

For some classes of trajectory, the existence of a feasible motion primitive can be guaranteed a priori , without running the tests described in the preceding section.

For the specific case of primitives starting and ending at rest (zero velocity, zero acceleration, and a given end point), a bound on the end time  T will be explicitly calculated in dependence of the translation distance, such that any end time larger than this bound is guaranteed to be feasible with respect to the input constraints. Furthermore, the position trajectory for such rest-to-rest primitives is shown to remain on the straight line segment between the initial and final positions. Thus, given a convex allowable flight space, all primitives that start and end at rest and within the allowable flight space will remain within the allowable flight space for the entire trajectory.

The input feasibility of general motion primitives, with arbitrary initial and final accelerations and velocities, is also briefly discussed. It should be noted that those motion primitives that can be guaranteed to be feasible a priori will be a conservative subset of the primitives that can be shown to be feasible a posteriori using the recursive tests described in Section IV . Further discussion is provided in Section VII .
A. Rest-to-Rest Primitives

First, an upper bound on the lowest end time  T at which a rest-to-rest primitive becomes feasible with respect to the input constraints is calculated in dependence of the translation distance. Without loss of generality, it is assumed that the quadrocopter's initial position coincides with the origin, and the problem is posed in a reference frame such that the final position is given as  \left({p}_{f},0,0 \right) , with  {p}_{f} being the distance from the origin to the final location, such that  {p}_{f}\ge 0 .

From (25) , it is clear that the optimal position trajectory along  x_2 and  x_3 has zero position for the duration of the primitive and, therefore, also zero acceleration and velocity.
1) Input Feasibility

The acceleration trajectory along axis  1 is calculated by solving the motion coefficients with (25) , and then substituting into (22) , such that \begin{align} \ddot{x}_1(t) = 60 \frac{t}{T^3}{p}_{f}- 180 \frac{t^2}{T^4}{p}_{f}+ 120 \frac{t^3}{T^5}{p}_{f}. \end{align} View Source \begin{align} \ddot{x}_1(t) = 60 \frac{t}{T^3}{p}_{f}- 180 \frac{t^2}{T^4}{p}_{f}+ 120 \frac{t^3}{T^5}{p}_{f}. \end{align}

Introducing the variable  \xi \in [0,1] such that  t = \xi T , and substituting for the above yields \begin{align} \ddot{x}_1(\xi T) = \frac{60 {p}_{f}}{T^2}\left(\xi -3 \xi ^2 + 2 \xi ^3 \right) \end{align} View Source \begin{align} \ddot{x}_1(\xi T) = \frac{60 {p}_{f}}{T^2}\left(\xi -3 \xi ^2 + 2 \xi ^3 \right) \end{align} for which the extrema lie at \begin{align} \xi ^* &= \frac{1}{2}\pm \frac{\sqrt{3}}{6}\\ \ddot{x}_1(\xi ^* T) &= \mp \frac{10 \sqrt{3} {p}_{f}}{3 T^2}. \end{align} View Source \begin{align} \xi ^* &= \frac{1}{2}\pm \frac{\sqrt{3}}{6}\\ \ddot{x}_1(\xi ^* T) &= \mp \frac{10 \sqrt{3} {p}_{f}}{3 T^2}. \end{align}

Exploiting the observation that  \left| \ddot{x}(\xi ^* T) \right| decreases monotonically with increasing  T , an upper bound  {T}_{f_{\min }} for the end time at which such a primitive becomes feasible with respect to the minimum thrust constraint can be calculated. This is done by substituting (46) for the sufficient criterion of (32) , under the worst-case assumption that the motion is aligned with gravity, i.e., the acceleration in the directions perpendicular to gravity are zero. Then \begin{align} {T}_{f_{\min }}= \sqrt{\frac{10 {p}_{f}}{\sqrt{3}\left(\left\Vert {\bm g} \right\Vert - f_{\min } \right)}}. \end{align} View Source \begin{align} {T}_{f_{\min }}= \sqrt{\frac{10 {p}_{f}}{\sqrt{3}\left(\left\Vert {\bm g} \right\Vert - f_{\min } \right)}}. \end{align}

Similarly, an upper bound  {T}_{f_{\max }} for the end time at which the primitive becomes feasible with respect to the maximum thrust constraint can be calculated by substituting the maximum acceleration bound of (46) into the sufficient criterion of (31) . Again, the worst case occurs when the motion is aligned with gravity, and the final time can be calculated as \begin{align} {T}_{f_{\max }}= \sqrt{\frac{10 {p}_{f}}{\sqrt{3}\left(f_{\max }-\left\Vert {\bm g} \right\Vert \right)}}. \end{align} View Source \begin{align} {T}_{f_{\max }}= \sqrt{\frac{10 {p}_{f}}{\sqrt{3}\left(f_{\max }-\left\Vert {\bm g} \right\Vert \right)}}. \end{align}

Finally, an upper bound  {T}_{\omega _{\max }} for the end time at which the primitive satisfies the body rates constraint is calculated as follows. First, the jerk along axis  1 is solved for with (21) , and  t = \xi T is substituted as before, to give \begin{align} j_1(\xi T) = \frac{60 {p}_{f}}{T^3} \left(6 \xi ^2 - 6\xi + 1 \right). \end{align} View Source \begin{align} j_1(\xi T) = \frac{60 {p}_{f}}{T^3} \left(6 \xi ^2 - 6\xi + 1 \right). \end{align} This has extrema at  \xi \in \lbrace 0,\frac{1}{2},1\rbrace , and the maximum of  \left| j_1(\xi T) \right| occurs at  \xi ^* \in \lbrace 0,1\rbrace so that \begin{align} \underset{t\in [0,T]}{\max } \left| j_i(t) \right| = \left| j_i(\xi ^* T) \right| =\frac{60 {p}_{f}}{T^3}. \end{align} View Source \begin{align} \underset{t\in [0,T]}{\max } \left| j_i(t) \right| = \left| j_i(\xi ^* T) \right| =\frac{60 {p}_{f}}{T^3}. \end{align} Again, this maximum is monotonically decreasing for increasing end time  T .

This value is then substituted for the numerator of (40) , and it is assumed that the primitive satisfies the minimum thrust constraint so that  f_{\min } can be substituted for the denominator. This makes the conservative assumption that the maximum jerk value is achieved at the same time as the minimum thrust value. Equating the result to  \omega _{\max } and solving for  {T}_{\omega _{\max }} yields \begin{align} {T}_{\omega _{\max }}= \root 3 \of {\frac{60 {p}_{f}}{\omega _{\max } f_{\min }}}. \end{align} View Source \begin{align} {T}_{\omega _{\max }}= \root 3 \of {\frac{60 {p}_{f}}{\omega _{\max } f_{\min }}}. \end{align} Note that this requires f_{\min } to be strictly positive [instead of nonnegative as specified in  (4) ].

Combining (47) , (48) , and (51) , any rest-to-rest primitive within a ball of radius  {p}_{f} is guaranteed to be feasible with respect to the input constraints of Section II-A1 if the end time  T is chosen to satisfy the below bound: \begin{align} T \ge \max \lbrace {T}_{f_{\min }}, {T}_{f_{\max }}, {T}_{\omega _{\max }}\rbrace. \end{align} View Source \begin{align} T \ge \max \lbrace {T}_{f_{\min }}, {T}_{f_{\max }}, {T}_{\omega _{\max }}\rbrace. \end{align} The conservatism of this bound is investigated in Section VII .
2) Position Feasibility

It will be shown that the position along a rest-to-rest primitive remains on the straight line segment between the initial and final positions, independent of the end time  T . Solving the full position trajectory as given in Section III-C1 and substituting  p_0=0 ,  v_0=v_f = 0 , and  a_0=a_f=0 , the position trajectory in axis  1 is given by \begin{align} \begin{split} x_1(t) = {p}_{f}\left(6\frac{t^{5}}{T^{5}} - 15\frac{t^{4}}{T^{4}} + 10\frac{t^{3}}{T^{3}}\right) \end{split} \end{align} View Source \begin{align} \begin{split} x_1(t) = {p}_{f}\left(6\frac{t^{5}}{T^{5}} - 15\frac{t^{4}}{T^{4}} + 10\frac{t^{3}}{T^{3}}\right) \end{split} \end{align} with  {p}_{f}\ge 0 being the desired displacement along axis  1 . Substituting again for  \xi =t/T such that  \xi \in [0,1] , the position trajectory can be rewritten as \begin{align} x_1\left(\xi T \right) = {p}_{f}\left(6\xi ^5 - 15 \xi ^4 + 10 \xi ^3 \right). \end{align} View Source \begin{align} x_1\left(\xi T \right) = {p}_{f}\left(6\xi ^5 - 15 \xi ^4 + 10 \xi ^3 \right). \end{align} It is now straight forward to show that the extrema of  x_1(\xi T) are at  \xi ^* \in \lbrace 0,1\rbrace , and specifically that \begin{align} x_1(t) \in \left[ 0,{p}_{f} \right]. \end{align} View Source \begin{align} x_1(t) \in \left[ 0,{p}_{f} \right]. \end{align}

Axes 2 and 3 will remain at zero so that the rest-to-rest primitive will travel along the straight line segment connecting the initial and final positions in three dimensional space. Therefore, given a convex allowable flight space, if the initial and final position are in the allowable flight space, all rest-to-rest primitives will remain within the allowable flight space.
3) Maximum Velocity

In some applications, it is desirable to limit the maximum velocity of the vehicle along the motion, most notably where the quadrocopter's pose is estimated with onboard vision [27] . For rest-to-rest primitives of duration  T , the maximum speed occurs at  t=T/2 and equals \begin{align} \underset{t\in [0,T]}{\max } \left\Vert \dot{{\bm x}}(t) \right\Vert = \underset{t\in [0,T]}{\max } \left| \dot{x}_1(t) \right| = \frac{15}{8}\;\frac{{p}_{f}}{T}. \end{align} View Source \begin{align} \underset{t\in [0,T]}{\max } \left\Vert \dot{{\bm x}}(t) \right\Vert = \underset{t\in [0,T]}{\max } \left| \dot{x}_1(t) \right| = \frac{15}{8}\;\frac{{p}_{f}}{T}. \end{align} Thus, given some maximum allowable velocity magnitude and a distance to translate, the primitive end time  T at which this maximum velocity will not be exceeded can be readily calculated from the above.
B. Guarantees for General Primitives

For general primitives, with nonzero initial and/or final conditions, and with possibly unconstrained end states, it is harder to provide conditions under which feasible primitives can be guaranteed. Indeed, cases can be input feasible for some specific end times, but become infeasible if the time is extended. It can, however, be stated for a motion primitive along an axis  k (with arbitrary initial and final conditions and with any combination of final translational variable constraints in the goal state) that as the end time  T tends to infinity:

    the magnitude of the jerk trajectory tends to zero, and

    the magnitude of the acceleration trajectory becomes independent of both initial and final position and velocity constraints and can be bounded as

\begin{align} \underset{T\rightarrow \infty }{\lim }\;\; \underset{t\in [0,T]}{\max } {\ddot{x}_k(t)} &\le \max \lbrace \left| a_{k0} \right|,\left| a_{kf} \right| \rbrace \\ \underset{T\rightarrow \infty }{\lim }\;\; \underset{t\in [0,T]}{\min } {\ddot{x}_k(t)} &\ge -\max \lbrace \left| a_{k0} \right|,\left| a_{kf} \right| \rbrace. \end{align} View Source \begin{align} \underset{T\rightarrow \infty }{\lim }\;\; \underset{t\in [0,T]}{\max } {\ddot{x}_k(t)} &\le \max \lbrace \left| a_{k0} \right|,\left| a_{kf} \right| \rbrace \\ \underset{T\rightarrow \infty }{\lim }\;\; \underset{t\in [0,T]}{\min } {\ddot{x}_k(t)} &\ge -\max \lbrace \left| a_{k0} \right|,\left| a_{kf} \right| \rbrace. \end{align}

If the final acceleration is not specified, the acceleration bounds are \begin{align} \underset{T\rightarrow \infty }{\lim }\;\; \underset{t\in [0,T]}{\max } {\ddot{x}_k(t)} &\le \left| a_{k0} \right| \\ \underset{T\rightarrow \infty }{\lim }\;\; \underset{t\in [0,T]}{\min } {\ddot{x}_k(t)} &\ge -\left| a_{k0} \right|. \end{align} View Source \begin{align} \underset{T\rightarrow \infty }{\lim }\;\; \underset{t\in [0,T]}{\max } {\ddot{x}_k(t)} &\le \left| a_{k0} \right| \\ \underset{T\rightarrow \infty }{\lim }\;\; \underset{t\in [0,T]}{\min } {\ddot{x}_k(t)} &\ge -\left| a_{k0} \right|. \end{align} The calculations to show this can be found in Appendix B .

This knowledge can then be combined with the input feasibility constraints (similar to the rest-to-rest primitives, above) to guarantee the existence of an input feasible motion primitive based on the values of  \left| a_0 \right| and  \left| a_f \right| , at least as the end time is extended to infinity. Furthermore, by expanding the acceleration trajectory from (22) and applying the triangle inequality, the magnitude of the acceleration for finite end times can also be bounded. This bound can then be used to calculate an upper bound on the end time  T at which the primitive will be feasible with respect to the inputs; however, this bound will typically be very conservative.
Algorithm Overview

The focus in the preceding sections is on the generation and feasibility verification for a quadrocopter motion primitive, with an arbitrary initial state, to a set of goal end translational variables  \hat{\sigma }_i in a given time  T . The resulting acceleration trajectory, along any axis, is a cubic polynomial in time. These trajectories minimize an upper bound representative of a product of the inputs, and computationally convenient methods are presented to test whether these trajectories are feasible with respect to input constraints, and with respect to bounds on linear combinations of the translational variables. Guarantees on feasible trajectories are given, with a specific focus on rest-to-rest trajectories.

In the following section, the set of end times and goal end translational variables for which feasible trajectories can be found with the presented approach is compared with the total set of feasible trajectories, for the class of rest-to-rest trajectories. The computational cost of the presented approach is investigated in Section VIII . Section IX describes an experimental demonstration, where the presented primitives are incorporated into a larger trajectory generator.
SECTION VII.
Conservatism

If the motion primitive computed with the presented approach is not feasible, it does not imply that no feasible trajectory is possible. There are two reasons for this.

    The trajectories generated in Section III are restricted to have accelerations described by cubic polynomials in time.

    The feasibility verification of Section IV is sufficient, but not necessary.

This section attempts to give an indication of the space of end times  T and end translational variables  \hat{\sigma }_i for which a quadrocopter could fly a trajectory, but the presented method is unable to find a feasible motion primitive. This section will specifically consider rest-to-rest motions.

In [28] , an algorithm is given to compute minimum time trajectories which satisfy Pontryagin's minimum principle, for the quadrocopter system dynamics and input constraints of Section II-A . These trajectories represent the surface of the feasible region for quadrocopter rest-to-rest trajectories: given a desired final translation, a feasible trajectory exists with any end time larger than the time optimal end time (e.g., by executing the time optimal trajectory, and then simply waiting). By definition, no feasible trajectory exists for shorter end times.

Fig. 5 compares this feasible region to those trajectories that can be found with the methods of Sections III and IV . The system limits were set as in  [28] , with  f_{\min }={1}\,{\rm m/s^2} , f_{\max }={20}\,{\rm m/s^2} , \omega _{\max }={10}\,{\text{rad/s}} . For a given translation distance d , the desired end translational variables are defined such that all components are zero, except the position in the direction of motion which is set to  d .
Fig. 5.

Set of horizontal/vertical final displacements for which the presented algorithm is able to find input feasible trajectories (the lightly shaded area above the dashed line), and the set of final displacements and end times for which no trajectories are possible (the darkly shaded area, with the boundary as given by the time optimal trajectories of [28] ). The dotted line is the conservative end time guarantee as calculated in Section VI-A . The white area represents displacements that could be reached by the vehicle, but where the presented method cannot find a feasible motion primitive.

Show All

For each distance  d , the space of feasible end times was determined as follows. A set of end times was generated, starting at zero and with increments of  {1}{\rm ms} . For each end time, a motion primitive was generated, and the set of end distances and end times  (T,d) for which an input feasible trajectory was found is shown in Fig. 5 . For the sake of comparison, the guaranteed feasible end time given in Section VI-A is also plotted.

The fastest feasible manoeuvre found with the presented algorithm requires on the order of 50% longer than the time optimal trajectory of  [28] when translating vertically, and on the order of 20% longer when translating horizontally. From the figure, it can be seen that the guaranteed feasible end time of Section VI is quite conservative, requiring the order of three times longer for the manoeuvre than the time optimal trajectory. However, these trajectories can be computed at very low cost, specifically requiring no iterations to determine feasibility.
SECTION VIII.
Computation Times

This section presents statistics for the computational cost of the presented algorithm when implemented on a standard laptop computer and on a standard microcontroller. The algorithm was implemented in C++. Except for setting the compiler optimisation to maximum, no systematic attempt was made to optimize the code for speed. To evaluate the time required to compute the motion primitives described in this paper, primitives were generated for a quadrocopter starting at rest, at the origin, and translating to a final position chosen uniformly at random in a box with side length 4 m, centered at the origin. The target end velocity and acceleration were also chosen uniformly between  {-2} and  {2}\,{\rm m/s} , and  {-2} and  {2}\,{\rm m/s^2} , respectively. The end time was chosen uniformly at random between  {0.2} and  {10}{\text{s}} . The algorithm was implemented on a laptop computer with an Intel Core i7-3720QM CPU running at 2.6 GHz, with 8 GB of RAM, with the solver compiled with Microsoft Visual C++ 11.0. The solver was run as a single thread.

For one hundred million such motion primitives, the average computation time per primitive was measured to be  {1.05}\,\mu {\rm s} , or approximately 950 000 primitives per second. This includes

    generating the primitive;

    verifying that the inputs along the trajectory are feasible (with the recursive test of Section IV-A3 , for  f_{\rm min}={5}\,{\rm m/s^2} ,  f_{\rm max}={25}\,{\rm m/s^2} , and  \omega _{\rm max}={20}\,{\rm rad/s} ;

    verifying that the position of the quadrocopter stays within a  4\times 4\times 4\,{}{\rm m} box centered at the origin (that is, six affine constraints of the form  (8) as described in Section IV-B ).

Of the primitives, 91.6% tested feasible with respect to the inputs, 6.4% infeasible, and the remaining 2.0% were indeterminate.

If the position feasibility test is not performed, the average computation time drops to  {0.74}\,\mu {\rm s} , again averaged over the generation of one hundred million random primitives, or approximately 1.3 million per second.

The algorithm was also implemented on the STM32-F4 microcontroller, which costs approximately €10 and is, for example, used on the open-source PX4 autopilot system [29] . One million random primitives were generated, with the same parameters as above. The average execution time was  {149}\,\mu {\rm s} per primitive (or approximately 6700 primitives per second), including trajectory generation, input feasibility, and position feasibility tests. If the position feasibility test is not performed, the average computation time drops to  {95}\mu {\rm s} per primitive, or approximately 10 500 per second.
SECTION IX.
Example Application and Experimental Results

This section presents an example of a high-level trajectory generator that uses the motion primitives to achieve a high level goal (as illustrated in Fig. 1 ). The high-level goal is for a quadrocopter, with an attached net, to catch a ball thrown by a person. This task was chosen due to its highly dynamic 3-D nature, the requirement for real-time trajectory generation, and the existence of a variety of trajectories, which would achieve the goal of catching the ball. All the presented data are from actual flight experiments.

The algorithm is applied in a naïve brute force approach, to illustrate the ease with which a complex, highly dynamic, quadrocopter task may be encoded and solved. The multimedia attachment contains a video showing the quadrocopter catching the ball.

To catch the ball, the motion primitive generator is used in two different ways:

    to generate trajectories to a catching point, starting from the quadrocopter's current state and ending at a state and time at which the ball enters the attached net;

    to generate stopping trajectories, which are used to bring the quadrocopter to rest after the ball enters the net.

The experiments were conducted in the Flying Machine Arena, a space equipped with an overhead motion capture system which tracks the pose of the quadrocopters and the position of the balls. A PC processes the motion capture data and generates commands that are transmitted wirelessly to the vehicles at  {50}{\rm Hz} . More information on the system can be found in  [30] . The quadrocopter used is a modified Ascending Technologies “Hummingbird”  [31] , with a net attached approximately  {18}{\rm cm} above the vehicle's center of mass (see Fig. 6 ).
Fig. 6.

Quadrocopter with attached catching net, as used to demonstrate the algorithm. The center of the net is mounted above the vehicle's center of mass in the quadrocopter's  {\bm e}_3 direction.

Show All
1) Catching Trajectories

The computational speed of the presented approach is exploited to evaluate many different ways of catching the ball. This is done with a naïve brute force approach, where thousands of different primitives are generated at every controller step. Each primitive encodes a different strategy to catch the ball, of which infeasible primitives are rejected and the “best” is kept from the remainder. This is done in real time and used as an implicit feedback law, with one controller cycle typically involving the evaluation of thousands of candidate motion primitives. This task is related to that of hitting a ball with a racket attached to a quadrocopter, as was previously investigated in  [21] and  [32] .

The catching task is encoded in the format of Section II-B by stipulating that the center of the net must be at the same position as the ball, and the velocity of the quadrocopter perpendicular to the ball's flight must be zero. The requirement on the velocity reduces the impact of timing errors on the system. Because the center of the net is not at the center of the quadrocopter, the goal end state must also include the quadrocopter's normal direction  {\bm e}_3 —given some ball position, there exists a family of quadrocopter positions and normal directions which will place the center of the net at the ball's position. The desired end translational variables  \hat{\sigma } thus contains the quadrocopter's position, its normal direction (thus acceleration), and its velocity components perpendicular to the ball's velocity (thus specifying eight of the nine possible variables). The strategy for specifying these eight variables is described below.

The ball is modeled as a point mass with quadratic drag, and at every controller update step, its trajectory is predicted until it hits the floor. This is discretized to generate a set of possible catching times  T^{(k)} , with the discretization time step size chosen such that at most 20 end times are generated, and that the time step size is no smaller than the controller update period.

For each of these possible catching times  T^{(k)} , a set of candidate desired end translational variables  \hat{\sigma }^{(j,k)} is generated as follows. The quadrocopter's goal normal direction is generated by generating 49 candidate end normals, centered around the direction opposing the ball's velocity at time  T^{(k)} . To convert these candidate end normals to goal accelerations, it is necessary to further specify an end thrust value for each. The goal acceleration can then be calculated with  (1) . For each of the orientations generated, ten candidate final thrust values are used, spaced uniformly between  f_{\min } and  f_{\max } .

Given an end normal direction, the required quadrocopter position at the catching instant can be calculated as that position placing the center of the net at the ball (for the 49 different normal direction candidates, the end location of the vehicle center of mass will be located on a sphere centered at the ball's position).

The quadrocopter's velocity is required to be zero in the directions perpendicular to the ball's velocity at the catching time, while the quadrocopter velocity component parallel to the ball's velocity is left free. Thus, eight components of the end translational variables in  (7) are specified.

For each of the candidate catching instants, there are 490 candidate end states to be evaluated. Because the number of end times is limited to 20, this means that there are at most 9800 catching primitives of the form  \left(T^{(k)}, \hat{\sigma }^{(j,k)} \right) calculated at any controller update step.

Next the candidate primitive is tested for feasibility with respect to the inputs as described in Section IV-A , with the input limits set to  f_{\rm min}={5}\,{\rm m/s^2} ,  f_{\rm max}={25}\,{\rm m/s^2} , and  \omega _{\rm max}={20}\,{\rm rad/s} . Then, the candidate is tested for position feasibility, where the position trajectory is verified to remain inside a safe box as described in Section IV-B —this is to remove trajectories that would either collide with the floor or the walls. If the primitive fails either of these tests, it is rejected.

Some such candidate motion primitives are visualized in Fig. 7 .
Fig. 7.

Sampled motion primitives at one time step of a catching manoeuvre: On the left is shown the quadrocopter's center of mass for 81 candidate primitives to catch a thrown ball. The primitives are shown as solid lines, starting at the position  (0,1){}{\rm m} , and the ball's predicted trajectory is shown as a dashed-dotted line, moving from left to right in the figure. The ball's position at each of three candidate catching instants is shown as a solid circle. Each candidate primitive places the center of the net at the ball, with the quadrocopter's velocity at that instant parallel to the ball's velocity. Note that the final orientation is a parameter that is searched over, as is the thrust value at the catching instant. A total of 2812 candidates were evaluated at this time instant, which required  {3.05}\,{\rm ms} of computation. The primitives shown passing through the ground (at  {0}{\rm m} height) are eliminated when the position boundaries are evaluated. The right most two plots show detail of some of these primitives, showing the quadrocopter's orientation along the primitives. At the top-right plot, three candidate primitives are shown with different end orientations (and only showing orientations lying in the plane of the plot). The lower right plot shows primitives to the same orientation, but with varying end thrusts.

Show All

For each candidate catching primitive remaining, a stopping trajectory will be searched for (described in more detail below). If no stopping trajectory for a candidate catching primitive is found that satisfies both the input feasibility constraints and position constraints, that catching candidate is removed from the set.

Now, each remaining candidate is feasible with respect to input and position constraints, both for catching the ball, and the stopping manoeuvre after the ball is caught. From this set, that candidate with the lowest cost  J_\Sigma (as defined in Section III-C3 ) is selected as the best.
2) Stopping Trajectories

At the catching instant, a catching candidate trajectory will generally have a nonzero velocity and acceleration, making it necessary to generate trajectories from this state to rest. For these stopping trajectories, the goal end state translational variables specify that the velocity and acceleration must be zero, but leave the position unspecified. The primitive duration is sampled from a set of six possibilities, ranging from 2 down to 0.25 s. The search is terminated after the first stopping primitive is found that is feasible with respect to the inputs and the position constraints. Two such stopping primitives are shown in Fig. 8 .
Fig. 8.

Sampled stopping motion primitives: Two candidate stopping primitives bringing the quadrocopter to rest, starting at the catching instant of the optimal catching primitive from Fig. 7 . The quadrocopter moves from right to left in both figures. The upper stopping candidate brings the quadrocopter to rest in  {2}\,{\rm s} , the lower in  {1}\,{\rm s} .

Show All
3) Closed-Loop Control

Each remaining candidate catching primitive is feasible with respect to the input constraints, the position box constraints, and has a feasible stopping primitive. From these, the catching candidate with the lowest cost value is then selected as the best. This algorithm is then applied as an implicit feedback law, as in model-predictive control  [33] , such that the entire process is repeated at the controller frequency of  {50}\,{\rm Hz} —thus, the high-level trajectory generator must run in under  {20}{\rm ms} . This allows the system to implicitly update the trajectories as the prediction of the ball's flight becomes more precise, as well as compensate for disturbances acting on the quadrocopter.

If no candidate catching primitive remains, the last feasible trajectory is used as reference trajectory, tracked under feedback control. This typically happens at the end of the motion, as the end time goes to zero. After the ball is caught, the stopping primitive is executed. The stopping primitive is used as a reference trajectory tracked by the controller described in  [30] .

The completed catching trajectory corresponding to the candidates of Fig. 7 is shown in Fig. 9 . The catching manoeuvre lasted  {1.63}\,{\rm s} , during which a total of 375 985 motion primitives were evaluated (including both catching and stopping manoeuvres). To catch the ball, the quadrocopter translated a distance of  {2.93}\,{\rm m} , having started at rest.
Fig. 9.

Actual trajectory flown to catch the ball shown in Fig. 7 . The top-most plot shows the ball's flight shown as a dashed-dotted line, and the ball's position at the catching instant shown as a solid circle. Note that the offset between the vehicle and the ball at the catching instant is due to the net's offset from the quadrocopter's center of mass. The three lower plots show the manoeuvre history, until the catching instant, with (from top to bottom) the quadrocopter's velocity, attitude, and thrust commands. The attitude of the vehicle is shown using the conventional 3-2-1 Euler yaw-pitch-roll sequence  [24] . The bottom plot shows the thrust command, which can be seen to be within the limits of 5– {25}\,{\rm m\cdot s^{-2}} . It should be noted that the motion primitives are applied as an implicit feedback law, and thus, the flown trajectory does not correspond to any single planned motion primitive.

Show All

The attached video shows that the quadrocopter manages to catch thrown balls, validating the brute-force approach used to encode this problem. The video also shows the acrobatic nature of the resulting manoeuvres.
SECTION X.
Conclusion

This paper has presented a motion primitive that is computationally efficient both to generate and to test for feasibility. The motion primitive starts at an arbitrary quadrocopter state and generates a thrice differentiable position trajectory guiding the quadrocopter to a set of desired end translational variables (consisting of any combination of components of the vehicle's position, velocity, and acceleration). The acceleration allows for the encoding of two components of the vehicle's attitude. The time to calculate a motion primitive and apply input and translational feasibility tests is shown to be on the order of a microsecond on a standard laptop computer.

The algorithm is experimentally demonstrated by catching a thrown ball with a quadrocopter, where it is used as part of an implicit feedback controller. In the application, thousands of candidate primitives are calculated and evaluated per controller update step, allowing the search over a large space of possible catching manoeuvres.

The algorithm appears well suited to problems requiring to search over a large trajectory space, such as probabilistic planning algorithms [34] , or the problem of planning for dynamic tasks with multiple vehicles in real time, similar to [35] . The algorithm may be especially useful if the high-level goal is described by nonconvex constraints.

The presented motion primitive is independent of the quadrocopter's rotation about its thrust axis (the Euler yaw angle). This is reflected in that the resulting commands do not specify a yaw rate,  \omega _3 . A useful extension would be to compute an input trajectory for the quadrocopter yaw rate to achieve a desired final yaw angle.

It is shown that constraints on affine combinations of the quadrocopter's position, velocity, and acceleration may be tested efficiently. An interesting extension would be to investigate efficient tests for alternative constraint sets, for example, more general convex sets.

Implementations of the algorithm in both Python and C++ can be found in  [19] .
ACKNOWLEDGMENT

The Flying Machine Arena is the result of contributions of many people, a full list of which can be found at http://flyingmachinearena.org/ .

Authors
Figures
References
Citations
Keywords
Metrics
Media
   Back to Results   
More Like This
Robust trajectory control for unmanned helicopter with mismatched disturbances via novel sliding mode control

2015 34th Chinese Control Conference (CCC)

Published: 2015
Smart Real-Time Motion Control Framework for 2-DOF Helicopters: A Teleoperation Approach

2019 IEEE 28th International Symposium on Industrial Electronics (ISIE)

Published: 2019
Show More
References
References is not available for this document.
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
