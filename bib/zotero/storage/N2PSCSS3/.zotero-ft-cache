IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Typesetting math: 100%

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
ADVANCED SEARCH
Conferences > 2021 IEEE/RSJ International C...
Robust and Recursively Feasible Real-Time Trajectory Planning in Unknown Environments
Publisher: IEEE
Cite This
PDF
Inkyu Jang ; Dongjae Lee ; Seungjae Lee ; H. Jin Kim
All Authors
87
Full
Text Views

    Alerts

Abstract
Document Sections

    I.
    INTRODUCTION
    II.
    Preliminaries
    III.
    Algorithm Overview
    IV.
    Robust Funnel Loop Planning
    V.
    Experiment Results

Show Full Outline
Authors
Figures
References
Keywords
Metrics
Media
Footnotes
Abstract:
Motion planners for mobile robots in unknown environments face the challenge of simultaneously maintaining both robustness against unmodeled uncertainties and persistent feasibility of the trajectory-finding problem. That is, while dealing with uncertainties, a motion planner must update its trajectory, adapting to the newly revealed environment in real-time; failing to do so may involve unsafe circumstances. Many existing planning algorithms guarantee these by maintaining the clearance needed to perform an emergency brake, which is itself a robust and persistently feasible maneuver. However, such maneuvers are not applicable for systems in which braking is impossible or risky, such as fixed-wing aircraft. To that end, we propose a real-time robust planner that recursively guarantees persistent feasibility without any need of braking. The planner ensures robustness against bounded uncertainties and persistent feasibility by constructing a loop of sequentially composed funnels, starting from the receding horizon local trajectory’s forward reachable set. We implement the proposed algorithm for a robotic car tracking a speed-fixed reference trajectory. The experiment results show that the proposed algorithm can be run at faster than 16 Hz, while successfully keeping the system away from entering any dead end, to maintain safety and feasibility.
Published in: 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)
Date of Conference: 27 Sept.-1 Oct. 2021
Date Added to IEEE Xplore : 16 December 2021
ISBN Information:
ISSN Information:
INSPEC Accession Number: 21487565
DOI: 10.1109/IROS51168.2021.9636048
Publisher: IEEE
Conference Location: Prague, Czech Republic
SECTION I.
INTRODUCTION

Motion planners for autonomous mobile robots in unknown space should tackle two major challenges: being robust against unmodeled uncertainties, and persistently maintaining the feasibility of the planning problem itself.

Unmodeled uncertainties include the trajectory tracking error, sensor measurement error, and/or external forces such as wind disturbance. Their influence is often overcome by employing a trajectory planner which is robust against a prescribed class of uncertainties [1] [2] – [3] , e.g., wind disturbance of known maximum speed. Such methodologies provide a tube, within which the system is guaranteed to stay without collision. However, these tube-based methodologies often drive the system into dead ends from which the system cannot escape. Moreover, newly discovered obstacles may invalidate the trajectory. In such cases, failing to find a feasible trajectory update might lead to loss of safety.

Therefore, maintaining persistent feasibility is as important. It is usually ensured through recursion [4] , [5] : i.e., recursive feasibility holds if having a single feasible maneuver provides either persistent safety or the feasibility of finding a next one. For many systems, braking is a widely-used recursively feasible maneuvering strategy. [6] assumes the system’s ability to perform a sudden stop, and [7] , [8] explicitly compute the spare space needed for the system to brake. However, in some systems such as a fixed-wing aircraft, the mentioned emergency brakes are difficult or impossible. Feasibility must therefore be considered more carefully for them.
Fig. 1:

An autonomous ground rover avoids obstacle while trying to reach the goal position (marked using yellow arrow) in unknown space (shadowed region). The global path that leads to the goal is marked blue. The FRS around the local receding horizon trajectory is marked red. Starting from the endpoint of the local trajectory, funnels are cyclically composed within known free area to ensure recursive feasibility of the trajectory planner.

Show All

In this paper, we present a real-time trajectory planning algorithm that is both robust to bounded uncertainties and recursively feasible at the same time, without any need of braking capability. We begin by following the common planning framework, planning a global path to the goal through the free and unknown spaces, which is tracked by a receding horizon local trajectory in the free space. We guarantee recursive feasibility by attaching a loop of sequentially constructed funnels starting from the local trajectory. Robustness against uncertainties is guaranteed by requiring the forward reachable set (FRS) of the local trajectory to end inside the funnel loop. Suggested in [6] , funnels are basically FRSs that start from a big initial set. If the system is located inside a funnel’s initial set, it can be provably driven to its exit by its associated controller. The set of pre-computed funnels, funnel library, can be used as building blocks for safe trajectory. If a funnel’s entrance encompasses another funnel’s exit, than the two funnels are sequentially composed and act like a single funnel. Fig. 1 briefly shows how the proposed planner runs. At an epoch, the planner finds the global and local trajectories, the FRS of the local trajectory, and a funnel loop that follows the local trajectory. A funnel loop acts like a single funnel whose entrance encompasses its exit, so the system can permanently stay inside the loop without braking.
A. Contributions

The contributions of this paper can be summarized as follows.

    We propose a trajectory planner that utilizes cyclic funnel compositions to guarantee persistent safety and feasibility.

    We present a forward reachability analysis method that simulates the adversarial disturbance sequence in real-time, in order to check whether the system can robustly be driven into the funnel loop or not.

    The planner is scalable in execution time. It can be run long without any need of additional memory, since we discard unnecessary funnel loops once another is found.

    Our planner provides some resilience to map changes. Since it creates the funnel loop only in the neighborhood of the current configuration, persistent feasibility is still guaranteed as long as map changes only occur outside the existing funnel loop.

    The proposed algorithm is validated through an experiment using an actual ground robot running an off-the-shelf mapping software. The proposed planner achieves computation time of less than 60 ms and can be run at real-time.

B. Relevant Work

The influence caused by uncertainties is often overcome by having a reachability-based robust motion planner. Such planners pre-compute the FRS of the system, with known disturbance bounds. The most accurate approximation of the FRS is obtained by solving the Hamilton-Jacobi partial differential equations (PDE) [9] , [10] , although solving them requires extremely burdensome computation. For polynomial dynamics, one can achieve faster FRS computation by converting the complex PDE into a convex optimization problem. Sum-of-squares (SOS) programming was used in [6] , and to further accelerate computation speed, positive polynomials such as Bernstein bases can be used [11] . However, due to the limited expressivity of polynomials, both entail over-conservatism as a trade-off. Some planners circumvent burdensome computations by using pre-calculated asymptotic bounds on which feedback control and disturbance effects are balanced [2] , [12] . [13] , [14] propose tube-based model predictive control (MPC) approaches that computes the bound online through min-max inequalities, but they carry heavy computational load.

In the perspective of motion planning, [6] composes funnels sequentially to build a trajectory in known environments from start to goal. The funnels can be also composed in runtime (not in the planning phase), but it requires the robot to be able to perform a sudden stop in case of an infeasibility. In [1] and [15] , Hamilton-Jacobi reachability is directly used. The partial differential equation is translated to a more conservative but simpler form, so that an over-approximated FRS can be computed in real-time along the planned trajectory.

To take persistent feasibility into account, [16] identifies inevitable collision states, which are instantaneously collision-free but will unavoidably lead to collision with a nearby obstacle. Avoiding such states provides safety. [7] , [17] have separate local planners to find a trajectory with final stop condition within the known-free space. In [8] , the braking maneuver is explicitly considered to guarantee persistent feasibility. [18] addresses the problem for multiple airplanes. Each agent avoids collision and infeasibility by having a virtual box on one side that fits a loiter pattern and letting nothing inside the box. In [5] , the system expands the exploration tree consisting only of points from which the agent can safely return to the home position. The algorithm can be applied to systems with no brakes, but is vulnerable to even small changes in obstacle configuration near home, because this change may block many returning paths. In the world of reinforcement learning, in [19] , the agents learn how to reset themselves when they encounter irreversible or hazardous states. Penalizing resets will eventually lead the agent to learn a reversible policy, although this is out of the scope of this paper.
SECTION II.
Preliminaries

We start by considering a nonlinear discrete-time time-invariant mobile robot system with state x ∈ ℝ n and input u ∈ U ⊆ R m under additive disturbance w ∈ W ⊆ R n . The evolution of the system at any epoch t is governed by
x ( t + 1 ) = f ( x ( t ) , u ( t ) ) + w ( t ) . (1)
View Source \begin{equation*}x(t + 1) = f(x(t),u(t)) + w(t).\tag{1}\end{equation*}

The state space consists of two components: cyclic and non-cyclic coordinates. Let x = ( x c , x nc ) ∈ ℝ n , where x c ∈ ℝ d and x nc ∈ ℝ n−d are the cyclic and noncyclic parts, respectively. The system’s governing equation is assumed to be invariant under translation in the cyclic coordinates, i.e., we can write
x ( t + 1 ) = f ( x ( t ) , u ( t ) ) + w ( t ) = x ( t ) + f ^ ( x nc ( t ) , u ( t ) ) + w ( t ) , (2)
View Source \begin{equation*}\begin{array}{c} x(t + 1) = f(x(t),u(t)) + w(t) \\ = x(t) + \hat f\left( {{x_{{\text{nc}}}}(t),u(t)} \right) + w(t), \end{array} \tag{2}\end{equation*} where f ^ : R n − d × R m → R n is a function only of non-cyclic coordinates and input. In mobile robot systems, the cyclic coordinates are usually their position in the Euclidean workspace. The cyclic component can be obtained using the projection map Π : ℝ n → ℝ d :
x c = Π ( x ) . (3)
View Source \begin{equation*}{x_c} = \Pi (x).\tag{3}\end{equation*}

The remaining parts of this paper assume that the cyclic coordinates of the system is equal to the robot’s position, hence collision checking can be done by just examining the cyclic coordinates.

A funnel F = ( I , E , X ) is a tuple consisting of three sets: entrance I ⊆ ℝ n and exit X ⊆ ℝ n in the state space, encompassing shape E ⊆ ℝ d in the Euclidean workspace. Mathematically, if x ( t 0 ) ∈ I , then there exists an epoch t 1 > t 0 and u ( t , x ( t ) , ⋯ ) ∈ U , ∀ t ∈ [ t 0 , t 1 ] , such that x ( t 1 ) ∈ X and Π( x ( t )) ∈ E, ∀t ∈ [ t 0 , t 1 ]. In this paper, we consider funnels that satisfy the following:

    The entrance I is of the form I = { ( p , x nc ) ∈ R n ∣ p ∈ Π ( I ) , x nc ∈ I nc ⊆ R n − d } , where Π( I ) = {p ∈ ℝ d | A I | ( p −p I ) ≤ b I . A I and b I are matrix and column vector with appropriate sizes, respectively. That is, the constraints for cyclic and noncyclic coordinates are decoupled, and the cyclic coordinate part is a polytope. p I ∈ ℝ d is the center of I , which is the starting point of the nominal trajectory that traverses the funnel.

    The exit X is of the form X = { ( p , x nc ) ∈ X ∣ ∥ p − p X ∥ 2 ≤ r X , x nc ∈ X nc ⊆ R n − d } , where p X is the (cyclic) coordinate of the funnel exit, r X > 0 is the exit radius on the cyclic coordinate.

    The encompassing shape E is a polytope, i.e., E = { p ∈ ℝ d | A Ep ≤ b E } , where A E is a matrix and b E is a column vector, both with appropriate sizes.

Additionally, for the sake of simple description, we normalize each row of A I and A E to be a unit vector.
Fig. 2:

A schematic explanation of the proposed planning algorithm. Green and red arrows denote that the corresponding step has succeeded or failed, respectively. The funnel loop finding part is marked using a red box.

Show All

We say that two funnels F i = ( I i , X i , E i ) and F j = ( I j , X j , E j ) are sequentially composed if the entrance of F j completely encompasses X i , i.e.,
X i ⊆ I j , (4)
View Source \begin{equation*}{X_i} \subseteq {I_j},\tag{4}\end{equation*} so that starting in I i guarantees the existence of a trajectory that leads to X j . We denote this using the ⊳ symbol, i.e., F i ▹ F j . If F 1 ▹ ⋯ ▹ F n F and F n F ▹ F 1 , the funnels form a loop, which the system can persistently stay within.

SECTION III.
Algorithm Overview

Our algorithm adds the following three steps to the global-local trajectory planning algorithm mentioned in the introduction: funnel loop candidate searching, forward reachability analysis, and funnel loop closure. In the funnel loop candidate searching step, we find a sequence of funnels which are expected to be adjustable in the cyclic coordinates to form a valid loop. The forward reachability analysis ensures that the planned local trajectory robustly drives the system into the entrance of the first funnel, despite the effect of disturbances. In the last step, the funnel positions are adjusted so that the loop is closed while maintaining collision avoidance and robustness of the local planner. As a result, we always have a funnel loop trajectory , which consists of a collision-free funnel loop and a robust local trajectory that drives the system into the loop. The system can stay inside the funnel loop as long as needed, before it finds a next valid funnel loop trajectory.
Fig. 3:

A graphical description of the funnel planning algorithm (the red-boxed part of Fig. 2 ). The system is drawn as an airplane. The obstacle areas are colored brown, and only the bright regions are known to the system. The goal position is marked with yellow arrow. a) A global path (blue curve) and local trajectory (red short curve) are found using the global and local planners. b) A funnel loop candidate is found by growing a tree of funnels. c) Forward reachability analysis ensures that the local trajectory is free from collision and safely leads the system into the first funnel’s entrance. d) The funnel positions are adjusted to complete a closed loop.

Show All

A schematic explanation of this procedure is given in Fig. 2 . The proposed three steps are marked using a red box. Fig. 3 provides a graphical explanation of the algorithm. In the next section, we elucidate each step of the proposed algorithm.
SECTION IV.
Robust Funnel Loop Planning

For an ordered set of n F funnels ( F 1 = ( I 1 , X 1 , E 1 ) , ⋯ F n F = ( I n F , X n F , E n F ) ) to form a valid loop, (4) should hold for all neighboring index pairs ( i , j ) ∈ I = { ( 1 , 2 ) , ⋯ , ( n F − 1 , n F ) , ( n F , 1 ) } . That is, to elaborate,
X nc ⋅ i ⊆ I nc ⋅ j ∀ ( i , j ) ∈ I (5)
View Source \begin{equation*}{X_{{\text{nc}} \cdot i}} \subseteq {I_{{\text{nc}} \cdot j}}\quad \forall (i,j) \in {\mathbb{I}}\tag{5}\end{equation*} and
A I j ( p X i − p I j ) ≤ b I j − r X i ∀ ( i , j ) ∈ I . (6)
View Source \begin{equation*}{A_{{I_j}}}\left( {{p_{{X_i}}} - {p_{{I_j}}}} \right) \leq {b_{{I_j}}} - {r_{{X_i}}}\quad \forall (i,j) \in {\mathbb{I}}.\tag{6}\end{equation*}

The goal of this section is to find n F funnels, each of them being a translated funnel from the funnel library F = { F L ⋅ 1 , ⋯ , F L ⋅ n F } , such that the funnels satisfy (5) and (6) . We tackle this through a three-step process: in step 1, we find the funnel sequence that satisfies (5) completely and (6) roughly using a graph search algorithm ( section IV-A ); in step 2, we confirm that the local trajectory robustly leads to the entrance of the funnel trajectory candidate of step 1 ( section IV-B ); and in the last step, we adjust the positions of the funnel path candidate to completely satisfy (6) ( section IV-C ). This is possible owing to the funnel property that the constraints in the cyclic and noncyclic coordinates are decoupled.
Fig. 4:

The FRS of a planar quadrotor system with state ( x , y , θ , x ˙ , y ˙ , θ ˙ ) ∈ R 6 and input ( f,τ ) ∈ ℝ 2 in a flipping maneuver shown in the right, where x , y , and θ are the quadrotor’s horizontal displacement, altitude, and pitch angle, respectively. The input consists of thrust f and pitching torque τ. The blue bounds represent the estimated FRS, and black curves are the error trajectories caused by adversarial disturbance.

Show All
A. Funnel Loop Candidate Searching

We find a cyclic funnel path candidate by constructing and traversing a tree of properly connected funnels. First, the tree is initialized with the reachable set of the local trajectory as the root node. Given a node X = X c × X nc ⊆ ℝ n where X c = { p ∣ ∥ p − p X ∥ 2 ≤ r X } ⊆ R d , the funnels that satisfy (5) are chosen and are translated such that the cyclic coordinates of the entrance and p X are matched. If a translated funnel is collision-free, its exit becomes the child node. We continue this process until we find a node that is sufficiently close to the root node in the cyclic coordinates, and is completely encompassed by the first funnel’s entrance in the noncyclic coordinates. The criterion used to determine whether a node is sufficiently close may vary depending on the system or the environment, and can be heuristically selected to maximize the success rate of finding a valid funnel path. Any off-the-shelf tree searching algorithm can be used in this step.
B. Forward Reachability Analysis

After finding a funnel cycle candidate, the validity of the local planning results is checked. The checking procedure consists of two steps: collision avoidance, and funnel composability.

Assume that we are given a memoryless feedback controller u ( t ) = k ( t ; x ( t ), x r ( t )) and the local trajectory x r ( t ) ∈ ℝ n for t ∈ { 0, •⋯,T}. Then, we have the time-varying closed-loop error dynamics.
e ( t + 1 ) = f ( x r ( t ) + e ( t ) , k ( t ; x r ( t ) + e ( t ) , x r ( t ) ) ) − x r ( t ) + w ( t ) = h ( t ; e ( t ) ) + w ( t ) (7)
View Source \begin{equation*}\begin{array}{c} e(t + 1) = f\left( {{x_r}(t) + e(t),k\left( {t;{x_r}(t) + e(t),{x_r}(t)} \right)} \right) \\ - {x_r}(t) + w(t) \\ = h(t;e(t)) + w(t) \end{array} \tag{7}\end{equation*}

where the error e ( t ) ∈ ℝ n is defined as e ( t ) = x ( t ) −x r ( t ), and h is the function that describes the closed-loop dynamics. We assume that the disturbance w ( t ) is bounded by w ( t ) ∈ W = { w ∈ R n ∣ A w w ≤ b w } . The goal of this step is to find the sequence of disturbance w ( t ) for t, ∈ { 0,⋯, τ – 1} for an epoch τ ∈ { 1, • ⋯, T} , which drives the system in the way that maximizes a given objective function a : ℝ n → ℝ. That is, we solve the following optimal control problem:
max . s . t . a ( e ( τ ) ) e ( t + 1 ) = h ( t ; e ( t ) ) + w ( t ) e ( 0 ) = x 0 − x r ( 0 ) w ( t ) ∈ W ∀ t ∈ { 0 , ⋯ , τ − 1 } ∀ t ∈ { 0 , ⋯ , τ − 1 } . (8)
View Source \begin{equation*}\begin{array}{ccc} {\max .}&{a(e(\tau ))}&{} \\ {{\text{s}}.{\text{t}}.}&{e(t + 1) = h(t;e(t)) + w(t)}&{\forall t \in \{ 0, \cdots ,\tau - 1\} } \\ {}&{e(0) = {x_0} - {x_r}(0)}&{} \\ {}&{w(t) \in {\mathbb{W}}}&{\forall t \in \{ 0, \cdots ,\tau - 1\} .} \end{array}\tag{8}\end{equation*}

To solve this, we use a modified version of the differential dynamic programming (DDP) algorithm that only propagates the first-order gradients, which is an extension of [20] to nonlinear systems.

First, the algorithm initializes with the disturbance sequence w ( t ). The error sequence e ( t ) is determined by simulating (7) forwards. Let g t denote the gradient of the objective function with respect to w ( t ), on the forward-passed trajectory. It is straightforward to find out that
g τ − 1 = ( ∂ a ∂ e ( e ( τ ) ) ) ⊤ . (9)
View Source \begin{equation*}{g_{\tau - 1}} = {\left( {\frac{{\partial a}}{{\partial e}}(e(\tau ))} \right)^ \top }.\tag{9}\end{equation*}

We can now backward-pass g t using
g t − 1 = ( ∂ e ( t ) ∂ e ( t − 1 ) ) ⊤ g t = ( ∂ h ( t − 1 ; ⋅ ) ∂ e ( e ( t − 1 ) ) ) ⊤ g t , (10)
View Source \begin{equation*}{g_{t - 1}} = {\left( {\frac{{\partial e(t)}}{{\partial e(t - 1)}}} \right)^ \top }{g_t} = {\left( {\frac{{\partial h(t - 1; \cdot )}}{{\partial e}}(e(t - 1))} \right)^ \top }{g_t},\tag{10}\end{equation*} which can be derived using the chain rule. The disturbance sequence is updated using the steepest ascent by solving the following quadratic programming (QP) problem:
w ( t ) ′ = argmax w ∈ W ⋅ g ⊤ t w + α ∥ w − w ( t ) ∥ 2 2 , (11)
View Source \begin{equation*}w{(t)^\prime } = \mathop {\operatorname{argmax} }\limits_{w \in {\mathbb{W}}} \cdot g_t^ \top w + \alpha \left\| {w - w(t)} \right\|_2^2,\tag{11}\end{equation*} where w ( t )′ is the new value for w ( t ). The weight α ≥ 0 penalizes drastic changes in w ( t ) and prevents the problem from falling into a local optimum. We found that in many cases, setting α = 0 is sufficient: in such cases, the problem becomes a linear programming (LP) problem. Since the domain W is the same in every update, we can pre-compute the vertices and their connectivity in the offline phase in order to enhance the computation speed. Unlike DDP methods used in trajectory planning or MPC, the backward pass can be calculated in parallel, since (11) does not reuse the previous calculation results. Fig. 4 shows an example FRS calculated using the proposed method for linear objective functions.

Now, we denote the entrance of the first funnel by I 1 = { ( p , x nc ) ∣ A I 1 p ≤ b I 1 , g nc ( x nc ) ≤ 0 } , where A I 1 = [ a ⊤ 1 ; ⋯ ; a ⊤ n 1 ] and B I 1 = [ b 1 ; ⋯ ; b n 1 ] . For FRS-funnel composability check, the objective of (8) is set to a ( e ) = g nc ( x r•nc ( T ) + e nc ) ≤ 0 and a ( e ) = a ⊤ i ( x r ⋅ c ( T ) + Π ( e ) ) ≤ b i , for noncyclic and cyclic coordinates, respectively. The cyclic composability check should yield the translatable margin for the first funnel as A I 1 δ p ≤ b FRS . For each τ ∈ { 0, ⋯,T} , collision with the environment is also checked. For that, we construct a single safe flight corridor (SFC) in cyclic coordinate space around
Fig. 5:

A graphical description of Algorithm 1 . a) The target funnel encompassing shape E is depicted blue. The purple squares represent the nearby occupied (or unknown) voxels in the open set. Voxels removed from the open set are colored gray. b) First, an encompassing circle (or sphere) of E is found to obtain c E . c) Starting from the nearest voxel (red), two points p and v are obtained to find a wall (depicted using blue line). Voxels outside the wall are removed from the open set. d) After finite iterations, open set is emptied, and the obtained walls form a convex region in which the funnel can freely translate (yellow polygon).

Show All

the local trajectory using [21] . SFC is a large convex region built in the obstacle-free space, which we can use to bring a nonconvex trajectory optimization problem to a slightly more conservative but convex domain [21] , [22] . Denote the obtained SFC by SFC = {p|A SFC p ≤ b SFC } where [ a ⊤ SFC ⋅ 1 ; ⋯ ; a ⊤ SFC ⋅ n SC ] . Similarly, collision can be checked by letting a ( e ) = a ⊤ SFC ⋅ i Π ( e ) .
C. Funnel Loop Closure

Let the result from the previous step be denoted by an ordered set ( F 1 , ⋯ , F n F ) , which is a valid funnel composition (but yet to be loop-closed). The objective of this step is to adjust the given funnels along the cyclic coordinates, so that F n F and F 1 are connected, while not losing validity. We consider the situation in which F 1 shall be translated by δ p i ∈ ℝ d . Two constraints should be satisfied for each translation: collision avoidance, and funnel composability.
1) Colision Avoidance Constraint:

For collision avoidance, we propose an algorithm that generates a convex adjustable area of a funnel, in which the funnel can translate without collision. We first represent each obstacle as a convex shape in ℝ d space, which is a voxel in most cases. The unknown space is also considered an obstacle, because the funnel loop must be built within regions known to be free. Our algorithm (algorithm 1) builds linear inequalities, one at a time, whose intersection constructs the adjustable margin. It initializes with the unadjusted encompassing polytope E of a funnel, and the open_set that contains neighboring obstacle yet to be considered. The smallest_sphere_center in line 2 returns the center c E of the smallest sphere that completely covers E. The loop in line 3 iterates over the elements of open_set , starting from the nearest obstacle from c E , and finds a separating hyperplane between the funnel and the obstacle. Using the hyperplane, we find the linear constraint written {δp ∈ ℝ d | a ⊤ δp ≤ b} ( a ∈ ℝ d
Algorithm 1 Funnel adjustable area computation

and b ∈ ℝ), which guarantees E to be collision-free when translated by δp. With an obstacle region V , we first find two points, each in E and V , that are closest, by solving a QP problem with 2 d decision variables:
min p , v ∈ R d  s .t .  ∥ p − v ∥ 2 2 p ∈ E , v ∈ V . (12)
View Source \begin{equation*}\begin{array}{cc} {\mathop {\min }\limits_{p,v \in {\mathbb{R}^d}} }&{\left\| {p - v} \right\|_2^2} \\ {{\text{ s}}{\text{.t}}{\text{. }}}&{p \in E,\quad v \in V.} \end{array}\tag{12}\end{equation*}

Since the two shapes are convex, we can conclude that E can be translated in the direction of v – p by distance ∥ v − p ∥ 2 while not colliding with V , i.e.,
( v − p ∥ v − p ∥ 2 ) ⊤ δ p = a ⊤ δ p ≤ ∥ v − p ∥ 2 = b (13)
View Source \begin{equation*}{\left( {\frac{{v - p}}{{{{\left\| {v - p} \right\|}_2}}}} \right)^ \top }\delta p = {a^ \top }\delta p \leq {\left\| {v - p} \right\|_2} = b\tag{13}\end{equation*}

provides a collision-avoiding bound for δp. We then remove obstacles that are farther in the v − p direction than V from the open_set , as they are already not reachable by E when (13) is satisfied. The obtained a ⊤ and b are added to the rows of A A ∈ R n A × d and b A ∈ R n A This process iterates until the open_set is emptied. A brief graphical explanation is provided in Fig. 5 .
2) Cyclic Composability Constraint:

For cyclic composability, (6) is directly used. Let F i ▹ F j . A point p lies within the entrance of F j translated by δp j if
A I j ( p − p I j − δ p j ) ≤ b I j . (14)
View Source \begin{equation*}{A_{{I_j}}}(p - {p_{{I_j}}} - \delta {p_j}) \leq {b_{{I_j}}}.\tag{14}\end{equation*}

This should be satisfied by the exit of F i translated by δp i , with margin r X i .
A I j ( p X i − p I j + δ p i − δ p j ) ≤ b I j − r X i (15)
View Source \begin{equation*}{A_{{I_j}}}\left( {{p_{{X_i}}} - {p_{{I_j}}} + \delta {p_i} - \delta {p_j}} \right) \leq {b_{{I_j}}} - {r_{{X_i}}}\tag{15}\end{equation*}

Additionally, the first funnel entrance should cover the FRS of the local trajectory:
A I 1 ( p I 1 + δ p 1 − Π ( x ( T ) ) ) ≤ b FRS (16)
View Source \begin{equation*}{A_{{I_1}}}\left( {{p_{{I_1}}} + \delta {p_1} - \Pi (x(T))} \right) \leq {b_{{\text{FRS}}}}\tag{16}\end{equation*}

Fig. 6:

The ground rover used in the experiment.

Show All

Subject to the mentioned constraints, the following QP problem is solved to find feasible adjustment while minimizing jolty motions when switching between funnels:
min .  s .t .  ∑ ( i , j ) ∈ I w i , j ∥ ∥ ( p X i + δ p i ) − ( p I j + δ p j ) ∥ ∥ 2 2 + w 0 ∥ Π ( x ( T ) ) − ( p I 1 + δ p 1 ) ∥ 2 2 A k A δ p k ≤ b k A ∀ k ∈ { 1 , ⋯ , n F } A I j ( p X i − p I j + δ p i − δ p j ) ≤ b I j − r X i ∀ ( i , j ) ∈ I A I 1 ( p I 1 + δ p 1 − Π ( x ( T ) ) ) ≤ b FRS (17)
View Source \begin{equation*}\begin{array}{ll} {\min .}&{\sum\limits_{(i,j) \in {\mathbb{I}}} {{w_{i,j}}\left\| {\left( {{p_{{X_i}}} + \delta {p_i}} \right) - \left( {{p_{{I_j}}} + \delta {p_j}} \right)} \right\|_2^2} } \\ {}&{ + {w_0}\left\| {\Pi (x(T)) - \left( {{p_{{I_1}}} + \delta {p_1}} \right)} \right\|_2^2} \\ {{\text{ s}}{\text{.t}}{\text{. }}\quad }&{A_A^k\delta {p_k} \leq b_A^k\quad \forall k \in \left\{ {1, \cdots ,{n_F}} \right\}} \\ {}&{{A_{{I_j}}}\left( {{p_{{X_i}}} - {p_{{I_j}}} + \delta {p_i} - \delta {p_j}} \right) \leq {b_{{I_j}}} - {r_{{X_i}}}\quad \forall (i,j) \in {\mathbb{I}}} \\ {}&{{A_{{I_1}}}\left( {{p_{{I_1}}} + \delta {p_1} - \Pi (x(T))} \right) \leq {b_{{\text{FRS}}}}} \end{array}\tag{17}\end{equation*} where A k A is the adjustable area for the k -th funnel and w i,j , w 0 ≥ 0 are nonnegative weights. The optimization problem (17) minimizes the magnitude of jump required in switching between funnels in the cyclic coordinates. A good way to select the weights is to more heavily penalize jumps with lower indices, since they are more likely to be actually traversed than the ones with bigger indices.

SECTION V.
Experiment Results

To validate the proposed planning algorithm, an experiment was conducted using a ground rover shown in Fig. 6 . The rover is an Ackerman steering robot equipped with an onboard computer (Intel NUC), a planar LiDAR sensor (YDLIDAR X4), and an IMU. The onboard computer has a 6-core CPU with base clock frequency of 1.10 GHz and 16 GB memory. The LiDAR scans the environment at 10 Hz. The planning algorithm is implemented in C++, and OSQP [23] is used for solving QPs. For real-time mapping and localization, Cartographer [24] is used. To provide a good initial guess to the SLAM module, pose estimates from the OptiTrack motion capture system and Intel Realsense Tracking Camera T265 are used. The map is updated every second.

The kinematics of the ground rover system is governed by the following bicycle-model equation:
p x ( t + 1 ) = p x ( t ) + v ( t ) cos θ ( t ) ⋅ δ t + w 1 ( t ) p y ( t + 1 ) = p y ( t ) + v ( t ) sin θ ( t ) ⋅ δ t + w 2 ( t ) θ ( t + 1 ) = θ ( t ) + v ( t ) κ ( t ) ⋅ δ t + w 3 ( t ) , (18)
View Source \begin{equation*}\begin{array}{c} {p_x}(t + 1) = {p_x}(t) + v(t)\cos \theta (t) \cdot \delta t + {w_1}(t) \\ {p_y}(t + 1) = {p_y}(t) + v(t)\sin \theta (t) \cdot \delta t + {w_2}(t) \\ \theta (t + 1) = \theta (t) + v(t)\kappa (t) \cdot \delta t + {w_3}(t), \end{array} \tag{18}\end{equation*} where x ( t ) = [ p x ( t ); p y ( t ); θ ( t )] ∈ ℝ 3 , u ( t ) = [ v ( t ); κ ( t )] ∈ ℝ 2 , and w ( t ) = [ w 1 ( t ); w 2 ( t ); w 3 ( t )] ∈ ℝ 3 are the state, input, and disturbance vectors, respectively. The time discretization step δt is a positive constant. The cyclic and noncyclic coordinates are x c ( t ) = [ p x ( t ); p y ( t )] ∈ ℝ 2 and x nc ( t ) = [ θ ( t )] ∈ ℝ 1 , respectively. We use the feedback controller in the following form to find the set point in speed v s ( t ) and turning rate κ s ( t ):
[ v s ( t ) κ s ( t ) ] = sat ⎛ ⎝ ⎜ u r ( t ) − K p ⋅ ⎡ ⎣ ⎢ Δ f Δ l Δ θ ⎤ ⎦ ⎥ − K d ⋅ d d t ⎡ ⎣ ⎢ Δ f Δ l Δ θ ⎤ ⎦ ⎥ ⎞ ⎠ ⎟ , (19)
View Source \begin{equation*}\left[ {\begin{array}{c} {{v_s}(t)} \\ {{\kappa _s}(t)} \end{array}} \right] = \operatorname{sat} \left( {{u_r}(t) - {K_p} \cdot \left[ {\begin{array}{c} {\Delta f} \\ {\Delta l} \\ {\Delta \theta } \end{array}} \right] - {K_d} \cdot \frac{{\text{d}}}{{{\text{d}}t}}\left[ {\begin{array}{c} {\Delta f} \\ {\Delta l} \\ {\Delta \theta } \end{array}} \right]} \right),\tag{19}\end{equation*} where K p and K d are gain matrices in appropriate sizes, ∆ f and ∆ l represent the forward and leftward displacements of the robot measured from the reference trajectory, respectively. ∆ θ is the deviation of the heading angle θ with respect to the reference. The function sat : ℝ 2 → ℝ 2 clips the magnitude of the control commands to u – – ≤ u ( t ) ≤ u ¯ . The set points are forwarded to the low-level controller, which converts the set points to motor commands. The actual values of the parameters are summarized in Table I .

TABLE I: The values of the parameters used in the experiment
Fig. 7:

The first five funnels from the funnel library used in the experiment are depicted. The funnel library consists of 80 funnels in total, where the remaining 75 of them are the rotated ones the five funnels depicted in this figure. Dotted black lines represent the actual trajectory recorded from the funnel-building experiment.

Show All

To make the experiment more challenging, we restrict the speed of the reference trajectory to be fixed at 0.5 m / s, and the turning rate (curvature) is limited to be less than 1.1 m −1 . We however allow small jumps in the reference trajectory, and the tracking error due to jumps or external force is considered disturbance. The funnels and disturbance bound used in the experiment are obtained through a preliminary experiment, in which the tracking error is measured while successively running randomly chosen nominal trajectories. Fig. 7 shows the first five funnels used in the experiment, projected onto the cyclic coordinates. For the global planner, jump point search (JPS) [25] is used. The local planner is sampling-based: we keep a trajectory library consisting of 7 local trajectories and select on that best tracks the global trajectory. The A ⋆ algorithm is employed for the funnel loop candidate searching step, as it was one of the fastest among competing algorithms when used in the authors’ implementation.
Fig. 8:

Three scenarios tested in the experiment. (a) The first scenario consists of a corridor with both ends open. (b) The second also has a corridor, whose one side is however blocked. (c) The last environment consists of boxes sized about a meter in width and depth. One of them (red-circled box) is manually placed and removed repeatedly during the experiment.

Show All
Fig. 9:

The trajectory snippets recorded during the experiment. The goal positions are marked using yellow arrows. Each trajectory (black curve) starts from a red circle (•) and ends at an arrow head (►).

Show All

The experiment consists of three scenarios. In each scenario, the robot runs in different environments, which are shown in Fig. 8 . The goal positions change over time, and are given manually. In the experiment, the robot avoids the obstacle despite large tracking error, whose positions are a priori unknown, while keeping its (tracking) reference speed at 0.5 m/s. The following subsections provide discussions about some important snippets taken from the experiment results.

    Goal in Known and Reachable Space: If the goal is given in known and reachable space, the planner acts like a normal receding horizon planner, because the local trajectory gets replaced by a new local trajectory before the robot enters the funnel loop. Fig. 9-(a) shows how the robot reaches the goal in environments where the funnel loops could be found easily.

    Goal in Unknown but Reachable Space: Fig. 9-(b) shows the trajectory of the robot when it is told to reach the goal in unknown space behind a wall. The robot cannot reach the goal at once, but while staying inside the funnel loop, it naturally explores the unknown space to build a funnel loop around the wall ( Fig. 10 ).

    Goal in Enterable but Not Escapable Space: Goals marked in Fig. 9-(c) are reachable in the myopic sense but not potentially safe, because there is not enough space for the robot to turn around and escape. While funnel loops cannot be found in such cases, the robot does not reach the goal.

    Nonstatic Environment: The third scenario is designed to verify the resilience of the proposed algorithm to small map changes. The box shown in Fig. 8-(c) is placed and removed repeatedly during the experiment. Fig. 11 shows the recorded trajectory during a 3-minute run, during which the box was placed and removed twice. The robot succeeded to generate safe trajectories despite map changes, and also utilized the freed area during the box was removed.

Fig. 10:

Funnel loops generated while trying to reach the goal in unknown space, behind the wall. The robot’s poses are marked using thin yellow arrows. Brown lines represent the global trajectories that lead to the goal position at the big yellow arrow. Each funnel loops start with a local trajectory marked using a red curve.

Show All
Fig. 11:

Trajectory data recorded during the third scenario. The position of the box is shown as the magenta rectangle. Red curves are the trajectory with the box in place, while blue curves are run while the box was removed.

Show All
A. Computation Time Analysis

For the sake of vehicle stability, the planner runs at 5 Hz in the experiment. However, a complete planning procedure finished in 60 ms (over 16 Hz) in average: 3 ms for global path planning, less than a millisecond for local planning, 47 ms for FRS calculation, 3 ms for funnel loop candidate searching, and 6 ms for the funnel loop adjustment step.
B. Remarks on Implementation

The A ⋆ algorithm is known to become faster with an optimistic heuristic, if optimality can be sacrificed. This is precisely the case, since the funnel loop is only used when the trajectory planning fails to find the next trajectory update and hence there is very little need to make the cyclic funnel sequence short. Thus, we used the heuristic which is ten times the consistent heuristic, which reduced the number of searches roughly in half.

Although the proposed algorithm can be run in real-time, the computation time is non-negligible. Thus, the local trajectory should start at the future state expected after the computation time estimation.
SECTION VI.
Conclusion

In this paper, we presented a planning algorithm that can be run under disturbances in unknown environments, while guaranteeing safety without emergency brakes. We first start by planning global and local trajectories. A loop of sequentially composed funnels is constructed starting from the end of the local trajectory. Requiring the FRS of the local trajectory to lie within the funnel loop entrance guarantees that the system can be driven robustly into the funnel loop, in which it can stay permanently without collision, seeking for the chance of trajectory update. Experiment results showed that the planner can generate safe trajectories in real-time on onboard computers. It also demonstrated that the proposed algorithm is resilient to map changes, as the funnel loop is built locally.

Future work may include: enhancing the global planner so that it does not repeat planning through unreachable spaces; exploiting other symmetries in the funnel planning step, e.g., rotation; and extending this algorithm to multi-agent systems.

Authors
Figures
References
Keywords
Metrics
Media
Footnotes
   Back to Results   
More Like This
Comparing temporally aware mobile robot controllers built with Sun's Java Real-Time System, OROCOS's real-time toolkit and player

2010 IEEE/RSJ International Conference on Intelligent Robots and Systems

Published: 2010
Performance Evaluation of Real-Time System for Vision-Based Navigation of Small Autonomous Mobile Robots

2019 10th International Conference on Dependable Systems, Services and Technologies (DESSERT)

Published: 2019
Show More
References
References is not available for this document.
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
