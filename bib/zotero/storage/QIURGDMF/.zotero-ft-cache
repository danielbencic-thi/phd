2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) September 27 - October 1, 2021. Prague, Czech Republic

2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) | 978-1-6654-1714-3/21/$31.00 ©2021 IEEE | DOI: 10.1109/IROS51168.2021.9636846

Trajectory Splitting: A Distributed Formulation for Collision Avoiding Trajectory Optimization
Changhao Wang1, Jeffrey Bingham2, and Masayoshi Tomizuka1

Abstract— Efﬁcient trajectory optimization is essential for avoiding collisions in unstructured environments, but it remains challenging to have both speed and quality in the solutions. One reason is that second-order optimality requires calculating Hessian matrices that can grow with O(N2) with the number of waypoints. Decreasing the waypoints can quadratically decrease computation time. Unfortunately, fewer waypoints result in lower quality trajectories that may not avoid the collision. To have both, dense waypoints and reduced computation time, we took inspiration from recent studies on consensus optimization and propose a distributed formulation of collocated trajectory optimization. It breaks a long trajectory into several segments, where each segment becomes a subproblem of a few waypoints. These subproblems are solved classically, but in parallel, and the solutions are fused into a single trajectory with a consensus constraint that enforces continuity of the segments through a consensus update. With this scheme, the quadratic complexity is distributed to each segment and enables solving for higherquality trajectories with denser waypoints. Furthermore, the proposed formulation is amenable to using any existing trajectory optimizer for solving the subproblems. We compare the performance of our implementation of trajectory splitting against leading motion planning algorithms and demonstrate the improved computational efﬁciency of our method.
I. INTRODUCTION
Finding optimal, collision-free trajectories is important for robots to interact with people and the environment. Sampling and optimization are two of the most powerful ways to achieve the goal. Optimization allows deﬁning the problem in terms of constraints and ﬁnding solutions that optimize performance. Currently, collocation-based optimization methods, such as TrajOpt [1], solve a non-linear program (NLP) using non-linear optimization algorithms like sequential quadratic programming (SQP) [2]. The structure of the NLP leads to at least O(N2) time complexity concerning the number of waypoints to satisfy second-order optimality criteria. Therefore, increasing the density of waypoints quadratically increases the computation time. In comparison, sampling-based planners, such as rapidly-exploring random trees (RRT) [3], are able to be parallelized to achieve a higher computation efﬁciency.
Our goal is to combine the expressiveness and quality of optimization-based techniques with the computational advantages of parallelization in sampling-based methods. We propose a method that separates the trajectory optimization problem into a set of subproblems that can be solved in a distributed manner.
1Dept. of Mechanical Engineering, University of California, Berkeley, CA, USA. {changhaowang, tomizuka} @berkeley.edu
2 X, the Moonshot Factory, Mountain View, CA, USA. jeffbingham@x.team

Prevailing methods for parallel or distributed optimization mainly focus on multi-agent planning [4], [5] with limited research applying the techniques to single-agent planning. Brendan. et al [6] pioneered in this ﬁeld by applying the operator splitting method to convex optimal control problems. They proposed splitting an optimal control problem into subproblems by constraint. This idea is further studied in [7] and applied to more challenging control scenarios. If it were applied to a collision-avoiding trajectory problem for a robot, two subproblems would be created. One subproblem would satisfy only the robot dynamics and the other would only avoid the collision. These problems would then be fused using an iterative consensus update to ﬁnd the optimal trajectory. However, even with this splitting scheme, the number of variables for each subproblem remains the same, and it still suffers from the O(N2) time complexity. Furthermore, splitting by constraint may create subproblems with different complexity. Some subproblems may dominate the computation time, and others should wait until the most complicated subproblem is ﬁnished in order to begin the next consensus iteration.
To deal with those problems, we propose to split the problem by the path variables, creating subproblems for segments of the trajectory. In this way, the problem complexity can be equally distributed. These segments are then fused together using a consensus update scheme similar to the method described above. This proposed method of “trajectory splitting” exploits the observation that complexity decreases as path-length decreases and in this way offers a more efﬁcient approach of solving trajectory optimization for certain classes of problems. Moreover, the proposed splitting scheme is amenable to be incorporated with any existing trajectory optimizers to solve the subproblem. To the authors’ knowledge, this is the ﬁrst approach to parallelizing optimization-based trajectory planning by splitting the path variables in order to equally distribute the problem complexity to each trajectory segment. The contributions of the proposed method are listed as follows:
• A novel formulation of trajectory optimization problems via splitting the trajectory into segments that can equally distribute the problem complexity.
• A distributed optimization algorithm to solve the proposed formulation for better computational efﬁciency.
• An implementation of the trajectory splitting algorithm with a state-of-the-art collision checker and optimization solver.
• Comprehensive comparisons of the proposed trajectory

978-1-6654-1714-3/21/$31.00 ©2021 IEEE

8113

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on May 18,2022 at 13:46:09 UTC from IEEE Xplore. Restrictions apply.

splitting algorithm against existing methods using both and alternating direction method of multipliers (ADMM) is

simulation and real-world experiments.

illustrated in Section III-B.

II. RELATED WORKS
Motion planning algorithms are nominally classiﬁed into two broad categories, sampling, and optimization. Sampling methods are well suited for problems where any feasible solution is acceptable and gradient information is difﬁcult or expensive to compute. Probabilistic roadmap (PRM) [8] solves the planning problem by constructing a complete map of the workspace and then using a search algorithm to ﬁnd a feasible path from the map. One major problem of PRM is the computation time. It is time-consuming to build a complete roadmap, especially in high-dimensional space. RRT [3] deals with this problem by incrementally building a graph and checking feasible paths at the same time. In practice, RRT and its variants [3], [9] are still some of the most powerful ways to deal with the planning problem. They are efﬁcient and can easily be parallelized [3] for even better performance. However, since sampling-based planners are stochastic, they may ﬁnd different solutions for the same problem, and the solution quality and the computation time may also have a large variance. This problem has been reported in several papers [10], [11]. It is still an active research area to improve the robustness of sampling planners.
Though sampling planners are effective to ﬁnd feasible paths, it is often preferable to obtain ‘optimal’ paths that satisfy an objective. RRT* [3], an optimal variant of traditional RRT, is able to obtain optimal paths with the help of an additional ‘rewire’ operation. Exploiting the probabilistic completeness property provides a theoretical guarantee of globally optimal solutions. However, in practice, the planner is only given ﬁnite time to ﬁnd a path and thus, RRT* performance declines sharply as the dimensionality of the scenario increases [11].
Optimization, on the other hand, provides a way to go beyond ﬁnding a feasible solution and offers a means to seek ‘better’ solutions based on an objective. State-of-theart trajectory optimization algorithms start with an infeasible solution and evolve a trajectory to minimize a deﬁned cost and satisfy all constraints. CHOMP [10] pioneered this approach for collision avoidance planning problems in robotics, proposing a covariant gradient descent update rule to optimize the trajectory. To deal with non-differentiable constraints, STOMP [12] proposed a stochastic update rule. TrajOpt [1] introduced an SQP formulation to solve the planning problems. Recently, there has been considerable progress in this ﬁeld [13], [14], and these efforts suggest new approaches to optimization-based planning has the potential to be both computationally efﬁcient and retain high-quality solutions.
III. MATHEMATICAL BACKGROUND
In this section, we introduce the preliminaries of the proposed method. The classic trajectory optimization formulation by collocation is introduced in Section III-A. The mathematical background of consensus optimization

A. Trajectory Optimization Formulation

A common discrete form of trajectory planning can be

formulated as an optimization problem with the following

form:

min c(τ)
τ

s.t. xi+1 = f (xi)

(1)

g(xi) ≤ 0

i = 1, · · · , N − 1

where τ = {x1, · · · , xN} denotes a discretized robot trajectory, and xi denotes the robot state (position, velocity, and acceleration). c(·) is a human designed cost function, f (·) may
include the robot kinematics or dynamics constraints, and g(·) is the robot state constraint. In this paper, we assume
the cost function and constraints are separable (or blockseparable) c(τ) = ∑Ni=1 ci(xi).

B. ADMM and Consensus Optimization
Consensus optimization [15] considers the problem with separable objectives:

N

∑ min

ci(xi)

x1,··· ,xN ,z∈RN i=1

(2)

s.t. xi = z i = 1, · · · , N

where xi is called a local variable, and z is a global value that each local variable tries to achieve.
ADMM [15], an augmented Lagrangian method [16], is able to parallelize the consensus problem and solve it efﬁciently. The augmented Lagrangian of (2) is shown in (3), where yi denotes the Lagrange multiplier of the corresponding consensus constraint. Similar to penalty methods, the augmented Lagrangian adds an additional constraint term to the original Lagrangian in order to penalize the constraint violation, and ρ is a weight that controls the constraint violation.

N

∑ L = [ci(xi) + yTi (xi − z) + (ρ/2) xi − z 2

(3)

i=1

Based on the augmented Lagrangian in (3), ADMM can solve the original problem in a distributed way as shown in Fig. 1. First, ADMM initializes N separate agents (solver) in order to update each local variable xi. Then, a central unit collects the solution from the agent and updates the dual variable accordingly yi. The update rule is then given by:

xik+1

=

arg min
xi

[ci(xi) + yki T (xi − zk) + (ρ/2)||xi − zk||2]

yki +1 = yki + ρ(xik+1 + zk+1)

∑ zk+1

=

1 N

N
xik+1
i=1

(4)

8114

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on May 18,2022 at 13:46:09 UTC from IEEE Xplore. Restrictions apply.

ADMM Scheme
)" *",+"
Agent 1: Solve Subproblem 1

Central Unit: Update Dual Variables
)# *#,+#
Agent 2: Solve Subproblem 2

*$,+$

)$

Agent 3: Solve Subproblem 3

waypoint x&
%$%! x$!

splitting point
x$" %$%" x'

Obstacle

x#

x(

%$! = %$%! x#

x&

%$" = %$%"

x'

Obstacle x(

Consensus Optimization

(s!, "" denote the indices of splitting points. In this example "! = 2, "" = 4)

Fig. 1. An illustration of the ADMM update rule to solve consensus problems. ADMM solves the problem in a distributed manner, where it creates N separate agents to solve each subproblem. A central unit then collects the results obtained from each agent and updates the dual variable until a stopping criterion is met.
The convergence and optimality condition of ADMM is illustrated in Theorem 1. For the convex consensus optimization problem, a globally optimal solution is guaranteed.
The ADMM algorithm has also been extensively applied to non-convex, coupling optimization problems [17], [18]. Recently, convergence criteria for general non-convex problems have been studied and we refer readers to [17] for further details. We will discuss convergence for our implementation and similar problems in Section IV-E. In summary, ADMM algorithms show amazing practical success in solving both convex and general nonlinear optimization problems even while the theoretical proof of convergence is forthcoming.
Assumption 1: ci(x), i = 1, · · · , N are closed, proper, and convex.
Assumption 2: The augmented Lagrangian L0 contains a saddle point
Theorem 1: Under Assumptions 1 and 2, the ADMM iteration satisﬁes the following [15]:
• Residual convergence: xi − z → 0 as k → ∞ • Objective convergence: ∑Ni=1 ci(xi) → f ∗ as k → ∞ • Dual convergence: yki → y∗i , i = 1, · · · , N as k → ∞ It is worth noticing that (2) is a simpliﬁed form of the consensus problem. For the general form [15], each local variable, or even each element, can have its own consensus constraints. The above update rule can be easily transformed to the general case by replacing the consensus constraint, and the optimality and convergence analysis still hold for the general formulation.
IV. TRAJECTORY SPLITTING ALGORITHM
Trajectory optimization aims at ﬁnding a smooth and collision-free trajectory between two predeﬁned states. Similar to previous methods [1], we formulate the motion planning problem as an NLP as introduced in Section III-A. While in contrast with other methods, which directly apply optimization algorithms (such as, covariant gradient descent or SQP) to solve the entire problem, we propose splitting the trajectory into several segments and solving them in a distributed manner for better computational efﬁciency. The splitting formulation as a consensus optimization will be introduced in Section IV-A, IV-B. The collision avoidance constraints will be formalized in Section IV-C. The optimization update rule will be explained in Section IV-D. In

Fig. 2. Illustration of trajectory splitting algorithm. The waypoints are
denoted by the yellow dots, and the orange dots are the splitting points xsi . The trajectory splitting algorithm is able to ﬁnd feasible trajectory pieces
in parallel and then connect them together.

the end, we provide the stopping criterion and convergence analysis of the proposed algorithm.

A. Intuition for Trajectory Splitting: A Three Waypoint Example

Let us begin with an example with three waypoints
x1, x2, x3. Consider we want to split the trajectory at x2 creating a leading trajectory of τ1 = {x1, x2}, and a trailing trajectory of τ2 = {x2, x3}. Here x2 is a slack variable that is deﬁned to be equal to x2. According to the consensus formulation in (2), in order to achieve the consensus between
x2 and x2, a global variable z is introduced to enforce this constraint. Therefore, we can rewrite the three waypoint
trajectory optimization problem in (1) as follows:

1

1

min
x1 ,x2 ,x2 ,x2 ,z

c1(x1) + 2 c2(x2) + 2 c2(x2) + c3(x3)

s.t. x2 = z, x2 = z

x2 = f (x1), x3 = f (x2)

(5)

g(xi) ≤ 0, i = 1, 2, 3

g(x2) ≤ 0

Notice that the problem is separable between these two trajectory pieces, except for the ﬁrst two consensus constraints. According to the consensus optimization update rule in (4), each trajectory segment τ1, and τ2 can be updated by solving the following optimization where the dual variable update follows the same manner as in (4).

min
x1 ,x2

c1(x1

)

+

1 2

c2(x2)

+

yT1

(x2

−

z)

+

(ρ

/2)

x2 − z

2

s.t. x2 = f (x1)

(6)

g(x1) ≤ 0, i = 1, 2

min
x2 ,x3

1 2

c2(x2

)

+

c3(x3)

+

yT2

(x2

−

z)

+

(ρ

/2)

x2 − z

2

s.t. x3 = f (x2)

g(x2) ≤ 0

(7)

g(x3) ≤ 0

8115

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on May 18,2022 at 13:46:09 UTC from IEEE Xplore. Restrictions apply.

Remark 1: Constraints can be incorporated into the objective function via indicator functions. Therefore, it does not affect the update rule for the ADMM formulation.
B. General Trajectory Splitting Formulation

the surfaces of the objects interpenetrate. We mathematically deﬁne the signed distance function between two objects A and B by:
sd(A, B) = dist(A, B) − penetration(A, B) (11)

Algorithm 1: Trajectory Splitting

Input: Trajectory: τi, Dual variables: yi,1, yi,2 1: while splitting tolerance (16) not satisﬁed do

2: for i = 1, · · · , M + 1 do

3:

τi ← Solve Eq. 10

4: end for

5: for i = 1, · · · , M do

6:

zi

=

1 2

(xsi

+ xsi )

7:

yi,1 = yi,1 + ρ(xsi − zi)

8:

yi,2 = yi,2 + ρ(xsi − zi)

9: end for

10: end while

11: Output: τi i = 1, · · · , M + 1

Consider we split the trajectory into M + 1 segments, and
the position that splitting happens is denoted by xsi , where si is the index of the i th splitting point on the original trajectory
as shown in Fig. 2. Similar to the previous example, we
introduce the slack variable xsi as a copy of the splitting point. In order to enforce that the trajectories are connected
with each other, a global variable zi is used for this constraint:

xsi = zi

(8)

xsi = zi, i = 1, · · · , M

and we use yi,1 and yi,2 to denote the Lagrangian multipliers of the consensus constraints above. Thus, we can formulate

the augmented Lagrangian Li for each trajectory piece as shown in (9). Then the primal update rule for each trajectory

segment is given in (10).

τik+1

=

min
τi

Li

s.t. x j+1 = f (x j)

g(x j) ≤ 0

(10)

∀x j ∈ τi

The overall algorithm is illustrated in Alg. 1. In practice, the trajectory τ can be initialized as a straight line that goes from the initial point to the target point, or it can be given as a feasible solution from sampling-based planners. The Lagrange multipliers yi,1, yi,2 can be initialized as zero vectors. The number of splitting M could be any integer that is smaller than the number of waypoints, and the waypoints are then uniformly separated into each subproblem.
C. Collision Avoidance Constraints
We consider collision-avoidance constraint g(xi) ≤ 0 as a function of signed distance [1]. As shown in Fig. 3, the signed distance function denotes the minimum distance between two objects, where the sign is determined by whether

where the ‘dist’ function is deﬁned as the minimum translation distance to just cause contact between the surfaces of a pair of objects:

dist = inf{ T : ∃pA ∈ A, pA + T ∈ B}

(12)

and similarly, the ‘penetration’ function denotes the minimum translation that moves the two objects out of contact:

penetration = inf{ T : ∀pA ∈ A, pA + T ∈/ B} (13)

In our implementation, we approximated the signed distance using methods from the Flexible Collision Library (FCL) [19]. In turn, this signed distance method was used to formulate a collision-avoidance constraint where the signed distance between the robot and each obstacle had a strictly positive value along the entire trajectory. An additional approximation was adopted by utilizing the Jacobian for the contact point from the signed distance, as introduced in [1]. With this technique, assume the object A is a robot link and its position is determined by the robot state x. Then, the signed distance is deﬁned by contact points denoted by pA for the robot link and pB for an obstacle. A static assumption is made to arrive at the approximation given in (14) by assuming the contact point pA is not a function of x:

sdAB(x) ≈ nˆ(FAw(x)pA − FBw pB)

(14)

where FAw and FBw are the homogeneous transformation from A, and B frames to the world coordinate, and nˆ is the direction that points from pB to pA.
In addition, the gradient of this constraint can be computed
as a Jacobian of the signed distance sdAB with the following approximation:

∇sdAB(x) ≈ nˆT JpA (x)

(15)

where JpA denotes the robot translation Jacobian at pA.

D. Optimization
The key to this algorithm is the separation of the trajectory optimization problem into several subproblems that can be solved independently. For each subproblem in (10), it is expressed in a standard form for trajectory optimization; therefore, existing optimization algorithms, such as gradient descent, SQP [2], CHOMP [10], and TrajOpt [1] can be directly applied.
In our implementation, we use the optimization library IPOPT [20] as the basis of our subproblem solver. IPOPT implements a primal-dual interior-point ﬁlter line search algorithm to solve the general nonlinear optimization problems, and the convergence of this algorithm is proved in [21].

8116

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on May 18,2022 at 13:46:09 UTC from IEEE Xplore. Restrictions apply.

∑ L1

=

s1 −1 j=1

c

j (x

j)

+

1 2

cs1 (xs1 )

+

yT1,1(xs1

−

z1)

+

(ρ /2)

xs1 − z1

2

···

∑ Li

=

1 2 csi−1 (xsi−1 ) +

si+1 −1
c j(x j) +
j=si+1

1 2

csi

(xsi

)

+

yTi−1,2(xsi−1

− zi−1) + (ρ/2)

xsi−1 − zi−1

2 + yTi,1(xsi − zi) + (ρ/2)

xsi − zi

2

···

∑ LM

=

N
c j(x j) +
j=sM +1

1 2

csM

(xsM

)

+

yTM,1

(xsM

− zM) + (ρ/2)

xsM − zM

2

(9)

A

!"

#"

!!

B

A
!! !" #"
B

(a) In Collision: (b) Collision Free:

sd(A,B) < 0

sd(A,B) > 0

Fig. 3. Illustration of signed distance function. The signed distance value is positive if objects are collision free, and the value is negative if they are in collision.

E. Stopping Criterion and Convergence Analysis

Similar to [22], we choose to use the primal residuals as the stopping criterion:

rk 2 ≤ ε

(16)

where ε is a predeﬁned positive scalar, and splitting tolerance rk is the average of constraint violations:

∑ rk

1M

2

=

( M i=1

qksi − qsi k

2

)

1 2

(17)

The convergence of the proposed trajectory splitting algorithm can be divided into three cases:

• Convex: According to Theorem 1, if the objective functions and constraints are convex (the equality constraint should be linear), the proposed trajectory splitting algorithm is guaranteed to converge to a global optimal solution. An example of this type of problem is the Linear-Quadratic Regulators (LQR). For the LQR problem, the trajectory splitting algorithm is guaranteed to ﬁnd a global optimal solution.
• Restricted prox-regular [17]: Recent studies provide the convergence of ADMM on non-convex, non-smooth problems. [17] proves the condition that if the objectives and constraints satisfy the restricted prox-regular condition, then the ADMM algorithm will converge to a stationary point. In our scenario, if the dynamics constraint f (·) is linear, and the nonlinear collision constraint g(·) is restricted prox-regular, then the solution (τ, y, z)

obtained from Alg. 1 will converge to a stationary point (τ∗, y∗, z∗) for the augmented Lagrangian in (9). According to [17], restricted prox-regular is a weaker condition than prox-regular and semi-convex [23]. As studied in [14], the signed distance function between two convex objects is semi-convex; therefore, a large set of trajectory optimization problems fall into this category. This includes mobile robot planning with convex obstacles and linear kinematics (as shown in Section V-B). • General non-convex: For the general non-convex case, the convergence of ADMM is still an active ﬁeld of optimization research. The multi-joint robotic motion planning problem falls into this category. Though the signed distance function of convex obstacles satisﬁes the semi-convex condition, the nonlinear robot forward kinematics violates these conditions and makes the planning problem extremely challenging. This is a common problem encountered by all the existing trajectory optimization algorithms. Though there is no theoretical proof of convergence yet, our practical observation from simulation and experiments show that the trajectory splitting algorithm converges reasonably for this challenging scenario (as shown in Section V-C, and Section V-D).

V. SIMULATION AND EXPERIMENTS

A. Robot Model

The proposed trajectory splitting algorithm is tested in two
scenarios. The ﬁrst scenario is a simple 2D case with a sphere
obstacle (as shown in Fig. 5), and the second is on a 6-DoF
FANUC LRMATE 200iD robot (as shown in Fig. 4).
For the 2D example, the robot state x is deﬁned as the Cartesian position, and velocity in 2D: x = [px, py, p˙x, p˙y]T , where px, and py denote the position in x and y axes.
For the multi-jointed robot case, the robot state x is selected to include the robot joint angle θ ∈ R6, joint velocity θ˙ ∈ R6, and joint acceleration θ¨ ∈ R6. For optimization, we use linear double-integrator dynamics as the equality
constraint:

θi+1 θ˙i+1

=I 0

TI I

θi θ˙i

+

0 TI

θ¨i

(18)

8117

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on May 18,2022 at 13:46:09 UTC from IEEE Xplore. Restrictions apply.

Fig. 4. Simulation benchmark results showing four different planning problems and the results obtained by the trajectory splitting algorithm in the bookcase scenario. The algorithm is able to ﬁnd the local optimal solution for each trajectory segment efﬁciently and connect them together in a smooth trajectory.

TABLE I SIMULATION BENCHMARK OF 6-DOF ROBOT PLANNING

Algorithm Average Time (s) Path Length (rad) Success Rate

RRT 0.254 11.24 25/25

LBKPIECE 0.218 10.97 25/25

RRT* 5.001 9.03 25/25

CHOMP 0.267 7.15 21/25

IPOPT 0.489 7.23 23/25

TrajSplit 5 0.381 7.82 21/25

TrajSplit 3 0.178 7.43 23/25

1

waypoints

0.9

splitting points

splitting points
0.8

0.7

0.6

Obstacle

0.5

0.4

0.3

0.2

0.1

0

0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

(a) Iteration 1

1

waypoints
0.9
splitting points

0.8

splitting points

0.7

0.6

Obstacle

0.5

0.4

0.3

0.2

0.1

0

0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

(c) Iteration 5

1

waypoints

0.9

splitting points

splitting points
0.8

0.7

0.6

Obstacle

0.5

0.4

0.3

0.2

0.1

0

0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

(b) Iteration 2

1

waypoints
0.9
splitting points

0.8

splitting points

0.7

0.6

Obstacle

0.5

0.4

0.3

0.2

0.1

0

0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

0.9

1

(d) Iteration 10

Fig. 5. A 2D example of trajectory splitting. The planning problem is split into three segments and solved in a distributed manner. The trajectory is initialized using linear interpolation. As the optimization begins, each segment is very short and there is a large splitting error since the individual problems have an objective that minimizes segment distance. As the optimization progresses, the consensus update reduces the splitting error and a continuous, smooth trajectory is obtained.

where 0 ∈ R6×6, and I ∈ R6×6 are the zero and identity matrices, and T is a positive scalar that denotes the robot travel time in-between each consecutive waypoint pair. The objective function is selected to minimize the summation of joint velocities in (19) for the minimum path length trajectory.

N

c(x) = ∑ θ˙i 2

(19)

i=1

B. Simulation in 2D

We ﬁrst evaluate the effectiveness of the proposed trajectory splitting algorithm in a 2D scene with a sphere obstacle.

Fig. 6. Parameter sweeps for the trajectory splitting algorithm, where Trajsplit 2, Trajsplit 3, Trajsplit 5 denote using the splitting algorithm to separate a trajectory into two, three, and ﬁve pieces. Computation time decreases as splitting error tolerance in the stopping criterion is increased. In general, increasing the number of split segments does not guarantee a shorter computation time. For these problems, three segments provide a nice balance between the number of ADMM iterations and subproblem complexity.

The collision avoidance constraint is formulated as:

||

px py

−

pox poy

||2 ≥ ro2

(20)

where po and ro denote the obstacle center position and its radius. As we can see from the simulation results in Fig. 5, the trajectory is split into three segments. The evolution of the solution initially produces short segments with a large splitting error that is reﬁned through the consensus iteration to produce the ﬁnal smooth trajectory.

C. Simulation on Multi-jointed Robot
We benchmarked the proposed trajectory splitting algorithm against existing state-of-the-art motion planners and optimization solvers, which include sampling-based methods RRT, RRT*, LBKPIECE in OMPL/Moveit, and an

8118

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on May 18,2022 at 13:46:09 UTC from IEEE Xplore. Restrictions apply.

Fig. 7. Parameter sweeps for the trajectory splitting algorithm, where Trajsplit 2, Trajsplit 3, Trajsplit 5 denote using the splitting algorithm to separate a trajectory into two, three, and ﬁve pieces. Reducing the splitting error tolerance results in smoother trajectories at the cost of greater computation time. These problems show a good reasonable trade-off in quality and performance by setting the splitting error tolerance to 10 degrees with two or three split segments.
optimization-based method CHOMP in MoveIt using default parameters. We also implemented an optimization baseline using IPOPT with FCL as the collision checker. Our implementation of the trajectory splitting planner is based on the IPOPT baseline and uses the python multiprocess library to achieve parallelization.
Fig. 4 shows the 4 of the benchmark results obtained from the proposed trajectory splitting algorithm. We manually selected 5 start poses and 5 end poses to construct 25 unique planning problems. The planning time limit is set to 5 seconds. Since MoveIt planners can only compute paths instead of trajectories, to make the comparison fair, we also only compute the joint path and ignore the dynamics constraint in (18) for this benchmark. The initialization for the IPOPT baseline and the trajectory splitting algorithms is set to be a straight line.
Table. I shows the benchmark results. TrajSplit 3 and TrajSplit 5 denote the proposed splitting methods that split a trajectory into 3 and 5 segments respectively. Samplingbased planners, such as RRT, and LBKPIECE performs well in these tasks. They all achieve a 100% success rate in this setting. However, since those sampling planners are stochastic, they may generate different paths for the same problem, and the computation time and solution quality also has a very large variance (for example, RRT is normally efﬁcient to deal with those problems, but sometimes it may take over 3.7 seconds to obtain a sub-optimal solution). We noticed in our benchmarking, that the sampling-based planners sometimes generated non-intuitive motion with much larger average path lengths than the optimization-based planners. RRT* is a sampling-based method that tries to deal with the optimality problem. However, for all our tasks, RRT* was not able to ﬁnd an optimal solution within the 5 seconds limit and the solution quality was qualitatively poor relative to the other optimization-based planners we compared. Similar results have been reported in other paper [11]. These data corroborate that RRT* is not as competitive in terms of

computation efﬁciency.
The CHOMP algorithm in MoveIt was able to obtain optimal paths efﬁciently. However, the robustness of the optimization-based planner was low. In our benchmark, the planner was often caught in a local minimum and incapable of ﬁnding a feasible solution when the start pose was close to the obstacle. In contrast, the IPOPT baseline was slower but more robust, and able to solve most of the problems, which was expected as IPOPT is built for general NLP and not for speed. Our proposed trajectory splitting method demonstrated a nice balance between speed and solution quality when the splitting error tolerance was set to 10 degrees and split into three segments. The splitting error is negligible considering the robot has 6 DOF. Trade-offs in quality and speed were straightforward by adjusting the number of splits and tolerance of the splitting error. However, the most efﬁcient setup required balancing the number of segments that may beneﬁt the computation time for a single primal update with additional ADMM iterations that may be required to meet the stopping criterion. The typical failure case of the proposed trajectory splitting algorithm comes from the misalignment of the splitting point that penetrates the obstacle. Due to the splitting of the trajectory, each segment tends to keep away from the obstacle. When the obstacle is thinner than the distance that results from the splitting error tolerance, the intermediate trajectory may penetrate the obstacle. We will address this problem in future work.
We further tested the behavior of our method by tuning hyperparameters: number of segments and splitting tolerance. We illustrate the variation of the computation time and path length for different splitting tolerance and different splitting segment numbers. As shown in Fig. 7, splitting a trajectory into more pieces resulted in a longer path length due to the splitting residual. In practice, there was a trade-off between the computation time and the splitting residual tolerance as shown in Fig. 6. To balance the solution quality and the efﬁciency, people may need to carefully tune these two parameters for different types of requirements.
D. Experiments
We tested the effectiveness of the trajectory splitting algorithm in a real-world scenario using a 6 DOF FANUC LRMATE 200id robot. As shown in Fig. 8, the robot picks a bottle from a wooden chair and places it into a bookshelf. The trajectory was initialized with linear interpolation in joint space and the problem was split into two segments with a splitting tolerance of 10 degrees. The solution was obtained from Alg. 1, and the assembled trajectory was sent as a list of joint space positions to the robot for execution. The snapshots from the video show the continuity of the complete trajectory, free from any collision. Note that with this splitting error tolerance a small motion artifact is observable between the two split segments.

8119

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on May 18,2022 at 13:46:09 UTC from IEEE Xplore. Restrictions apply.

Initial Pose

Splitting Point

Obstacle Avoidance

Target Pose

Fig. 8. Experiment snapshots. The robot picks a bottle onto the bookshelf. Using the proposed trajectory splitting framework, the problem is split into two pieces and solved in a distributed manner. The splitting happens in the middle of the trajectory, and we can observe a tiny splitting residual during the execution in the experiment video.

VI. CONCLUSIONS
Modern computational hardware is replete with opportunities for parallel computation, e.g. multi-core CPUs, GPUs, and TPUs. Our algorithm offers a novel scheme to exploit parallelism in trajectory optimization and a framework for balancing trajectory quality with computational speed. Planning tasks that require fast solve times can choose fewer segments and looser splitting tolerances to obtain quick, reasonable quality solutions. Conversely, high-accuracy trajectories can be obtained with increased segments and tighter splitting tolerance with modest increases in planning time.
For the limitations, the current implementation requires tuning of hyper-parameters. Furthermore, tight-tolerance for reducing jumps in the trajectory at the split points currently requires many more ADMM updates to achieve consensus, which can eat away gains made through parallelizing the subproblems. In future works, we plan to incorporate advances from Fast ADMM [24] to address slow consensus convergence and explore using different optimizers for solving the subproblems to further improve robustness and speed.
REFERENCES
[1] J. Schulman, J. Ho, A. X. Lee, I. Awwal, H. Bradlow, and P. Abbeel, “Finding locally optimal, collision-free trajectories with sequential convex optimization.” in Robotics: science and systems, vol. 9, no. 1. Citeseer, 2013, pp. 1–10.
[2] P. T. Boggs and J. W. Tolle, “Sequential quadratic programming,” Acta numerica, vol. 4, pp. 1–51, 1995.
[3] S. M. LaValle, Planning algorithms. Cambridge university press, 2006.
[4] F. Rey, Z. Pan, A. Hauswirth, and J. Lygeros, “Fully decentralized admm for coordination and collision avoidance,” in 2018 European Control Conference (ECC). IEEE, 2018, pp. 825–830.
[5] M. Li, N. Cheng, J. Gao, Y. Wang, L. Zhao, and X. Shen, “Energyefﬁcient uav-assisted mobile edge computing: Resource allocation and trajectory optimization,” IEEE Transactions on Vehicular Technology, vol. 69, no. 3, pp. 3424–3438, 2020.
[6] B. O’Donoghue, G. Stathopoulos, and S. Boyd, “A splitting method for optimal control,” IEEE Transactions on Control Systems Technology, vol. 21, no. 6, pp. 2432–2442, 2013.
[7] V. Sindhwani, R. Roelofs, and M. Kalakrishnan, “Sequential operator splitting for constrained nonlinear optimal control,” in 2017 American Control Conference (ACC). IEEE, 2017, pp. 4864–4871.
[8] L. E. Kavraki, P. Svestka, J.-C. Latombe, and M. H. Overmars, “Probabilistic roadmaps for path planning in high-dimensional conﬁguration spaces,” IEEE transactions on Robotics and Automation, vol. 12, no. 4, pp. 566–580, 1996.

[9] J. J. Kuffner and S. M. LaValle, “Rrt-connect: An efﬁcient approach to single-query path planning,” in Proceedings 2000 ICRA. Millennium Conference. IEEE International Conference on Robotics and Automation. Symposia Proceedings (Cat. No. 00CH37065), vol. 2. IEEE, 2000, pp. 995–1001.
[10] M. Zucker, N. Ratliff, A. D. Dragan, M. Pivtoraiko, M. Klingensmith, C. M. Dellin, J. A. Bagnell, and S. S. Srinivasa, “Chomp: Covariant hamiltonian optimization for motion planning,” The International Journal of Robotics Research, vol. 32, no. 9-10, pp. 1164–1193, 2013.
[11] J. Meijer, Q. Lei, and M. Wisse, “Performance study of single-query motion planning for grasp execution using various manipulators,” in 2017 18th International Conference on Advanced Robotics (ICAR). IEEE, 2017, pp. 450–457.
[12] M. Kalakrishnan, S. Chitta, E. Theodorou, P. Pastor, and S. Schaal, “Stomp: Stochastic trajectory optimization for motion planning,” in 2011 IEEE international conference on robotics and automation. IEEE, 2011, pp. 4569–4574.
[13] M. Mukadam, J. Dong, X. Yan, F. Dellaert, and B. Boots, “Continuoustime gaussian process motion planning via probabilistic inference,” The International Journal of Robotics Research, vol. 37, no. 11, pp. 1319–1340, 2018.
[14] C. Liu, C.-Y. Lin, and M. Tomizuka, “The convex feasible set algorithm for real time optimization in motion planning,” SIAM Journal on Control and optimization, vol. 56, no. 4, pp. 2712–2733, 2018.
[15] S. Boyd, N. Parikh, and E. Chu, Distributed optimization and statistical learning via the alternating direction method of multipliers. Now Publishers Inc, 2011.
[16] D. P. Bertsekas, “Nonlinear programming,” Journal of the Operational Research Society, vol. 48, no. 3, pp. 334–334, 1997.
[17] Y. Wang, W. Yin, and J. Zeng, “Global convergence of admm in nonconvex nonsmooth optimization,” Journal of Scientiﬁc Computing, vol. 78, no. 1, pp. 29–63, 2019.
[18] Q. Liu, X. Shen, and Y. Gu, “Linearized admm for nonconvex nonsmooth optimization with convergence analysis,” IEEE Access, vol. 7, pp. 76 131–76 144, 2019.
[19] J. Pan, S. Chitta, and D. Manocha, “Fcl: A general purpose library for collision and proximity queries,” in 2012 IEEE International Conference on Robotics and Automation. IEEE, 2012, pp. 3859– 3866.
[20] A. Wa¨chter and L. T. Biegler, “On the implementation of an interiorpoint ﬁlter line-search algorithm for large-scale nonlinear programming,” Mathematical programming, vol. 106, no. 1, pp. 25–57, 2006.
[21] ——, “Line search ﬁlter methods for nonlinear programming: Motivation and global convergence,” SIAM Journal on Optimization, vol. 16, no. 1, pp. 1–31, 2005.
[22] Z. Zhou and Y. Zhao, “Accelerated admm based trajectory optimization for legged locomotion with coupled rigid body dynamics,” in 2020 American Control Conference (ACC). IEEE, 2020, pp. 5082–5089.
[23] A. Colesanti and D. Hug, “Hessian measures of semi-convex functions and applications to support measures of convex bodies,” manuscripta mathematica, vol. 101, no. 2, pp. 209–238, 2000.
[24] T. Goldstein, B. O’Donoghue, S. Setzer, and R. Baraniuk, “Fast alternating direction optimization methods,” SIAM Journal on Imaging Sciences, vol. 7, no. 3, pp. 1588–1623, 2014.

8120

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on May 18,2022 at 13:46:09 UTC from IEEE Xplore. Restrictions apply.

