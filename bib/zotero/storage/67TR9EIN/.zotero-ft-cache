2018 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) Madrid, Spain, October 1-5, 2018

A Topology-based Path Similarity Metric and Its Application to Sampling-based Motion Planning
Jory Denny, Kaiwen Chen, and Hanglin Zhou

Abstract— Many applications of robotic motion planning beneﬁt from considering multiple homotopically distinct paths rather than a single path from start to goal. However, determining whether paths represent different homotopy classes can be difﬁcult to compute. We propose metrics for efﬁciently approximating the homotopic similarity of two paths are, instead of verifying homotopy equivalence directly. We propose two metrics: (1) a naive application of local planning, a common subroutine of sampling-based motion planning, and (2) a novel approach that reasons about the topologically distinct portions of the workspace that a path visits. We present three applications of our metric to demonstrate its use and effectiveness: extracting topologically distinct paths from an existing roadmap, comparing paths for robot manipulators, and improving the computational efﬁciency of an existing samplingbased method, Path Deformation Roadmaps (PDRs), by over two orders of magnitude. We explore the trade-off between quality and computational efﬁciency in the proposed metrics.
I. INTRODUCTION
Motion planning is an important problem in many domains such as robotics, bioinformatics, virtual reality, and virtual prototyping [16]. These applications often involve planning for multi-agent systems [3], dynamically changing environments [28], or planning under uncertainty [14], where having many candidate solutions to the problem is beneﬁcial. Ideally, the candidate paths are different in nature and explore varying portions of the problem space. Differing paths are caused by obstacles in an environment. For example, a support pillar in the middle of a room creates two types of paths — those that go left and those that go right (Figure 1).
The set of paths that are equivalent in this sense belong to the same homotopy class [10]. Prior work has utilized homotopy classes for solving motion planning problems [4], [9], [11] or has focused on identifying homotopy classes [1], [2]. Determining if two solution paths are homotopy equivalent requires proving whether a continuous function that morphs one path into another does, or does not, exist — an operation that is potentially difﬁcult to compute.
We are concerned neither with the process of ﬁnding the candidate paths nor with proving homotopy equivalence. Instead, we propose two approximation techniques (Figure 1) for determining whether two paths might be homotopy equivalent: (1) Local Planner Success Similarity (LPSS), which uses visibility [13], [27] to analyze a candidate deformation function that morphs one path into another, and (2) Topology-Based Edit Distance Similarity (TBEDS), which compares the regions of the workspace visited by each path
Jory Denny, Kaiwen Chen, and Hanglin Zhou are with the Spider Robotics Lab (SpiRoL), Department of Mathematics and Computer Science, University of Richmond, VA, USA, jdenny@richmond.edu.

(a) Local Planner Success Similarity (LPSS)

(b) Topology-Based Edit Distance Similarity (TBEDS)

Fig. 1. Example path comparison using the proposed similarity metrics.

to give a topologically informed likelihood for whether or not a deformation function exists. We demonstrate how these approximation techniques can be applied in sampling-based motion planning. Our speciﬁc contributions include:
• a deﬁnition and discussion of path similarity, • the presentation of two novel similarity metrics: (1)
local planner success similarity and (2) topology-based edit distance similarity, and • demonstration of the technique to extracting distinct paths from an existing roadmap, comparing paths for robot manipulators, and improving the efﬁciency of a known sampling-based method, Path Deformation Roadmaps (PDRs), by over two orders of magnitude.
We consider our metrics complementary and explore the trade-off between the accuracy of the metric and its computational efﬁciency.
II. PRELIMINARIES
We deﬁne and review relevant terms for understanding our problem and metrics. Additionally, we highlight important related work.
A. Motion Planning
In this paper, we consider holonomic robots with d degrees of freedom (DOFs). DOFs parameterize a unique placement of the robot (center of mass position, orientation, joint angles, etc.) in its two- or three-dimensional world, or workspace. A conﬁguration q = x1, x2, . . . , xd is a speciﬁcation of the values for the DOFs, where xi is the ith DOF. The set of all possible conﬁgurations is called the conﬁguration space (Cspace) [18], and it can be partitioned into two main subsets: free space (Cfree) and obstacle space (Cobst). These two subsets represent all possible valid, e.g., collision-free, and invalid conﬁgurations respectively. In general, it is infeasible to explicitly compute a representation of Cobst [24].

978-1-5386-8094-0/18/$31.00 ©2018 IEEE

6498

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 16,2022 at 07:03:29 UTC from IEEE Xplore. Restrictions apply.

Although it is not the focus here, we review an example motion planning approach, Probabilistic RoadMaps (PRMs) [15], in order to give an understanding of how solution paths can be found and given as input into our metrics. PRMs construct a map of Cfree by ﬁrst randomly sampling valid conﬁgurations. Nearby samples are then connected by validating simple paths between them, which form the edges of the map. A local planner, e.g., straight-line interpolation, is an algorithm used to verify these transitions. Finally, start and goal conﬁguration pairs are connected to the roadmap and a graph search, e.g., A∗, is used to extract a solution.
We deﬁne a path, Deﬁnition 1, as a sequence of adjacent conﬁgurations. When comparing two paths of differing lengths, there could be a large difference in numbers of conﬁgurations in each sequence. To facilitate this representational issue, we use a secondary deﬁnition of paths based on a parametric representation of the trajectories. t-resolution paths, Deﬁnition 2, are a sequence of conﬁgurations along a path discretized at resolution steps in the parametric form. Due to this, two t-resolution paths will have the same number of conﬁgurations in each sequence, and we can carefully choose the resolution to be appropriate for use in our metrics. These deﬁnitions are similar to those found in path smoothing and modiﬁcation [8].
Deﬁnition 1: A path π = {q1, q2, . . . , qm} is a contiguous sequence of conﬁgurations. Two conﬁgurations qi and qi+1 are adjacent if δ(qi, qi+1) ≤ r, where δ is a distance function and r is a problem speciﬁc resolution.
Deﬁnition 2: Let π = {q1, q2, . . . , qm} be a path. The tresolution path τ of π is a contiguous sequence of conﬁgurations discretized at tres steps, where tres is a resolution, from a parametric representation t ∈ [0, 1] of π, where t = 0 is q1, t = 1 is qm. Let τ k denote the kth conﬁguration of τ , where k ∈ [0, 1].
B. Topology
In this section, we review important aspects of topology related to our study: homotopy classes and Reeb Graphs.
1) Homotopy: Deﬁnition 3 presents the concept of homotopy equivalence [10] — loosely, it is the concept that two paths visit the same parts of Cspace. Further, Deﬁnition 4 shows that homotopy classes [10] are a set of pairwise homotopy equivalent paths. Homotopy classes group portions of the space together in a semantic sense. As an example, consider a fork in a road. There is in general an inﬁnite set of paths and combination of footstep placements along the paths, but they can be grouped into two classes: those that take the left path and those that take the right path.
Deﬁnition 3: Two paths π1, π2 ∈ Cfree (or t-resolution paths τ1 and τ2) are homotopy equivalent if and only if a function exists that continuously deforms π1 to π2 in Cfree (τ1 to τ2), i.e., without transitioning through Cobst.
Deﬁnition 4: A homotopy class is a set of paths Π (or tresolution paths) such that all pairs πi, πj ∈ Π are homotopy equivalent.
These concepts are fundamental to motion planning and deﬁne the basis of many methods. As an example, geometric

(a) Tetrahedralization

(c) Arc 0

(e) Arc 2

(b) Reeb graph

(d) Arc 1

(f) Arc 3

Fig. 2. Example computation of a Reeb graph from a tetrahedralization. (a) Tetrahedralization of an environment. (b) Reeb graph formed from the tetrahedralization. (c-f) The tetrahedrons that are mapped to each Reeb Arc.

methods [4], [9], [11] use mathematical reasoning to represent homotopy classes and ﬁnd optimal planning solutions but are inefﬁcient for many planning problems.
Certain sampling-based methods are topologically inspired. Visibility-based PRMs [27] represent the space using a few “well placed” conﬁgurations. In this way, this method creates roadmaps that guarantee coverage and connectivity in at least one homotopy class. This method was extended to preserve homotopy classes [25] by checking not only visibility constraints but also merging portions of a roadmap that map to the same homotopy class. This class of methods attempts to introduce and deﬁne useful cycles into PRMs. Path Deformation Roadmaps (PDRs) further reduces the size of roadmaps based on this concept [13]. This methodology uses similar, but distinct, techniques to the ﬁrst metric we propose. Other approaches have discussed and incorporated useful cycles [6], [8], [20], [28].
Algorithms have been proposed that explicitly identify and represent homotopy classes using sophisticated mathematical reasoning [1], [2]. The aim of these techniques is usually to ﬁnd optimal solutions or paths constrained within a speciﬁc homotopy class. These methods could themselves inform a more expensive metric of comparing homotopy equivalence in the future. As such, they are considered complementary to our proposed work.
2) Reeb Graphs: Concise representations of all homotopy classes of a topological space exist. One such representation, a Reeb Graph [23] represents transitions in level sets of a real-valued function on a manifold. The nodes of a Reeb Graph encode critical values of the function, referred to as a Morse function, and the edges, or Reeb Arcs, are the topological transitions between them. For example, Figure 2(b) is a Reeb Graph for the space shown in Figure 2(a), where the y-value of any point is the value of the Morse function. Reeb Graphs have been applied to numerous domains and problems in computational geometry and computer graphics such as shape matching [12], iso-surface remeshing [30],

6499

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 16,2022 at 07:03:29 UTC from IEEE Xplore. Restrictions apply.

simpliﬁcation [29], and sampling-based planning [5]. To compute a Reeb Graph from a workspace, we use the
algorithm found in [21]. Other methods have since improved on the complexity and could be alternatively used [7]. This algorithm begins by computing a Delaunay tetrahedralization of the free workspace [26] (gray in Figure 2(a)). A Reeb Graph is initialized from the 1-skeleton of the tetrahedralization (vertices and edges of the tetrahedrons form nodes and Reeb Arcs respectively). Then, the 2-skeleton of the tetrahedralization (facets of the tetrahedrons) is used to reduce the initial graph to be a true Reeb Graph that encodes topological information of the space. For all triangles of the 2-skeleton, the algorithm merges the three associated Reeb Arcs into two. A triangle is a safe criterion for merging as it represents a sector of topological equivalence. During post-processing, 2-nodes of the Reeb Graph are removed by merging the two associated Reeb Arcs into one. Figure 2(b) shows the resulting Reeb Graph from the tetrahedralization (Figure 2(a)). From our experience, a Reeb Graph from environments composed of over 2, 000 facets can be computed on the order of a few seconds.
It is important to note that critical points occur whenever there are two or more adjacent tetrahedra that have a pair of vertices that cannot be connected by a straight-line through free space — a critical point represents a divide in the free workspace volume. Thus, each Reeb Arc captures a distinct workspace homotopy class between two critical points.
During construction, related tetrahedra to Reeb Arcs are tracked. The related tetrahedra for each Reeb Arc in our example are shown in Figures 2(c)–2(f). It is important to observe that tetrahedrons are not unique to each Reeb Arc; they may correspond to more than one. A good example is that a tetrahedron related to a critical point is shared among all Reeb Arcs connected to the critical point.
III. ALGORITHMS FOR COMPUTING PATH SIMILARITY
We present the problem of approximating path similarity and explore the requirements for a high quality metric. After, we describe and discuss two similarity metrics that we consider to be complementary. The ﬁrst is based on a naive application of local planning, a common subroutine of sampling-based motion planners, and the second is rooted in a topological analysis of the paths in workspace.
A. Overview of Path Similarity
As discussed in Section II, all paths between a set start conﬁguration and goal conﬁguration pair can be classiﬁed into equivalence classes (i.e., homotopy classes). Determining if two paths are in the same homotopy class can be difﬁcult for the general case. Instead, we are interested in deﬁning a metric that approximates the likelihood that two paths are homotopy equivalent.
We deﬁne a path similarity metric, µ, as a function that takes as input two t-resolution paths and returns a real number in the range [0, 1]. For a high-quality metric, a zero value implies the paths are in distinct homotopy classes,

and a value of one implies that the paths are homotopy equivalent. All values in between deﬁne the likelihood that the paths are in (or not in) the same homotopy class.
B. Local Planner Success Similarity
We introduce a naive similarity metric based upon application of local planning, a common subroutine of samplingbased motion planners [15]. The metric, called Local Planner Success Similarity (LPSS), is shown in Algorithm 1. The metric essentially computes a ratio of successful local planning attempts to total attempts between conﬁgurations of the two paths with the same t value. In Figure 1(a), we show two example paths (green and magenta) and the local planning attempts between pairs of conﬁgurations along the paths (blue dashed lines are successful attempts, and red dashed lines are unsuccessful attempts).

Algorithm 1 Local Planner Success Similarity

Input: t-resolution Paths τ1, τ2, Local planner ∆ Output: Similarity s ∈ [0, 1]

1: s ← 0, n ← 0

2: for t ∈ [0, 1] at t-resolution increments do

3: if ∆(τ1t, τ2t) then

4:

s←s+1

5: n ← n + 1

6: return

s n

In LPSS, it is easy to verify that a metric value equal to one conﬁrms a linear transformation of one path into another up to a t-resolution, i.e., they are in the same homotopy class. A value close to one implies that a transformation is likely to exist, but the linear transformation is not it. A value close to zero implies that a transformation is unlikely to exist that morphs one path into another, i.e., the paths are in distinct homotopy classes. We note that this algorithm will not give a value of zero because the start and goal conﬁgurations of the paths are identical, i.e., a local plan between them is trivially successful.
By only verifying one possible transformation, LPSS does not speciﬁcally use any topological information in determining similarity. However, a strength of the metric is that when two paths are determined to be similar, we not only know the equivalence class but also a function that deforms one path into the other.
This method is similar to the deformation technique in [13]. However, that work speciﬁcally uses an A∗ search through the pair-wise visibility of conﬁgurations between two t-resolution paths. Our method is a more efﬁcient algorithm and returns a numeric value.
C. Topology-based Edit Distance Similarity
We present a novel similarity metric rooted in topological reasoning. Essentially, the metric compares the portions of the workspace each path visits. Our metric, called TopologyBased Edit Distance Similarity (TBEDS), shown in Algorithm 2, translates each path into a string and uses the notion

6500

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 16,2022 at 07:03:29 UTC from IEEE Xplore. Restrictions apply.

Algorithm 2 Topology-based Edit Distance Similarity

Input: t-resolution Paths τ1, τ2, Local planner ∆ Output: Similarity s ∈ [0, 1]

1: s1 ← TOPOLOGYBASEDSTRING(τ1)

2: s2 ← TOPOLOGYBASEDSTRING(τ2)

3: d ← LEVENSHTEINDISTANCE(s1, s2)

4: return

1

−

d max(|s1|,|s2|)

Algorithm 3 Path to Topology-based String
Input: t-resolution Path τ
Output: String s {Find tetrahedron sequence that τ passes through}
1: Sequence tetras ← ∅ 2: for t ∈ [0, 1] at t-resolution increments do 3: tetras ← tetras ∪ FINDTETRAHEDRON(τ t) 4: UNIQUE(tetras)
{Find sequence of Reeb arcs that τ passes along} 5: Sequence reebArcs ← ∅ 6: for all tetra ∈ tetras do 7: reebArcs ← reebArcs ∪ FINDREEBARCS(tetra) 8: UNIQUE(reebArcs) 9: return REEBARCSEQUENCETOSTRING(reebArcs)

of edit distance as the metric [19]. Speciﬁcally, we use Levenshtein Distance [17] in our implementation. Levenshtein Distance counts the minimum number of additions, deletions, and substitutions required to convert one string into another. The string used for each path is the sequence of workspace regions that the path traverses. Edit distance has been used in motion planning in the context of path merging [22] — a tangential problem to path similarity.
To determine the sequence of workspace regions, we use the methodology shown in Algorithm 3. The method assumes that the workspace of the robot has been tetrahedralized and converted into a Reeb Graph, as discussed in Section II. The ﬁrst phase of the algorithm determines the sequence of tetrahedrons that a point of interest of the robot passes through along the path. The point of interest could be something as simple as the center of mass of the robot or more complex like the end-effector location of a manipulator robot. After the initial sequence is determined, we run an algorithm called UNIQUE on the sequence. This eliminates adjacent duplicates from the sequence. In the second phase of the algorithm, we map the tetrahedron sequence to a sequence of sets of Reeb Arcs. For each tetrahedron, we determine all of the associated Reeb Arcs to it and use this as the set — recall from Section II that based on the reduction algorithm tetrahedrons may belong to more than one Reeb Arc. Again, we use UNIQUE to eliminate adjacent duplicates from the sequence of Reeb Arc sets. Finally, we determine a string by mapping each unique set of Reeb Arcs to a unique “character.” We use the term “character” loosely, and more speciﬁcally map each set to a non-negative integer.
As an example of converting a path to a string using Algorithm 3, we refer to the right path of Figure 3(a)

(a) Typical case

(b) Degenerate case

Fig. 3. Example computations of converting paths to topology-based strings. Unique Reeb Arc sets are shown as distinct shaded regions. (a) Typical case of representing a simple path that visits a linear sequence of Reeb Arc sets. (b) Atypical (degenerate) case of representing a complex path that visits a backtracking sequence of Reeb Arc sets.

(green). Looking at this path, we ﬁrst observe that a point

moving along this path at a t-resolution visits a sequence

of tetrahedrons. Second, we can determine the unique se-

quence of Reeb Arc sets traversed along the path. The gray

patterns show the unique Reeb Arc sets in this environment

— visually, the reader can refer to Figure 2 to view the

tetrahedrons for each Reeb Arc and verify the unique Reeb

Arc set from their overlaps. So, this path visits the bottom

region, then the right region, and then the top region. We

translate this to a unique string “BRT.” Following the same

observations, we can see the left path (magenta) translates

to the string “BLT.” After converting the paths to strings, we

can apply Algorithm 2 to see that the edit distance is one

and

the

TBEDS

metric

is

2 3

—

we

can

substitute

‘R’

for

‘L’

to get the second string and a Levenshtein Distance of one.

In TBEDS, if a value of one is returned, then the paths

taken by the point of interest of the robot are in the same

homotopy classes of the workspace. This may or may not

imply the same for the conﬁguration space paths; it depends

on the speciﬁc problem and choice of the point of interest.

When the metric returns a value close to zero, the paths taken

by the point of interest are in disjoint homotopy classes of

the workspace and therefore are in disjoint homotopy classes

of the free conﬁguration space. The metric cannot return zero

because the start and goal for the paths are identical.

The TBEDS metric provides a few interesting discussion

points from a theoretical view. First, the metric is rooted

in topological reasoning, an important distinction from the

nature of LPSS. We established a metric that analyzes the

regions of the workspace (preprocessed and grouped into

topological equivalences) that a path visits. TBEDS is limited

to reasoning about workspace regions and cannot reason

about regions of Cfree.

Second, there are degenerate cases for TBEDS. Speciﬁ-

cally, we refer to the example shown in Figure 3(b). The

simple path (green) is identical to the right path in the

previous example and translates to “BRT.” Analyzing the

second complex path (magenta), we note it translates to

“BLBRTLT.” The Levenshtein edit distance is now 5 (one

substitution

and

four

deletions)

and

our

TBEDS

metric

is

2 7

.

This is problematic given that the two paths are homotopy

equivalent. One method to overcome this is to apply path

6501

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 16,2022 at 07:03:29 UTC from IEEE Xplore. Restrictions apply.

smoothing to improve the paths before comparing them; however, some path smoothing methods [8], like shortcutting, can actually change the homotopy class of the path. Because of this, we did not apply smoothing in this study. In our applications, the degenerate case did not arise often, and we leave further exploration of them to future work.
IV. APPLICATION: PATH EXTRACTION
We apply our metrics to the application of extracting homotopically distinct paths from a roadmap. Further, we explore the trade-offs of each metric in more topologically complex environments, i.e., they contain more homotopy classes.
A. Algorithm Overview
For our application, we explore the problem of extracting topologically distinct paths from a roadmap. Algorithm 4 is used for this purpose. It is a modiﬁcation of depth-ﬁrst search that explores all simple paths between a start and goal node of a graph. For each path that is found, the algorithm uses a path similarity metric to compare it to all previously found paths. If the new path is signiﬁcantly different (compared to a threshold), then the new path is added to the output set.
This algorithm has exponential complexity, and we use it on small roadmaps only. Note, this algorithm is not the focus of our paper, and we chose this approach to extensively test and compare our metrics.
B. Analysis
We implemented our metrics in C++ using the GNU gcc compiler version 5.4.0, and we ran all experiments on Ubuntu 16.04 with an Intel R CoreTM i7-6700U CPU at 3.4 GHz and 16 GB of RAM.
We used a t-resolution of 0.01 and the Euclidean distance as the distance function where needed. LPSS used a straightline local planner using a bisection evaluation order over the interpolation.

Algorithm 4 Generate Paths

Input: Roadmap R, t-resolution Paths Π, Threshold

threshold,

Vertex u, Vertex goal, Vertex sequence p

1: u.VISITED(true)

2: p ← p ∪ {u}

3: if u = goal then

4: t-resolution path τ ← GETPATH(R, p)

5: for all τi ∈ Π do

6:

if PATHSIMILARITY(τ, τi) > threshold then

7:

return

8: Π ← Π ∪ {τ }

9: else

10: for all v ∈ u.ADJACENTVERTICES() do

11:

if ¬v.ISVISITED() then

12:

GENERATEPATHS(R, Π, v, g, p, threshold)

13: u.VISITED(false)

(a) Cyl3

(b) Cyl6

(c) Cyl9

Fig. 4. Environments for the path extraction application. The environments are composed of increasing numbers of columns that create topologically more complex scenes in the workspace, i.e., Cyl9 (c) has more homotopy classes than Cyl3 (a). The query is from the bottom to the top in each environment.

TABLE I REEB GRAPH SIZES, AVERAGE ROADMAP SIZES, THRESHOLDS, AND
AVERAGE NUMBER OF PATHS EXTRACTED FOR THE EXPERIMENTAL
A NA LY S I S .

Reeb Graph Sz. (nodes, edges) Avg. Roadmap Sz. (nodes, edges) Threshold – TBEDS Threshold – LPSS Avg. Num. Unique Paths – TBEDS Avg. Num. Total Paths – TBEDS Avg. Num. Unique Paths – LPSS Avg. Num. Total Paths – LPSS

Cyl3 8, 10 14, 53 0.50 0.85
6.6 1400
6.4 1060

Cyl6 14, 19 17, 57
0.50 0.75 6.8 1270 6.0 1150

Cyl9 20, 28 20, 56
0.50 0.70 6.7 577 7.6 617

We analyze the algorithm using the environments shown in Figure 4. The environments contain approximated cylinders of radius 2m and height 6m in an environment that is 20 × 20 × 6m. The environments increase in topological complexity (contain more homotopy classes) as the number of cylinders increase from three to nine. They are arranged as uniform rows, so the ﬁrst environment has one row of three cylinders and the last environment has three rows of three cylinders. We used a query from the bottom to the top in each environment.
We ﬁrst create roadmap using the PRM approach [15] that captures some or all of the homotopy classes. The roadmap nodes were generated by performing uniform random sampling, where samples are generated a predeﬁned distance apart, and the edges were formed by a radiusbased neighborhood connection scheme using a straightline local planner. The size of the roadmaps were limited to accommodate the application. We created 30 different roadmaps for the experiments. Table I shows the average roadmap and Reeb Graph size for each environment.
For the experiment, we selected thresholds so that we yield about the same total number of paths compared and about the same number of unique paths extracted. To verify, we present the thresholds and the average number of paths extracted using each method in Table I. All averages are very similar and within one standard deviation from each other. The threshold for LPSS was reduced with increasing environment complexity as the metric becomes more accurate with increased Cobst volume.
Figure 5 presents the average time taken to analyze the roadmaps for path extraction over the 30 trials. As seen, the TBEDS metric is about ten times faster across the three

6502

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 16,2022 at 07:03:29 UTC from IEEE Xplore. Restrictions apply.

Time (s)

35

30

TBEDS LPSS

25

20

15

10

5

0

Cyl3

Cyl6

Cyl9

Fig. 5. Average time shown for path extraction over 30 trials using both the LPSS and TBEDS metrics in all three cylinder environments.

(a) Manipulator

Time (s)

0.12

Evaluation

0.1

Reeb Graph Construction

0.08

0.06

0.04

0.02

0

TBEDS

LPSS

(b) Time Comparison

Fig. 6. Experimental comparison of TBEDS and LPSS metrics on a robot manipulator. (a) Environment with ﬁxed-base manipulator arm. The two paths used in the comparison are shown in red and blue. (b) Timing results for the comparison.

Algorithm 5 Path Deformation Roadmap

Input: Maximum failure iterations nmax Output: Path Deformation Roadmap R
1: nfail ← 0 2: Roadmap R ← ∅

3: while nfail < nmax do

4: q ← GETRANDOMFREECFG()

5: Rvis ← VISIBLESUBROADMAP(q)

6: if Rvis = ∅ then

7:

ADDNEWGUARD(R, q)

8:

nfail ← 0

9: else if Rvis.NUMCCS() > 1 then

10:

{v1, v2} ← TWONEAREST(Rvis, q)

11:

τ ← PATHINDUCED(v1, q, v2)

12:

if ISUSEFULCYCLE(R, v1, v2, τ ) then

13:

ADDCYCLICPATH(R, τ )

14:

nfail ← 0

15:

else

16:

nfail ← nfail + 1

17: else {Rvis.NUMCCS() = 1}

18:

nfail ← nfail + 1

19: return R

environments. Using a statistical t-test TBEDS is faster than LPSS with a p-value < 0.0001 across all three environments. The largest computation cost of TBEDS is the Reeb Graph construction, but its cost is amortized over the execution of the algorithm.
TBEDS and LPSS compute metrics of different topological meaning, but from this experiment we also see a signiﬁcant trade-off in computational efﬁciency.
V. APPLICATION: ROBOT MANIPULATORS
We apply our metrics to comparing paths of a robotic arm. Our system setup is identical to Section IV-B. The key difference is that we use the position of the end effector at the point-of-interest of the robot for TBEDS.
We use the scenario shown in Figure 6(a). In this problem, an eight DOF manipulator arm must reach around a cube, while avoiding collision with a wall located to the left of the robot. The robot’s base is ﬁxed to the origin of the environment. We computed two different paths to the same end effector position using a sampling-based planner, one that goes below the obstacle (red) and the other that reaches above the obstacle (blue). We analyze each metric on the pair of homotopically distinct paths of the end effector position and compare both the similarity computed and the computation time taken. The analysis was repeated 30 times and the average computation time is shown in Figure 6(b).
Both TBEDS and LPSS present similarity values noting large differences between the two paths, 0.38 and 0.40 respectively. Timing is shown in Figure 6(b). TBEDS is about four times faster than LPSS. Again the Reeb Graph construction time is dominant. Considering evaluation time only, TBEDS is approximately seven times faster.

VI. APPLICATION: PATH DEFORMATION ROADMAPS
We use our metrics to improve on an existing technique in sampling-based motion planning. The methodology, called Path Deformation Roadmaps (PDRs) [13], extends Visibilitybased PRM [27] to contain useful cycles in the roadmap that represent multiple homotopy classes in an environment. We review the core algorithm, explain how our metrics can be used in the approach, and experimentally analyze them.
A. Algorithm Overview
We present an iterative formulation of PDR construction in Algorithm 5. In each iteration, a random conﬁguration q ∈ Cfree is generated and the visible portion of the roadmap Rvis to q is determined — this is computed incrementally by performing either rigorous visibility checks, i.e., local planner attempts, or by reasoning about the clearance (minimum visibility) of conﬁgurations, which we used here (see [13] for further implementation details). If Rvis is empty, q is classiﬁed as a new guard [27], a conﬁguration covering a new part of Cfree, and added to the roadmap. If Rvis contains multiple connected components, q becomes a candidate for creating a useful cycle in the roadmap. The algorithm ﬁnds the two nearest conﬁgurations in Rvis to q, induces a cycle, and checks the cycle for redundancy (Algorithm 6). If Rvis is one connected component, or q does not create a useful cycle, the number of failed iterations is incremented. The algorithm continues until a maximum number of failed iterations is reached.
The original PDR algorithm uses an A∗ search through pair-wise visibility checks of two t-resolution candidate paths. A successful search yields a path deformation, and thus a homotopically redundant cycle is determined.

6503

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 16,2022 at 07:03:29 UTC from IEEE Xplore. Restrictions apply.

Algorithm 6 IsUsefulCycle
Input: Roadmap R, conﬁgurations v1, v2, and candidate path τ . Pre-conﬁgured input for number of comparison paths k, path similarity metric µ, and threshold ǫ.
Output: true if τ augments R with a useful cycle between v1 and v2, false otherwise
1: T ← KSHORTESTPATHS(R, k) 2: for all τ ′ ∈ T do 3: if µ(τ, τ ′) >= ǫ then 4: return false
5: return true

(a) Building

(b) Tunnel

Fig. 7. Additional environments for application of the metrics to creating PDRs. (a) Building and (b) Tunnel both contain inherently threedimensional homotopy classes providing increased difﬁcult of roadmap creation.

TABLE II SIMILARITY METRIC THRESHOLD AND MAXIMUM FAILED ITERATIONS
USED FOR PDR CONSTRUCTION, AND THE RESULTING AVERAGE ROADMAP SIZES (NODES AND EDGES) OVER ALL TRIALS (OUTLIERS REMOVED) FOR TBEDS, LPSS, AND A∗. NOTE, A∗ WAS UNABLE TO
COMPLETE COMPUTATION IN 10,000 SECONDS ON ALL TRIALS IN BUILDING AND TUNNEL.

Cyl3 Cyl6 Cyl9 Building Tunnel

Threshold Max Failure Roadmap Size Threshold Max Failure Roadmap Size Threshold Max Failure Roadmap Size Threshold Max Failure Roadmap Size Threshold Max Failure Roadmap Size

TBEDS 0.45 40
12, 38 0.35 40
24, 74 0.45 40
39, 121 0.30 30
15, 31 0.35 600
31, 76

LPSS 1.0 200
12, 33 1.0 45
19, 48 1.0 30
27, 70 1.0 20
19, 42 1.0 500
25, 58

A∗ 1.0 200 9.1, 22 1.0 45 17, 40 1.0 30 24, 59 1.0 20
– 1.0 500
–

1000 100

TBEDS LPSS A*

Normalized Time to TBEDS

We modify the PDR algorithm’s veriﬁcation for useful cycles — its most expensive step. Our updated approach is shown in Algorithm 6 which abstracts the path redundancy check with a path similarity metric, µ. We compare the metric value to a threshold for redundancy determination. In our experiments, TBEDS, LPSS, and A∗ refer to constructing a PDR using the TBEDS metric, LPSS metric, or original A∗ search, respectively, for checking useful cycles.
B. Analysis
In this experiment, we compare the cost of generating a roadmap using the PDR algorithm with TBEDS, LPSS, and A∗ as metrics for determining whether two paths are deformable. We use the same experimental setup as that used in Section IV-B.
For this application, we use environments similar to those shown in Figure 4 except the radii of the cylinders were increased to 4m and spaced evenly in the environment. Additionally, we use the environments in Figure 7, both of which have a three-dimensional workspace, a sixdimensional Cspace (translation and rotation of a rigid body robot), and contain multiple homotopy classes. Building, Figure 7(a), represents a UAV robot (no kinematics are considered) inspecting an urban apartment complex that has a solid center and two wings with four stories each. Tunnel, Figure 7(b), is a maze of tunnels through complex geometry that exercises the cost of collision detection and Reeb Graph construction more fully.
Table II displays the variables used for the similarity metric thresholds and maximum failures allowed for for PDR construction. We used k = 5 shortest paths in the algorithm across all methods. We determined the values to

10

1

0.1

Cyl3

Cyl6

Cyl9 Building Tunnel

Fig. 8. Time for PDR creation with TBEDS, LPSS, and A∗ normalized to TBEDS in the ﬁve environments. In darker color is the time required for path comparison phase of the algorithm. Results averaged over 30 trials (10 in Tunnel, outliers removed). A∗ did not complete within 10,000 seconds on any trial in the Building or Tunnel environments.

create roadmaps of comparable sizes and qualities (bold) to facilitate a fair comparison between the various approaches. The average time to construct each PDR in 30 trials (10 in Tunnel) with outliers removed and normalized to the time TBEDS required is shown in Figure 8. In darker color, the time required speciﬁcally for the useful cycle check (Algorithm 6) is shown. A∗ did not complete within 10,000 seconds on any trial in the Building or Tunnel environments. The time reported for TBEDS includes the time required to construct the Reeb Graph representation of the environment.
Our results show that both TBEDS and LPSS allow PDRs to be more efﬁciently constructed by more than two orders of magnitude in certain environments compared with A∗. Further, TBEDS is more efﬁcient in time than LPSS by a factor of two to twelve depending on the environment.
The core reason this occurs is a reduction in the time taken for useful cycle validation (shown in dark color in the

6504

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 16,2022 at 07:03:29 UTC from IEEE Xplore. Restrictions apply.

histogram). Note that in both LPSS and A∗ the dominant computation is the useful cycle check, often taking more than 90% of the computation time. While LPSS reduces the number of collision checks using an approximated validation of deformation compared with A∗, TBEDS entirely eliminates collision checking during this phase. Ultimately, the A∗ approach is not scalable to complicated environments. Using path similarity allows PDRs to be constructed in a reasonable time frame.
This is not without a trade-off. As noted before, LPSS performs a deformation validation check, whereas TBEDS simply approximates a likelihood of this existing. However, with a cheaper useful cycle check more effort could be spent checking more samples to create a higher quality roadmap. We would like to explore this effect and apply concepts from TBEDS to further reduce the computation time required for PDR construction.
VII. CONCLUSION
We presented the problem of approximating path similarity and proposed two similarity metrics. Further, we demonstrated the usefulness and efﬁciency of our metrics in various ways. We consider our metrics complementary in how they approximate path similarity.
In the future, we would like to explore how the notion of path similarity can be used in developing and analyzing novel motion planning algorithms and applications for multiagent robot systems. Additionally, we would like to continue to improve upon the topology-based edit distance similarity to overcome degenerate cases.
REFERENCES
[1] S. Bhattacharya, V. Kumar, and M. Likhachev. Search-based path planning with homotopy class constraints. In Proc. of the Twentyfourth AAAI Conference on Artiﬁcial Intelligence, July 2010.
[2] S. Bhattacharya, M. Likhachev, and V. Kumar. Identiﬁcation and representation of homotopy classes of trajectories for search-based path planning in 3d. In Proceedings of Robotics: Science and Systems, Los Angeles, CA, USA, June 2011.
[3] F. Bourgault, A. A. Makarenko, S. B. Williams, B. Grocholsky, and H. F. Durrant-Whyte. Information based adaptive robotic exploration. In Proc. IEEE/RSJ Int. Conf. Intelligent Robots and Systems (IROS), volume 1, pages 540–545 vol.1, 2002.
[4] D. Demyen and M. Buro. Efﬁcient triangulation-based pathﬁnding. In Proceedings of the 21st National Conference on Artiﬁcial Intelligence - Volume 1, AAAI’06, pages 942–947. AAAI Press, 2006.
[5] J. Denny, R. Sandstro¨m, A. Bregger, and N. M. Amato. Dynamic region-biased rapidly-exploring random trees. In Proc. Int. Workshop on Algorithmic Foundations of Robotics (WAFR), San Francisco, CA, December 2016.
[6] A. Dobson and K. E. Bekris. Sparse roadmap spanners for asymptotically near-optimal motion planning. Int. J. of Robotics Research, 33:18–47, 2014.
[7] H. Doraiswamy and V. Natarajan. Efﬁcient algorithms for computing reeb graphs. Comput. Geom. Theory Appl., 42(6-7):606–616, Aug. 2009.
[8] R. Geraerts and M. H. Overmars. Creating high-quality paths for motion planning. Int. J. of Robotics Research, 26(8):845–863, 2007.

[9] D. Grigoriev and A. Slissenko. Polytime algorithm for the shortest path in a homotopy class amidst semi-algebraic obstacles in the plane. In Proceedings of the 1998 International Symposium on Symbolic and Algebraic Computation, ISSAC ’98, pages 17–24, New York, NY, USA, 1998. ACM.
[10] A. Hatcher. Algebraic Topology. Cambridge University Press, 2001. [11] J. Hershberger and J. Snoeyink. Computing minimum length paths
of a given homotopy class. In Proc. 2nd Workshop Algorithms Data Struct., volume 519 of Lecture Notes Comput. Sci., pages 331–342. Springer-Verlag, 1991. [12] M. Hilaga, Y. Shinagawa, T. Kohmura, and T. L. Kunii. Topology matching for fully automatic similarity estimation of 3d shapes. In Proceedings of the 28th Annual Conference on Computer Graphics and Interactive Techniques, SIGGRAPH ’01, pages 203–212, New York, NY, USA, 2001. ACM. [13] L. Jaillet and T. Sime´on. Path deformation roadmaps: Compact graphs with useful cycles for motion planning. Int. J. of Robotics Research, 27(11-12):1175–1188, 2008. [14] L. P. Kaelbling and T. Lozano-Pe´rez. Integrated task and motion planning in belief space. The International Journal of Robotics Research, 2013. [15] L. E. Kavraki, P. Sˇ vestka, J. C. Latombe, and M. H. Overmars. Probabilistic roadmaps for path planning in high-dimensional conﬁguration spaces. IEEE Trans. on Robotics and Automation, 12(4):566–580, August 1996. [16] J. C. Latombe. Motion planning: A journey of robots, molecules, digital actors, and other artifacts. Int. J. of Robotics Research, 18(11):1119–1128, 1999. [17] V. I. Levenshtein. Binary Codes Capable of Correcting Deletions, Insertions and Reversals. Soviet Physics Doklady, 10:707, Feb. 1966. [18] T. Lozano-Pe´rez and M. A. Wesley. An algorithm for planning collision-free paths among polyhedral obstacles. Communications of the ACM, 22(10):560–570, October 1979. [19] G. Navarro. A guided tour to approximate string matching. ACM Comput. Surv., 33(1):31–88, Mar. 2001. [20] D. Nieuwenhuisen and M. H. Overmars. Useful cycles in probabilistic roadmap graphs. pages 446–452, 2004. [21] V. Pascucci, G. Scorzelli, P.-T. Bremer, and A. Mascarenhas. Robust on-line computation of reeb graphs: Simplicity and speed. ACM Trans. Graph., 26(3), July 2007. [22] B. Raveh, A. Enosh, and D. Halperin. A little more, a lot better: Improving path quality by a path-merging algorithm. IEEE Transactions on Robotics, 27(2):365–371, April 2011. [23] G. Reeb. Sur les points singuliers d’une forme de pfaff complement integrable ou d’une fonction numerique. Comptes Rendus Acad. Sciences Paris, 222:847–849, 1946. [24] J. H. Reif. Complexity of the mover’s problem and generalizations. In Proc. IEEE Symp. Foundations of Computer Science (FOCS), pages 421–427, San Juan, Puerto Rico, October 1979. [25] E. Schmitzberger, J. L. Bouchet, M. Dufaut, D. Wolf, and R. Husson. Capture of homotopy classes with probabilistic road map. In Proc. IEEE/RSJ Int. Conf. Intelligent Robots and Systems (IROS), volume 3, pages 2317–2322 vol.3, 2002. [26] H. Si. Tetgen, a delaunay-based quality tetrahedral mesh generator. ACM Trans. Math. Softw., 41(2):11:1–11:36, Feb. 2015. [27] T. Simeon, J.-P. Laumond, and C. Nissoux. Visibility-based probabilistic roadmaps for motion planning. Advanced Robotics, 14(6):477–493, 2000. [28] J. P. van den Berg, D. Nieuwenhuisen, L. Jaillet, and M. H. Overmars. Creating robust roadmaps for motion planning in changing environments. In Proc. IEEE/RSJ Int. Conf. Intelligent Robots and Systems (IROS), pages 1053–1059, Aug 2005. [29] Z. Wood, H. Hoppe, M. Desbrun, and P. Schro¨der. Removing excess topology from isosurfaces. ACM Trans. Graph., 23(2):190–208, Apr. 2004. [30] Z. J. Wood, P. Schro¨der, D. Breen, and M. Desbrun. Semi-regular mesh extraction from volumes. In Proceedings of the Conference on Visualization ’00, VIS ’00, pages 275–282, Los Alamitos, CA, USA, 2000. IEEE Computer Society Press.

6505 Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 16,2022 at 07:03:29 UTC from IEEE Xplore. Restrictions apply.

