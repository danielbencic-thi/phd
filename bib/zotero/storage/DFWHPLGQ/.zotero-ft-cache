MODELING, SIMULATION AND COMPLETE CONTROL OF A QUADCOPTER
ME – 440 Major Project Semester Report
Submitted in partial fulfillment of the requirements for the degree of BACHELOR OF TECHNOLOGY in MECHANICAL ENGINEERING By ABID SULFICAR 13ME107
HARIKRISHNAN SURESH 13ME141 ARAVIND VARMA 13ME216
ARJUN RADHAKRISHNAN 13ME217
Under the guidance of: Prof. VIJAY DESAI DEPARTMENT OF MECHANICAL ENGINEERING NATIONAL INSTITUTE OF TECHNOLOGY KARNATAKA SURATHKAL, MANGALORE – 575025
May, 2017
1

DEPARTMENT OF MECHANICAL ENGINEERING NATIONAL INSTITUTE OF TECHNOLOGY KARNATAKA SURATHKAL, MANGALORE- 575025
CERTIFICATE
This is to certify that the U.G. project work report titled “Modeling, Simulation, and Control of a Quadcopter”, submitted by Abid Sulficar 13ME107 Harikrishnan Suresh 13ME141 Aravind Varma 13ME216 Arjun Radhakrishnan 13ME217
is the record of the work carried out by them, and is accepted as the U.G. Project Work Report submission in partial fulfilment of the requirements for the award of Bachelor of Technology Degree by the Department of Mechanical Engineering, National Institute of Technology Karnataka, Surathkal.

Prof. Vijay Desai Department of Mechanical Engineering
Project Guide

Prof. Narendra Nath S Head, Department of Mechanical
Engineering

2

DECLARATION
We hereby declare that the report of the U.G. project work titled “Modeling, Simulation, and Control of a Quadcopter”, which is being submitted to the National Institute of Technology Karnataka Surathkal, for the award of Bachelor of Technology in Mechanical Engineering is a bonafide report of the work carried out by us. The material contained in this report has not been submitted to any University of Institution for the award of any degree.

Abid Sulficar Harikrishnan Suresh Aravind Varma Arjun Radhakrishnan

13ME107 13ME141 13ME216 13ME217

Place: NITK, Surathkal Date:

3

ACKNOWLEDGEMENT
We wish to express our sincere thanks to the people who extended their help during the course of this project. We express our deepest gratitude to our guide Prof. Vijay Desai, Department of Mechanical Engineering, NITK Surathkal for providing us the opportunity to do our major project under his guidance. We thank him for the constant technical support and guidance which has immensely contributed to the successful completion of this project. We thank our Head of the Department for providing the facilities necessary to undertake this project.
4

Contents
List of figures................................................................................................................................. 7
List of tables................................................................................................................................... 8
Nomenclature ................................................................................................................................ 9
Chapter 1 - Introduction ............................................................................................................ 10
Chapter 2 - Literature Survey ................................................................................................... 12
Chapter 3 – Methodology ........................................................................................................... 17
3.1 Mathematical model of quadcopter................................................................................. 17 3.2 Mathematical model of quadcopter with one failed rotor............................................. 22 3.3 Attitude controller............................................................................................................. 24
3.3.1 PID controller ............................................................................................................... 24 3.3.2 Feedback linearization controller ................................................................................. 26 3.3.3 Linear Quadratic Regulator .......................................................................................... 30 3.4 Trajectory planning using image processing .................................................................. 32 3.4.1 Feasible landing point................................................................................................... 32 3.4.2 Trajectory planning algorithm ...................................................................................... 34 3.5 Trajectory Controller ....................................................................................................... 35 Chapter 4 - Simulation ............................................................................................................... 37
4.1. Simulation for attitude controller comparison .............................................................. 38 4.1.1. Attitude commands...................................................................................................... 38 4.1.2. Control gains................................................................................................................ 38
4.2. Simulation for trajectory following – feasible landing point ....................................... 39 4.2.1. Path commands............................................................................................................ 39 4.2.2. Control gains................................................................................................................ 40
4.3. Simulation for trajectory following – using a trajectory planner................................ 40 4.3.1. Path commands............................................................................................................ 40 4.3.2. Control gains................................................................................................................ 41 4.3.3. VR Simulation ............................................................................................................. 41
Chapter 5 - Results and Discussions.......................................................................................... 43
5.1 Attitude controller comparison ........................................................................................ 43
5

5.2 Trajectory planner ............................................................................................................ 47 5.2.1 Selecting the most feasible landing point ..................................................................... 47 5.2.2 Trajectory Planning algorithm...................................................................................... 48
5.3 Trajectory tracking ........................................................................................................... 49 5.3.1 Trajectory tracking – Most feasible landing point........................................................ 49 5.3.2. Trajectory tracking – traversing the maze ................................................................... 51
Further work ............................................................................................................................... 54 References .................................................................................................................................... 55 Appendix...................................................................................................................................... 56
Appendix A1: Quadcopter plant ............................................................................................... 56 Appendix A2: Quadcopter plant with a failed rotor.................................................................. 59 Appendix A3: Layout for PID controller .................................................................................. 62 Appendix A4: Layout for FBL+PD controller .......................................................................... 62 Appendix A5: Inside FBL blocks.............................................................................................. 63 Appendix A6: Layout of LQR .................................................................................................. 64 Appendix A7: Linriz.m function ............................................................................................... 64 Appendix A8: Inside image processing block........................................................................... 65 Appendix A9: Pathgen.m function............................................................................................ 66 Appendix A10: Circle2.m function ........................................................................................... 67 Appendix A11: dijkstra.m function........................................................................................... 69 Appendix A12: Functions called by Dijkstra.m........................................................................ 70 Appendix A13: pathcr.m function............................................................................................. 71 Appendix A14: Trajectory controller ........................................................................................ 75 Appendix A15: Complete layout for trajectory control simulation 1 ....................................... 76 Appendix A16: Complete layout for trajectory control simulation 2 ....................................... 76
6

List of figures
Figure 1: Control architecture (taken from [3]) ............................................................................ 13 Figure 2: Comparison between controllers on the basis of total error (taken from [4]) ............... 14 Figure 3: Inertial and body frames of quadcopter (taken from [1]) .............................................. 17 Figure 4: Quad plant Simulink Block ........................................................................................... 21 Figure 5: Block diagram of Attitude Controller ........................................................................... 24 Figure 6: Desired path with switching ......................................................................................... 40 Figure 7: A VR model of quadcopter during simulation (viewpoint 1) ....................................... 42 Figure 8: A VR model of quadcopter during simulation (viewpoint 2) ....................................... 42 Figure 9: Step responses of controllers – Φ .................................................................................. 43 Figure 10: Step responses of controllers – θ ................................................................................. 44 Figure 11: Step responses of controllers – Ψ ................................................................................ 45 Figure 12: Step responses of controllers –Z ................................................................................. 46 Figure 13: Image containing different shapes in different colors ................................................. 47 Figure 14: Black circle given as output ........................................................................................ 47 Figure 15 : Maze input to the trajectory planner........................................................................... 48 Figure 16 : Path generated by the trajectory planner .................................................................... 48 Figure 17: Actual path followed .................................................................................................. 49 Figure 18: Coordinate wise comparison of desired and actual paths............................................ 50 Figure 19: Plots of attitude variables vs Time .............................................................................. 50 Figure 20: Desired path generated by trajectory planner.............................................................. 51 Figure 21: Actual path followed by quadcopter ........................................................................... 52 Figure 22: Coordinate wise comparison of desired path and actual path ..................................... 52 Figure 23: Plots of Attitude variables vs Time ............................................................................. 53
7

List of tables
Table 1: Parameter values for quad plant ..................................................................................... 37 Table 2: Initial conditions for trajectory control simulation 1...................................................... 37 Table 3: Initial conditions for trajectory control simulation 2 ...................................................... 38 Table 4: Gain values for attitude controller 1 ............................................................................... 39 Table 5: Gain values for attitude controller 2 ............................................................................... 39 Table 6: Gain values for attitude controller 3 ............................................................................... 39 Table 7: Gain values for trajectory controller............................................................................... 40 Table 8: Gain values for trajectory controller............................................................................... 41 Table 9: Characteristic parameters to a step input for Φ .............................................................. 44 Table 10: Characteristic parameters to a step input for θ ............................................................. 44 Table 11: Characteristic parameters to a step input for Ψ ............................................................ 45 Table 12: Characteristic parameters to a step input for Z ............................................................. 46 Table 13: Computational time of controllers ................................................................................ 46
8

Nomenclature

{O}(O,X,Y,Z) {B}(OB,XB,YB,ZB) ε η Φ θ Ψ P,Q,R VX,VY,VZ CD ωi A r 𝑇𝑖 Ax, Ay, Az 𝑀𝛷 𝑀𝜃 𝑀𝜓 𝐿 B IR Ar 𝐼 m g

Inertial frame Body frame Quadcopter position w.r.t {O}, m Quadcopter Euler angles w.r.t {O}, rad Roll angle, rad Pitch angle, rad Yaw angle, rad Angular velocities about XB,YB,ZB respectively, rad/s Linear velocities about XB,YB,ZB respectively, m/s Thrust coefficient of the motor Rotational speed of ith rotor, rad/s Cross-sectional area of the propeller’s rotation, m2 Radius of rotor, m Thrust given by ith rotor, N Linear drag coefficients in the X,Y,Z respectively, N.s/m Rolling moment, N.m Pitching moment, N.m Yawing moment, N.m Distance between the center of propeller and the center of quadcopter, m Torque coefficient of motor inertia moment of rotor, kg.m2 Rotational drag coefficient, N.m.s Inertia matrix, kg.m2 Mass of quadcopter, kg Acceleration due to gravity, m/s2

9

Chapter 1 - Introduction
A Quadcopter is a rotor-based, unmanned aerial vehicle. Quad copters are becoming increasingly popular because of their small size and high maneuverability and find applications in diverse fields. The dynamics of a quadcopter is highly non-linear. Furthermore, it is an under-actuated system with six degrees of freedom and four control inputs. The thrust as well as the torques required for tilting the quadcopter are the control inputs which determine the motion of the vehicle. The thrust as well as torques are generated by adjusting the rotor speeds. The thrust generated by the rotor blades is always in the direction of the central axis of the quadcopter. Therefore, to achieve propulsion in a particular direction, the axis of quadcopter should be tilted with respect to the vertical. The translational motion of a quadcopter is hence coupled with its angular orientation, making quadcopter dynamics and control very complex.
Quad copters have applications in many fields, some of which are listed below.
 Reconnaissance – used to gather military intelligence by scouting enemy territory. Because of their small size and minimal noise generated, they can move undetected.
 Aerial surveillance – road patrol, home security, law and order. The ease of motion between points through air and large visibility of the surroundings, especially with a strong camera makes quad copters a prime candidate for aerial surveillance needs.
 Used in motion picture film making and photography for aerial shots and views.  Assistance for search and rescue operations in disaster struck areas or in case of fire.  Used in automation systems in industries for material handling purposes.  Delivery of goods and items.  Used for 3D modelling of terrains or large structures as well as thermal imaging.
Failure of quadcopter may occur due to many reasons such as
 Electronic Speed Control (ESC) burn out – ESC may burn out if the current exceeds the maximum permissible current. This causes the propeller associated with the ESC to stop spinning and can lead to failure.
 Damage to motor, whether due to physical damage or exceeding the maximum current value can cause the motor to stop functioning mid-flight or may cause loss in efficiency.
 Any physical damage to the propeller blades such as dents, nicks, cuts etc. can cause vibrations and may cause the propeller blade to come off mid-flight.
 Bending of propeller blades can lead to a decrease in lift and increased noise during operation leading to a decrease in efficiency.
10

The loss of quadcopter propeller blades can cause the quadcopter to crash. Apart from the monetary loses associated with the damage to quadcopter parts, it can have many negative consequences. Loss of a quadcopter used for reconnaissance work can lead to loss of valuable military intelligence and causes the risk of it being discovered by the enemy. In motion picture film making, thermal imaging photography etc., the equipment mounted on the quadcopter are very costly and propeller failure can lead to the damage of valuable equipment. In search and rescue operations in disaster affected regions, the failure of the quadcopter can lead to possible delays, increasing the risk on the life of affected people. In material handling systems, failure may lead to damage of costly parts. Added to all this, there is also the risk of the quadcopter crashing on to people and causing injuries especially in public spaces.
The potential risk of loss of a propeller is high in many of the situations in terms of cost as well as other factors. Hence, a mechanism for the control of a quadcopter against the possibility of failure is a necessity. Quadcopter control, even with four propellers functioning, is a complex problem because it is an under-actuated and highly non-linear system. Various control algorithms like PID and feedback linearization are used for the purpose of control. The control problem becomes more complex when there is complete loss of one or more propellers. The first stage in devising an algorithm for such a case is fault detection. If left unchecked, the fault leads to the failure of the system. In this case, the loss of a propeller is the fault. After detecting the nature of the fault and the component in which the fault has occurred, the next stage is replacing the model of the system with a new model which takes into account the effect of the fault. The original model does not accurately represent the behavior of the system in the event of a fault. Finally, a controller should be devised to control the system represented by the new model. The controller used for this purpose should ensure that the quadcopter stays in flight regardless of the failure of a rotor and that its motion could be controlled sufficiently enough to land it safely on a desired location in the vicinity.
The quadcopter has to maneuver through obstacles at times. Image processing is used for this purpose in this project. One variant of the model involves generating a path through a maze. The image (resolution: 50x50) of the maze is fed into MATLAB as a 50x50x3 array. Each pixel containing an obstacle is assigned a high cost. The cost assigned to the pixel reduces as the quadcopter move away from the obstacles. The aim is to move from the source to the destination while minimizing the cost. The path thus obtained would not only be devoid of obstacles, but also be at a safe distance from them.
Another variant involves scanning the image for safe landing points in case failure occurs. Given the landing points, the one nearest to the quadcopter at the time of failure could be found out using a simple distance formula. But this may not always be the most suitable landing point. The velocity of the quadcopter when the failure occurs should also be taken into account. Instead of going to the nearest landing point, a better alternative is to move to the one which can be reached in the shortest time.
11

Chapter 2 - Literature Survey
The employment of quadcopters in challenging applications like rescue, surveillance comes from its ability to perform aggressive maneuvers and follow complex trajectory in 3D space. For these applications, precise angle handling of quadcopters is important. This calls for a clear understanding of the system dynamics before designing a controller to achieve the purpose.
Mathematical modeling is the first and most critical step towards understanding the system dynamics and monitoring the response. The differential equations governing the quadcopter dynamics derived using the two most popular approaches (Newton-Euler equations and EulerLagrange equations) is presented in [1]. While the derivations are listed for a simplified model, the paper also presents a more realistic model for the quadcopter with the inclusion of the drag force caused by air resistance. Other complex dynamic interactions like aerodynamic effects and blade flapping have been neglected due to challenges in modeling. A matrix approach for the derivation of governing equations is elaborated in [2]. The concept of mixed frame of reference for describing the state variables along with its convenience in developing the mathematical model is described. A more detailed study of the dominant aerodynamic effects on the quadcopter is addressed in [3]. The derivation for exogenous forces on the body of quadcopter, considering even the complex aerodynamic phenomena neglected in the simplified models used in [1] and [2] is also given. The steady state thrust and reaction torque (due to rotor drag) for a hovering rotor in free air is modelled using momentum theory. The lumped parameter approximation used for thrust and reaction torque expressions is shown here, with the constant value obtained from static thrust tests. The dynamic model considering flapping dynamics and rotor stiffness for induced drag is presented here, though these terms are minor considerations from robotics perspective. It is mentioned that high gain control can dominate all the secondary aerodynamic effects, and high performance control can be achieved using the simple static thrust model.
Different control methods for attitude stabilization have been researched, including PID controllers ([1], [3], [5] and [8]), back-stepping controller [4], sliding mode controller ([4] and [12]), linear quadratic regulator ([8] and [10]) and feedback linearization control ([9], [10], [11] and [12]). A hierarchical control approach is implemented in [3], with nested feedback loops as shown in the figure. The control problem is decoupled into position controller and attitude controller, with the position controller providing the set-points to the attitude controller.
12

Figure 1: Control architecture (taken from [3])
An exponentially converging attitude controller is presented considering the measure of error in rotations. A skew-symmetric matrix is generated to go from actual attitude vector to the desired attitude vector. For small deviations from the hover position, the error matrix is linearized and a PD controller gives satisfactory performance. The control law for large deviations is also given, where the error matrix is not linearized. A much simpler PD controller is implemented in [1], where the expression for thrust and torque components are obtained from the error in attitude values, and the individual rotor speeds are calculated from the thrust and torque commands. Here, the motor dynamics is neglected while deriving the force and torque expressions from the motorpropeller system. A PID controller with an additional term for angular acceleration feedback is used for attitude control in [5]. This additional term allows the gains to significantly increase, thereby yielding higher bandwidth. A first order time delay in thrust is also included in the model for controlling each angle.
Among the nonlinear controllers, the most popular approach is feedback linearization control which in turn has two approaches. Both the approaches are discussed in [10] - Exact linearization and non-interacting control via dynamic feedback and Dynamic inversion with zero-dynamics stabilization. The former approach involves the use of dynamic feedback control law, and the nonlinear system cannot be solved using static feedback control. With the position variables chosen as output function, the thrust input is delayed till its second derivative and the system is extended to include the thrust input and its first derivative as the system states. The extended system fulfills the condition for feedback linearization and can be transformed via dynamic feedback into a system which is fully Linear and controllable. The latter approach uses attitude variables as the output variables, and dynamic inversion is carried out with small angle approximation. Here, the attitude variables are differentiated till the input terms appear and the system is not extended. The paper also shows the implementation of Linear Quadratic Regulator (LQR) on the quadcopter, where model linearization is performed using small angle approximation, and the LQR function in Matlab is used to solve the algebraic equation using Riccati’s method and obtain the control gains.
Feedback linearization with position variables and yaw angle as output terms of interest is also shown in [12], where the equations are differentiated twice till the input terms appear. Repeated differentiation of dynamic equations causes it to be very sensitive to noise, along with high cost of
13

computation. Here, the computation is reduced by assuming small angle approximation which also lowers the extent of nonlinearity in the system. Feedback linearization by dynamic inversion is discussed in [10] and [11], where the attitude variables are considered as outputs of interest. A two layer architecture is adopted for structured tracking, with a dynamic inversion inner loop and an internal dynamics stabilization outer loop. Dynamic inversion is carried out with small angle approximations for the Euler angles, which gives a simplified expression for the matrix to be inverted. A back stepping approach is used in [10] to design the linear controller for the linearized dynamics and the residual dynamics. The paper also presents a detailed stability analysis for the two controllers. However, in [11] the traditional PD controller is used to provide the linear control inputs in the inner loop and a PID is designed to perform trajectory following along with internal dynamics stabilization.
A comparative study between these different controllers for attitude stabilization and control is addressed in [4]. The controllers are applied to the system and analyzed separately to find the optimum controller for the quadcopter. As seen in the figure where total error is used to evaluate the performance of different controllers, the sliding mode technique proves to be the superior to other techniques. But the PD controller shows reasonable performance compared to the sliding mode technique, and as its implementation is much easier most of the literature contains PD controller in the model. Inverse control based on feedback linearization is also easy to implement, with better settling time compared to PID and sliding mode controllers though the response is slower.
Figure 2: Comparison between controllers on the basis of total error (taken from [4])
A Comparison between PID control and LQR control is given in [8]. Here, multiple PID controllers are designed for a near hover condition neglecting the gyroscopic effects. In order to implement the LQR, the system is linearized around each state. Linearization around the equilibrium point ignoring the gyroscopic effects causes a huge drift from reality, and is avoided.
14

Feedback linearization controller and sliding mode controllers have superior performance compared to PID as seen in [4], and a detailed analysis between these two controllers is performed in [12]. While feedback linearization controller is simpler to implement, uncertainty in the dynamic model can severely affect performance, and even cause instability. In addition, the dependence on higher derivative terms of states makes it highly sensitive to external disturbances. The sliding mode controller is a more robust approach which compensates for model uncertainties and external disturbances. However, handling these uncertainties causes very high input gains and is a serious problem in power-limited systems like mini quadcopters. Feedback linearization controllers also use more efficient inputs without chattering, compared to sliding mode controller.
All the above papers that implemented feedback linearization (both approaches) have used small angle approximation. This may hold well in near hover conditions, but for a quadcopter involved in trajectory following or sometimes complex motions will have the Euler angles reaching high values. So, a more general approach for feedback linearization is required, which will be addressed through this project.
In addition to the controller, the motor dynamics and their interactions with the drag forces on the propellers is also modelled in [3], with a first order linear approximation. As rotor speed drives the dynamic model, high-quality control of the motor speed is critical for the overall control of the vehicle. Direct voltage control is sufficient in most cases, as the steady state motor speed is directly proportional to the voltage supplied. The performance of the controller is limited by the amount of current that can be supplied by the batteries. Assuming that the battery is able to supply the required current for all rotor speeds and current levels do not exceed the limiting value at any stage, the motor controller can be removed from the system.
Trajectory tracking is a widely studied problem for quadcopters. A lot of literature has focused on nonlinear methods like input-output linearization using differential flatness theory and backstepping control which enables acrobatic maneuvers. For normal trajectory tracking, such approaches are not necessary. Trajectory control in [1] is done using a heuristic approach to generate a symmetric function for jounce to control the acceleration and in turn determine the control inputs to achieve the desired trajectory. A PD controller is integrated into the heuristic method for better response to the disturbances and to stabilize the quadcopter during its trajectory tracking. In [3], the dynamics is linearized about the desired trajectory. An acceleration vector command is computed to minimize the error in the trajectory. The commands for roll and pitch are then calculated based on this acceleration vector and desired yaw angle and fed to the attitude controller. A position controller without linearization is also addressed, where the position error is projected along the yaw axis. A trajectory planning algorithm is discussed in [3], where the problem is simplified by assuming differential flat theory for quadcopters that respect the dynamics of the under actuated system. The trajectory is generated by minimizing a cost function derived from jounce and yaw accelerations. Hence, real time planning is carried out to generate the optimal path. Another trajectory planning algorithm is illustrated in [5]. Here, a sequence of desired
15

waypoints is inputted and a dynamically feasible trajectory is generated that traverses the waypoints in minimum time while satisfying acceleration and velocity constraints. The controller consists of a piecewise PI control in the along direction, and PID in the cross track direction which provides the respective control inputs to follow the desired path. The controllers mentioned above require derivatives of the desired path to be given as input, which limits aggressive maneuvers of the quadcopter. This calls for a trajectory controller that does not depend on the higher order derivatives and can enable complex motions of the quadcopter. Based on the literature survey, the following objectives were established for this project:
1. Implement a linear and nonlinear controller for attitude control of a quadcopter, and perform a comparative study for the same.
2. Integrate a trajectory controller into the attitude controller, to follow the path commands given by the trajectory planner to the nearest landing point. Determine the coordinates of the landing points in the inputted map using image processing and identify the landing site nearest to the point of failure.
3. Develop a trajectory planning algorithm that helps traverse a maze without hitting the walls and test the trajectory controller for this complex trajectory.
4. Develop a failure detection module for the quadcopter to enable switching of controllers in order to ensure stability of the system.
16

Chapter 3 – Methodology
3.1 Mathematical model of quadcopter
The kinematics and dynamics of a quadcopter can be clearly understood by considering two frames of reference: earth inertial frame { O } and body fixed frame { B }. The earth inertial frame is defined with gravity pointing in the negative z direction, and the coordinate axes of the body frame are along the arms of the quadcopter. 4 DC motors are placed at the extremities of all the arms, with a propeller mounted on them to provide the required thrust. In the structure shown in figure
3, Motors 1 and 3 rotate in the counter-clockwise direction with angular velocities ω1 and ω3, whereas motors 2 and 4 rotate in the clockwise direction ω2 and ω4.

Figure 3: Inertial and body frames of quadcopter (taken from [1])

The absolute position of the center of mass of the quadcopter is expressed in the inertial frame as
ε = [ X Y Z ] T . The attitude or the angular position is defined in the inertial frame with the ‘roll-pitch-yaw’ Euler angles η = [ Φ θ Ψ ] T . The linear velocities VB = [ VX VY VZ ] T and angular velocities ν = [ P Q R ]T are defined in the body frame.

The relationship between these two frames is expressed using the rotation matrix 𝑅1

𝐶𝛹𝐶𝜃 𝐶𝛹𝑆𝜃𝑆𝛷 − 𝑆𝛹𝐶𝛷 𝐶𝛹𝑆𝜃𝐶𝛷 + 𝑆𝛹𝑆𝛷

𝑅1 = [𝑆𝛹𝐶𝜃 𝑆𝛹𝑆𝜃𝑆𝛷 + 𝐶𝛹𝐶𝛷 𝑆𝛹𝑆𝜃𝐶𝛷 − 𝐶𝛹𝑆𝛷]

(3.1)

−𝑆𝜃

𝐶𝜃 𝑆𝛷

𝐶𝜃 𝐶𝛷

Where Cθ = cos(θ) and Sθ = sin(θ). R1 is orthogonal, which implies R-1 = RT which is the
rotation matrix from { B } to { O }.
17

Since all the motors are identical, the derivation is explained for a single one. The thrust acting on the quadcopter by a single motor-propeller system is given by momentum theory:

𝑇𝑖 = 𝐶𝐷𝜌𝐴𝑟2𝜔𝑖2

(3.2)

Where CD is thrust coefficient of the motor, ρ is the density of air, A is the cross-sectional area of
the propeller’s rotation, r is the radius of rotor and ω1 is the angular speed of the rotor. For simple
flight motion, a lumped parameter approach is considered to simplify the above equation to

𝑇𝑖 = 𝐾𝜔𝑖2

(3.3)

Combining the thrust from all the 4 motor-propeller system, the net thrust in the body frame Z direction is given by:

𝑇 = 𝐾 ∑ 𝜔𝑖2

(3.4)

Therefore, the net thrust acting on the quadcopter in the body frame is:

𝐹𝐵 = [0 0 𝑇]𝑇

(3.5)

In addition to thrust, a drag force also acts on the quadcopter which is a resisting force. It has components along the coordinate axes in the inertial frame directly proportional to the corresponding velocities. The drag force is given in the component form as

𝐴𝑥 0 0 𝑥̇

𝐹𝐷 = [ 0 𝐴𝑦 0 ] [𝑦̇ ]

(3.6)

0 0 𝐴𝑧 𝑧̇

where Ax, Ay and Az are the drag coefficients in the x, y and z directions.

If all the rotor velocities are equal, the quadcopter will experience a force in z direction will move up, hover or fall down depending on the magnitude of the force relative to gravity. The moments acting on the quadcopter cause pitch, roll and yaw motion. Pitching moment MΦ occurs due to
difference in thrust produced by motors 2 and 4. Rolling moment Mθ occurs due to difference in thrust produced by motors 1 and 3.

𝑀𝛷 = 𝐿(𝑇4 − 𝑇2)

(3.7)

𝑀𝜃 = 𝐿(𝑇3 − 𝑇1)

(3.8)

in which L is the distance between the center of propeller and the center of quadcopter.

Yawing moment MΨ is caused by the drag force acting on all the propellers and opposing their rotation. Again from the lumped parameter approach,

18

𝜏𝑀𝑖 = 𝐵𝜔𝑖2 + 𝐼𝑅𝜔̇ 𝑖

(3.9)

where τM1 is the torque produced by motor 1, B is the torque constant, IR is the inertia moment of
rotor. The effect of 𝜔1̇ is very small and can be neglected.

𝑀𝜓 = 𝐵(−𝜔12 + 𝜔22 − 𝜔32 + 𝜔42)

(3.10)

The rotational moment acting on the quadcopter in the body frame is:
𝑀𝐵 = [𝑀𝛷 𝑀𝜃 𝑀𝜓]𝑇

(3.11)

There is also a rotational drag which is a resistive torque that acts on the body frame which is proportional to the body from angular velocities. The rotational drag is given by:

𝑀𝑅 = [𝐴𝑟𝑃 𝐴𝑟𝑄 𝐴𝑟𝑅]𝑇

(3.12)

where Ar is the rotational drag coefficient.

The model presented here has been simplified by ignoring several complex effects like, blade flapping (deformation of blades at high velocities and flexible materials), surrounding wind velocities etc.

Newton-Euler formulation is used to derive the dynamic equations of motion for the quadcopter. The quadcopter is assumed to have a symmetrical structure, so the Inertia matrix is diagonal and
time-invariant, with IXX = IYY.

𝐼𝑋𝑋 0 0 𝐼 = [ 0 𝐼𝑌𝑌 0 ]
0 0 𝐼𝑍𝑍

(3.13)

In the body frame, the force producing the acceleration of mass m 𝑉𝐵̇ and the centrifugal force ν ×( m VB ) are equal to the gravity RTG and the total external thrust FB and the aero dynamical drag force RTFD.

𝑚 𝑉𝐵̇ + 𝜈 × ( 𝑚 𝑉𝐵 ) = 𝑅𝑇𝐺 + 𝐹𝐵 − 𝑅𝑇𝐹𝐷

(3.14)

In the case of a quadcopter, it is convenient to express the dynamics with respect to a mixed frame { M } with the translational dynamics with respect to the inertial frame and { O } and the rotational dynamics with respect to the body frame { B }.

In the inertial frame, centrifugal effects are negligible. The only forces coming into play are the gravitational force, thrust, drag and acceleration of the mass of quadcopter.

19

𝑚 𝜀̈ = 𝐺 + 𝑅 𝐹𝐵 − 𝐹𝐷

(3.15)

Rewriting this,

𝑥̈ [𝑦̈ ] = 𝑧̈

0 [ 0 ]+𝑅 −𝑔

𝐹𝐵 𝑚

𝐹𝐷 −𝑚

(3.16)

Making the following substitution and taking the component form gives the dynamic equation for translational motion:

̇

𝑋𝑈

[𝑌̇ ] = [ 𝑉 ]

𝑍̇ 𝑊

(3.17)

𝑈̇ =

(sin 𝛷 sin 𝛹 +

cos

𝛷

sin

𝜃

cos

𝛹)

𝑇 𝑚

−

𝐴𝑥 𝑚

𝑈

𝑉̇ =

(− 𝑠𝑖𝑛 𝛷 𝑐𝑜𝑠 𝛹 +

𝑐𝑜𝑠

𝛷

𝑠𝑖𝑛

𝜃

𝑠𝑖𝑛

𝛹)

𝑇 𝑚

−

𝐴𝑦 𝑚

𝑉

𝑊̇

=

−𝑔

+

(

𝑐𝑜𝑠

𝛷

𝑐𝑜𝑠

𝜃)

𝑇 𝑚

−

𝐴𝑧 𝑚

𝑊

(3.18 a) (3.18 b) (3.18 c)

Again, considering the rotational dynamics in the body frame, the angular acceleration of the
inertia I 𝜈̇ , the centripetal forces ν × (I ν) and the gyroscopic forces Ʈ are equal to the external torque MB and the torque generated due to aero dynamic drag.

𝐼 𝜈̇ + 𝜈 × ( 𝐼 𝜈 ) + Ʈ = 𝑀𝐵 − 𝑀𝐷

(3.19)

Rewriting this equation,

𝑃 𝐼𝑋𝑋𝑃

𝑃0

𝜈̇ = 𝐼−1 (− [𝑄] × [𝐼𝑌𝑌𝑄] − 𝐼𝑅 [𝑄] × [0] 𝛺 + 𝑀𝐵 − 𝑀𝐷)

𝑅 𝐼𝑍𝑍𝑅

𝑅1

(3.20)

Where Ω = - ω1 + ω2 - ω3 + ω4 and 𝐼𝑅 is the rotational inertia of each motor.

Writing in component form,

20

𝑃̇ =

(𝐼𝑋𝑋𝐼−𝑍𝑍 𝐼𝑌𝑌 )

𝑄𝑅

−

𝐼𝑅 𝐼𝑋𝑋

𝑄𝛺

+

𝑀𝛷 𝐼𝑋𝑋

−

𝐴𝑟 𝐼𝑥𝑥

𝑃

𝑄̇ =

(𝐼𝑍𝑍

− 𝐼𝑋𝑋 𝐼𝑌𝑌

)

𝑃𝑅

−

𝐼𝑅 𝐼𝑌𝑌

𝑃𝛺

+

𝑀𝜃 𝐼𝑌𝑌

−

𝐴𝑟 𝐼𝑦𝑦

𝑄

𝑅̇ =

(𝐼𝑋𝑋𝐼−𝑍𝑍𝐼𝑌𝑌) 𝑃𝑄 +

𝑀𝛹 𝐼𝑍𝑍

−

𝐴𝑟 𝐼𝑧𝑧

𝑅

(3.21 a) (3.21 b) (3.21 c)

The transformation of angular velocities from body frame to inertial frame is given by:

𝛷̇ [ 𝜃̇ ] =

1 0

𝛹̇ [0

𝑠𝑖𝑛 ∅ 𝑡𝑎𝑛 𝜃 𝑐𝑜𝑠 ∅ 𝑠𝑖𝑛 ∅
𝑐𝑜𝑠 𝜃

𝑐𝑜𝑠 ∅ 𝑡𝑎𝑛 𝜃

− 𝑠𝑖𝑛 ∅ 𝑐𝑜𝑠 ∅
𝑐𝑜𝑠 𝜃

𝑃 [𝑄] ] 𝑅

(3.22)

Using the complete equations of motion describing the dynamics of the system, a quadcopter plant
is created in Simulink using the Level-2 S-Function block. For the plant, the 4 rotor speeds {ω1, ω2, ω3, ω4 } are considered as the inputs and the 12 states in the mixed frame { U, V, W, P, Q, R, Φ, θ, Ψ, X, Y, Z } as the outputs.

Figure 4: Quad plant Simulink Block
Using the equation of thrust and torque mentioned in dynamics of quadcopter and the above four equations of thrust and torques, the values of the angular velocities at each of the four rotors are obtained and shown in Equation 3.25.
21

𝑇

𝐾 𝐾 𝐾 𝐾 𝜔12

(𝑚𝑚𝜙𝜃 ) = 𝑚𝜓 (

0 𝐾𝐿 −𝐾𝐿 0 −𝐵 𝐵

0 −𝐾𝐿 𝜔22

𝐾𝐿 0

𝜔32

−𝐵 𝐵 ) (𝜔42)

(3.23)

Taking inverse of the above matrix, the following equations are obtained for individual rotor speeds:

𝜔12

=

𝑇 4𝑘

−

𝑚𝜽 2𝑘𝑙

−

𝑚𝝍 4𝑏

𝜔22

=

𝑇 4𝑘

−

𝑚𝝓 2𝑘𝑙

+

𝑚𝝍 4𝑏

𝜔32

=

𝑇 4𝑘

+

𝑚𝜽 2𝑘𝑙

−

𝑚𝝍 4𝑏

𝜔42

=

𝑇 4𝑘

+

𝑚𝝓 2𝑘𝑙

+

𝑚𝝍 4𝑏

(3.24 a) (3.24 b) (3.24 c) (3.24 d)

These 𝜔 are then used to calculate the current states of the quadcopter as mentioned before. This model is used to develop both the attitude and trajectory controller along with implementation of the trajectory planner. The model described in the following session is a special case, and is used only to test the failure detection module (Section 3.6).

3.2 Mathematical model of quadcopter with one failed rotor
The dynamics of the quadcopter remains almost the same in the case of failure of one rotor. However, the control problem becomes increasingly complex. It becomes impossible to control the full attitude of a quadcopter with only three functional rotors. Without loss of generality, it can
be assumed that the failed rotor is rotor number 2. This means that the torque control input MΦ is
lost as the torque can now be provided only in one direction. So the spinning of rotor 4 now creates an unbalanced torque. In order to avoid the toppling of the quad, the rotor 4 velocity must be minimized and this creates an unbalance in yaw. Any attempt to maintain the quad in hover in such a case implies that the yaw control must be relinquished. The total number of control inputs reduces to three. This changes only the right-hand side of the dynamical equations which deals with external driving forces and torques which are the control inputs.

22

With rotor 2 encountering failure, ω2 = 0. Therefore net thrust is given by 𝑇 = 𝐾(𝜔12 + 𝜔32 + 𝜔42)

(3.25)

and thrust due to each rotor is 𝑇𝑖 = 𝐾𝜔𝑖2, i = 1,3,4, and the torques are given by

𝑀𝛷 = 𝐿 ∗ 𝑇4
𝑀𝜃 = 𝐿(𝑇3 − 𝑇1) 𝑀𝜓 = 𝐵(−𝜔12 + 𝜔22 − 𝜔32 + 𝜔42)

(3.26) (3.27) (3.28)

As MΦ is no longer a control input, the equation for P is modified to express MΦ in terms of the
other control inputs. The remaining equations stay the same. The modified equations governing the rotational dynamics are given below

𝑃̇

=

(𝐼𝑋𝑋𝐼−𝑍𝑍 𝐼𝑌𝑌 )

𝑄𝑅

−

𝐼𝑅 𝐼𝑋𝑋

𝑄𝛺

+

0.5𝑙

(𝑇− 𝐼𝑋𝑋

𝑀𝜓 𝑑

)

−

𝐴𝑟 𝐼𝑥𝑥

𝑃

𝑄̇ =

(𝐼𝑍𝑍

− 𝐼𝑋𝑋 𝐼𝑌𝑌

)

𝑃𝑅

−

𝐼𝑅 𝐼𝑌𝑌

𝑃𝛺

+

𝑀𝜃 𝐼𝑌𝑌

−

𝐴𝑟 𝐼𝑦𝑦

𝑄

(3.29 a) (3.29 b)

𝑅̇ =

(𝐼𝑋𝑋𝐼−𝑍𝑍𝐼𝑌𝑌) 𝑃𝑄 +

𝑀𝛹 𝐼𝑍𝑍

−

𝐴𝑟 𝐼𝑧𝑧

𝑅

(3.29 c)

The angular velocities of rotors required for desired values of control inputs are given by:

𝑇

1 1 1 𝜔12

[𝑀𝜃 ] = 𝐾 [ −𝑙 −𝑙 0] [𝜔32]

𝑀𝜓

−𝑑 −𝑑 𝑑 𝜔42

(3.30)

Taking the inverse, we get the equations for the three rotor speeds as

𝜔12

=

𝑇 4𝑘

−

𝑚𝜽 2𝑘𝑙

−

𝑚𝝍 4𝑏

𝜔32

=

𝑇 4𝑘

+

𝑚𝜽 2𝑘𝑙

−

𝑚𝝍 4𝑏

𝜔42

=

𝑇 2𝑘

+

𝑚𝝍 2𝑏

(3.31 a) (3.31 b) (3.31 c)

23

3.3 Attitude controller
A quadcopter consists of mainly six outputs of interest (Φ, θ, Ψ, X, Y, Z) with only four control inputs. This is solved by decoupling it into two distinct control loops (figure 5), inner loop dealing with the attitude variables and the outer variable dealing with the position variables. The angular motion of the quadcopter does not depend on the translational components, whereas the translational motion depends on the Euler angles. So the aim is to first control the rotational behavior due to its independence and then control the translational behavior. Controlling vehicle attitude requires sensors to measure vehicle orientation, actuators to apply the torques needed to re-orient the vehicle to a desired attitude, and algorithms to command the actuators based on (1) sensor measurements of the current attitude and (2) specification of a desired attitude. Once the attitude control is designed and optimized, it can be integrated with the trajectory controller. The block diagram for attitude controller is as shown below:
Figure 5: Block diagram of Attitude Controller
A lot of different methods have been studied to achieve autonomous flight, from which three methods (both linear and nonlinear) are discussed below. A comparative study is carried out to identify the most optimal controller for attitude stabilization.
3.3.1 PID controller
Of all the controllers, a PID Controller is the easiest to implement. The general form of PID controller is 24

𝑒(𝑡) = 𝑥𝑑(𝑡) − 𝑥(𝑡) 𝑑
𝑢(𝑡) = 𝐾𝑃𝑒(𝑡) + 𝐾𝐼 ∫ 𝑒(𝜏)𝑑𝜏 + 𝐾𝐷 𝑑𝑡 𝑒(𝑡)

(3.32 a) (3.32 b)

Where u(t) is the control input and e(t) is the error between desired state xd (t) and present state x(t), and KP, KI and KD are the parameters for the proportional, integral and derivative elements
of the PID controller. The desired values of attitude are fed from an attitude command block.
The standard PID control technique is applied on the nonlinear system directly, with an individual PID block for each attitude variable to control it independently. This does not require the model to be linearized about the hover condition, and can thus stabilize the quadcopter on the advent of strong perturbations.
A phi controller is basically an attitude controller which is used to control the attitude of the quadcopter about the X axis. Using this controller, the 𝜙 angle is stabilized. It can also be used to set ϕ to a particular value, which would help in the motion of the quadcopter in Y direction. Similarly, the theta controller and psi controllers are used to stabilize θ and ψ attitudes of the quadcopter. The corresponding torques are calculated using the following equations:

𝑚𝜙 = 𝐼𝑥𝑥 ( 𝐾𝜙,𝐷𝑒𝜙̇ (𝑡) + 𝐾𝜙,𝑃𝑒𝜙(𝑡) + 𝐾𝜙,𝐼 ∫ 𝑒𝜙(𝑡)𝑑𝑡 ) 𝑚𝜃 = 𝐼𝑦𝑦(𝐾𝜃,𝐷𝑒𝜃̇ (𝑡) + 𝐾𝜃,𝑃𝑒𝜃(𝑡) + 𝐾𝜃,𝐼 ∫ 𝑒𝜃(𝑡)𝑑𝑡) 𝑚𝜓 = 𝐼𝑧𝑧(𝐾𝜓,𝐷𝑒𝜓̇ (𝑡) + 𝐾𝜓,𝑃𝑒𝜓(𝑡) + 𝐾𝜓,𝐼 ∫ 𝑒𝜓(𝑡)𝑑𝑡)

(3.33 a) (3.33 b) (3.33 c)

Where 𝑒𝜙(𝑡) = 𝜙𝑑(𝑡) − 𝜙(𝑡), 𝑒𝜃(𝑡) = 𝜃𝑑(𝑡) − 𝜃(𝑡) and 𝑒𝜓(𝑡) = 𝜓𝑑(𝑡) − 𝜓(𝑡).
The Z controller is used to stabilize the altitude of the quadcopter to a desired value. Similar to the angular attitude controllers, this controller also employs a PID to control the altitude. Here, the thrust required is calculated using the following equation:

𝑇 = 𝑚𝐶𝜃𝐶𝜙 [𝑔 + 𝐾𝑧,𝐷𝑒𝑧̇ (𝑡) + 𝐾𝑧,𝑃𝑒𝑧(𝑡) + 𝐾𝑧,𝐼 ∫ 𝑒𝑧(𝑡)𝑑𝑡]

(3.34)

Where 𝑒𝑧(𝑡) = 𝑧𝑑(𝑡) − 𝑧(𝑡).

25

Since thrust is calculated in the body frame while 𝑔 and other PID terms are in the inertial frame, a rotational matrix is applied to the terms in the inertial frame which is given by 𝐶𝜃𝐶𝜙 where 𝐶
stands for cos function.

3.3.2 Feedback linearization controller

Feedback linearization control is a popular nonlinear control approach, where the nonlinear system is algebraically transformed into (fully or partly) linear ones by cancelling the nonlinearities. Most feedback linearization techniques are based either on input-output linearization or input-state linearization. We have adopted the input-output linearization in our work. Input-Output linearization involves the repeated differentiation of the output variables till the input term appears,
the last derivative being the rth one. This will help in obtaining a mapping between the transformed
inputs and the outputs. We use the concept of dynamic inversion to the system given by [], which yields the inner loop that feedback linearizes the system from the control input to the output. The output variables not considered above is called residual or internal dynamics. Dynamic inversion need not necessarily yield the internal dynamics stable, which will then require another outer stabilizing loop.
Consider a SISO (Single Input Single Output) system with state x, input u and output y whose dynamics are given by

𝑥̇ = 𝑓(𝑥) + 𝑔(𝑥)𝑢

(3.35)

𝑦 = ℎ(𝑥)

The derivative of the output y can be expressed as

𝑦̇

=

𝜕ℎ 𝜕𝑥

[𝑓(𝑥)

+

𝑔(𝑥)𝑢]

(3.36) (3.37 a)

The derivative of h along the trajectory of the state x is known as the Lie Derivate and equation (3.41) can be written in terms of lie derivative as

𝜕ℎ 𝑦̇ = 𝜕𝑥 [𝑓(𝑥) + 𝑔(𝑥)𝑢] = 𝐿𝑓ℎ(𝑥) + 𝐿𝑔ℎ(𝑥)𝑢

(3.37 b)

The output y is differentiated continuously until input terms appear in the differential equation. Generally, the ith derivative of y is expressed in terms of lie derivative as

26

𝑦(𝑖) = 𝐿𝑓𝑖 ℎ(𝑥) + 𝐿𝑔𝐿𝑓𝑖−1ℎ(𝑥)𝑢

The above equation can be linearized through dynamic inversion, choosing u as

𝑢

=

1 𝐿𝑔 𝐿𝑓𝑖−1 ℎ(𝑥)

[−𝐿𝑓𝑖 ℎ(𝑥)

+

𝑣]

(3.38) (3.39)

This yields the simple output equation

𝑦𝑖 = 𝑣

(3.40)

The concepts used for the SISO systems can be extended to MIMO systems. In particular, we consider square systems having the same number of inputs and outputs. Suppose that an input term first appears in the rth derivative of the ith output. Then, the equation for the ith output is expressed as

𝑚

𝑦𝑖(𝑟𝑖) = 𝐿𝑓𝑟𝑖ℎ𝑖(𝑥) + ∑ 𝐿𝑔𝑗𝐿𝑓𝑟𝑖−1ℎ𝑖(𝑥)𝑢𝑗

(3.41)

𝑗=1

The set of differential equations that corresponds to the input – output relations may be expressed

in the matrix form as

𝑦𝑖(𝑟𝑖)

𝐿𝑓𝑟1 ℎ1 (𝑥)

𝑢1

[ ⋮ ] = [ ⋮ ] + 𝑬(𝑥) [ ⋮ ]

𝑦𝑚(𝑟𝑚)

𝐿𝑓𝑟𝑚 ℎ𝑚 (𝑥)

𝑢𝑚

(3.42)

Where E(x) is an m x m coefficient matrix of the inputs.

This set of equations can be converted to simple linear equations for the outputs by the following input transformation

𝐿𝑓𝑟1 ℎ1 (𝑥)

𝒖 = −𝑬−1 [ ⋮ ] + 𝒗

[ 𝐿𝑓𝑟𝑚ℎ𝑚(𝑥)

]

(3.43)

This yields equations of the form
𝑦𝑖(𝑟𝑖) = 𝑣𝑖

(3.44)

27

Thus, the inversion-based control law has the capability in shaping the output response by simply
designing the new controls vi to get the desired output.
To implement this controller, we assume the system is decomposed into two sub models – M1 with
states X1 = [Z, Φ, θ, Ψ, W, P, Q, R] and M2 with states X2 = [X, Y, U, V].
Consider the inner loop with the sub model M1 and output variables

Y1 = [Z Φ θ Ψ] T

(3.45)

The first derivative w.r.t time does not contain input terms, as evident from the following equations. The expressions are obtained from Equations 3.17 and 3.22.

𝑍̇ [𝛷𝜃̇̇ ] =

1
0 0

𝛹̇ [0

0 1 0
0

00

𝑠𝑖𝑛 ∅ 𝑡𝑎𝑛 𝜃 𝑐𝑜𝑠 ∅ 𝑡𝑎𝑛 𝜃 𝑊

𝑐𝑜𝑠 ∅ − 𝑠𝑖𝑛 ∅ 𝑠𝑖𝑛 ∅ 𝑐𝑜𝑠 ∅
𝑐𝑜𝑠 𝜃 𝑐𝑜𝑠 𝜃

[

𝑃 𝑄

]

] 𝑅

(3.46)

The transformation matrix is denoted by MatW.

Differentiating this again gives:

𝑍̈

𝑊

𝑊̇

𝑌1̈

=

[𝛷𝜃̈̈ ] =

𝑑 𝑑𝑡

(𝑀𝑎𝑡𝑊) ∗

[

𝑃 𝑄

]

+

𝑀𝑎𝑡𝑊

∗

[

𝑃̇ 𝑄̇

]

𝛹̈

𝑅

𝑅̇

(3.47)

The expressions of 𝑊̇ , 𝑃̇ , 𝑄̇ , and 𝑅̇ contain input terms are obtained from Equations 3.18 c
and 3.21.

28

−𝑔

𝑊̇

[

𝑃̇ 𝑄̇

]

=

𝑅̇

(𝐼𝑋𝑋𝐼−𝑍𝑍 𝐼𝑌𝑌 )

𝑄𝑅

−

𝐼𝑅 𝐼𝑋𝑋

𝑄𝛺

(𝐼𝑍𝑍

− 𝐼𝑋𝑋 𝐼𝑌𝑌

)

𝑃𝑅

−

𝐼𝑅 𝐼𝑌𝑌

𝑃𝛺

[

(𝐼𝑋𝑋𝐼−𝑍𝑍𝐼𝑌𝑌) 𝑃𝑄

]

1

( 𝑐𝑜𝑠 𝛷 𝑐𝑜𝑠 𝜃) 𝑚 0 1

00

𝑇

+

0

0

[

0

𝐼𝑋𝑋
0 0

0
1 𝐼𝑌𝑌 0

0 0 1

[𝑀𝑀𝛷𝜃 ] 𝑀𝛹

𝐼𝑌𝑌 ]

= 𝑀𝑎𝑡𝐶 + 𝑀𝑎𝑡𝐷 ∗ 𝑈

(3.48)

From the above equations, we obtain the general form for 𝑌1̈ 𝑌1̈ = 𝐴1(𝑿𝟏) + 𝐵1(𝑿𝟏) ∗ 𝑈

(3.49)

𝑊

Where

𝐴1(𝑿𝟏) = 𝑀𝑎𝑡𝐴 =

𝑑 𝑑𝑡

𝑀𝑎𝑡𝑊 ∗

[

𝑃 𝑄

]

+ 𝑀𝑎𝑡𝑊 ∗

𝑀𝑎𝑡𝐶

and

𝑅

𝐵1(𝑿𝟏) = 𝑀𝑎𝑡𝐵 = 𝑀𝑎𝑡𝑊 ∗ 𝑀𝑎𝑡𝐷

The relative degree of the system is calculated as eight, whereas number of states of the system is twelve. To ensure the stability of the whole system, the remaining internal dynamics must be stabilized. But if we consider the sub model that has eight states, the sub model is stabilized.

Based on the general form, the input to the system can be written as:

𝑈 = 𝛼(𝑿𝟏) + 𝛽(𝑿𝟏) ∗ 𝜗

(3.50)

where 𝛼(𝑿𝟏) = −𝐵1(𝑿𝟏)−1 ∗ 𝐴1(𝑿𝟏)
29

and 𝛽(𝑿𝟏) = 𝐵1(𝑿𝟏)−1
This on simplification yields 𝑌1̈ = 𝜗, which is a linear system.
The new input 𝜗 = [𝜗1 𝜗2 𝜗3 𝜗4] 𝑇 can be designed using any of the standard linear control
techniques.
In the first approach, we used PD controller to design the 4 linear control inputs, where the error
term is given by 𝑒 = 𝑍𝑑 − 𝑍 and so on. The control gains are tuned manually to obtain the
desired response.

3.3.3 Linear Quadratic Regulator

In the second approach, the control inputs are designed using the Linear Quadratic Regulator (LQR) approach. LQR is an optimal control technique used to determine the control signal which drives the system states to the desired value along with minimizing a cost function. Hence, the control effort in case of LQR is the least.
Consider a dynamic system of the form:

𝑿̇ = 𝐴 . 𝑿 + 𝐵 . 𝑈 𝒀 = 𝐶.𝑿

(3.51 a) (3.51 b)

The cost function for this optimal problem is given by:

∞
𝐽 = ∫ {𝑈(𝑡)𝑇 . 𝑅 . 𝑈(𝑡) + [𝑿(𝑡) − 𝑿𝒅(𝑡)]𝑇 . 𝑄 . [𝑿(𝑡) − 𝑿𝒅(𝑡)] } 𝑑𝑡
𝑡0

(3.52)

Where R is the cost of actuators and Q is the cost of the state.

The control input U that minimizes the cost function is a static linear feedback as:

𝑈 = −𝐾 . [𝑿(𝑡) − 𝑿𝒅(𝑡)]

(3.53)

The value of K is obtained by solving the Riccati’s algebraic equation, performed by Matlab using
the LQR function:

𝐾 = 𝐿𝑄𝑅(𝐴, 𝐵, 𝑄, 𝑅)

(3.54)

30

The decomposition of the dynamic model into sub models M1 and M2 is done in this case too, with the controller being designed for the sub model M1. The equations in state variable form for the eight states is the same as Equations 3.18 c, 3.21 and 3.22.

The sub model M1 is linearized around the equilibrium point (near hover condition) using the

Jacobian approach ( 𝐴𝑟

=

𝜕 𝜕𝑥

𝐴(0) and 𝐵𝑟

= 𝐵(0) ).

The linearized plant dynamics is given by

𝑿𝟏̇ = 𝐴𝑟𝑿𝟏 + 𝐵𝑟𝑈

(3.55 a)

𝑌1 = 𝐶𝑿𝟏

(3.55 b)

0000 0000 0000 0000
0000 where 𝐴𝑟 =
0000

0000

[0 0 0 0

00 0

00 0

00 0

00 0

10 0

𝐵𝑟 = 𝑚 0

1

0

𝐼𝑋𝑋

00 1
𝐼𝑌𝑌

[0 0 0

10

01

00

0 − 𝐴𝑧
𝑚
0

0 0 − 𝐴𝑟
𝐼𝑋𝑋

00

00

0 0 0 0
0
and
0

0
1
𝐼𝑍𝑍]

0 0 1 0 0
0
− 𝐴𝑟
𝐼𝑌𝑌
0

0 0 0 1
0
,
0

0

−

𝐴𝑟
𝐼𝑍𝑍]

31

10000000

01000000

00100000

𝐶=

0 0

0 0

0 0

1 0

0 0

0 0

0 0

0 0

00000000

00000000 [0 0 0 0 0 0 0 0]

A function called linriz.m (Appendix A7) was written in Matlab to solve the algebraic equation using Riccati’s method, where the LQR in-built function was employed.

𝐾 = 𝐿𝑄𝑅(𝐴𝑟, 𝐵𝑟, 𝑄, 𝑅)

(3.56)

The 𝑄 matrix is then modified manually, the above equation is again solved to find the control
gains until the desired response is achieved.

3.4 Trajectory planning using image processing
Processing of visual information from the environment is desirable for an unmanned aerial vehicle. This becomes a necessity when the vehicle is autonomous. This visual information is fed into the quadcopter processor in the form of images. Obtaining useful information from the image data is necessary for taking decisions in case of an autonomous vehicle. This might involve determining the shortest path between two locations, identifying no-fly zones or traversing an environment full of obstacles. Therefore, image processing has an important role to play in the future of quadcopters.
3.4.1 Feasible landing point
Safe landing locations are represented by black circles in the input image. The objective of this algorithm is to calculate the coordinates of the centres of all the black circles in this image. The most suitable landing point is then found out based on the current position and velocity of the quadcopter. The inputted image is converted to grayscale and then to a black and white image. A very low threshold, while converting to black and white, ensures that only the darkest pixels are retained and the rest are converted to white.The features left in the image, that are less than a nominal
32

number of pixels, are considered to be disturbances and hence filtered out. The current image consists of only the most prominent black features.

The number of pixels lying on the perimeter of each of these features and the total number of pixels contained by each of these features (can be considered as area) can be calculated using in-built MATLAB functions. The metric used to decide if a given feature is a circle or not is given by:

4 ∗ 𝜋 ∗ 𝐴𝑟𝑒𝑎 𝑀𝑒𝑡𝑟𝑖𝑐 = (𝑃𝑒𝑟𝑖𝑚𝑒𝑡𝑒𝑟)2

(3.57)

It can be easily observed that the value of the above parameter equals 1 when the geometry is a circle. No two-dimensional geometry is possible for which the metric exceeds the value of 1. As the value of the metric approaches 1, geometry of the feature approaches that of a circle. Hence the metric is calculated for all the features and and the ones that surpass the threshold (0.9 in our case) qualify as a circle.

The mere proximity of a landing point to the quadcopter at the time of failure is not the best criterion for its selection. Minimizing the time taken to reach the landing point serves the purpose better. The distance from the landing point to the quadcopter and velocity of the quadcopter, at the time of failure, both, are taken into account. Using this, a landing point is suitably selected.

The algorithm for the above task is explained below:-

Let θ1 be the inclination of the line joining point of failure and landing point being considered with respect to the x-axis in the global coordinate system.

Let θ2 be the inclination of the velocity vector of quadcopter at point of failure with respect to the x-axis in the global coordinate system.

Then,

θ = θ1 - θ2, is the angle between the two lines.

Now, va is the velocity of the quadcopter along the line joining point of failure and landing point, and vp is the velocity of the quadcopter perpendicular to it.

𝑣𝑎 = |𝑣 ∗ 𝑐𝑜𝑠 𝜃|

(3.58 a)

𝑣𝑝 = |𝑣 ∗ sin 𝜃|

(3.58 b)

where 𝑣 is the velocity of the quadcopter at the time of failure.
The quadcopter has a maximum limit of acceleration. To reach the landing point in the shortest time, it is ensured that the quadcopter’s perpendicular displacement from the line joining the point

33

of failure and the landing point, reaches zero in the same time as it reaches the landing point along the line.

0

=

𝑢𝑡

+

1 2

𝑎𝑝

𝑡2

(3.59)

𝑑

=

𝑢𝑡

+

1 2

𝑎𝑎 𝑡 2

(3.60)

Here d is the distance between the landing point and point of failure.

Solving for t,

(−2 ∗ 𝑣𝑎 𝑢

∗ 𝑣𝑝) +

(2 ∗ 𝑣𝑝2 ∗ 𝑎𝑝) 𝑎𝑎2

=

𝑑

(3.61)

Also
𝑎𝑝2 + 𝑎𝑎2 = 𝑎2,

(3.62)

which is the maximum acceleration possible for the quadcopter.

On solving these two equations using MATLAB function, the value of ap and aa is obtained.

With the obtained accelerations along and perpendicular to the quadcopter, the shortest time required to move to the landing point is calculated using the equation,

𝑡

=

−2 ∗ | 𝑎𝑝

𝑣𝑝

|

(3.63)

Similarly, the time required for the quadcopter to move to the other landing points are also calculated. Then, the landing point with the shortest time required is chosen for safe landing of the quadcopter.

3.4.2 Trajectory planning algorithm
For maneuvering through the maze, a trajectory is devised from the image using a shortest path algorithm, called Dijkstra’s algorithm. Each pixel in the image is considered a node. Each node is assigned a weight based on its proximity to an obstacle. The pixels containing the obstacles have the highest weight and these nodes are not a part of the network. The node at the top left corner of
34

the image is called the initial node. Let the weight of node Y be the cost assigned to that node. The algorithm is as follows:
1. The initial node is set to current. All the other nodes are marked unvisited. A set of all the unvisited nodes called the unvisited set is created.
2. For the current node, all of its unvisited neighbors are considered and their tentative weights are calculated. The newly calculated tentative weight is compared to the current assigned value and the smaller one is assigned.
3. After considering all of the neighbors of the current node the current node is marked as visited and is removed from the unvisited set. A visited node is never checked again.
4. If the destination node has been marked visited, the algorithm is stopped. 5. Otherwise, the unvisited node that is marked with the smallest tentative weight is selected,
and is set as the new "current node", and the algorithm is repeated from step 2.
Once the trajectory from the source node to the destination node is obtained, it is traced by colored lines using MATLAB functions. A time series data of the trajectory is to be fed to the quadcopter model for trajectory tracking. For this, the time taken to move from one node to the neighboring node is assumed to be of the ratio 1:√2 for horizontal/vertical nodes and diagonal nodes, i.e. the time taken by a quadcopter to move to a diagonally adjacent node is √2 times the time it would take to move to a vertically or horizontally adjacent node.
Using this assumption, the units of time required to move from the source node to the destination node is calculated, by adding√2, if the next adjacent node is diagonal and 1, if it is horizontal or vertical, to the current node in the path obtained by Dijkstra’s algorithm.
Once the total time is computed, the actual time of flight of the quadcopter is divided by this total time, to get the equivalent of 1 unit in seconds. Now, having the X, Y and time data of each node in the path available, a time series data of the path from source node to destination node is created.
This time series data is taken from the workspace by the Simulink block of the quadcopter model when the simulation is started.
3.5 Trajectory Controller
In this controller, the deviation from the desired path is calculated (in the body frame) at every instant and is fed to the succeeding blocks as the desired velocity. Using this, the desired roll and pitch angles are calculated. This is the underlying principle of this controller.
The errors in X and Y positions are transformed from the inertial frame to the body frame.
35

Error in X in body frame = (𝑋𝑑 − 𝑋) 𝑐𝑜𝑠(𝜓) + (𝑌𝑑 − 𝑌) 𝑠𝑖𝑛(𝜓) (3.64 a)

Error in Y in body frame = (𝑌𝑑 − 𝑌) 𝑐𝑜𝑠(𝜓) − (𝑋𝑑 − 𝑋) 𝑠𝑖𝑛(𝜓) (3.64 b)

These errors are taken as the desired velocities in body frame. Therefore,
𝑈𝑑 = Error in X in body frame

(3.65 a)

𝑉𝑑 = Error in Y in body frame

(3.65 b)

The next step is calculation of desired attitudes in order to feed it to the attitude controller.

𝜃𝑑 = 𝐾𝑝,𝜃(𝑈𝑑 − 𝑈) − 𝐾𝑑,𝜃(𝑈̇ )

(3.66 a)

𝛷𝑑 =−{𝐾𝑝,𝛷(𝑉𝑑 − 𝑉) − 𝐾𝑑,𝛷(𝑉̇ )}

(3.66 b)

The above equations are devoid of 𝑉𝑑̇ and 𝑈𝑑̇ terms. The absence of these terms permits the
presence of non-differentiable points in the path function.

36

Chapter 4 - Simulation

The dynamic model, controllers and the trajectory planners are implemented in Matlab/Simulink. Separate simulations are carried out for attitude control comparison, trajectory following to the nearest landing point and trajectory following based on the planner. The complete Simulink model including the path commands, trajectory controller, attitude controller and the quadcopter plant is shown in Appendix A15.

The values for the parameters in the quad plant are given in Table 1.

Parameter g L m K d B IXX IYY IZZ
IR

Value 9.81 0.225 0.468 2.98*10-6 0.0382 0.114*10-6 4.856*10-3 4.856*10-3 8.801*10-3
3.357*10-5

Unit m/s2 m kg
kg m2 kg m2 kg m2 kg m2

Table 1: Parameter values for quad plant

The initial conditions given to the quadcopter states for the simulation with feasible landing point is mentioned in Table 2.

State X Y Z U V W

Value

State

0 m

Φ

0 m

θ

2 m

Ψ

0 m/s

P

0 m/s

Q

0 m/s

R

Value 10 rad 12 rad 10 rad 0 rad/s 0 rad/s 0 rad/s

Table 2: Initial conditions for trajectory control simulation 1

37

The initial conditions given to the quadcopter states for the simulation with trajectory planner is mentioned in Table 3.

State X Y Z U V W

Value

State

1 m

Φ

1 m

θ

2 m

Ψ

0 m/s

P

0 m/s

Q

0 m/s

R

Value 0 rad 0 rad 0 rad 0 rad/s 0 rad/s 0 rad/s

Table 3: Initial conditions for trajectory control simulation 2

4.1. Simulation for attitude controller comparison
The three controllers – Feedback linearization with PD controller (FBL+ PD), Feedback linearization with LQR (FBL+LQR), and PID controller are implemented as separate Simulink models and simulated. The Simulink block layout is shown in Appendices A3- A6. A simulation time of 50s with a variable step size is given, and Ode-45 Dormand-Prince method is used to solve the numerical problem.

4.1.1. Attitude commands
The attitude commands are provided from a block, which contains step functions for each of the attitude variables. The step function starts with the initial condition as shown in Table 2, and falls to 0 with a step time of 5s for the 3 angles and rises to 3 with the same step time for height command.

4.1.2. Control gains
For the FBL+ PD controller combination, the values of all control gains are determined through manual tuning.

38

Controller

KP

KD

Roll

3

2

Pitch

3

2

Yaw

2

2

Height

3

2

Table 4: Gain values for attitude controller 1

For LQR, the values of all control gains are determined through inbuilt LQR Matlab function, as shown in linriz.m (Appendix A7).

Controller

K1

Roll

10

Pitch

10

Yaw

10

Height

10

K2 0.1703 0.1703 .0267 2.8195

Table 5: Gain values for attitude controller 2

For the PID controller, the values of all 3 gains are determined through manual tuning.

Controller

KP

Roll

6

Pitch

5

Yaw

6

Height

15

KI

KD

1.5

1.75

3

3

1.5

1.75

10

10

Table 6: Gain values for attitude controller 3

4.2. Simulation for trajectory following – feasible landing point
4.2.1. Path commands
The path commands are provided by two blocks, one that guides the quadcopter to the final goal location and the other that guides it to the nearest landing point determined through the image processing module. The quadcopter’s mission is to follow the specified trajectory and stop at its destination with the desired attitude values. A switch is used to change the source of path commands, which is to be activated by the failure detection module. Here, a clock input is given and switching at the end of 50s is performed assuming that the failure occurs then.

39

For the initial path commands, X and Y are fed as a ramp input such that the final goal having
coordinates (100,200) is reached within 100s. Z and Ψ are given as a constants 2m and 0 rad
respectively.
For the alternative path commands block, the current state is taken as input. The image processing module returns back the coordinates of the nearest landing location. Based on these two points, a ramp is created till the landing point for both X and Y. Once the actual X or Y reaches within 0.005% of the desired value, the ramp is replaced by a step with the desired value as magnitude.

4.2.2. Control gains

Figure 6: Desired path with switching

For the position PD controller, the values for proportional and derivative gains are determined through manual tuning till the desired performance is achieved.

Controller

KP

KD

Φ command

0.5

0.4

Θ command

0.36

0.45

Table 7: Gain values for trajectory controller

4.3. Simulation for trajectory following – using a trajectory planner
4.3.1. Path commands
The pathcr.m file, which performs the trajectory planning, is first run to obtain the path command data. While the desired X and Y commands are obtained as a time series data, the Z and Ψ values 40

are given as a constant function. Compared to the previous simulation, the quadcopter is made to follow a more complex trajectory.
4.3.2. Control gains

For the position PD controller, the values for proportional and derivative gains are determined through manual tuning till the desired performance is achieved.

Controller

KP

KD

Φ command

0.5

0.4

Θ command

0.36

0.45

Table 8: Gain values for trajectory controller

4.3.3. VR Simulation
The Simulink 3D Animation package provides apps for linking Simulink models and MATLAB algorithms to 3D graphics objects. This package can be used to visualize and verify dynamic system behavior in a virtual reality environment. Objects are represented in the Virtual Reality Modeling Language (VRML), a standard 3D modeling language. A 3D world can be animated by changing position, rotation, scale, and other object properties during desktop or real-time simulation.
A VR simulation model of the quadcopter was created using 3D World Editor in MATLAB. This model could be rotated or translated about any axes. It was then implemented into the various SIMULINK models of the quadcopter using a VR Sink block. The phi, theta and psi states of the quadcopter were connected to the rotation control of the VR model and the X, Y and Z states were connected to the translation control. Once the SIMULINK model is run, the VR model achieves the corresponding motion in a given terrain which can be seen through a VR simulator.

41

Figure 7: A VR model of quadcopter during simulation (viewpoint 1)
Figure 8: A VR model of quadcopter during simulation (viewpoint 2)
42

Chapter 5 - Results and Discussions
5.1 Attitude controller comparison
To compare the three different controllers used for the attitude control, a step input is provided as the desired value for each of the attitude variables. The comparison is done based on parameters like rise/fall time and percentage overshoot/undershoot.
Looking at the step response for Φ as seen in figure 9, it is evident that LQR controller shows
the best performance as the fall time is least and there is no significant undershoot. The combination of FBL and PD controller shows a comparatively slower response with some undershoot. PID controller shows comparatively poor performance as the fall is very gradual and it takes a long time to settle, though with no oscillations. All the three controllers reach the steady state value with no oscillations, and so settling time is not considered here.
Figure 9: Step responses of controllers – Φ
43

Table 9 gives a quantitative comparison between the parameters mentioned above, which clearly shows the superior performance of LQR.

Φ(t) Fall time (s) Undershoot (m) %

FBL + PD 1.076 5.851

PID 2.792 14.368

LQR 0.059 0.556

Table 9: Characteristic parameters to a step input for Φ

Consider the step response for θ, where LQR again shows the better performance. The
combination of FBL and PD controller has almost similar fall time, but shows some undershoot. The PID controller shows a large undershoot and some oscillations leading to a poor response. Based on settling time, both LQR and FBL+PD combination show similar performance but PID lags far behind.

Figure 10: Step responses of controllers – θ

Table 10 gives a clearer picture about the θ response of the three controllers for a step input.

θ(t) Fall time (s) Undershoot (m) %

FBL + PD 1.076 5.851

PID 3.612 30.921

LQR 0.074 0.505

Table 10: Characteristic parameters to a step input for θ

44

Figure 11 shows the step response for Ψ for the three controllers. Here, the combination of FBL and PD controller show the best performance with very small undershoot and a decent fall time. LQR shows the least fall time, but has a large undershoot and rapidly varying response before settling. PID also shows a very undershoot and the slowest response among the three controllers.

Figure 11: Step responses of controllers – Ψ

Table 11 contains the values of the characteristic parameters used for comparison, and clearly shows that the combination of FBL and PD controller has the best performance.

Ψ(t) Fall time (s) Undershoot (m) %

FBL + PD 1.561 1.531

PID 2.32 19.88

LQR 0.053 15.698

Table 11: Characteristic parameters to a step input for Ψ

For Z control, since a positive step was given as input the comparison is made on the basis of rise time and percentage of overshoot. Figure 12 shows the response of the three controllers, from which it is evident that the combination of FBL and PD controller has the best performance. It shows the least overshoot and remains steady before the step input is given. The PID controller has a faster rise, but higher overshoot due to the step input and a deviation before the step is provided. LQR shows a very poor performance in this case, as it saturates below the desired height. It also shows deviations before the step is given.

45

Figure 12: Step responses of controllers –Z

From table 12, it is clear that the combination of FBL and PD controller has the best performance.

Z(t) Rise time (s) Overshoot (m) %

FBL + PD 1.07 5.851

PID 0.788 21.341

LQR 0.33
58.871

Table 12: Characteristic parameters to a step input for Z

Finally, a comparison can also be made based on the computational time. All the 3 controllers were simulated for 50s in Matlab. As seen in the table below, the computational time is least for the combination of FBL and PD controller.

Controller FBL + PD
PID LQR

Simulation time (sec) 2.98 4.08 5.10

Table 13: Computational time of controllers
From the comparative study presented above, it is very evident that the combination of Feedback Linearization and PD controller shows the best performance. Hence, a trajectory controller is integrated with this to achieve the desired trajectory tracking.

46

5.2 Trajectory planner 5.2.1 Selecting the most feasible landing point
Figure 13: Image containing different shapes in different colors
The input image consists of various shapes in various colors. The final image consists of only the black circles. The centroids of these circles are the feasible landing points.
Figure 14: Black circle given as output
47

5.2.2 Trajectory Planning algorithm
Figure 15 : Maze input to the trajectory planner
The input maze consists of walls which are no fly zones shown in Figure 15. The Figure 16 shows the path generated by the trajectory planner.
Figure 16 : Path generated by the trajectory planner
48

5.3 Trajectory tracking 5.3.1 Trajectory tracking – Most feasible landing point
A comparison can be made between the desired trajectory and the actual trajectory using Figure 17. It can be inferred that the quadcopter is able to follow the trajectory with reasonable accuracy throughout. At the point of switching, the inertia of the quadcopter prevents it from making a sharp change in the trajectory. So it consumes some time before again following the desired trajectory. When it approaches the end point, the change in input from ramp to step occurs, but the quadcopter due to its inertia oscillates about that point before finally resting there. The final location of the quadcopter is exactly in the specified landing point, which can be concluded from Figure 18 where X and Y comparisons are plotted.
Figure 17: Actual path followed
49

Figure 18: Coordinate wise comparison of desired and actual paths
The plots of attitude variables vs time for the above simulation is given in Figure 19. There are three regions of interest – the starting point when a path command is given, during switching and finally after reaching the landing point. The attitude variables show changes only in these three regions.
Figure 19: Plots of attitude variables vs Time
50

5.3.2. Trajectory tracking – traversing the maze
In this simulation, the quadcopter is traversing a complex maze. The path planning is done based on the image of surroundings. The image is processed to identify obstacles and safe flying zones. The Dijkstra’s algorithm is employed to determine the shortest path from the starting point to destination. Then, trajectory tracking is used to closely follow this path. The shortest path from the left top corner of the image to the right bottom corner of the image is generated using Dijkstra’s Algorithm. The path is efficient and is devoid of any obstacles. This path can be seen in Figure 20.
Figure 20: Desired path generated by trajectory planner
This trajectory is fed in the form of a time series data to the controller. The trajectory is followed with reasonable accuracy. It is visible in Figure 21 that all the sharp turns in the desired trajectory are transformed to smooth curves in the actual path due to the inertia of the quadcopter.
51

Figure 21: Actual path followed by quadcopter
The trajectory controller is successful in guiding the quadcopter to traverse such a complex path, which is clearly seen in Figure 22 through a coordinate wise comparison. Although there is a slight lag between the desired and actual paths due to the slow response of the trajectory controller, it finally ceases at the end when the destination is reached.
Figure 22: Coordinate wise comparison of desired path and actual path
52

The attitude plots, especially the roll and pitch angles show changes throughout the course of the quadcopter motion because of the complexity in path. Theta and x are correlated whereas Phi and y are correlated. Z settles at 3m soon after the start of the simulation.
Figure 23: Plots of Attitude variables vs Time
53

Further work
Miniature Unmanned Aerial Vehicles (UAVs) with ability to vertically take-off and land (as in quadrotors) exhibit advantages and features in maneuverability that has recently gained strong interest in the research community. All the simulations were carried out ensuring that the quadcopters entire motion occurs at sufficient height above the ground, and take-off and landing are not performed by the quadcopter. The phenomenon of ground effect has also not been considered at low altitudes. Incorporating the ability to perform vertical take-off and landing overcoming ground effects is a key issue which will be addressed in the future. Reliability of control systems require robustness and fault tolerance capabilities in presence of anomalies and unexpected failures in actuators, sensors or subsystems. Designing a controller that can combat the failure of one or more rotors is a further step in this project. Based on the inputs from the FDI module, the quadcopter must be equipped to switch to the failsafe controller on the onset of failure. Implementing an adaptive control strategy of this kind is another key issue to be addressed.
54

References
[1] Luukkonen, Teppo. "Modelling and control of quadcopter." Independent research project in applied mathematics, Espoo (2011).
[2] Hossain, M. Raju, D. Geoff Rideout, and D. Nicholas Krouglicof. "Bond graph dynamic modeling and stabilization of a quad-rotor helicopter." Proceedings of the 2010 Spring Simulation Multiconference. Society for Computer Simulation International, 2010.
[3] Mahony, Robert, Vijay Kumar, and Peter Corke. "Multirotor aerial vehicles: Modeling, estimation, and control of quadrotor." IEEE robotics & automation magazine 19.3 (2012): 20-32.
[4] Dikmen, I. Can, Aydemir Arisoy, and Hakan Temeltas. "Attitude control of a quadrotor." Recent Advances in Space Technologies, 2009. RAST'09. 4th International Conference on. IEEE, 2009.
[5] Hoffmann, Gabriel M., Steven L. Waslander, and Claire J. Tomlin. "Quadrotor helicopter trajectory tracking control." AIAA guidance, navigation and control conference and exhibit. 2008.
[6] S. Bouabdallah, A. Noth, and R. Siegwart, “PID vs LQ control techniques applied to an indoor micro quadrotor,” IEEE/RSJ International Conference on Intelligent Robots and Systems, vol. 3, pp. 2451–2456, 2004.
[7] Zhou, Qing-Li, et al. "Design of feedback linearization control and reconfigurable control allocation with application to a quadrotor UAV." Control and Fault-Tolerant Systems (SysTol), 2010 Conference on. IEEE, 2010.
[8] Sabatino, Francesco. "Quadrotor control: modeling, nonlinear control design, and simulation." (2015).
[9] Das, Abhijit, Kamesh Subbarao, and Frank Lewis. "Dynamic inversion with zero-dynamics stabilisation for quadrotor control." IET control theory & applications 3.3 (2009): 303314.
[10] Lee, Daewon, H. Jin Kim, and Shankar Sastry. "Feedback linearization vs. adaptive sliding mode control for a quadrotor helicopter." International Journal of control, Automation and systems 7.3 (2009): 419-428.
[11] Slotine, Jean-Jacques E., and Weiping Li. Applied nonlinear control. Vol. 199. No. 1. Englewood Cliffs, NJ: prentice-Hall, 1991.
55

Appendix

Appendix A1: Quadcopter plant

function quadplant(block) setup(block);

function setup(block)

block.NumInputPorts = 4 ;

block.NumOutputPorts = 12;

for i = 1:4; % These are the motor inputs

block.InputPort(i).Dimensions

= 1;

block.InputPort(i).DirectFeedthrough = false;

block.InputPort(i).SamplingMode

= 'Sample';

end

for i = 1:12; block.OutputPort(i).Dimensions block.OutputPort(i).SamplingMode end

= 1; = 'Sample';

% Register the parameters.

block.NumDialogPrms

= 0; %fromtemplate

% Set up the continuous states. block.NumContStates = 12; %notintemplate

block.SampleTimes = [0 0];

block.SetAccelRunOnTLC(false);

block.SimStateCompliance = 'DefaultSimState';

block.RegBlockMethod('InitializeConditions', @InitializeConditions);

block.RegBlockMethod('Outputs', @Outputs);

block.RegBlockMethod('Derivatives', @Derivatives); block.RegBlockMethod('Terminate', @Terminate); % Required

function InitializeConditions(block)
% P, Q, R are in rad/s P=0; Q=0; R=0;
% Phi, The, Psi are in rads
56

Phi=10*pi/180; The=12*pi/180; Psi=10*pi/180;
U=0; V=0; W=0; X=0; Y=0; Z=2;
init = [P,Q,R,Phi,The,Psi,U,V,W,X,Y,Z];
for i=1:12 block.OutputPort(i).Data = init(i); block.ContStates.Data(i) = init(i); end
function Outputs(block) for i = 1:12;
block.OutputPort(i).Data = block.ContStates.Data(i); end
function Derivatives(block)
% P Q R in units of rad/sec P = block.ContStates.Data(1); Q = block.ContStates.Data(2); R = block.ContStates.Data(3); % Phi The Psi in radians Phi = block.ContStates.Data(4); The = block.ContStates.Data(5); Psi = block.ContStates.Data(6); % U V W in units of m/s U = block.ContStates.Data(7); V = block.ContStates.Data(8); W = block.ContStates.Data(9); % X Y Z in units of m X = block.ContStates.Data(10); Y = block.ContStates.Data(11); Z = block.ContStates.Data(12); % w values in rev/min! NOT radians/s!!!! w1 = block.InputPort(1).Data; w2 = block.InputPort(2).Data; w3 = block.InputPort(3).Data; w4 = block.InputPort(4).Data; w = [w1; w2; w3; w4];
% CALCULATE MOMENT AND THRUST FORCES
%find k,d,l k=2.98e-06; d=.0382; l=0.225;
%find m,Ixx,Iyy,Izz,Ir m=0.468; Ixx=4.856e-03;Iyy=4.856e-03;Izz=8.801e-03;Ir=3.357e-05; Ax=.3; Ay=0.3; Az=0.25; Ar=0.2; T1= k*w1^2; T2= k*w2^2; T3= k*w3^2; T4= k*w4^2;
57

T = T1+T2+T3+T4; %total thrust Mphi= l*(T4-T2); %torques Mthe= l*(T3-T1); Mpsi= d*(-T1+T2-T3+T4); Omega=w1-w2+w3-w4; dP= ((Iyy-Izz)/Ixx)*Q*R - Ir/Ixx * Q*Omega + Mphi/Ixx - Ar/Ixx*P; dQ= ((Izz-Ixx)/Iyy)*P*R + Ir/Iyy * P*Omega + Mthe/Iyy - Ar/Iyy*Q; dR= ((Ixx-Iyy)/Izz)*P*Q + Mpsi/Izz -Ar/Izz*R; dPhi= P+ sin(Phi)*tan(The)*Q + cos(Phi)*tan(The)*R; dTheta= cos(Phi)*Q - sin(Phi)*R; dPsi= sin(Phi)/cos(The)*Q + cos(Phi)/cos(The)*R; dU= ( sin(Phi)*sin(Psi) + cos(Phi)*sin(The)*cos(Psi) )*T/m - Ax/m*U; dV= ( -sin(Phi)*cos(Psi) + cos(Phi)*sin(The)*sin(Psi) )*T/m - Ay/m*V; dW= -9.8 + cos(Phi)*cos(The)*T/m - Az/m*W; vb = [U;V;W]; dX = U; dY = V; dZ = W; f = [dP dQ dR dPhi dTheta dPsi dU dV dW dX dY dZ].';
%This is the state derivative vector block.Derivatives.Data = f; function Terminate(block) %endfunction
58

Appendix A2: Quadcopter plant with a failed rotor
function quadplant2(block) setup(block); function setup(block)
block.NumInputPorts = 3; block.NumOutputPorts = 12;

for i = 1:3; % These are the motor inputs

block.InputPort(i).Dimensions

= 1;

block.InputPort(i).DirectFeedthrough = false;

block.InputPort(i).SamplingMode

= 'Sample';

end

for i = 1:12; block.OutputPort(i).Dimensions block.OutputPort(i).SamplingMode end

= 1; = 'Sample';

% Register the parameters.

block.NumDialogPrms

= 0; %fromtemplate

% Set up the continuous states. block.NumContStates = 12; %notintemplate

block.SampleTimes = [0 0];

block.SetAccelRunOnTLC(false);

block.SimStateCompliance = 'DefaultSimState';

block.RegBlockMethod('InitializeConditions', @InitializeConditions);

block.RegBlockMethod('Outputs', @Outputs);

block.RegBlockMethod('Derivatives', @Derivatives); block.RegBlockMethod('Terminate', @Terminate); % Required

function InitializeConditions(block) % P, Q, R are in rad/s P=0; Q=0; R=0;
% Phi, The, Psi are in rads Phi=10*pi/180; The=12*pi/180; Psi=10*pi/180;
U=0; V=0; W=0; X=0; Y=0; Z=2;
59

init = [P,Q,R,Phi,The,Psi,U,V,W,X,Y,Z];
for i=1:12 block.OutputPort(i).Data = init(i); block.ContStates.Data(i) = init(i); end
function Outputs(block) for i = 1:12;
block.OutputPort(i).Data = block.ContStates.Data(i); end
function Derivatives(block)
% P Q R in units of rad/sec P = block.ContStates.Data(1); Q = block.ContStates.Data(2); R = block.ContStates.Data(3); % Phi The Psi in radians Phi = block.ContStates.Data(4); The = block.ContStates.Data(5); Psi = block.ContStates.Data(6); % U V W in units of m/s U = block.ContStates.Data(7); V = block.ContStates.Data(8); W = block.ContStates.Data(9); % X Y Z in units of m X = block.ContStates.Data(10); Y = block.ContStates.Data(11); Z = block.ContStates.Data(12); % w values in rev/min! NOT radians/s!!!! w1 = block.InputPort(1).Data; w3 = block.InputPort(2).Data; w4 = block.InputPort(3).Data; w = [w1; w3; w4];
%find k,d,l k=2.98e-06; d=.03825; l=0.225;
%find m,Ixx,Iyy,Izz,Ir m=0.468; Ixx=4.856e-03;Iyy=4.856e-03;Izz=8.801e-03;Ir=3.357e-05; Ax=.3; Ay=0.3; Az=0.25; Ar=0.1;
T1= k*w1^2; %T2= k*w2^2; T3= k*w3^2; T4= k*w4^2;
Fmat= [ 1 1 1; -l l 0; -d -d d;]; Fmat1=inv(Fmat);
mat1= [T1;T3;T4]; mat2= Fmat*mat1;
60

T = mat2(1); %total thrust Mthe= mat2(2);%torques Mpsi= mat2(3);
%Mphi is not used as control input but appears later in eq %Substitute for Mphi Mphi= 0.5*l*(T-Mpsi/d); Omega=w1+w3-w4; %or opp signs check.
dP= ((Iyy-Izz)/Ixx)*Q*R - Ir/Ixx * Q*Omega + Mphi/Ixx - Ar/Ixx*P; dQ= ((Izz-Ixx)/Iyy)*P*R + Ir/Iyy * P*Omega + Mthe/Iyy - Ar/Iyy*Q; dR= ((Ixx-Iyy)/Izz)*P*Q + Mpsi/Izz -Ar/Izz*R;
dPhi= P+ sin(Phi)*tan(The)*Q + cos(Phi)*tan(The)*R; dTheta= cos(Phi)*Q - sin(Phi)*R; dPsi= sin(Phi)/cos(The)*Q + cos(Phi)/cos(The)*R;
dX = U; dY = V; dZ = W;
dU= ( sin(Phi)*sin(Psi) + cos(Phi)*sin(The)*cos(Psi) )*T/m - Ax/m*U; dV= ( -sin(Phi)*cos(Psi) + cos(Phi)*sin(The)*sin(Psi) )*T/m - Ay/m*V; dW= -9.8 + cos(Phi)*cos(The)*T/m - Az/m*W;

vb = [U;V;W];

Rib = [cos(Psi)*cos(The) cos(Psi)*sin(The)*sin(Phi)-sin(Psi)*cos(Phi)

cos(Psi)*sin(The)*cos(Phi)+sin(Psi)*sin(Phi);

sin(Psi)*cos(The) sin(Psi)*sin(The)*sin(Phi)+cos(Psi)*cos(Phi)

sin(Psi)*sin(The)*cos(Phi)-cos(Psi)*sin(Phi);

-sin(The)

cos(The)*sin(Phi)

cos(The)*cos(Phi)];

% i_dp = Rib*vb;

%dX = i_dp(1);

%dY = i_dp(2);

%dZ = i_dp(3);

f = [dP dQ dR dPhi dTheta dPsi dU dV dW dX dY dZ].';

%This is the state derivative vector block.Derivatives.Data = f;

function Terminate(block)

%endfunction

61

Appendix A3: Layout for PID controller Appendix A4: Layout for FBL+PD controller
62

Appendix A5: Inside FBL blocks
Inside Create V block
Matrices used for Feedback linearization
function B = MatW(phi,the) B=[ 1 0 0 0; 0 1 sin(phi)*tan(the) cos(phi)*tan(the); 0 0 cos(phi) -sin(phi); 0 0 sin(phi)/cos(the) cos(phi)/cos(the)]; end function B = MatD(phi,the) m=0.468; Ixx=4.856e-03;Iyy=4.856e-03;Izz=8.801e-03; B=[ 1/m*cos(phi)*cos(the) 0 0 0; 0 1/Ixx 0 0; 0 0 1/Iyy 0; 0 0 0 1/Izz]; end function B = MatC(P,Q,R,Omega,W) m=0.468; Ixx=4.856e-03;Iyy=4.856e-03;Izz=8.801e-03;Ir=3.357e-05;Ar=0.2; Az=.25; B=[-9.8 - Az/m*W; (Iyy-Izz)/Ixx*Q*R - Ir/Ixx*Q*Omega - Ar/Ixx*P; (IzzIxx)/Iyy*P*R + Ir/Iyy*P*Omega - Ar/Iyy*Q; (Ixx-Iyy)/Izz*P*Q - Ar/Izz*R ]; end function B = MatA(W,Wdot,C,Q); B = W*C+Wdot*Q; end
63

Appendix A6: Layout of LQR
Appendix A7: Linriz.m function
A=[0 0 0 0 1 0 0 0;0 0 0 0 0 1 0 0;0 0 0 0 0 0 1 0;0 0 0 0 0 0 0 1;0 0 0 0 .5341 0 0 0;0 0 0 0 0 -41.186 0 0;0 0 0 0 0 0 -41.186 0;0 0 0 0 0 0 0 22.725]; B=[0 0 0 0;0 0 0 0;0 0 0 0;0 0 0 0;2.137 0 0 0;0 205.93 0 0;0 0 205.93 0;0 0 0 29788.5]; C=[1 0 0 0 0 0 0 0;0 1 0 0 0 0 0 0;0 0 1 0 0 0 0 0;0 0 0 1 0 0 0 0]; D=zeros(4); sys_ss = ss(A,B,C,D); co = ctrb(sys_ss); controllability = rank(co); Q = C'*C; R=eye(4); K = lqr(A,B,Q,R); %Increasing the weights to improve performance Q(1,1)=100; Q(2,2)=100; Q(3,3)=100; Q(4,4)=100; K = lqr(A,B,Q,R);
64

Appendix A8: Inside image processing block
Inside the image block 65

Appendix A9: Pathgen.m function
function y= pathgen(L,m,v_x,v_y,x,y) omega=1000; F=4*2.98*10^(-6)*omega^2; theta=pi/4; % m=0.468; a=F*sin(theta)/m; % v_x=10; % v_y=10; s=sqrt(v_x^2+v_y^2); % x=150; % y=150;
k=1; rows=size(L); while k<=rows(1,1)
theta1=atan2(L(k,2)-y,L(k,1)-x); theta2=atan2(v_y,v_x); theta=theta1-theta2;
v_a=abs(s*cos(theta)); v_p=abs(s*sin(theta));
d=sqrt((x-L(k,1))^2 + (y-L(k,2))^2);
if theta == 0 || s ==0 t(k)=(1/a)*(sqrt(v_a^2+2*a*d)-v_a);
elseif theta == pi || theta == -pi t(k)=(1/a)*(sqrt(v_a^2+2*a*d)+v_a);
else syms u v [solv, solu] = solve(u^2 + v^2 == a^2, (-2*v_a*v_p)/u + (2*v_p^2*v)/(u^2) == d);
p=1;
while p<=length(solv) if isreal(solv(p))==1
if (L(k,1)-x)*solv(p)>=0 a_x=solu(p); a_y=solv(p);
end end p=p+1; end
t(k)=abs(-2*v_p/a_y); end k=k+1; end
66

min = t(1);r=1; l=2; while l<=length(t)
if t(l)<=min min=t(l); r=l;
end l=l+1; end y=L(r,:);
Appendix A10: Circle2.m function
function y= circle2(RGB) % imshow(RGB);
I= rgb2gray(RGB); % bw = imbinarize(I); bw=im2bw(I,0.3);
bw2 = bwmorph(~bw, 'dilate',2); bw = bwareaopen(bw2,500); se = strel('disk',2); bw = imclose(bw,se); bw = imfill(bw,'holes');
[B,L] = bwboundaries(bw,'noholes');
% Display the label matrix and draw each boundary imshow(label2rgb(L, @jet, [.5 .5 .5])) hold on for k = 1:length(B)
boundary = B{k}; plot(boundary(:,2), boundary(:,1), 'w', 'LineWidth', 2) end
stats = regionprops(L,'Area','Centroid'); threshold = 0.99; centroid=zeros(length(B),2);
% loop over the boundaries i=1; for k = 1:length(B)
% obtain (X,Y) boundary coordinates corresponding to label 'k' boundary = B{k};
67

% compute a simple estimate of the object's perimeter delta_sq = diff(boundary).^2; perimeter = sum(sqrt(sum(delta_sq,2)));
% obtain the area calculation corresponding to label 'k' area = uint32(stats(k).Area);
% compute the roundness metric metric =(4*pi*area)/perimeter^2;
% display the results metric_string = sprintf('%2.2f',metric);
% mark objects above the threshold with a black circle if metric > threshold
centroid(i,:)=stats(k).Centroid; plot(centroid(1),centroid(2),'ko');
end i=i+1;
text(boundary(1,2)-35,boundary(1,1)+13,metric_string,'Color','y',... 'FontSize',14,'FontWeight','bold');
end % disp(centroid); p=1; q=0; while p<=length(B)
if centroid(p,1)~=0
q=q+1; end p=p+1;
end x=zeros(q,2); p=1; q=1; while p<=length(B)
if centroid(p,1)~=0 x(q,:)=centroid(p,:); q=q+1;
end p=p+1;
end y=x; % title(['Metrics closer to 1 indicate that ',...
68

%

'the object is approximately round']);

% imshow(bw);

Appendix A11: dijkstra.m function

%---------------------------------------------------

% Dijkstra Algorithm

% author : Dimas Aryo

% email : mr.dimasaryo@gmail.com

%

% usage

% [cost rute] = dijkstra(Graph, source, destination)

%

% example

% G = [0 3 9 0 0 0 0;

%

0 0 0 7 1 0 0;

%

0 2 0 7 0 0 0;

%

0 0 0 0 0 2 8;

%

0 0 4 5 0 9 0;

%

0 0 0 0 0 0 4;

%

0 0 0 0 0 0 0;

%

];

% [e L] = dijkstra(G,1,7)

%---------------------------------------------------

function [e L] = dijkstra(A,s,d)

if s==d e=0; L=[s];
else

A = setupgraph(A,inf,1);

if d==1 d=s;
end A=exchangenode(A,1,s);

lengthA=size(A,1); W=zeros(lengthA); for i=2 : lengthA
W(1,i)=i; W(2,i)=A(1,i); end

for i=1 : lengthA D(i,1)=A(1,i); D(i,2)=i;
end

D2=D(2:length(D),:); L=2;
69

while L<=(size(W,1)-1) L=L+1; D2=sortrows(D2,1); k=D2(1,2); W(L,1)=k; D2(1,:)=[]; for i=1 : size(D2,1) if D(D2(i,2),1)>(D(k,1)+A(k,D2(i,2))) D(D2(i,2),1) = D(k,1)+A(k,D2(i,2)); D2(i,1) = D(D2(i,2),1); end end
for i=2 : length(A) W(L,i)=D(i,1);
end end if d==s
L=[1]; else
L=[d]; end e=W(size(W,1),d); L = listdijkstra(L,W,s,d); end
Appendix A12: Functions called by Dijkstra.m
(save as separate files)
function L = listdijkstra(L,W,s,d)
index=size(W,1); while index>0
if W(2,d)==W(size(W,1),d) L=[L s]; index=0;
else index2=size(W,1); while index2>0 if W(index2,d)<W(index2-1,d) if W(index2,1)==s L = [L 1]; else L=[L W(index2,1)]; end L=listdijkstra(L,W,s,W(index2,1)); index2=0; else index2=index2-1; end index=0;
70

end end end
function G = exchangenode(G,a,b)
%Exchange element at column a with element at column b; buffer=G(:,a); G(:,a)=G(:,b); G(:,b)=buffer;
%Exchange element at row a with element at row b; buffer=G(a,:); G(a,:)=G(b,:); G(b,:)=buffer;
function G = setupgraph(G,b,s)
if s==1 for i=1 : size(G,1) for j=1 :size(G,1) if G(i,j)==0 G(i,j)=b; end end end
end if s==2
for i=1 : size(G,1) for j=1 : size(G,1) if G(i,j)==b G(i,j)=0; end end
end end
Appendix A13: pathcr.m function
% function d_path = pathcr(m) m=imread('path5.png');
n=rgb2gray(m); a=im2bw(n); p=ones(50,50); for i=1:1:50 for j=1:1:50 if a(i,j)==0
p(i,j)=5;
71

else p(i,j)=1;
end end end %for l=1:1:100 for i=1:1:50 for j=1:1:50
if p(i,j)~=5
if i==1 && j==1 p(i,j)=(p(i,j+1)+p(i+1,j))/2;
elseif i==1 && j==50 p(i,j)=(p(i,j-1)+p(i+1,j))/2;
elseif i==50 && j==50 p(i,j)=(p(i,j-1)+p(i-1,j))/2;
elseif i==50 && j==1 p(i,j)=(p(i,j+1)+p(i-1,j))/2;
elseif i==1 && j~=50 && j~=1 p(i,j)=(p(i,j-1)+p(i+1,j)+p(i,j+1))/3;
elseif i==50 && j~=50 && j~=1 p(i,j)=(p(i,j-1)+p(i-1,j)+p(i,j+1))/3;
elseif j==1 && i~=50 && i~=1 p(i,j)=(p(i-1,j)+p(i,j+1)+p(i+1,j))/3;
elseif j==50 && i~=50 && i~=1 p(i,j)=(p(i-1,j)+p(i,j-1)+p(i+1,j))/3;
else p(i,j)=(p(i-1,j)+p(i,j-1)+p(i+1,j)+p(i,j+1))/4;
end end
end end %end q=1; k=1; n=zeros(50,50); for i=1:1:50
for j=1:1:50 n(i,j)=q; q=q+1;
end end A=zeros(2500,2500); for i=1:1:50
for j=1:1:50
if i==1 && j==1 if p(i,j+1)~=5
A(n(i,j),n(i,j+1))=p(i,j+1); end if p(i+1,j)~=5
A(n(i,j),n(i+1,j))=p(i+1,j); end if p(i+1,j+1)~=5
A(n(i,j),n(i+1,j+1))=p(i+1,j+1); end elseif i==1 && j==50
72

if p(i,j-1)~=5 A(n(i,j),n(i,j-1))=p(i,j-1); end
if p(i+1,j)~=5 A(n(i,j),n(i+1,j))=p(i+1,j); end
if p(i+1,j-1)~=5 A(n(i,j),n(i+1,j-1))=p(i+1,j-1); end elseif i==50 && j==50
if p(i,j-1)~=5 A(n(i,j),n(i,j-1))=p(i,j-1); end
if p(i-1,j)~=5 A(n(i,j),n(i-1,j))=p(i-1,j); end
if p(i-1,j-1)~=5 A(n(i,j),n(i-1,j-1))=p(i-1,j-1); end elseif i==50 && j==1
if p(i,j+1)~=5 A(n(i,j),n(i,j+1))=p(i,j+1); end
if p(i-1,j)~=5 A(n(i,j),n(i-1,j))=p(i-1,j); end
if p(i-1,j+1)~=5 A(n(i,j),n(i-1,j+1))=p(i-1,j+1); end elseif i==1 && j~=50 && j~=1
if p(i,j+1)~=5 A(n(i,j),n(i,j+1))=p(i,j+1); end
if p(i+1,j)~=5 A(n(i,j),n(i+1,j))=p(i+1,j); end
if p(i,j-1)~=5 A(n(i,j),n(i,j-1))=p(i,j-1); end
if p(i+1,j-1)~=5 A(n(i,j),n(i+1,j-1))=p(i+1,j-1); end
if p(i+1,j+1)~=5 A(n(i,j),n(i+1,j+1))=p(i+1,j+1); end elseif i==50 && j~=50 && j~=1
if p(i,j+1)~=5 A(n(i,j),n(i,j+1))=p(i,j+1); end
if p(i-1,j)~=5 A(n(i,j),n(i-1,j))=p(i-1,j); end
if p(i,j-1)~=5 A(n(i,j),n(i,j-1))=p(i,j-1); end
if p(i-1,j-1)~=5 A(n(i,j),n(i-1,j-1))=p(i-1,j-1); end
if p(i-1,j+1)~=5 A(n(i,j),n(i-1,j+1))=p(i-1,j+1); end elseif j==1 && i~=50 && i~=1
if p(i+1,j)~=5 A(n(i,j),n(i+1,j))=p(i+1,j); end
if p(i,j+1)~=5 A(n(i,j),n(i,j+1))=p(i,j+1); end
if p(i-1,j)~=5 A(n(i,j),n(i-1,j))=p(i-1,j); end
if p(i-1,j+1)~=5 A(n(i,j),n(i-1,j+1))=p(i-1,j+1); end
if p(i+1,j+1)~=5 A(n(i,j),n(i+1,j+1))=p(i+1,j+1); end elseif j==50 && i~=50 && i~=1
if p(i+1,j)~=5 A(n(i,j),n(i+1,j))=p(i+1,j); end
if p(i,j-1)~=5
73

A(n(i,j),n(i,j-1))=p(i,j-1); end if p(i-1,j)~=5
A(n(i,j),n(i-1,j))=p(i-1,j); end if p(i-1,j-1)~=5
A(n(i,j),n(i-1,j-1))=p(i-1,j-1); end if p(i+1,j-1)~=5
A(n(i,j),n(i+1,j-1))=p(i+1,j-1); end else
if p(i,j+1)~=5 A(n(i,j),n(i,j+1))=p(i,j+1); end
if p(i+1,j)~=5 A(n(i,j),n(i+1,j))=p(i+1,j); end
if p(i,j-1)~=5 A(n(i,j),n(i,j-1))=p(i,j-1); end
if p(i+1,j-1)~=5 A(n(i,j),n(i+1,j-1))=p(i+1,j-1); end
if p(i+1,j+1)~=5 A(n(i,j),n(i+1,j+1))=p(i+1,j+1); end
if p(i-1,j)~=5 A(n(i,j),n(i-1,j))=p(i-1,j); end
if p(i-1,j-1)~=5 A(n(i,j),n(i-1,j-1))=p(i-1,j-1); end
if p(i-1,j+1)~=5 A(n(i,j),n(i-1,j+1))=p(i-1,j+1); end end
end end [cost, t_route] = dijkstra(A,1,2500); j=ones(50,50); l=length(t_route); x=zeros(1,l); y=zeros(1,l); for i=1:1:l
j(t_route(i))=0; x(i)=mod(t_route(i),50); if x(i)==0
x(i)=50; end y(i)=ceil(t_route(i)/50); end x=fliplr(x); y=fliplr(y); for i=1:1:10 x(l+i)=x(l); y(l+i)=y(l); end
w=m; for i=1:1:l+10
m(y(i),x(i))=0; end p=0; tim=zeros(1,l+10); for i=2:1:l+10
key_x=0; key_y=0; if x(i)-x(i-1)==1
74

key_x=1; end if y(i)-y(i-1)==1
key_y=1; end
if key_x==1&&key_y==1 p=p+sqrt(2);
else p=p+1;
end tim(i)=p; end time = 150*tim/tim(l+10) ; imshow(m); ts_x = timeseries(x,time); ts_y = timeseries(y,time); path = struct('x',ts_x,'y',ts_y); d_path=path; % save('x_time.mat',path);
Appendix A14: Trajectory controller
75

Appendix A15: Complete layout for trajectory control simulation 1 Appendix A16: Complete layout for trajectory control simulation 2
76

