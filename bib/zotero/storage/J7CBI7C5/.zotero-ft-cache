Aggressive flight of fixed-wing and quadrotor aircraft in dense indoor environments

The MIT Faculty has made this article openly available. Please share how this access benefits you. Your story matters.

Citation
As Published Publisher Version Citable link Terms of Use Detailed Terms

Bry, Adam et al. “Aggressive Flight of Fixed-Wing and Quadrotor Aircraft in Dense Indoor Environments.” The International Journal of Robotics Research 34.7 (2015): 969–1002.
http://dx.doi.org/10.1177/0278364914558129
Sage Publications
Author's final manuscript
http://hdl.handle.net/1721.1/106948
Creative Commons Attribution-Noncommercial-Share Alike
http://creativecommons.org/licenses/by-nc-sa/4.0/

In the International Journal of Robotics Research (IJRR), 37(7):969-1002, June 2015.
Aggressive Flight of Fixed-Wing and Quadrotor Aircraft in Dense Indoor Environments
Adam Bry∗, Charles Richter∗, Abraham Bachrach and Nicholas Roy
Abstract In this paper, we describe trajectory planning and state estimation algorithms for aggressive ﬂight of micro aerial vehicles in known, obstacledense environments. Finding aggressive but dynamically feasible and collision-free trajectories in cluttered environments requires trajectory optimization and state estimation in the full state space of the vehicle, which is usually computationally infeasible on realistic time scales for real vehicles and sensors. We ﬁrst build on previous work of van Nieuwstadt and Murray [51] and Mellinger and Kumar [38], to show how a search process can be coupled with optimization in the output space of a diﬀerentially ﬂat vehicle model to ﬁnd aggressive trajectories that utilize the full maneuvering capabilities of a quadrotor. We further extend this work to vehicles with complex, Dubins-type dynamics and present a novel trajectory representation called a Dubins-Polynomial trajectory, which allows us to optimize trajectories for ﬁxed-wing vehicles. To provide accurate state estimation for aggressive ﬂight, we show how the Gaussian particle ﬁlter can be extended to allow laser range ﬁnder localization to be combined with a Kalman ﬁlter. This formulation allows similar estimation accuracy to particle ﬁltering in the full vehicle state but with an order of magnitude more eﬃciency. We conclude with experiments demonstrating the execution of quadrotor and ﬁxed-wing trajectories in cluttered environments. We show results of aggressive ﬂight at speeds of up to 8 m/s for the quadrotor and 11 m/s for the ﬁxed-wing aircraft.
1 Introduction
Micro aerial vehicles (MAVs) have received considerable attention during the last decade due to their large and growing range of applications, including deployment as inexpensive mobile sensor platforms for monitoring, reconnaissance and mapping operations. Hence, most MAVs are limited to ﬂight at altitudes well above ground-level obstacles, foliage and buildings, where basic path planning techniques and GPS are suﬃcient for navigation. The practical uses of MAVs would expand considerably if they were capable of ﬂying at high speeds and among obstacles at low altitudes, enabling them to take detailed measurements of the street level of a city or the terrain in wilderness areas and cover signiﬁcantly more ground than the conservative motions of many current aerial robots. Our purpose in this research is to enable quadrotor and ﬁxed-wing vehicles to perform agile ﬂights in obstacle-dense environments for these applications.
∗These authors contributed equally to this work.
1

The two major algorithmic challenges that must be solved to enable aggressive ﬂight are trajectory planning and state estimation. These challenges are especially diﬃcult due to the limited computational resources that can be carried aboard a small MAV. Though sensing and computational hardware have advanced considerably, MAVs are still very restricted by their limited payload. Autonomous cars currently rely on a large number of heavy sensors including 3D LIDARs, which are infeasible to carry aboard small ﬂying platforms. Furthermore, processing the high volume of data produced by these sensors and planning long range trajectories given these observations of the world typically requires much more computation than a small multicopter or ﬁxed-wing vehicle is capable of carrying. Therefore, while many planning, estimation and control algorithms for autonomous vehicles have been described in the literature, we must adapt these algorithms in order to achieve truly aggressive ﬂight performance with computation and sensing that ﬁt aboard a MAV.
To address the trajectory planning challenge, we exploit the property of differential ﬂatness, which consists of an algebraic mapping from the state and input space of a dynamical system to a diﬀerent set of output variables and their derivatives. This special property enables eﬃcient algebraic calculation of the control inputs needed to exactly execute a given trajectory. Diﬀerentially ﬂat representations pair naturally with trajectories that are expressed as polynomials because polynomials are diﬀerentiable and are easily constrained to maintain continuity of derivatives, yielding smooth trajectories.
While the quadrotor and ﬁxed-wing vehicles are fundamentally diﬀerent in their capabilities, they both have nonlinear dynamics models that are diﬀerentially ﬂat. Polynomial trajectories for quadrotors have been demonstrated in the literature [38], and we extend this existing work in several ways. First, we use a fast low-dimensional search algorithm to automatically generate waypoints through the environment and use those waypoints as constraints in a polynomial optimization routine rather than hand-selecting waypoints. Next, we reformulate the existing constrained polynomial optimization method as an unconstrained quadratic program, yielding a method that is much more numerically stable for complex and long-range trajectories. Finally, we address the questions of selecting vehicle speeds along the trajectory subject to actuator constraints.
To plan aggressive trajectories for a ﬁxed-wing aircraft, we present a novel trajectory formulation that builds upon Dubins curves. The high-level motion capabilities of a ﬁxed-wing aircraft are well approximated by straight lines and circular arcs [34]. However, simple Dubins paths have discontinuous curvature at the intersection of segments, yielding paths that are dynamically infeasible for a real airplane. Therefore, we represent trajectories as underlying Dubins curves combined with polynomial transverse oﬀsets from those Dubins curves. We refer to trajectories with this representation as Dubins-Polynomial trajectories. This strategy allows us to plan in the space of straight lines and circular arcs, and then approximate the resulting path with a polynomial that is constrained to maintain continuity of derivatives up to the necessary order, resulting in smooth and dynamically feasible trajectories. Furthermore, by parameterizing our trajectories as transverse oﬀsets from Dubins curves, we isolate the transverse motions of the aircraft that correspond to roll dynamics and can easily optimize the polynomial to minimize roll rates and roll accelerations.
In order to execute aggressive trajectories accurately using our control sys-
2

tems, we need to estimate the vehicle state at arbitrary orientations encountered during agile ﬂight maneuvers. To meet this challenge, we present a novel formulation of the Extended Kalman ﬁlter (EKF), which uses exponential coordinates of rotation to update its estimate of vehicle orientation and to propagate uncertainty about that orientation. In addition to the IMU, the primary sensor for localization onboard both the quadrotor and the ﬁxed-wing vehicle is a 2D planar LIDAR. Incorporating the information provided by this sensor from arbitrary vehicle orientation is one of the key challenges in our state estimation method. In order to eﬃciently project the nonlinear laser measurement update of the vehicle position back through the state estimate, we integrate the laser range-ﬁnder measurement as a pseudo-measurement on a partition of the state space. The pseudo-measurement is computed from a Gaussian particle ﬁlter (GPF) state update [32]. This technique dramatically reduces the number of particles required compared to a basic implementation of a GPF, which in itself provides a marked improvement over a conventional particle ﬁlter [49]. Our algorithm enables accurate state estimation and realtime performance on an single-core Intel Atom processor running onboard the vehicle. The choice of ﬁlter formulation has the additional beneﬁt of being platform independent. We use the identical sensors and ﬁlter algorithm on the quadrotor and the ﬁxed-wing airplane without any modiﬁcation.
We have conducted ﬂight tests using our state estimation, planning, and control algorithms to perform autonomous ﬂight in constrained indoor spaces with the quadrotor and ﬁxed-wing vehicles. We give results of the ﬁxed-wing vehicle completing a seven minute ﬂight at 10 m/s through a parking garage with approximately 0.25 m clearance between the wingtips and the environment, as well as several aggressive ﬂights between obstacles in a gymnasium. We also give results of the quadrotor completing multiple ﬂights in obstacle-dense oﬃce-type spaces, traveling through doors, down hallways, and between hanging lights at up to 8 m/s.
The rest of this paper is organized as follows. We ﬁrst describe the high-level approach to trajectory planning using polynomials coupled with a diﬀerentially ﬂat model. Then we describe the state estimation algorithms that are common to both the quadrotor and ﬁxed-wing aircraft. Next, we describe vehicle-speciﬁc aspects of trajectory planning and experimental results for both platforms. For the quadrotor, we show how the output of a low-dimensional path planner can be used to automatically generate waypoints that will be connected by polynomial trajectory segments, and we also discuss a method for ensuring that the resulting trajectory is both collision free and dynamically feasible given the input limits of the vehicle. We then describe the Dubins-Polynomial trajectory formulation that extends existing polynomial trajectory planning to Dubins-type vehicles. We have separated this section from the general discussion of planning for diﬀerentially ﬂat vehicles due to the unique demands of a ﬁxed-wing dynamics model. While we describe a method for fully automated planning for the quadrotor, we have not extended our technique to include the corresponding automatic waypoint generation capability for the ﬁxed-wing aircraft. We leave it as a potential future extension of this work using a low-dimensional planner for Dubins-type vehicles ([11, 26]) Finally, we oﬀer some discussion and conclusions.
Some of the results presented in this paper have appeared in our prior work. The quadrotor trajectory planning techniques and experimental results
3

appeared in [45]. The state estimation algorithms used in both the quadrotor and ﬁxed-wing experiments appeared in [8]. The Dubins-Polynomial trajectory parameterization we use for the ﬁxed-wing aircraft is a new contribution of this paper, and the corresponding experimental results represent a considerable advance in the experimental capabilities for ﬁxed-wing aircraft ﬂying outside of motion capture environments among obstacles.
2 Related Work
While many trajectory planning approaches exist in the literature, there has yet to emerge a single algorithm capable of ﬁnding and optimizing a trajectory for an agile 12-DOF vehicle through a complex real-world environment using only several seconds of computation. Yet, there is a strong need for such algorithms to be developed for MAVs, which have limited computational resources and limited ﬂight time to accomplish their missions. We address this technical gap using a combination of capabilities from control theory and robotic motion planning.
2.1 Trajectory Planning
Trajectory planning research has given rise to successful demonstrations of aerial vehicles maneuvering at the limits of their dynamic capabilities. The control community has addressed the trajectory generation problem by casting it as a nonlinear optimization problem. In contrast, the robotics community has typically solved motion planning problems using the tools of discrete or randomized search over sequences of feasible actions. While both approaches are capable of generating similar solutions, they have diﬀerent advantages and disadvantages depending on the application scenario.
Trajectory optimization has a long history in the control literature [7]. These problems can take many forms, but the overall concept is to optimize some sequence of inputs to a dynamical system using the tools of optimization, subject to constraints imposed by the diﬀerential equations of motion, control inputs, and obstacles in the environment. Often, the objective function will be to minimize time of traversal, energy usage, or some penalty weighting the relative costs of deviation from a goal state and the use of control inputs (i.e., LQR). Recently, these tools have been applied to generate extremely dynamic maneuvers for quadrotor helicopters [22] in motion-capture environments. For comparison, Barry et al. report 3-5 minutes of computation time [5] to optimize a 4.5 m trajectory for a 12-state, 5-input airplane maneuvering between several cylindrical obstacles using direct collocation with the SNOPT optimization software [4].
One disadvantage to conventional numerical trajectory optimization approaches is that obstacles in the world enter the problem as constraints, which must be represented analytically in the problem formulation. When the world is represented as an occupancy-grid map (common in robotics applications), trajectory optimization may become very cumbersome, although promising work has recently emerged in this area [44, 47]. In our case, the set of obstacles is stored in a 3D occupancy grid map containing millions of cells, rendering these approaches infeasible without signiﬁcant eﬀort to handle this source of complexity.
4

For the important subset of nonlinear systems that are diﬀerentially ﬂat, the trajectory optimization problem can be mapped into a diﬀerent set of variables called the ﬂat output variables. There are several potential beneﬁts of working in the ﬂat output space. In particular, the states and inputs of a diﬀerentially ﬂat system can be mapped algebraically to the the ﬂat output variables and a number of their derivatives. Since derivatives are needed, it is natural to express the evolution of the ﬂat output variables as a sequence of diﬀerentiable trajectories such as polynomials or B-splines. Trajectory optimization over the parameters of such splines may result in a lower-dimensional or otherwise more eﬃcient solution [39]. The property of diﬀerential ﬂatness combined with polynomial trajectories has led to eﬃcient computation of very high performance trajectories for quadrotors [38] and is the topic of much of this paper. We discuss the beneﬁts of diﬀerential ﬂatness in the planning context in Section 4.
Roboticists have often favored search-based approaches to motion planning. Search over a graph representing feasible actions can be performed eﬃciently using conventional algorithms such as A* and Dijkstra’s Algorithm. To handle collisions with the environment, edges that traverse occupied regions are simply deleted from the graph. Graph search has been successfully applied to motion planning for dynamic vehicles, including the CMU entry in the DARPA Urban Challenge [15]. When applied to dynamical systems, it is common to pre-compute a set of feasible actions connecting discretized locations in state space, which will serve as edges in the search graph. One challenge in using these methods is that there is no simple methodology for designing a set of actions that will suﬃciently span the vehicle’s true capabilities while remaining sparse enough for search to be eﬃcient. Furthermore, graph search has worked well for automobiles, which can be modeled using 4 or 5 state variables. However, to plan aggressive trajectories for a general rigid body system in 12 dimensions, it is likely that graph search would succumb to the curse of dimensionality due to the exponential growth of the number of nodes in a search graph as a function of the number of dimensions [43].
To limit computational complexity, approximations or restrictions can be made to model the vehicle capabilities in a lower dimensional space. For example, the maneuvering capabilities of ﬁxed-wing vehicles are often represented approximately as straight lines and arcs of constant curvature, reducing the airplane trajectory generation problem to a kinematic planning problem [11]. Frazzoli et al. present a method of planning with a maneuver automaton, in which a set of carefully selected dynamically feasible “trim primitives” can be concatenated into a complex motion plan [18]. Straight-line paths returned by a low-dimensional search can also be post-processed to be made feasible for nonholonomic vehicles [16].
In contrast with traditional graph search, randomized search algorithms have proven eﬀective for planning in high-dimensional state spaces. One prominent example for dynamical systems is the Rapidly-Exploring Random Tree (RRT), which operates by building a randomized tree of feasible trajectories through forward-simulation of the equations of a motion [35]. Frazzoli et al. extend the RRT to operate with pre-computed library of feasible trajectories for agile vehicles subject to actuator constraints [17]. The Closed-Loop RRT (CL-RRT) is an alternative that was employed in the MIT entry in the DARPA Urban Challenge [33]. The CL-RRT diﬀers from the RRT in that the tree of feasible trajectories is generated by forward-simulating a complete closed-loop control
5

system. The RRT and CL-RRT are very eﬀective for generating feasible trajectories, however they are not designed to compute optimal trajectories, so the output trajectory may be excessively long or costly.
Recently, the RRT has been modiﬁed to converge to the globally optimal solution in the limit of inﬁnite samples (RRT*) [27], and this approach has been extended to work with dynamical systems [26]. RRT* requires a steer-function in order to generate node connections in the search tree, and for dynamical systems, this steer function must solve a boundary-value problem to drive the system between two speciﬁed points in state space. RRT* solves the trajectory planning problem, however for general dynamical systems, this boundary-value problem is costly and dominates the practical complexity. In Section 4.4, we compare our approach against RRT*.
2.2 State Estimation
Aggressive ﬂight of MAVs has introduced a new need for state estimation capabilities beyond what has been developed for ground robots or quadrotors maneuvering conservatively near the hover regime. Speciﬁcally, aggressive ﬂight requires accurate, singularity-free estimation of arbitrary vehicle attitudes, which is not handled elegantly by existing ﬁltering techniques. Furthermore, there is no estimator as eﬃcient as the Kalman ﬁlter that incorporates the kind of measurement data provided by a LIDAR sensor. Yet, small LIDARs are some of the only sensors capable of accurate localization that can be carried aboard a small MAV.
State estimation using Kalman ﬁltering techniques has been extensively studied for vehicles ﬂying outdoors where GPS is available. A relevant example of such a state estimation scheme developed by Kingston et al. [30] involves two Kalman ﬁlters where roll and pitch are determined by a ﬁlter driven by gyro readings as system inputs while the accelerometer measurements are treated as a measurement of the gravity vector, assuming unaccelerated ﬂight. A separate ﬁlter estimates position and yaw using GPS measurements.
This approach is representative of many IMU-based estimators that assume zero acceleration and thus use the accelerometer reading as a direct measurement of attitude (many commercially available IMUs implement similar techniques onboard using a complementary ﬁlter). While this approach has practical appeal and has been successfully used on a number of MAVs, the zero-acceleration assumption does not hold for general ﬂight maneuvering and thus the accuracy of the state estimate degrades quickly during aggressive ﬂight.
Van der Merwe et al. use a sigma-point unscented Kalman ﬁlter (UKF) for state estimation on an autonomous helicopter [50]. The ﬁlter utilizes another typical approach whereby the accelerometer and gyro measurements are directly integrated to obtain position and orientation and are thus treated as noise-perturbed inputs to the ﬁlter. Our ﬁlter utilizes this scheme in our process model, however we use an EKF with an exponential coordinates-based attitude representation instead of the quaternions used by Van der Merwe et al. By using a three-parameter exponential coordinates representation, we avoid the problems of rank-deﬁcient covariance matrices that are encountered when Kalman ﬁltering any attitude representation using four or more parameters. Furthermore, with this representation, we do not need to enforce any constraints between attitude parameters to ensure that our estimated attitude is in SO(3).
6

Techniques to identify the noise parameters relevant for the Kalman ﬁlter emerged not long after the original ﬁlter, however the most powerful analytical techniques assume steady state behavior of a linear time-invariant system and are thus unsuitable for the time varying system that results from linearizing a nonlinear system [37]. More recent work optimizes the likelihood of a groundtruth projection of the state over the noise parameters but thus requires the system be ﬁtted with a sensor capable of providing ground-truth for training. [2]. Our algorithm does not require the use of additional sensors, or external ground-truth.
Laser rangeﬁnders combined with particle ﬁlter-based localization is widely used in ground robotic systems [49]. While planar LIDARs are commonly used to estimate motion in the 2D plane, they have also proved useful for localization in 3D environments. Prior work in our group [3], as well as others [48, 19] leveraged a 2D laser rangeﬁnder to perform SLAM from a quadrotor in GPSdenied environments. These systems employ 2D scan-matching algorithms to estimate the position and heading, and redirect a few of the beams in a laser scan to estimate the height. While these systems have demonstrated very good performance in a number of realistic environments, they must make relatively strong assumptions about the motion of the vehicle and the shape of the environment. Speciﬁcally, they require walls that are at least locally vertical, and a mostly ﬂat ﬂoor for height estimation. As a result, these algorithms do not extend to the aggressive ﬂight regime targeted in this paper. Scherer et al. use laser rangeﬁnders to build occupancy maps, and avoid obstacles while ﬂying at high speed [46], however they rely on accurate GPS measurements for state estimation.
In addition to the laser-based systems for GPS-denied ﬂight, there has been a signiﬁcant amount of research on vision-based control of air vehicles. This includes both ﬁxed-wing vehicles [29], as well as larger scale helicopters [10, 28, 24]. While vision-based approaches warrant further study, the authors do not address the challenge of agile ﬂight. This is likely to be particularly challenging for vision sensors due to the computational complexity of vision algorithms and sensitivity to lighting and environment conditions.
Recently, Hesch et al. [23] developed a system that is similar in spirit to ours to localize a laser scanner and INS for localizing people walking around in indoor environments. They make a number of simplifying assumptions such as zero-velocity updates, that are not possible for a micro air vehicle. Furthermore, they model the environment as a set of planar structures aligned with one of 3 principle axes, which severely limits the types of environments in which their approach is applicable. Our system uses a general occupancy grid representation which provides much greater ﬂexibility of environments.
3 Nomenclature and Coordinate Frames
The state of a rigid body dynamical system is described by the quantities x = [ωb, vb, R, ∆], where ωb = [p, q, r] is the angular velocity in body coordinates, vb = [u, v, w] is the linear velocity in body coordinates, R is the rigid body orientation rotation matrix, and ∆ = [∆x, ∆y, ∆z] is the translation vector from the world origin to the center of mass of the body, expressed in global coordinates. We will refer to this rigid body state in the context of state esti-
7

Figure 1: The global frame, body frame and velocity frame depicted with x-, y-, and z-axes in red, green, and blue respectively. The ENU global frame is ﬁxed to the ground (with the x-direction pointing East). The body frame is ﬁxed to the vehicle with the x-direction pointing forward, aligned with the longitudinal vehicle axis. The velocity frame, assuming coordinated ﬂight, shares the y-axis with the body frame and has its x-axis aligned with velocity.
mation and in describing our vehicle models. For planning and control, we will make use of three coordinate frames. The
world frame, denoted with the letter w, is a static East-North-Up (ENU) coordinate frame anchored at some origin in the world. The body frame is ﬁxed to the center of mass of the the aircraft, with the x-direction pointing forward and aligned with the longitudinal axis of the vehicle, the y-direction pointing left, and the z-direction pointing up (FLU). The body frame is denoted with the letter b, and quantities expressed in body frame coordinates will be denoted with a subscript b. The transformation between world and body frames is deﬁned by the translation vector ∆ and orientation R. The third frame is a “velocity” frame, which shares its origin and y-direction with the body frame, but has its x-axis aligned with the body velocity direction. The velocity frame is denoted with the letter v. This convention is depicted in Figure 1.
The use of the ENU-FLU coordinate frame runs counter to the convention of aerospace control literature, however it is consistent with more recent work using quadrotors indoors (which inherit z-up coordinate frames from ground robots) and the choice was made to make easier use of existing software libraries for mapping and visualization. We will be estimating the velocity and angular velocities in the body frame (vb, ωb), however in other contexts it is convenient to discuss velocity and acceleration in the world frame. In these cases we will refer to derivatives of position for clarity (i.e., ∆˙ , ∆¨ ).
If we wish to refer to a single component of a vector expressed in a certain frame, we will use the subscript of the associated unit vector. For example, the scalar forward velocity aligned with the longitudinal axis of the vehicle (bx) will be denoted vbx .
8

4 Trajectory Planning for Aggressive Flight
Given a 3D occupancy map of the environment and speciﬁed start and goal locations, we wish to compute dynamically feasible trajectories from start to goal, which do not intersect obstacles in the environment, and which minimize a penalty on the derivatives of the trajectory. To quantify our computational eﬃciency requirement, we require that the solution take no more than a matter of seconds to generate. This is not a hard time constraint, and the diﬃculty of planning will scale with the size and complexity of the environment. However, our aim is to plan trajectories much faster than existing optimal planning algorithms that might be used instead. In Section 4.4 we show that solving our planning problem with RRT* in the full 12-DOF state space of a quadrotor would take many minutes to converge, exceeding the 10-minute ﬂight time of our MAVs. For practical use in missions consisting of multiple or changing destinations, we need to be able to generate new plans much more eﬃciently.
As outlined in Section 2.1, there exist many algorithms capable of planning trajectories for dynamical systems. However, there remains a signiﬁcant gap in the practical capabilities of these algorithms to quickly ﬁnd and optimize longrange trajectories for 12-DOF dynamical systems. Algorithms which perform the dual functions of search and optimization, such as graph search (A*) or randomized search (RRT*) will succumb to the curse of dimensionality when faced with the full dynamics of a quadrotor or ﬁxed-wing vehicle. Therefore, these algorithms will not be able to return an optimal or near-optimal trajectory in a matter of seconds, but may instead take many minutes to terminate. On the other hand, planning algorithms which ﬁnd trajectories quickly but oﬀer no optimization capabilities, such as the RRT or CL-RRT, may return solutions that are overly high in cost according to some function, or may require abrupt or excessive control inputs.
It is useful to minimize certain trajectory derivatives for several reasons. First, these derivatives map directly to the required control inputs, and we would like to avoid unnecessary power requirements and wear on our system due to excessive actuation. Additionally, reducing the required control inputs along a trajectory helps to retain maximum control authority for feedback stabilization. Finally, trajectories requiring abrupt motions tend to excite high-order dynamic eﬀects that are diﬃcult to model and control, such as turbulence, actuator response and latency. Roughly speaking, minimizing derivatives can encourage “graceful” motions. For quadrotors, minimizing snap (fourth derivative) limits the motor commands required to follow a trajectory [38], while for ﬁxed-wing vehicles, we may instead prefer to minimize the third derivative to limit roll rates. If we select polynomials as our trajectory basis function, then minimizing these cost functions on the derivatives is straightforward and computationally eﬃcient. Furthermore, if we exploit the property of diﬀerential ﬂatness for our vehicle models, then the mapping from trajectory derivatives to control inputs is an algebraic expression, and we can easily verify dynamic feasibility.
In the next section, we describe the role of diﬀerential ﬂatness in the context of planning. Then, we develop the necessary tools for optimizing polynomial trajectories in order to take advantage of diﬀerential ﬂatness and minimize our desired cost function on the trajectory derivatives. The optimization itself does not directly incorporate dynamic or kinematic constraints. Finally, in Section 4.4, we will combine these polynomial optimization tools with a low-dimensional
9

search algorithm to develop a full planning procedure that can both ﬁnd and optimize trajectories for diﬀerentially ﬂat systems in a matter of seconds.
4.1 Diﬀerential Flatness for Trajectory Planning
While very detailed models are available for the quadrotor and ﬁxed-wing vehicles, capturing complex aerodynamic eﬀects and detailed input response characteristics, we instead focus on planning with particular simpliﬁed representations. Speciﬁcally, we focus on representations for these vehicles that are diﬀerentially ﬂat. For our purposes, the result of diﬀerential ﬂatness is an algebraic mapping from a set of ﬂat output variables and their derivatives to the vehicle states and inputs [51]. While there is no systematic way of determining whether such a mapping exists in general, ﬂatness has been shown for a large number of useful systems [40].
The mapping between vehicle states and inputs and the ﬂat output space is what makes diﬀerential ﬂatness useful for trajectory planning. The challenge in trajectory optimization and motion planning for dynamical systems is to ﬁnd a (minimum cost) sequence of control inputs that will carry the system between speciﬁed initial and terminal states subject to the diﬀerential equations of the system. This problem can be framed as a numerical optimization or graph search, but in either case, it involves an expensive search over the set of possible input sequences. The advantage of diﬀerential ﬂatness in the context of trajectory planning is that a trajectory can be speciﬁed directly in the ﬂat output space, and the control inputs needed to execute that trajectory can be obtained as an algebraic function of the trajectory and its derivatives. For many systems, it may be much easier to specify and optimize a trajectory in the ﬂat output space than it is to perform a search over the input space.
In general, the ﬂat output variables need not correspond to convenient physical quantities, but often they do. For the quadrotor, the four ﬂat output variables are the three components of the global position vector along with the heading angle. Likewise, the three ﬂat output variables for the ﬁxed-wing vehicle are also the three components of the global position vector. Therefore, it is easy to specify start and goal locations in the ﬂat output space, as well as to check for collisions with obstacles in our three dimensional environment.
To recover the states and inputs to the vehicle along a trajectory, we need not only the values of the ﬂat outputs along the trajectory, but also their derivatives. Intuitively, the states and inputs of a vehicle at some point along a trajectory must depend not only on the position, but also the velocity, acceleration and higher order derivatives of the trajectory at that point. Therefore it is convenient to deﬁne our trajectories using a diﬀerentiable basis function. While there are a variety of choices that would work in this setting, we have chosen polynomials due to their analytical and computational tractability.
4.2 Polynomial Trajectory Optimization
Consider the evolution of a ﬂat output variable over some time interval t ∈ [0, τ ], such as a position coordinate, prescribed by a polynomial P (t) between two points in the space of ﬂat outputs. We would like to select the coeﬃcients of P (t) such that its endpoints at t = 0 and t = τ (and the derivatives at those endpoints) match those that have been speciﬁed. With any remaining degrees of
10

freedom, we would like to optimize some cost function of the derivatives of the polynomial. Mellinger and Kumar use the minimum-snap (fourth derivative) cost function for quadrotors [38]. This cost function eﬀectively discourages abrupt changes in the motor commands to the quadrotor, leading to graceful trajectories. For other systems, we may prefer to minimize some other weighted combination of the derivatives of the trajectory.
Let pn denote the coeﬃcients of a polynomial P of degree N such that

P (t) = pntN + pn−1tn−1 . . . + p0

(1)

N

= pntn.

(2)

n=0

We are interested in optimizing the coeﬃcients of P to minimize cost functions of the form

t=τ

J=

c0P (t)2 + c1P (t)2 + c2P (t)2 + . . . + cN P (N)(t)2dt,

(3)

t=0

which can be written in quadratic form as

J = pT Qp,

(4)

where p ∈ N+1 is the vector of polynomial coeﬃcients and Q is a cost matrix corresponding to our desired penalty on each of the polynomial derivatives. In order to minimize the fourth derivative of a polynomial, for example, we would set c4 = 1 and set ci = 0 for i = 4.
In addition to specifying the cost function, we must also constrain the solution to enforce certain conditions on the value and derivatives of the initial and ﬁnal endpoints of the polynomial. The constraints take the following form:

A0p = b0

(5)

Aτ p = bτ

(6)

where A0 and Aτ are matrices that map the coeﬃcients p to the derivatives of the polynomial at the beginning and end, respectively. The vectors b0 and bτ indicate the values of the derivatives we wish to constrain. Each row of equations (5) and (6) corresponds to a particular derivative that we wish to constrain, including the 0th derivative, which allows us to constrain the value of the polynomial (i.e., the position). In Appendix A, we show how to derive the Q and A matrices.
By concatenating the desired constraints on the initial and ﬁnal derivatives of the polynomial, we have a standard quadratic programming problem

min

pT Qp

p

(7)

s.t. Ap − b = 0

which we can solve using an elimination approach [6].

4.2.1 Piecewise Polynomial Joint Optimization
In general, the trajectory of a given ﬂat output variable will consist not of a single polynomial segment, but of a sequence of several segments. We will

11

be optimizing trajectories that pass through a sequence of waypoints in the output space of the diﬀerentially ﬂat system. These waypoints will be obtained from a kinematic planning algorithm capable of ﬁnding a route through the environment, such as A* or RRT*.
The trajectory between each pair of waypoints will be an individual polynomial trajectory segment. Rather than optimizing each of these polynomials in isolation, we may obtain lower-cost trajectories by jointly optimizing the entire sequence of polynomials at once. Furthermore, we need the two polynomial segments that meet at every junction or waypoint to agree on the value of the trajectory derivatives at that junction. Joint optimization is a natural way to enforce these continuity constraints.
A piecewise polynomial describing the evolution of a ﬂat output variable can be constructed as:



P0(t) :

0 ≤ t ≤ τ0



P1(t − τ0) :

τ0 < t ≤ τ1 + τ0

T (t) = P2(t − (τ0 + τ1)) : τ0 + τ1 < t ≤ τ0 + τ1 + τ2

(8)

...

where we deﬁne Γk =

k κ=0

τκ

to

write

T (t) = Pk(t − Γk−1) :

Γk−1 < t ≤ Γk.

(9)

We can formulate an optimization over the polynomial coeﬃcients by forming a vector containing all the coeﬃcients pi of all of the polynomial segments:

p = p0 p1 . . . pK

(10)

The cost matrix is constructed as a block diagonal matrix composed of individual Qk matrices. The constraints for speciﬁed derivative values are composed as a concatenation of equations of the form in equations (5) and (6). However, if we do not specify particular derivative values, we still wish to enforce continuity of the derivatives at each junction between segments. Constraints enforcing continuity take the form:

−Aiτ

Ai0+1

pi pi+1

= σi

(11)

where σi is a vector of derivative oﬀsets between polynomials i and i+1. Setting this vector to zero will enforce continuity, but it will be necessary when we discuss trajectories for the ﬁxed-wing vehicle to enforce nonzero oﬀsets. The full constraint equation to enforce continuity (or derivative oﬀsets) is:

 p0 

 −A0τ A10

0 0 ...

0

 0 −A1τ A20 0 . . .

0

 

0

0 −A2τ A30 . . .

0

  

...

...

...

... . . .

...

0

 

p1



 σ0 

0

 

p2

 

 σ1 

0

 

p3

  =

σ2

 

...

  

...

  

  

...

  

0

0

0

0 . . . −AKτ −1 AK0

 

pK−1

 

σK−1

pK

(12)

12

We can also combine this equation with a second set of constraints to specify exact values of derivatives that we wish to ﬁx:

 A00

0

 

0

 

0

  

...

 

0

0

0 A10 0
0 ...
0
0

0
0 A20 0
...
0
0

0 0 0 A30 ... 0 0

... ... ... ... ...
... ...

0 0 0 0 ... AK0 AKτ

 
         

p0 p1 p2 p3 ...
pK


       


    =     

b00 b10 b20 b30 ... bK0 bKτ


         

(13)

where bi0 for i = 0, . . . , K − 1 is a vector of speciﬁed derivatives at the beginning of the ith piecewise polynomial segment and bKτ is a vector of speciﬁed derivatives at the end of the ﬁnal segment. Note that if we specify continuity using equation (12), then we need only specify derivatives at the beginning of each segment because the corresponding derivatives at the end of the preceding segment will also be enforced through continuity. In practice, some combination of the rows of equations (12) and (13) will enable us to specify the desired set of derivative values as well as enforce continuity up to the desired order. Having constructed the desired system of constraints, the joint optimization can then be performed using an elimination approach [6].
This constrained optimization method works well for small joint optimization problems as in [38], however this formulation becomes ill-conditioned for more than several segments, polynomials of high order, and when widely varying segment times are involved. Hence, it is only useful for short trajectories and must be improved for optimizing long range paths requiring many waypoints and segments.
We avoid the problems of ill-conditioning using a technique of substitution to convert the problem into an unconstrained QP, which allows us to solve directly for endpoint derivatives as decision variables, rather than solving for polynomial coeﬃcients. In practice, our reformulation is substantially more stable than the constrained formulation, allowing the joint optimization of more than 50 polynomial segments in a single matrix operation without encountering numerical issues. Once the optimal waypoint derivatives are found, the coeﬃcients of the polynomial connecting each pair of waypoints can be obtained by solving a small linear system with the appropriate constraint matrix.
To convert to an unconstrained optimization, we begin by substituting pi = A−i 1bi from the ith individual segment constraint equations into the original cost function:

 b0 T A0

J = 

...

 

 

...

−T Q0

 

...

 A0

 

...

−1  b0 

 

 

...

 

bK

AK

QK

AK

bK

(14)

Now the decision variables in this new quadratic cost function are the end-

point derivatives of the segments, bi. We re-order these variables such that

ﬁxed/speciﬁed derivatives are grouped together (bF ) and the free/unspeciﬁed derivatives are grouped together (bP ). A permutation matrix of ones and zeros

(C) is used to accomplish this re-ordering. Now we have:

13

J=

bF bP

T
CA−T QA−1CT

bF bP

=

bF bP

T

RF F RP F

RF P RP P

bF bP

R

(15)

where we have written the block-diagonal matrices as A and Q for simplicity of notation. We group the new augmented cost matrix into a single matrix R and partition it according to the indices of the ﬁxed and free derivatives. Partitioning allows us to write out the expression for total cost as:

J = bTF RF F bF + bTF RF P bP + bTP RP F bF + bTP RP P bP

(16)

Diﬀerentiating J and equating to zero yields the vector of optimal values for the free derivatives in terms of the ﬁxed/speciﬁed derivatives and the cost matrix:

b∗P = −R−P P1 RTF P bF

(17)

The polynomials can now be recovered from individual evaluations of the appropriate constraint equations mapping derivatives back into the space of coefﬁcients.

4.2.2 Performance of Polynomial Optimization
A key to the success of this trajectory planning process is the speed and numerical stability of the joint polynomial optimization method. We performed benchmark tests on an example problem consisting of four waypoints (3 polynomial segments) chosen to represent distance and time scales consistent with common environments for quadrotor ﬂight. The results are given in Table 1 and reﬂect MATLAB as well as C++/Eigen implementations [20]. This computational eﬃciency makes it feasible to use this planning framework in online applications and to use iterative path reﬁnement methods with polynomial optimization in the loop.
Table 1: Comparison of Polynomial Optimization Times.

Benchmark Problem: 3-Segment Joint Optimization

Method

Solution Time (ms)

MATLAB quadprog.m

9.5

MATLAB Constrained

1.7

MATLAB Unconstrained (Dense)

2.7

C++/Eigen Constrained

0.18

C++/Eigen Unconstrained (Dense)

0.34

While the unconstrained formulation is slightly slower than the constrained formulation, its primary beneﬁt lies in its stability. The constrained formulation encounters matrices very close to singular for joint optimizations consisting of more than three 9th order polynomials, and therefore may return inaccurate results depending on the quality of the linear algebra solver. In contrast, the unconstrained formulation is robust to numerical issues, as shown in Table 2, which lists the results of 20 polynomial optimization problems in which the
14

locations of intermediate waypoints and the segment times were randomly generated in the range [1, 3]. Clearly, the unconstrained optimization is much more robust to numerical instability, enabling this method to be used as a reliable, eﬃcient long-range trajectory optimization tool for navigation outside of small motion-capture environments.
Table 2: Numerical stability of optimization techniques for high-order polynomials and various numbers of segments.

Success Rates on Randomized Polynomial Optimization Problems

Formulation

Polynomial Order Number of Segments Success

9

3

100%

Constrained

9

4

55%

9

≥5

0%

9

50+

100%

Unconstrained

15

50+

100%

Since A−1 and Q are sparse block-diagonal and C is sparse, these problems can be implemented using a sparse solver which is roughly an order of magnitude faster than the dense computation for 10-segment joint optimizations.
The unconstrained optimization is more numerically stable because it is solving for waypoint derivative values such as velocities, accelerations, etc., that are similar in magnitude. The resulting polynomial segments are not particularly sensitive to the exact values of these derivatives. On the other hand, the constrained optimization solves simultaneously for the full set of polynomial coeﬃcients, which range in magnitude from approximately 101 down to 10−16 (i.e., machine precision). The resulting solution is extremely sensitive to the values of small coeﬃcients corresponding to high-order terms, which may be inaccurate due to rounding errors.

4.3 General Polynomial Trajectory Representation

One common trajectory representation for diﬀerentially ﬂat systems is to spec-

ify a separate polynomial for each of the ﬂat output variables of the system.

For a quadrotor, for example, the four ﬂat output variables are the x-, y-, and

z-position coordinates and the yaw angle, ψ. Therefore, we can specify a poly-

nomial trajectory through space as the set of piecewise-polynomial trajectories

{Px(t), Py(t), Pz(t), Pψ(t)} describing these four variables. An example of a polynomial trajectory is given in Figure 2. This general trajectory formulation

could also be used to describe the motions of rigid body chains, robotic arms,

or a variety of other diﬀerentially ﬂat systems.

For the quadrotor, motor inputs required to follow these trajectories are

functions of the trajectory derivatives up to fourth order. Typically we will

use polynomials with 10 coeﬃcients (9th order) so that we can specify all ten

derivative values if necessary. For example, for a single polynomial representing

∆x(t), we may want to specify:

b0

=

[∆x(0), ∆˙ x(0),

∆¨ x(0),

... ∆x(0),

.... ∆x

(0)]T

(18)

bτ

=

[∆x(τ

),

∆˙ x

(τ

),

∆¨ x

(τ

),

... ∆x

(τ

),

.... ∆ x(τ

)]T

(19)

15

X−position (m)

0.5

0

Z (m)

1 0.5
0 −0.5
−1 −1.5

2

1

Y (m)

0

1 0 −1 X (m)

Yaw (rad) Z−position (m)

Y−position (m)

−0.5

0

0.5

1

1.5

2

4

2

0

0

0.5

1

1.5

2

0.5

0

−0.5

0

0.5

1

1.5

2

2

1.5

1

0

0.5

1

1.5

2

Time (s)

Figure 2: Example piecewise polynomial trajectory for a quadrotor. The left panel illustrates a trajectory through space. The right panel shows the evolution of the x, y, z and ψ coordinates through time.

requiring 10 parameters to satisfy these constraints. In general, we will specify some subset of these derivatives, leaving the remaining parameters free for optimization.
Often we will constrain the trajectory to start and end at rest and constrain the higher derivatives to also begin at zero, as seen at the beginning of the red polynomial segments and the end of the blue segments on the right panel of Figure 2. For intermediate waypoints, we will only specify positions. The velocity, acceleration, and higher derivatives will be selected by optimization of the polynomial coeﬃcients. This strategy is convenient for planning if we have access to a sequence of waypoints with which to constrain the optimization. In the next section we will describe a method of obtaining waypoints and using them to construct a polynomial trajectory.
4.4 Planning with Polynomial Trajectories
Given a 3D occupancy map of an environment, we wish to eﬃciently compute feasible polynomial trajectories from start to goal, while respecting obstacle constraints and input saturation limits. In the previous section, we developed the tools for polynomial optimization, which will allow us to construct trajectories that are constrained to pass through a sequence of waypoints in the ﬂat output space. In [38], the initial and ﬁnal states of the trajectory, as well as the locations of all intermediate waypoints were selected by hand. However, in order to adapt this trajectory optimization method to function in a real-world planning context, we need a way of obtaining these constraints automatically. In this section, we develop the additional methods required to apply polynomial optimization to solve the trajectory planning problem.
First, we must obtain a sequence of waypoints through the environment, which function as constraints guiding the polynomial trajectories from start to goal. Our solution to this problem is to utilize the RRT* algorithm to ﬁnd a 3D collision-free path through the environment, initially considering only the kinematics of the vehicle and ignoring the dynamics. A variety of other search and

16

(a)

(b)

(c)

Figure 3: Using polynomial segments directly as an RRT* steer function (a) is computationally slow. Therefore, we run a straight-line RRT* and select waypoints from the optimal path (b). However, the straight-line RRT* ignores dynamics and returns a path that does not minimize our objective function. We therefore jointly optimize a set of polynomials through those waypoints to obtain a minimum-snap trajectory (c).

planning algorithms, such as A*, could also serve this purpose. The resulting path is pruned to a minimal set of waypoints, and a sequence of polynomial segments is jointly optimized to join those waypoints into a smooth minimum-snap trajectory from start to goal. Speciﬁcally, the waypoint positions comprise the constraint values (bi) for the intermediate polynomial segments in the optimization presented above. As a result of these constraints, the optimized polynomial trajectory will pass through each of these waypoints. At this point, it is possible that one or more of the polynomial trajectory segments will be in collision with the environment. In section 4.4.2 we describe our method for repairing such collisions.
A general search over the space of minimum-snap trajectories would be extremely expensive, though it would in principle return the globally optimal trajectory. To validate our approach, we ran an RRT* using individual polynomial trajectory segments as the “steer” function to grow the search tree of feasible trajectories. Figure 3(a) shows the resulting solution. Sampling for the RRT* with the polynomial steer function was performed in position and velocity space. We use the distance metric described by [25] of Euclidean distance divided by average velocity. One major diﬃculty with this approach is that segment times must be ﬁxed when generating polynomials to extend the tree, however the selection of segment time can have a dramatic impact on the quality of a path, so an appropriate guess must be made a priori for each segment, or the segment time must be included in the sampling space. In our implementation, the segment times were chosen as the Euclidean distance between vertices divided by the desired average velocity along the segment.
Table 3 shows several statistics on the performance of the RRT* with a

17

Table 3: Comparison of our method with RRT* using the polynomial steer function for the 2D problem in Figure 3.

Method RRT* (Polynomial Steer)
Our Approach

Runtime 120 s 3s

Jpoly. 5.72 × 108
1.07 × 105

τpath 21.94 s 19.66 s

Lpath 40.35 m 35.51 m

polynomial steer function compared to our algorithm. The RRT* runs much longer and fails to ﬁnd a path as smooth or with a cost as low as our algorithm. When sampling in the full state space of the system, the RRT* with a polynomial steer function would converge to a globally optimal solution in the limit of inﬁnite samples, however as shown here, the paths returned prior to convergence are of lower quality than those returned by our algorithm in a much shorter running time.

4.4.1 Time Allocation

Until this point in the trajectory optimization, we have ﬁxed an arbitrary amount of time τi associated with each segment, since these times factor into the construction of the cost matrix. These segment times constrain the solution quality, but can be allowed to vary to improve the overall solution with respect to a cost function. We therefore begin with an initial guess of segment times and then iteratively reﬁne those times using gradient descent. Several cost functions may be suitable candidates: in [12], Cutler and How minimize total time subject to constraints, while in [38], Mellinger and Kumar ﬁx the total time by hand and minimize snap (the original cost function) with the remaining degrees of freedom. In the planning context, we do not know the total trajectory time a priori, so we allow it to vary in the optimization to perform a trade-oﬀ between minimizing snap and total trajectory time. We attempt to minimize:

 p0 T Q0(τ0)

Jτ

= 

...

 

 

...

  p0 

K

 

...

 

+

cτ

τi

(20)

pK

QK (τK ) pK

i=0

where cτ is a user-speciﬁed penalty on time. The ﬁrst term in this cost function

is simply the original cost function for polynomial optimization. When penal-

izing only acceleration, jerk or snap, this original cost can be driven arbitrarily

close to zero by increasing the total time, but equation (20) has a minimum

value for some ﬁnite

K i=0

τi

that

varies

with

cτ .

Figure

4

shows

several

itera-

tions of gradient descent in which the total trajectory time is decreased from a

large initial guess (red) to smaller optimal value (blue), while the ratio of times

between segments also shifts to minimize the modiﬁed cost.

Rather than selecting total times arbitrarily, this cost function allows our

algorithm to automatically adjust for environments of widely varying scales, or

where the vehicle must slow down to navigate tightly spaced obstacles without

incurring excessive snap. Furthermore, our procedure produces trajectories of

comparable aggressiveness in a wide range of scenarios for a given ﬁxed value

of the single scale-independent parameter, cτ .

18

Figure 4: Illustration of the iterative reﬁnement of segment times, color-coded by total traversal time. The initial guess of total time is 10.5 s (red) and the ﬁnal optimized total time is 7 s (blue).
(a)
(b)
Figure 5: Segment time optimization with cτ = 500 (a) and cτ = 50000 (b). The optimal total trajectory times are 9.1 s and 5.1 s respectively. Vectors for waypoint velocity (red) and acceleration (green) are shown.
Figure 5 shows optimized trajectories for the same set of waypoints using two diﬀerent cτ values. The red arrows indicate waypoint velocities and the green arrows indicate accelerations. These quantities are greater in the bottom trajectory due to the higher time penalty. The vehicle axes are plotted at 0.1 s increments along the path. One emergent property resulting from time allocation is that the system moves very slowly around the sharp corner and then smoothly accelerates up to a higher speed in the straightaway where it does not incur a severe penalty on its fourth derivative. This same behavior could be equally useful for robotic arms executing smooth trajectories. Furthermore, the geometric shape of the optimal trajectory remains the same regardless of the value of cτ , indicating that the cost-minimizing ratios of segment times are independent of cτ for a given arrangement of waypoints. 4.4.2 Ensuring the Trajectory is Collision-Free If a particular trajectory segment is found to intersect an obstacle after optimization, an additional waypoint is simply added halfway between its two ends,
19

splitting this segment into two, as in [41]. This midpoint is known to be collisionfree because it lies on the optimal piecewise-linear path returned by the search algorithm. The polynomial is re-optimized (including time allocation) with the additional waypoint, and the process is repeated recursively if necessary until the polynomial trajectory is collision free.
A ﬁnite number of additional waypoints is suﬃcient to pull the polynomial trajectory close enough to the underlying piecewise-linear path to repair collisions as long as the corridor between obstacles is strictly wider than the vehicle. As the number of waypoints increases, the polynomial trajectory converges to the piecewise-linear path, which is known to be feasible for the quadrotor (we do not imply that this technique would work for a ﬁxed-wing aircraft, however). Figure 6 illustrates this procedure resolving a collision.
It is possible to construct environments and trajectories that require many additional waypoints to repair collisions, thus requiring the optimization problem to be re-solved many times to ﬁnd a feasible solution. Additional waypoints also increase the computational complexity of the QP being solved in each iteration. However, in our experience with indoor environments, one or two additional waypoints in a given segment is usually suﬃcient to resolve collisions.

(a) Polynomial trajectory (blue) intersects an (b) After bisecting the underlying straight

obstacle even though the underlying straight line twice with two additional waypoints, the

line between waypoints is collision-free.

polynomial trajectory is collision-free.

Figure 6: (a) The polynomial (blue) intersects an obstacle even though the line between waypoints is collision free (magenta). (b) These scenarios are resolved by iteratively adding waypoints along the collision-free path returned by the search algorithm.

There are several strategies that could be used to prevent the number of necessary additional waypoints from growing too large. One option would be to bias the underlying search away from potential collisions by placing an elevated cost on paths that go near obstacles. Another option would be to inﬂate obstacles slightly larger during the low-dimensional route-ﬁnding phase to leave an allowance for the smooth polynomial to deviate from the underlying piecewiselinear path. We leave the detailed analysis of collision-repair strategies for future work.

20

Motor Thrust (N)

Velocity (m/s)

9 8 7 6 5 4 3
0
15 10
5 0
0
6 4 2
5

Motor 1 Motor 2 Motor 3 Motor 4

2

4

Time (s)

2

4

Time (s)

10

15

X−position (m)

(a)

6 6
20

Velocity (m/s)

Y−position (m)

Motor Thrust (N)

9

8

7

6

5

4

3

0

1

2

3

4

Time (s)

15

10

5

0

0

1

2

3

4

Time (s)

6

4

2 5

10

15

20

X−position (m)

(b)

Y−position (m)

Figure 7: Comparison between two time allocations during gradient descent. The ﬁrst time allocation (a) is conservative in that it is a slower trajectory than the second one (b), which activates one of the actuator constraints indicated by the dashed line in the upper right plot.

4.4.3 Actuator Constraints
A second major factor contributing to feasibility is to ensure that the input constraints are satisﬁed such that no portion of the commanded trajectory requires control inputs outside of the range that the actuators are capable of providing. Formally, solving a trajectory optimization problem in the ﬂat output space of a diﬀerentially-ﬂat model requires mapping the constraints into the ﬂat output space as well as the dynamics. Some work has focused on computationally estimating the feasible set in ﬂat output space [14], however this set is generally a non-convex function of nonlinear inequalities and is a hard optimization problem unto itself.
Instead, we address this challenge during the time-allocation step of trajectory optimization, since the distribution of time along the trajectory largely determines the required accelerations and therefore the peaks in required actuator commands. First, we observe that in the limit as τ → ∞, the motion along the trajectory slows to a near-static state, which is known to be feasible for systems like hovering quadrotors. Therefore, we initialize our time-allocation optimization step with a conservatively large guess for initial segment times. Then, as the modiﬁed cost function is minimized, we compute the actuator commands algebraically during each iteration to verify that we remain within the feasible set. Optimization is terminated when either a local minimum is obtained or an actuator constraint becomes active. Figure 7 illustrates two diﬀerent time allocations during the optimization of a sample trajectory for a quadrotor. One of these time allocations is safely within the feasible set, since it

21

commands thrusts barely above the nominal thrust required for hover, whereas the other time allocation is very aggressive and activates an actuator constraint for one of the motors.
Due to the non-convexity of the feasible set in ﬂat output space, the optimization algorithm may encounter an actuator limit and terminate before converging to the optimal ratio of segment times (for example, one of the red or orange lines in Figure 4). To avoid this scenario, one strategy is to ﬁrst optimize the ratio of segment times via gradient descent while ignoring actuator constraints, taking advantage of the fact that the optimal ratio of times is invariant to the total time, as noted in Section 4.4.1. Then once the optimal ratio of times is achieved, scale the total trajectory time in a separate univariate optimization, preserving the optimal ratio, until the modiﬁed cost function is minimized or an actuator constraint becomes active. This general concept applies to a variety of other diﬀerentially ﬂat systems, such as robotic arms, which may have rate or torque constraints that could be satisﬁed by extending the duration of the trajectory to slow the motion.
5 State Estimation
To close the loop around the trajectory we must know the state of the vehicle. Since we are operating without the use of GPS, the state must be inferred from sensor readings and knowledge of rigid-body dynamics. The state estimation algorithm is responsible for taking as input sensor readings from the IMU and laser range ﬁnder and estimating the position and velocity of the vehicle to stabilize nominal trajectories. As described in Section 2.2, there are many existing state estimation algorithms that have been applied to autonomous vehicles. However, none of them are able to accurately perform localization using LIDAR measurements in a manner that is computationally eﬃcient enough to run on a small computer that can be carried onboard a MAV. Our approach is to use a Gaussian particle ﬁlter (GPF)-based update step together with an EKF process model driven by the IMU to eﬃciently and compactly ﬁlter the sensor inputs. We also provide a method for estimating the noise parameters of the model without using ground-truth data.
5.1 State Estimation Problem Statement
Given a 3D occupancy map of the environment and a sequence of sensor measurements, Z0:t, up to the present time, we wish to estimate the current system state xt = [ωb, vb, R, ∆]t. We model the system as a rigid body and we neglect higher-order eﬀects resulting from aerodynamics or other disturbances. We assume a set of inertial measurements consisting of 3-axis acceleration and 3-axis angular rate measurements, and exteroceptive measurements consisting of planar laser range scans.
5.2 IMU Process Model
Our state estimation algorithm uses an extended Kalman ﬁlter (EKF) to estimate a Gaussian distribution over system states. The EKF process model is
22

based on a discrete time, nonlinear discrete transition function:

xt+1 = f (xt, ut, wt)

(21)

where xt is the system state vector, ut is the input vector to the system, and wt is a random disturbance drawn from a normal distribution N (0, Q). The EKF tracks the state at time t as a Gaussian distribution with mean µt and covariance Σt. These ﬁrst two moments are propagated forward according to:

µ¯t+1 = f (µt, ut, 0) Σ¯ t+1 = AtΣtATt + WtQWtT

(22) (23)

where µ¯ and Σ¯ denote predicted quantities before a measurement update has occurred, and At and Wt are the appropriate partial derivatives of f . Note that in this section our use of the symbols A and Q is distinct from their use in polynomial optimization in order to remain consistent with state estimation literature.

5.2.1 Exponential Coordinates Attitude Uncertainty

We track orientation uncertainty in perturbation rotations in the body frame. If the true orientation is given by the rotation matrix R, we can write R = Rˆ R(χ) where Rˆ is the estimated orientation and R(χ) = eχ∧ is the error rotation matrix. χ ∈ 3 is the perturbation rotation about the body axes. We use the ∧ symbol to the right of a vector to denote the skew symmetric matrix formed
as:

 0 −χ3 χ2 

χ∧ =  χ3 0 −χ1 

(24)

−χ2 χ1 0

Taking the matrix exponential of a skew symmetric matrix returns a rotation
matrix corresponding to a rotation of |χ| about the axis deﬁned by χ where χ
is referred to as the exponential coordinates of rotation. In our expression for the true orientation, R(χ) post multiplies Rˆ which
puts the perturbations in the body frame. Since the error is parameterized by
χ, the covariance can be tracked in a 3 × 3 matrix Σχ. The covariance can be thought of as cones of uncertainty surrounding the body frame axes deﬁned by the columns of Rˆ . A sketch of this uncertainty is shown in Figure 8 for the
covariance (in degrees):

 32 0 0 

Σχ =  0 52 0 

(25)

0 0 152

This choice of coordinates for the ﬁlter error is desirable since fundamentally rigid body orientation, denoted mathematically as the special orthogonal group (SO(3)), has three degrees of freedom. While any three-element representation is provably singular for some orientation, more commonly-used parameterizations (i.e., quaternions or rotation matrices) will have constraints between the elements of the representation. Thus a linearized ﬁlter covariance over the parameters will not be full rank. Numerical errors pose the constant threat of

23

creating negative eigenvalues, and thus causing the estimator to diverge. Furthermore, an eﬃcient linearized measurement update as is commonly-used in Gaussian ﬁlters does not respect the constraints and thus does not map onto SO(3). A renormalization scheme could be used after every update, but at any given time the representation can be arbitrarily poor [50].
As we will see, the attitude uncertainty representation is agnostic to the actual underlying orientation integration and tracking. Quaternions and rotation matrices are easy to update based on using χ in the estimator state vector µ.

Figure 8: This ﬁgure shows the uncertainty representation in body axes. We see that high variance on the z-axis perturbation maps into large motions for the x- and y-bases.

5.2.2 Process Equations

The equations of motion for a rigid body are:

ω˙ b = J−1(−ωb × Jωb + τb)

(26)

v˙ b = −ωb × vb + RT g + ab

(27)

R˙ = Rωb∧

(28)

∆˙ = Rvb,

(29)

where τb is the torque applied to the body and ab is the acceleration in body coordinates. Since the IMU provides accurate measurements of ωb and ab, we follow the commonly-used technique of omitting ωb from the state, neglecting equation 26, and treating the IMU measurements as inputs to the ﬁlter using a standard linearized IMU update.
For the quantities used in equation 22 we have

x= u= w=

vb χ ∆ ugyro uaccel wgyro waccel

(30) (31) (32)

24

Combining this state representation with equations 27-29 gives:

 v˙ b 

fc(xt, ut, wt) =  R˙ 

(33)

∆˙

 −ωb × vb + RT g + guaccel 

=

Ru∧gyro

.

Rvb

(34)

Taking the appropriate partial derivatives we get:

∂v˙ b = ∂x

−ωb∧

(RT g)∧

0

(35)

∂χ˙ =
∂x

0 −ωb∧

0

(36)

∂∆˙ =
∂x

R −Rvb∧

0

(37)

for a continuous dynamics linearization of:

∂f  −ωb∧

Ac = ∂x = 

0 R

(RT g)∧ −ωb∧ −Rvb∧

0 0 0

(38)

and for the input vector we have:

∂v˙ b = ∂u

vb∧

gI

(39)

∂χ˙

= I0

(40)

∂u

∂∆˙

= 00

(41)

∂u

 ∂v˙ b 

∂f Wc = ∂x = 

∂u ∂χ˙ ∂u ∂∆˙

.

∂u

(42)

While more sophisticated approximations could be used, we construct the discrete quantities for the ﬁlter f , At, and Wt using Euler integration:

f (xt, ut, 0) = xt + fc(xt, ut, 0)dt

(43)

At = I + Acdt

(44)

Wt = Wcdt.

(45)

We integrate the attitude separately as

Rt+1 = RtR(u∧gyro).

(46)

5.3 Laser Measurement Update
While the EKF is eﬀective for propagating the ﬁrst two moments of the nonlinear dynamics through our IMU equations of motion, it is not well-suited

25

to integrating laser measurements from unstructured 3D environments. Using such sensors directly in an EKF requires the extraction and correspondence of features such as corners, and line segments from the sensor measurements; an error prone process that limits the applicability of the algorithms to environments with speciﬁc structure [23]. In contrast Monte-Carlo techniques are widely used in laser-based localization algorithms because they allow for the LIDAR range measurement model to be used directly in the measurement function [49].
While particle ﬁlters are eﬃcient enough for eﬀective use in localizing a 2D mobile robot, they require too many particles to be used for the estimation of a 3D MAV. Fortunately, we can obtain the best aspects of both algorithms, and a signiﬁcant speedup can be realized by employing a hybrid ﬁlter that uses an IMU-driven EKF process model with pseudo-measurements computed from Gaussian particle ﬁlter (GPF) laser measurement updates [32].

5.3.1 Gaussian Particle Filters

In its standard form, the GPF maintains a Gaussian distribution over the state
space given a measurement history: P (xt|z0:t) = N (xt; µt, Σt). However, at each iteration of the ﬁlter, particles are used to incorporate nonlinear process and measurement models. To compute P (xt+1|z0:t) a set of samples {x(tj)}M j=1 is drawn from N (µt, Σt) and the samples are then propagated through the process model f (xt, ut, wt). To perform the measurement update the samples are weighted according to the measurement model wt(j) = P (zt|x(tj)). The updated Gaussian at the end of an iteration of the ﬁlter is then obtained as the
weighted mean and covariance of the samples

µt+1 = Σt+1 =

M j=1

wt(j)x(tj)

wt(j)

M j=1

wt(j)(x(tj)

−

µt+1)(x(tj)

−

µt+1)T

.

wt(j)

(47) (48)

Assuming the underlying system is linear-Gaussian, the ﬁlter is shown to approximate the true distribution arbitrarily well with a large number of samples. The GPF ﬁlter diﬀers from a standard particle ﬁlter by maintaining a unimodal Gaussian distribution over the posterior state instead of the arbitrary (possibly multi-modal) distribution represented by the set of particles in a conventional particle ﬁlter.
A straightforward implementation of the GPF for state estimation using a LIDAR on a MAV is impractical and ineﬃcient for two reasons:

1. IMU dynamics are well-approximated by linearization as evidenced by the widespread use of EKFs in GPS-IMU state estimation. Thus, a particle process model adds signiﬁcant computational burden and sampling error, without signiﬁcantly improving the estimate of the posterior density.

2. The IMU ﬁlter maintains additional states to track velocity and IMU biases, however the laser measurements are only a function of the position and orientation, parameterized by ∆ and χ in our formulation. In fact, most of the orientation information in the measurement exists in the plane of the LIDAR, corresponding to χz.

26

To address the ﬁrst issue we only use the GPF to perform the measurement update, and instead of propagating samples through the measurement function, we sample directly from the prior distribution returned by the EKF after the process step, N (µ¯, Σ¯ ). To address the second issue we explicitly partition the state according to independence relationships in the measurement function. We perform a standard GPF measurement update on the partitioned state and use the result to compute a pseudo-measurement which is then used to update the full state.

5.3.2 Partitioned State Update

The state is partitioned as

xt = xm t xpt ,

(49)

where xm t ∈ k is the part of the state that aﬀects the measurement, and xpt ∈ n−k is independent from the measurement. As an example of this partitioning, the linear and angular velocities of the vehicle do not aﬀect the ranges measured by the LIDAR sensor. Therefore, these state variables can be considered independent from the measurement. More formally we assume our measurement function has the form

zt = h(xm t , vt),

(50)

permitting the independence factorization

P (zt|xpt , xm) = P (z|xm).

(51)

We can similarly partition the covariance

Σ¯ t =

Σ¯ t(m2) Σ¯ (tpm)

Σ¯ (tmp) Σ¯ t(p2)

.

(52)

To perform the measurement update we draw samples {xm t (j)}M j=1 from N (µ¯m t , Σ¯ m t ). The samples are weighted with the measurement function in equation 51. From these weighted samples we can compute an update for P (xm t |z0:t) using the conventional GPF weighted mean and covariance as in equations 47 and 48. The key idea is to then use the GPF update on the state variables that aﬀect the measurement to propagate a Kalman update to the rest of the state.
To perform a Kalman measurement update we need to know the measurement value zt, the covariance of the measurement R, and the observation matrix C. First, we set C as a selector matrix for the measurement part of the state

C = Ik 0n−k .

(53)

A measurement update on xm would proceed as

Km = Σ¯ m t (Cm)T (CmΣ¯ t(Cm)T + R)−1 µm t = µ¯m t + Km(zt − Cmµ¯m t ) Σm t = (I − KmCm)Σ¯ m t .

(54) (55) (56)

27

Plugging in the identity matrix for Cm, the above equations can be solved for Rt

Σm t = Σ¯ m t − Σ¯ m t (Cm)T (CmΣ¯ t(Cm)T + Rt)−1Σ¯ m t Rt = (Σ¯ tm−1 − Σ¯ m t −1 Σm t Σ¯ m t −1 )−1 − Σ¯ m t
= (Σtm−1 − Σ¯ m t −1 )−1,

(57) (58) (59)

where we make use of the matrix inversion lemma between equations 58 and 59. Using Rt we can now solve for the Kalman gain that would have produced
the same change between our prior and posterior covariance using equation 54 and then recover the actual measurement that would have produced the same change in the mean of prior vs. posterior distributions:

zt = Km−1 (µm t − µ¯m t ) + µ¯m t .

(60)

A Kalman gain for the entire state can then be computed using Rt and zt, and a standard Kalman measurement update performed.
The posterior distribution quantities µm t −1 and Σm t −1 are readily available from the GPF measurement update on the measurement part of the state vector.
Na¨ıvely one might use the Gaussian prior from which the samples were drawn to
evaluate equations 59 and 60. However, the quantities we care about, Rt and zt, are obviously sensitive to the diﬀerence between the prior and posterior mean
and covariance. With a ﬁnite number of samples there will be some error between the distribution described by the sample set {xm t (j)}M j=1 and the Gaussian prior. This error will carry over to the weighted sample set which approximates
the posterior. We can compensate by using the mean and covariance of the prior sample distribution instead of our analytic expressions for µ¯m t and Σ¯ m t . In practice, this substitution makes an enormous diﬀerence, particularly with low
numbers of particles (which is highly desirable in a real-time application). The solutions for Rt and zt hinge on the invertibility of Cm which is a proxy
for the invertibility of our measurement function h in equation 50 with respect to xm t . It can be diﬃcult to know a priori if the measurement is well conditioned or invertible. If it is not (i.e., if the measurement does not actually contain information about some piece of xm t ) then the Rt matrix may not be positivedeﬁnite, leading to a ﬁlter divergence. Thus it is necessary in practice to perform
an eigenvalue decomposition on Rt and set any negative eigenvalues to a large constant (implying no information gain along the corresponding eigenvector)
and then reconstruct the matrix. This step also protects the algorithm from
negative eigenvalues entering through sampling errors.

5.3.3 LIDAR Likelihood Computation
The LIDAR likelihood evaluation proceeds according to standard techniques used in 2D localization. We blur the a 3D occupancy map stored as an OctoMap [52] using a Gaussian kernel around occupied cells. To perform particle measurement updates we project the current scan into the map using the sampled particle state, and sum the log-likelihood of the relevant cells before exponentiating to obtain a probability with which to weight the particles.
An interesting question is the appropriate partitioning of the state vector for the updates described in the previous section. The use of planar LIDARs

28

to localize in the horizontal plane is ubiquitous, suggesting that when working in 3D, laser range scans should at least contain information about x, y and χz (orientation about the yaw axis of the vehicle). In general, a planar slice of a 3D environment may contain some information about the full orientation. However, populating the 6D pose space parameterized by χ and ∆ with particles may produce limited extra information relative to the computational cost incurred, especially because the direct formulation for our ﬁlter based on exponential coordinates is capable of inferring attitude from accurate position measurements. We investigate diﬀerent choices for xm in our experiments in section 5.5.

5.4 Identifying the Process Noise Parameters
Accuracy and precision in state estimation are very important during aggressive ﬂight, since our MAVs ﬂy within centimeters of obstacles and small deviations from the desired trajectory could result in collision. In this section, we investigate a strategy for identifying process noise parameters in order to maximize the performance of our state estimate.
Due to the symmetry of the inertial sensors in the IMU, we assume the process noise covariance Q is a diagonal matrix populated as

Q=

qgyroI3

0

0

qaccelI3

,

(61)

where qaccel and qgyro are the parameters we wish to identify. Two issues make it diﬃcult to ﬁnd these values. First, the way the noise projects onto the state changes with the time-varying Wt matrix such that the Q matrix cannot be recovered in closed form simply by summing the outer product of sampled error. More importantly we cannot depend on the availability of ground-truth measurements of the measured quantities, since even accurate positioning systems do not directly measure acceleration and angular rate. Further, the behavior of the sensor may be diﬀerent under actual ﬂight conditions due to vibration and loading eﬀects and thus the values obtained in a static test may not hold.
Nonetheless it is desirable that the model parameters, and especially the process noise parameters, be accurate. For planning purposes we must be able to predict distributions over future states to guarantee safe trajectories. Within the context of state estimation and Monte-Carlo localization, as we describe in Section 5.3.3, it is important that an accurate covariance of the state estimate be maintained when sensor data is sparse or absent, such that the state estimate can be properly distributed to incorporate measurements when they become available.
While we do not have access to ground-truth acceleration and angular rate with which to estimate the noise parameters, we can post-process data using a Kalman smoothing algorithm to obtain a state history X = [xˆ0, xˆ1, . . . , xˆT ] with the error associated with each smoothed state estimate given by

Γt = E (xˆt − xt)(xˆt − xt)T

(62)

The key idea in our approach is in projecting the process noise forward over multiple time steps such that the process noise dominates the error in the smoothed estimate, thus allowing us to treat the smoothed estimate as ground-truth. This

29

approach works because the IMU process equations are neutrally stable and thus the perturbing noise results in unbounded growth in covariance without position updates. The error on the smoothed estimate (with position updates), on the other hand, must be bounded (even if the smoothing occurs with incorrect noise parameters) since the system is observable. Additionally, by projecting the noise forward over multiple steps, the parameters we identify will be suitable for use in planning algorithms that require open-loop predictions [9] and the parameters will work with intermittent measurement functions as may be the case for laser localization in sparse environments.
Using the linearized dynamics from the EKF we can project the ﬁlter covariance forward N steps by repeatedly applying equations 22 and 23. Neglecting the error on the smoothed estimate, we obtain the expression:

E (xˆt+N − xˆt)(xˆt+N − xˆt))T

N −1

=

Gt+i,N QGTt+i,N

i=0

= Σt,N

(63) (64)

where Gt,N =

t+N −1 j=t+1

Aj

Wt.

This is an important quantity for our noise

identiﬁcation algorithm because it maps the noise at each time step onto the

state vector at time t + N . We can see that for identifying characteristics of the

process noise, At must be neutrally stable and Wt must have full column rank.

If At is highly unstable, the Σt,N will be overly sensitive to the noise values

wi for small i, whereas if At is highly stable, Σt,N will be dominated by larger

values of i and thus the forward projection oﬀers little beneﬁt. However, many

robotic systems, including our IMU dynamics, exhibit approximately neutrally

stable behavior.

For neutrally stable systems, as N gets large we expect Σt >> Γt. We

can then divide up the dataset X to get M = T /N samples from prediction

distributions obtained by subtracting the state at time tend = iN + N − 1 from

the state at time tbegin = iN for i ∈ [0, M − 1]. This gives us M samples

yi = xtend − xtbegin drawn from distributions N (0, Σtbegin,N ) = P (xtend |xtbegin ). We have a joint likelihood function for our data given the parameters of Q as:

M −1

P (Y|x0, Q) =

P (xiN+N−1|xiN , Q).

i=0

(65)

We would like to maximize this probability for which we use the log-likelihood function,

l(Y|x0,

Q)

=

−

1 2

M −1

log

|Σi|

+

yiT

Σiyi.

(66)

i=0

From an intuitive standpoint we are optimizing for the q parameters that would produce the observed drift away from the smoothed estimate given by the samples yi.
We setup and solve the optimization using standard nonlinear programming techniques. Speciﬁcally we use the interior point method implemented in MATLAB to solve for the maximum likelihood values of qgyro and qaccel. These new values are then used to obtain the Kalman smoothed trajectory, and the process is repeated until convergence.

30

Source Vicon Optimization GPS Optimization Manufacturer

Gyro Noise (degrees/s) 0.35 0.34 0.2

Accelerometer Noise (g) 0.0042 0.0182 0.005

Table 4: Noise parameter values.

Orientation Error 4

3

Degrees

2

1

0

0

5

10

15

20

Time (s)

Position Error 40

vicon

30

vicon−predicted

gps

20

gps−predicted

Meters

10

0

0

5

10

15

20

Time (s)

Figure 9: This ﬁgure shows the predicted normed error and the actual normed deviation from the smoothed estimates as a function of look-ahead time for the optimization run on both the Vicon and GPS datasets. With the optimized values we can accurately predict uncertainty for both estimation and planning purposes.

To identify the noise parameters of the IMU we ﬂew our experimental vehicle (described in Section 7.4) outdoors with a low cost uBlox GPS unit. We also collected a dataset in a high accuracy Vicon indoor motion capture system. Optimized noise parameters for a look-ahead time of 20 seconds are shown in Table 4 with the manufacturer speciﬁed values for comparison.
The optimization on the Vicon dataset converges quickly and consistently. However, when the optimization is performed on the GPS dataset the optimization is more sensitive to initial conditions and window size. The Vicon system measures attitude directly, thus the smoothed attitude estimate is dominated by the actual measurement. With the GPS dataset, attitude must be inferred from position updates which means the attitude estimate will be more strongly correlated with the IMU noise, thus making it more diﬃcult ﬁnd the underlying noise parameter. Additionally, the GPS measurements are subject to timevarying bias which is not modeled in our ﬁlter. Nonetheless, the optimization for Vicon and GPS converge to nearly identical values for the gyro noise at at 20 second window. The relative sensitivity to the window size for the GPS optimization can be seen in Figure 10.
The noise parameters in Table 4 were used to generate the predicted error

31

q gyro (deg/s)

Optimal IMU Noise Parameters vs. Lookahead Time

0.4

0.2

vicon

gps

0

0

5

10

15

20

q accel (g)

0.02

0.01

0

0

5

10

15

20

Optimization Lookahead time (seconds)

Figure 10: This ﬁgure shows values for qgyro and qaccel obtained by optimizing equation 66 for diﬀerent look-ahead times (values of N scaled by sampling frequency) for both GPS and Vicon. For small time the optimal noise parameters obtained with GPS are dominated by the error in the smoothed estimates, Γt, but we see for large N consistent values are reached. The Vicon dataset is less susceptible to this issue. It is interesting to note that as look-ahead time increases fewer “samples” are available from a dataset of ﬁxed size, and thus the computed noise values have higher variance, implying some optimal look-ahead window to identify the parameters.

lines in Figure 9. We can see that the predicted error for GPS and Vicon are very close for orientation as we would expect from the tabular values. In position, the deviation is also small, which is surprising given the large diﬀerence in optimized accelerometer noise values. The reason for this observation is that the position uncertainty is largely a function of angular uncertainty resulting in the gravity vector being misinterpreted as lateral acceleration. This highlights another diﬃculty in separating the relative eﬀects of the noise parameters during aggressive ﬂight.

5.5 State Estimation Experimental Results
For each experimental test of our state estimation algorithm, we ﬁrst collect a 3D map of the test environment using a pair of planar LIDARs mounted orthogonally on a wheeled tripod. We push the tripod around manually to obtain laser scans from every region of the environment. Then we run a SLAM algorithm to estimate the poses of the horizontal LIDAR, and project the corresponding scans from the vertically-mounted LIDAR to ﬁll out the 3D map. This procedure takes several minutes and is the only preparation needed to run our estimation algorithm in a new environment.
We conducted a number of manually ﬂown ﬂight tests in the indoor environment shown in Figure 11(a). The accuracy of our state estimates are validated qualitatively by looking at the accurate reconstruction of the 3D environment by re-projecting the laser points using our state estimates. One such 3D point cloud is shown in Figure 11(b). A video of these experiments is available at: http://groups.csail.mit.edu/rrg/icra12-agile-flight.
To quantify the error of the state estimator, we aggressively maneuvered the

32

(a)

(b)

Figure 11: A picture of the indoor space (a) where we ﬂew our ﬁxed-wing vehicle. The space is roughly 12 meters by 20 meters and our vehicle ﬂies between 6 and 10 m/s, thus aggressive maneuvering and tight turning is required to stay airborne. The trajectory ﬂown by the vehicle is shown by the red, green, and blue axes in (b). The quality of the state estimates is evident in the (height colored) point cloud rendered using the state estimates of our algorithm. The ﬂoor and ceiling were cropped for visual clarity.

Fraction Diverged Mean Velocity Error (m/s)

1.0 0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1 0.0
101

102

103

Number of Particles

(a)

∆ ∆, χz ∆,χ x
104

0.148 0.146 0.144 0.142
0.14 0.138 0.136 0.134 0.132
0.13 0.128
101

∆ ∆, χz
∆,χ x

102

103

104

Number of Particles

(b)

Figure 12: This ﬁgure shows the percentage of trials where the ﬁlter diverged (a) and the mean velocity error verses the number of particles used in the GPF (b) for diﬀerent state partitions in the measurement. As expected, the more states we use in the measurement function the more particles are required to obtain satisfactory estimates. In a na¨ıve implementation where the full state is used in the measurement and thus a standard GPF update performed, we require 2000 particles to get similar performance to a measurement update in ∆ using only 100 particles. Thus our algorithm yields an eﬀective 20x speedup.

33

sensors in a Vicon motion capture environment. While the motion of the sensors will certainly be very diﬀerent when the vehicle is ﬂying, the data allows us to evaluate our algorithms with a ground-truth comparison. These ground-truth state estimates allow us to evaluate the properties of our state estimation algorithm. Results for diﬀerent numbers of particles and diﬀerent partitions of the state vector are summarized in Figure 12. We can see that by not partitioning the state and performing standard GPF updates we incur signiﬁcant computational cost in terms of number of particles needed to achieve the same level of accuracy. This increase in the number of particles is to be expected given that we are using particles to capture the same correlations that are well captured analytically by the Kalman pseudo-measurement update.
The experiments demonstrate the ability of our algorithm to maintain accurate state estimates during fast motion, with linear velocities up to 11 m/s, and angular rates of up to 360 degrees per second. Furthermore, during the closedloop ﬂight tests described in Sections 6.1 and 7.5, our algorithm provided a consistently accurate state estimate and never diverged. While a na¨ıve implementation of the GPF measurement update correctly estimates the state of the vehicle with a suﬃcient number of particles, the required number of particles is dramatically larger than for the partitioned state version. The na¨ıve GPF implementation would not be able to run in real time onboard the vehicle given the computation power available.
6 Quadrotor Trajectory Planning and Experimental Results
In Section 4, we developed a procedure for eﬃciently computing polynomial trajectories. In this section, we apply this procedure to solve the planning problem for quadrotors. As is common in the literature, we model the quadrotor as a rigid body. We assume that certain higher-order eﬀects such as aerodynamic drag are negligible for our purposes. The equations governing the motion of a rigid body were given in the context of state estimation (26-29). In the case of a multi-copter helicopter, we exert moments by commanding diﬀerent thrusts from opposing rotors. In a simpliﬁed representation of a conventional helicopter, we can exert a moment on the body through the use of the cyclic control. In either case, we assume that our low-level inputs can be selected in order to achieve the desired roll, pitch, and yaw moments comprising the τb vector. The major restriction we must make is that the net thrust of a helicopter is always aligned with the rotor axis of rotation. Therefore, we can replace ab in equation (27) with (f /m)bz, where f is the scalar sum of thrusts provided by the rotors and m is the vehicle mass. This set of equations has been used in the literature to describe the simpliﬁed dynamics of quadrotors [36] and conventional helicopters [31, 17].
After restricting the direction of thrust to align with the bz-direction, these equations have been shown to be diﬀerentially ﬂat in reference to quadrotors. Mellinger and Kumar provide a detailed description of the mapping from the states and inputs of the vehicle to the ﬂat output space, which we will not repeat here [38]. We follow Mellinger and Kumar in expressing a quadrotor trajectory segment as a set of four independent polynomials that describe the evolution
34

of the four ﬂat output variables through time, namely positions ∆x(t), ∆y(t), ∆z(t), and the yaw angle ψ(t).
The nonlinear controller employed to follow diﬀerentiable trajectories was developed in [36], and includes the methods of computing desired orientations and angular velocities from ∆(t) and ψ(t) and their derivatives. In the following equations we use the subscript d to refer to the desired position (∆d), orientation (Rd), and angular velocity (ωd) as speciﬁed by the trajectory.

f =(−kpep − kded + mgwz + m∆¨ d) · bz

(67)

τb = − kReR − kωeω + ωb × Jωb − J(ωb∧RT Rdωd − RT Rdω˙ d)

(68)

where ep, ed, eR, and eω are the error vectors in position, velocity, orientation and angular velocity, and kp, kd, kR, and kω are associated control gains. The mass of the vehicle is m.
These equations include a combination of feed-forward terms, representing the open-loop commands that would be needed to execute a given trajectory in the absence of disturbances, and feedback commands that stabilize the vehicle during its execution of the trajectory. Since the desired trajectory and its derivatives are suﬃcient to compute the states and control inputs at every point along the path in closed form (equations 67-68), these quantities eﬀectively serve as a simulation of the vehicle’s motion in the absence of disturbances. This is the powerful capability enabled by diﬀerential ﬂatness and the chosen trajectory parameterization that eliminates the need for iterated numerical integration of equations of motion, or a search over the space of inputs during planning.

6.1 Quadrotor Experimental Flight Results
We tested the performance of our quadrotor trajectory planning strategy on challenging real-world planning problems by planning and ﬂying trajectories through complex indoor lab spaces in the MIT Stata Center. The environment used for these tests has curved non-vertical walls, interior columns, barriers aligned at oblique angles and hanging lights, representing a challenging arrangement of obstacles for our planning algorithm. Interestingly, the complexity of the environment and density of obstacles actually makes localization easier due to the unique pattern of objects in each laser scan as compared to a large empty environment. An OctoMap representation of the lab was generated using a pair of planar laser range ﬁnders and each occupied cell was dilated with a radius of 0.65 m to leave room for the 0.35 m radius of the vehicle and a minimal allowance for error in estimation and control. Table 5 gives tracking errors of the controller incurred during experiments. These errors are suﬃciently small to navigate within one vehicle-width of obstacles, which was required during signiﬁcant portions of both trajectories.
The trajectories returned by our algorithm are shown in Figure 13, and they both exhibit approximately 2 m of altitude variation in order to ﬂy through doorways and navigate over tall shelves and dividing walls. These trajectories were generated in several seconds on a ground-based Intel Core 2 Duo laptop for the purposes of visualization prior to execution, however the planning procedure is eﬃcient enough to run easily on currently available small form-factor computers that could be carried onboard a quadrotor. The quadrotor used for these

35

(a)

(b)

Figure 13: Automatically generated trajectories navigating atrium (a) and laboratory (b) environments in the MIT Stata Center at up to 8 m/s. Due to the tight spacing of obstacles, these environments are particularly challenging for motion planning of high-speed vehicles.

Environment Mean Position Error (m) Mean Velocity Error (m/s)

Atrium

0.3631

0.3363

Laboratory

0.3054

0.2717

Table 5: Position and velocity tracking errors incurred during execution of the quadrotor trajectories through an atrium 13(a) and a laboratory 13(b). Since we do not have access to ground-truth state estimation, our tracking errors are reported with respect to the onboard state estimate.

experiments was an Asctec Pelican, equipped with a Hokuyo UTM-30LX laser rangeﬁnder, a Microstrain 3DM-GX3-25 IMU, and a 2.0GHz Intel Atom based ﬂight computer. Figure 14 shows onboard video frames taken while executing these trajectories at speeds up to 8 m/s. Video of these trajectories and ﬂights is available at: http://groups.csail.mit.edu/rrg/quad_polynomial_trajectory_ planning.

36

(a)

(b)

Figure 14: Onboard video frames from aggressive quadrotor ﬂight up to 8 m/s.

7 Fixed-Wing Trajectory Planning and Experi-
mental Results
In Section 4, we saw how it was possible to eﬃciently plan polynomial trajectories for systems in which the three position coordinates can be controlled independently. For example, a quadrotor can modulate its pitch angle to generate motions forward and backward, while simultaneously modulating roll to move left or right and adjusting the total thrust to move up and down. In these cases, a suitable trajectory representation is to describe the motion of each ﬂat output with its own polynomial trajectory.
In principle, we could also use this trajectory representation to describe the motions of a ﬁxed-wing aircraft. As we will see in this section, the diﬀerentially ﬂat model for the ﬁxed-wing vehicle uses the three components of its global position vector as the ﬂat outputs. However, the key diﬀerence between this model and the quadrotor model is that the ﬁxed-wing cannot independently control these three position coordinates. Rather, its motions are characterized as Dubins-type motions, which means qualitatively that it is capable of traveling along trajectories consisting of lines and arcs of bounded curvature, but cannot translate sideways or vertically like a quadrotor. Therefore, describing the motion of the three position coordinates using independent polynomials is not ideal for this type of system.
Instead, we will develop a special trajectory formulation for ﬁxed-wing aircraft and vehicles with similar maneuvering capabilities, called Dubins-Polynomial trajectories. These trajectories are deﬁned as a sequence of straight lines and arcs of constant curvature, combined with a piecewise-polynomial transverse oﬀset from those underlying arcs. The transverse dynamics of the ﬁxed-wing aircraft correspond roughly to roll maneuvers, so we can now use polynomial optimization to minimize quantities of interest like roll rate and roll acceleration, which are important for generating graceful trajectories. We will ﬁrst describe the vehicle model, then develop this Dubins-Polynomial trajectory formulation, and ﬁnally we will describe simulation and experimental results for the ﬁxed-wing platform.

37

7.1 Fixed-Wing Coordinated Flight Model
The planning and control algorithms for the ﬁxed-wing vehicle are based on a coordinated ﬂight model due to Hauser and Hindman [21]. In order to plan trajectories for ﬁxed-wing aircraft, we must understand its dynamic capabilities and the ﬂat output space associated with its diﬀerentially ﬂat representation.
Coordinated ﬂight is deﬁned as a ﬂight condition in which the body velocity of the vehicle is contained within the longitudinal plane, hence vby = 0, where vby is the component of velocity directed along the by axis aligned with the axis of the wing. The equations of motion for the coordinated ﬂight model are expressed in the velocity frame, which diﬀers from the body frame by the angle of attack of the vehicle (assuming the vehicle is in a state of coordinated ﬂight). The orientation of the velocity frame is given by the rotation matrix Rv. The unit vector of the ﬁrst column aligns with the velocity such that vvy = vvz = 0. To map velocity and acceleration back into the world frame, we have ∆˙ = Rvvv and ∆¨ = g + Rvav.
To maintain coordinated ﬂight, the second and third components of angular velocity (pitch and yaw rates) are constrained to be:

ωvy = −(avz + gvz )/V ωvz = gv2 /V,

(69) (70)

where V = ||∆˙ || and gvy and gvz represent the components of the gravity vector projected along the vy and vz directions, respectively.
In these equations, av is the acceleration of the body expressed in the velocity frame. Components avx and avz represent the axial and normal accelerations of the vehicle, which are determined by the forward thrust of the propellers and the lift force provided by the wing. In the diﬀerentially ﬂat model, derivatives of these quantities will serve as two of the inputs to the system.
A system is diﬀerentially ﬂat if the inputs and states can be written as functions of the outputs and their derivatives. The coordinated ﬂight model is diﬀerentially ﬂat with inputs (ωvx , a˙ vx , a˙ vz ) and outputs ∆. The mapping is:

 a˙ vx   −ωvy avz   1

 ωvx  =  ωvz avx /avz  +  0

a˙ vz

ωvy avx

0

0
−1/avz 0

0 0





RT

... ∆

1

(71)

Equation (71) is powerful, in that it gives the necessary inputs for the simpliﬁed coordinated ﬂight model to achieve an arbitrary third derivative on the position of the airplane.
The diﬀerentially ﬂat representation also provides a direct method for stabilizing a desired path. Since the model allows us to command the third spatial derivative of the vehicle we can simply write the desired third derivative as the open loop derivative of the path plus feedback on deviation from the path and deviation derivatives (equation (8), [21]):

... ∆

=

.ρ..

+

k2e¨

+

k1e˙

+

k0e

(72)

where ρ(t) is the path to be followed, e(t) = ρ(t) − ∆(t), and k0, k1 and k2 are feedback gains. The disadvantage of this approach is that the aircraft will modulate tangential acceleration (thrust) to correct axial errors along the path

38

(i.e., if the vehicle gets ahead or behind its target point). However, ﬁxed-wing aircraft are designed for a small range of safe cruising velocities and it is often assumed that the thrust will be ﬁxed to maintain a particular safe airspeed. In the worst case, if the aircraft slowed down too aggressively to track a reference state, it could lose the necessary lift to stay aloft or otherwise exit the safe operating envelope.
Therefore, we opt for an alternative strategy, which is to alter the state representation to include a path parameter s(3) in place of a˙ vx , which will be integrated along with the rest of the state. Following equation (11) in [21] we have:

 s(3)   avz ωvy + a˙ vx 

M  ωvx  =  avx ωvz 

a˙ vz

−avx ωvy

− RT 3ρ (s)s¨s˙ + ρ (s)s˙3 + k2e¨ + k1e˙ + k0e ,

(73)

where,

 ...

 00

M

=

 

RT ρ (s)

avz

0

 

(74)

 ...

 0 −1

Introduction of the path parameter s enables dynamic inversion of the tra-

jectory when the throttle is eﬀectively ﬁxed, which would be impossible without

it. In our formulation s is the metric distance along the path so s˙ can be initial-

ized as the ﬂight speed entering the path. The only restriction on this control

law is that M be invertible, which requires that the ﬁrst column of Rv ∝ ∆˙

not be desired

orthogonal to ρ . Intuitively, path, no control authority on

if the plane is ﬂying the error dynamics is

paevrapileanbdleictuhlarorutgoht.hs..e.

The singularity in M is also not of practical concern so long as the controller is

initialized from reasonable conditions. In Appendix B, we show how to translate

the variables of the diﬀerentially ﬂat model into control surface deﬂections for

the low-level controller onboard the aircraft.

7.2 Dubins-Polynomial Trajectory Representation for FixedWing Aircraft
In the preceding discussion of the diﬀerentially ﬂat ﬁxed-wing representation, we have seen how it is possible to obtain the necessary inputs to the vehicle directly from the third derivative of the desired position trajectory. The next challenge is to deﬁne a trajectory representation that is capable of expressing paths that we would like our aircraft to follow. Additionally, this representation should be diﬀerentiable so that we can easily compute the quantities needed to perform control. Finally, we would like the trajectory representation to enforce continuity of derivatives up to third order so that the resulting motions of the aircraft will be smooth, and in particular, have continuous roll rate.
Except for takeoﬀ and landing maneuvers, we restrict the motion of the vehicle to the horizontal plane at constant altitude and ﬁxed speed. For planning purposes we wish to be able to generate trajectories from an initial position, (∆x, ∆y), yaw angle (ψ), roll angle (φ), and roll rate (φ˙), to a ﬁnal conﬁguration of those variables.

39

Trajectory generation must primarily be concerned with roll dynamics as the pitch is eﬀectively constrained to stay in the plane, the rudder is constrained to maintain coordinated ﬂight, and the throttle is constrained to maintain constant speed. For the case of constant speed planar motion,

φ = tan−1 V 2κ ,

(75)

g

is a special case of equation 71, where κ is the curvature of the path (inverse radius, positive turning to the left or counterclockwise (CCW)).
The most commonly used approach for planar path planning for ﬁxed-wing vehicles is to use Dubins curves [34]. Dubins curves represent the optimal (shortest distance) path between two position and orientation, (∆x, ∆y, ψ), conﬁgurations respecting a minimum turning radius. The path between any two conﬁgurations will be made up of three path segments consisting of either arcs (of the minimum turning radius) or straight lines, belonging to six possible “words,” LSL, RSR, RSL, LSR, RLR, LRL, where L is a left turning arc, R is a right turning arc, and S is a straight line. The parameters of the segments (center, entry and exit angles for an arc, and start and end point for a line) can be directly determined from the geometry of the start and end conﬁgurations for each feasible word for a given conﬁguration, and then the shortest word is selected. It is also possible to analytically determine which word will be shortest based on an algebraic partitioning of SE(2), but for implementation simplicity we use the former method.
Since Dubins curves are composed of tangent lines and arcs, the curves are smooth in the sense that a vehicle following the path will have continuous yaw angle, but the curvature is discontinuous. We can see from equation 75 that discontinuity in curvature will translate to discontinuity in roll angle. This is clearly kinodynamically infeasible for a ﬁxed-wing vehicle. Clothoid arc paths are an extension of Dubins paths with clothoid arc segments stitching the lines and arc segments together to maintain continuous curvature (roll angle) [34]. However, clothoid paths would still be discontinuous in roll rate. By diﬀerentiating equation 75, we can see that roll rate φ˙ is proportional to the derivative of curvature. Therefore, if we consider the roll angle to be a second order system with aileron input ([42]), then a trajectory must maintain continuity up to the derivative of curvature to be kinodynamically feasible. Furthermore, we can minimize roll rates and roll accelerations by penalizing the ﬁrst and second derivatives of curvature of the trajectory.
A quadrotor is capable of rolling about any axis in the body’s horizontal plane and thus minimizing the snap or 4th derivative of independent splines in three dimensions will minimize abrupt changes in control inputs needed to follow the path. For a ﬁxed-wing vehicle, however, the picture is substantially more complicated. The axis of roll motion rotates with the heading of the vehicle and the vehicle must turn with a ﬁnite radius, all while traveling at a nearly constant speed. This makes the independent-axes spline representation inapplicable.
To meet the needs of a dynamically feasible ﬁxed-wing trajectory, we deﬁne a “Dubins-Polynomial” trajectory as a Dubins curve combined with a transverse polynomial oﬀset from that Dubins curve. The key idea behind the DubinsPolynomial formulation is that by parameterizing a lateral oﬀset from a nominal path, we isolate the roll dynamics of interest for steering a ﬁxed-wing aircraft.

40

Transverse Offset (m)

30

0

−1

25

−2

−3

20

0

0.2 0.4 0.6 0.8

1

Normalized Path Coordinate (τ)

0.5

15 0

Offset Second Derivative Offset Derivative

Y−position (m)

10

−0.5

0

0.2 0.4 0.6 0.8

1

Normalized Path Coordinate (τ) 0.2

5

0

0

0

5

10

15

X−position (m)

−0.2

0

0.2 0.4 0.6 0.8

1

Normalized Path Coordinate (τ)

Figure 15: Example trajectory for a ﬁxed-wing aircraft. The underlying Dubins curve (LSL) is illustrated in black in the left panel. The three polynomial segments representing the transverse oﬀset from this Dubins curve are illustrated in red, green and blue. These polynomial segments are also illustrated with their ﬁrst and second derivatives in the right panel. Note the intentional discontinuity in the second derivative, which corrects for the change in curvature between the circular arcs and the straight line segment.

An example Dubins-Polynomial trajectory is illustrated in Figure 15. The sequence of polynomials is illustrated in red, green and blue. In this ﬁgure, the red arc is oﬀset from the ﬁrst curve, which is a left turn with an 8 m radius. The green arc is an oﬀset from the middle segment, which is a straight line. Finally, the blue arc is an oﬀset from the third segment, which is another left turn with 8 m radius.
The polynomials themselves are illustrated on the right side of Figure 15. Notice that the oﬀset and its ﬁrst derivative are constrained to be zero at the start and end of this trajectory. The second derivative, which corresponds to curvature, is constrained to have a value equal to the curvature of the underlying Dubins segment at the beginning and end of the trajectory. In this example, the initial and ﬁnal curvatures are equal to 0.125 m−1, corresponding to the 8 m radius.
Since the curvature of the underlying Dubins curve changes from 0.125 m−1 to 0 m−1 at the intersection between the circular arcs and the straight line, we must enforce an oﬀset in the second derivatives of the polynomials at these junctions. These oﬀsets are seen in the second derivative plot in the bottom-right of Figure 15. These oﬀsets correct for the discontinuities in curvature between segments of the underlying Dubins curve. Note that the spatial locations of the intermediate junctions between polynomial segments, as well as higher derivatives, are not speciﬁed directly. Rather they are optimized according to a cost function.

41

7.2.1 Procedure for Generating Fixed-Wing Trajectories
The optimization method described in Section 4.2 is capable of jointly optimizing polynomial segments subject to oﬀset constraints on their derivatives where two segments meet. While the idea of jointly optimizing polynomial segments is straightforward, the expressions for the transverse derivatives of a polynomial oﬀset are rather complex. In Sections 7.2.2 and 7.2.3 we develop the necessary expressions. As seen in these expressions, the transverse derivatives of the resulting spatial curve are nonlinear functions of the polynomial derivatives. Therefore, the initial joint optimization will, in general, be an approximation that must be corrected to ensure true continuity of derivatives. The approximation lies in the fact that we are using linear constraints in our quadratic program to enforce continuity of polynomials, when in fact the derivatives we actually want to constrain (the derivatives of the trajectory through space) are nonlinear functions of those polynomials.
The overall strategy is to ﬁrst generate the underlying Dubins curve based on initial and ﬁnal points, (∆x, ∆y, ψ)0 and (∆x, ∆y, ψ)1. Then, we solve for the piecewise-polynomial transverse oﬀset using the joint optimization method outlined in Section 4.2.1, with speciﬁed boundary constraints, (κ, κ˙ , κ¨)0 and (κ, κ˙ , κ¨)1. These boundary constraints on curvature correspond to endpoint constraints on the the second, third and fourth derivatives of the polynomial. For the purpose of achieving derivative continuity between Dubins curve segments, all the elements of σi in equation (12) are set to zero except for the second derivative, which is set to the curvature diﬀerence between the preceding and following segments. As illustrated in Figure 15, this oﬀset corrects for the underlying curvature diﬀerence between the arc segments and straight line segments.
We have now optimized a polynomial, however as stated above, the transverse derivatives of the resulting spatial curve that we actually wish to constrain are nonlinear functions of the polynomial derivatives. Therefore, we must repair our polynomial solution to obtain a trajectory whose transverse derivatives are in fact continuous. In order to do so, we compute “true” transverse derivative values at each junction by taking the average of the transverse derivatives for the preceding and following segment at that junction. These transverse derivatives are derived below, and are given in equations 88-90 (or 98-100 for a line).
The purpose of computing an average at each junction is so that the preceding and following segments can be re-optimized individually, using that set of average derivatives as boundary conditions. Thus, the resulting sequence of individually optimized polynomials will have truly continuous transverse derivatives. To accomplish this goal, we invert the transverse derivatives using equations 91-93 (101-103) to obtain polynomial boundary conditions for each segment. Finally, we perform individual optimizations for each segment using the procedure given in Section 4.2. In the next two sections we develop the necessary equations to compute these transverse derivatives.
7.2.2 Polar Coordinates Corrections
The polynomial oﬀset from a circular arc in a Dubins curve is eﬀectively a polynomial in polar coordinates, expressed as R(θ) = R0 ± P (θ), where the sign of addition depends on whether the arc is CCW (-) or CW (+). R0 is the
42

nominal radius of the underlying circular arc, P (θ) is the polynomial oﬀset from
the circular arc, and θ is the parameter indicating position along the arc. In this section we will use unit vectors rˆ and θˆ, denoting the radial and
angular directions, respectively. Note that θˆ may be CCW-positive or CW-
positive depending on the intrinsic arc direction, in contrast to conventional CCW-only use. The parameter θ sweeps positive in the θˆ direction. When used in a standard coordinate system rˆ(θ) = cos(θ)wx + sin(θ)wy and θˆ(θ) = − sin(θ)wx + cos(θ)wy for a CCW arc and θˆ(θ) = sin(θ)wx − cos(θ)wy for a
CW arc.
To analyze the true derivatives of the trajectory in polar coordinates, we use the arc path ρ in the rˆ direction. Using the identities rˆ (θ) = θˆ(θ) and θˆ (θ) = −rˆ(θ) we obtain

ρ(θ) = R(θ)rˆ(θ)

(76)

ρ (θ) = P (θ)rˆ(θ) + R(θ)θˆ(θ)

(77)

ρ (θ) = (P (θ) − R(θ))rˆ(θ) + 2P (θ)θˆ(θ)

(78)

ρ (θ) = (P (θ) − 3P (θ))rˆ(θ) + (3P (θ) − R(θ))θˆ(θ),

(79)

for the ﬁrst three derivatives. To generate smooth paths we would like to parameterize in terms of the
metric distance along the path as opposed to the angle swept out by the arc. To accomplish this we write θ as a function of the distance s to get the arc as ρ(θ(s)) and take the derivatives with respect to the distance.

dρ(θ(s))

= ρ(θ(s)) θ (s)

(80)

ds

d2ρ(θ(s)) ds2

=ρ

(θ(s))θ (s)2 + ρ (θ(s))θ

(s)

(81)

d3ρ(θ(s)) ds3 = ρ

(θ(s))θ (s)3 + 3ρ (θ(s))θ (s)θ (s) + ρ (θ(s))θ

(s).

(82)

To enforce that s is the distance along the path we use the constraint:

||ρ (θ(s))|| = 1 = θ (s) P (θ(s))2 + (R(θ(s)))2,

(83)

which yields the relationship:

1

θ (s) =

,

(84)

P (θ(s))2 + (R(θ(s)))2

which can then be diﬀerentiated for use in the full path derivative expressions:

1

θ=

(85)

L

P (P + R)

θ =−

L4

(86)

L2(P (P + R) + P (P + P )) − 4P 2(P + R)2

θ =−

L7

. (87)

43

√ For convenience we deﬁne L = P 2 + R2 and omit the argument θ for compactness in the expressions. Equations 77 - 79 and 85-87 can then be plugged into 80-82 to obtain expressions for the true path derivatives in the rˆ direction:

rˆT dρ(θ(s)) = √ P

(88)

ds

P 2 + R2

rˆT

d2ρ(θ) ds2

=

P

1 P2

R P 2R

L2 − L4 − L2 − L4

(89)

rˆT

d3ρ(θ(s)) ds3

=

P

− 3P L3

P (P − R)2

−3

L5

P 2+P R+P P +P 2

4P 2(P + R)2 , (90)

−P

L5

−

L7

and similar expressions can be obtained in the θˆ direction (or the numerical values substituted directly). To complete the optimization we also need the expressions solved for the ﬁrst three polynomial derivatives:

P=

RrˆT

dρ(θ(s)) ds

1−

rˆT

dρ(θ(s)) ds

2

P

=

rˆT

d2 ρ(θ) ds2

+

R L2

+

− 1

P2

L2

L4

P 2R L4

P

=

L3rˆT

d3ρ(θ(s)) ds3

+

3P

P (P − R)2

+3

L2

P 2 + P R + P P + P 2 4P 2(P

+ R)2

.

+P

L2

−

L4

(91) (92) (93)

7.2.3 Line Segment Corrections

For the line segments in a Dubins path similar analysis applies. Using the same ρ notation with rˆ perpendicular to the left of the line segment and θˆ aligned
with the line segment, and θ the linear distance along the segment, we have:

ρ(θ) = P (θ)rˆ + θθˆ

(94)

ρ (θ) = P (θ)rˆ + θˆ

(95)

ρ (θ) = P (θ)rˆ

(96)

ρ (θ) = P (θ)rˆ.

(97)

Following the same procedure as for arc segments we obtain:

rˆT dρ(θ(s)) = √ P

ds

P 2+1

rˆT

d2ρ(θ) ds2

=

P L2

−

P 2P L4

rˆT

d3ρ(θ(s)) ds3

=

P L3

PP − 3 L5

2
−P

L2(P

2+P

P ) − 4P 2P L7

2
,

(98) (99) (100)

44

and solved for the polynomial derivatives:

P=

rˆT

dρ(θ(s)) ds

1−

rˆT

dρ(θ(s)) ds

2

P

=

L2rˆT

d2ρ(θ) ds2

+

P 2P L2

P

=

L3rˆT

d3ρ(θ(s)) ds3

+

P 3

P L2

2
+P

L2(P

2+P

P ) + 4P 2P L4

2
.

(101)
(102) (103)

7.2.4 Example Dubins-Polynomial Paths

(a) 30

20

10

0 −20 −10

25

20

15

10

5

0

−10

0

0

10 20

(c)

10

20

(b)

10

5

0

0

5

10 15

(d) 0

−5

−10

−15

−20

−25

0

10

20

Figure 16: This ﬁgure shows Dubins-Polynomial paths for various conﬁgurations. The blue line in the transverse polynomial path and the black line is the Dubins path from which it is oﬀset. For each of these examples, the curvature is constrained to be 0 at the start and end of the path. We can see that generally the optimization yields paths that distribute the shifts in curvature across the Dubins segment junctions (denoted with black stars), reducing the need for abrupt changes in roll angle and roll rate.

It is important to note that the polynomials used in equations 91-93 and 88-90 are in terms of the arc angle θ and thus the polynomials obtained must be rescaled by the arc radius as appropriate to be consistent in cost units between arc and line segments. To verify the correctness of our ex..p. ressions for derivatives, we numerically integrated the third path derivative (∆) for example paths and conﬁrmed that the numerical integration converged exactly to the example path as discretization was reﬁned. Example curves for various conﬁgurations are shown in Figure 16.

7.2.5 Limitations of Dubins-Polynomial Trajectories
To the extent that P is small in the case of line segments and P and P are small in the case of arc segments (since change in P changes the radius and

45

thus introduces Coriolis and other higher order polar eﬀects), the polynomial optimization directly optimizes the curvature derivative (3rd polynomial derivative), and second curvature derivative (4th polynomial derivative). However, we can see from the correction equations in Sections 7.2.2 and 7.2.3 that the approximation breaks down for P and P far from zero. If the nominal path from which the oﬀset is speciﬁed is chosen sensibly, this problem can be mitigated. The optimization also allows for cost on P and P to penalize too much deviation from the nominal path and thus maintain the ﬁdelity of the higher order derivatives. Further, even if the optimization is an approximation, the correction step ensures derivative continuity at segment junctions.
If the cost on curvature derivatives is high and the radius used in the Dubins paths too small, the optimization may occasionally yield arc segments with negative radius. When this occurs, the path must either be discarded or the cost on P increased until a positive radius is achieved. Potential locations of radius violations may be obtained using polynomial root ﬁnding algorithms.
7.3 Fixed-Wing Simulation Results
To validate our trajectory generation and control methodologies we used the physics engine from the open source CRRCsim ﬂight simulator [1]. The simulator takes as input aerodynamic derivatives computed with a model of our ﬁxed-wing aircraft in AVL, an open source extended vortex lattice aerodynamic analysis program [13].
We sampled 1000 random conﬁgurations and used them to generate Dubins paths, transverse polynomial paths enforcing 3rd order continuity, and transverse polynomial paths enforcing 4th order continuity. The nominal paths were then simulated with the full nonlinear model. The planning radius used in the Dubins curves was R0 = 8 m with a desired ﬂight velocity of 7 m/s which places the vehicle close to it’s dynamic limit. Polynomials of order N = 10 were used with cost of the zeroth-fourth derivatives, c = 0.3 1 0 50 1 , and all other cost terms set to zero. The paths were sampled in a 40 m square so they usually involve sequential turns without extended straight sequences. The samples were used to plan: Dubins paths, transverse polynomial paths up to 3rd order continuity, and transverse polynomial paths up to 4th order continuity. For computation time comparison we also include the full simulated model. Using a full model-based method to compute feasible trajectories would have computational cost on this order, as the full dynamics are simulated forward.
If the simulated vehicle deviated by more than 10 m from the planned path, the case was marked as a failure and discarded. These samples were used to generate the results shown in Table 6. We can see that for these conditions the pure Dubins curves fail more than 19% of the time. Additionally the average normed tracking error is more than double what it is for both of the transverse polynomial paths. Interestingly, fourth order continuity paths have slightly higher normed error with slightly lower failure rate. The failure cases of the transverse polynomial paths are likely due to rare cases of poor geometries leading to infeasible trajectories in the optimization which could be discarded with dynamic constraint checking. The higher normed error for the fourth order paths probably indicates that within the ﬁdelity of our ﬁt control mappings, the continuity in roll rate is not important. However, the optimization still minimizes roll acceleration eﬀort, which clearly increases the feasibility of the
46

Path Type Dubins
3rd Order 4th Order Full Model

Error Norm (m) 1.60 0.67 0.75 -

Fraction Failed 0.194 0.006 0.003 -

Computation Time (µs) 20.0 495.7 516.6
10609.3

Table 6: This table shows path-following error, fraction of simulations diverged, and computation time for a path for Dubins curves, transverse-polynomial curves enforcing continuity up to 3rd and 4th order, and a full simulation of the nonlinear model.

paths compared to the fully discontinuous Dubins case. The computation time of the transverse polynomial paths is dominated by
the matrix inversion of the piecewise polynomial QP. While it is substantially slower than the Dubins calculation alone, it is still more than 20 times faster than a single simulation of the full model, and to get an exact solution, multiple simulations would be required, as in the shooting method [7].
Figures 17 and 18 give some intuition for why the optimized paths are superior for tracking. Each depicts an example of tracking performance with the coordinated ﬂight model for both Dubins curves and the same Dubins curve with an optimized polynomial oﬀset. As we would expect, the coordinated ﬂight model exhibits perfect tracking behavior on these paths.

20 18 16 14 12 10
8 6 4 2 0
−10

Tracking

−5

0

5

(a)

20 actual desired 18 dubins
16

14

12

10

8

6

4

2

0

10

−10

Tracking

−5

0

5

(b)

actual desired dubins
10

Figure 17: This ﬁgure shows tracking performance for the coordinated ﬂight model for a Dubins curve (a) and a transverse polynomial path (b). We can see the actual and desired paths match for the transverse polynomial path as the optimization “anticipates” the discontinuity and symmetrically distributes the roll angle change into each arc segment. In contrast, when tracking the Dubins curve, the vehicle can not roll instantaneously and thus deviates from the path before stabilizing back onto it.
Since the coordinated ﬂight model tracks the paths exactly, the deviation must be introduced by errors in the control mappings from the coordinated ﬂight model to the full nonlinear model (equations 123, 124, and 125). This is not surprising since we approximated the mapping using simple linear ﬁtting,

47

Tracking

4

4 actual

desired

2

dubins

2

0

0

−2

−2

−4

−4

Tracking

actual desired dubins

−6

−6

−8

−8

−10

−8

−6

−4

−2

0

2

4

6

8

(a)

−8

−6

−4

−2

0

2

4

6

8

(b)

Figure 18: This ﬁgure shows another example with the pure Dubins curve (a) and the transverse polynomial path (b). We can see the optimization smoothly distributes curvature over the path, leading to perfect tracking performance, whereas with a pure Dubins curve the tracking deviates at the segment junction.

treating the nonlinear model as a black box. A more reﬁned model ﬁtting might be useful to further improve performance. Ideally the ﬁtting would take place on ﬂight data exhibiting coordinated ﬂight, so one possibility would be to iteratively ﬁt and collect data under closed loop control until some threshold of tracking error is attained. We leave this step as future work on the actual vehicle.
7.4 Custom Fixed-Wing Vehicle Platform
While not a primary focus of our research, the payload, speed, and size constraints for ﬂying in conﬁned indoor spaces led us to design and build a custom ﬁxed-wing vehicle, shown in Figure 19. Our experimental platform consists of a custom built ﬁxed-wing vehicle carrying a Hokuyo UTM-30LX laser rangeﬁnder, a Microstrain 3DM-GX3-25 IMU, and a 2.0GHz Intel Atom based ﬂight computer.
7.5 Fixed-Wing Experimental Results
We conducted closed-loop autonomous ﬂights in a gymnasium and in a parking garage. In total, we have logged over 20 minutes of autonomous ﬂight time, at speeds ranging from 7 m/s to 11 m/s. Initial closed-loop ﬂight tests were conducted with circular holding patterns in the gymnasium. We then performed “simple” and “slalom” paths through curtains hung from the gymnasium ceiling, and a ﬁgure-eight through the pillars of a parking garage. These trajectories are depicted in Figure 20. They were constructed by hand-selecting waypoints and optimizing Dubins-Polynomial trajectories between the waypoints.
During early testing, failures were caused by dynamics mismatches between the model and the actual vehicle. However, once parameters of the dynamics model and controller were suﬃciently ﬁt, the ﬁxed-wing ﬂights were very repeatable. The trajectories depicted in Figure 20 were ﬂown without failure

48

(a)

(b)

Figure 19: This ﬁgure shows our custom vehicle (a) and an internal view of the fuselage (b). The vehicle is designed to ﬂy slowly enough to ﬂy in tight spaces, while still maintaining maneuvering capability. The construction makes use of foam, carbon ﬁber, and thin plywood.

and the number of laps around each trajectory was limited only by battery life. The trajectories in the gymnasium lasted several minutes each, and the parking garage trajectory accounted for 8 minutes of continuous ﬂight or approximately 5 km of ﬂight distance.
Table 7 gives the controller tracking errors incurred during execution of these trajectories. Tracking performance for the simple gymnasium trajectory and the parking garage ﬁgure-eight was excellent, with an average position error of only approximately 30 cm over many laps around these environments. Given the 2 m wingspan of the vehicle, this level of tracking performance is suﬃcient to ﬂy very close to obstacles without risking collision.
It is interesting to note that tracking of the slalom path was not as accurate. Average tracking error for this trajectory was more than twice the tracking error on the other two trajectories (though still less than half the wingspan). The slalom trajectory is composed of a sequence of seven back-to-back turns, most of which are tight turns nearly at the estimated curvature limit of the vehicle. Therefore, this trajectory required the most dramatic rolling motions to track. Furthermore, this trajectory has no straight segments of any signiﬁcant length, so it is much more diﬃcult for the control system to re-converge if tracking errors develop. The drop in performance observed in the slalom trajectory suggests the need for a more accurate estimate of the dynamic limits of the vehicle.
The ﬁxed-wing vehicle during autonomous ﬂight is shown in Figure 21 and onboard camera views are shown in Figure 22. A video illustrating the ﬁxedwing experimental results is available at: http://groups.csail.mit.edu/rrg/ fixed_wing_flight.
8 Conclusion and Future Work
In this paper, we have presented several novel algorithms for trajectory planning and state estimation needed to achieve aggressive autonomous ﬂight in obstacledense indoor environments. The experimental results presented on both the

49

Environment Gymnasium (“slalom”) Gymnasium (“simple”)
Parking Garage

Mean Position Error (m) 0.8313 0.3489 0.2653

Mean Velocity Error (m/s) 1.3121 0.4839 0.3206

Table 7: This table gives position and velocity tracking errors incurred during execution of the ﬁxed-wing trajectories through a gymnasium (Figure 20(a) and Figure 20(b)), and a parking garage (Figure 20(c)). Since we do not have ground-truth state estimation, these errors are reported with respect to the onboard state estimate.

(a)

(b)

(c)

Figure 20: Dubins-Polynomial trajectories in a gymnasium (“slalom”) (a) and (“simple”) (b), and in a parking garage (c). The black lines are the underlying Dubins paths, and the blue lines are the polynomial oﬀset trajectories.

50

(a)

(b)

Figure 21: Autonomous ﬂight in a gymnasium (a) and a parking garage (b).

(a)

(b)

Figure 22: Onboard camera images from autonomous ﬂight in a gymnasium (a) and a parking garage (b).

ﬁxed-wing and quadrotor vehicles highlight the generality of our approach. Since our state estimator is based upon the rigid-body equations of motion, it makes no assumptions about vehicle type, and therefore can be applied without modiﬁcation to any vehicle capable of carrying the required sensors. This generality makes it an extremely powerful tool for cross-platform experimentation.
While our planning approaches are vehicle-speciﬁc, they both make use of the same underlying property of diﬀerential ﬂatness and reuse a signiﬁcant portion of the mathematical tools needed to optimize trajectories. We believe that our overall strategy could be applied to a range of vehicles beyond what we have presented here. In particular, the results for our quadrotor could apply to any multi-copter, simpliﬁed conventional helicopter, submarine or satellite whose thrusters are capable of exerting forces and moments like a quadrotor. Likewise, the results for the ﬁxed-wing airplane would be equally applicable to any curvature-constrained or Dubins-type vehicle, including automobiles.
There are several simple extensions to the planning tools we have presented here, which would improve the performance of automatic trajectory generation. For the quadrotor, we take waypoints from a low-dimensional search algorithm as constraints in the optimization. However, it is often possible to move these waypoints within their local neighborhood to achieve lower-cost trajectories. Moving the waypoints may result in relaxing unnecessarily tight turns in a trajectory, or moving the whole trajectory into a diﬀerent, preferable homotopy

51

class. Such an optimizer might take the form of one presented in [39]. For the ﬁxed-wing vehicle, we have not presented any results using a low-
dimensional search to seed the polynomial optimization, as we did for the quadrotor. It would be straightforward to apply a simple search algorithm to automatically compute a Dubins path and then optimize corresponding DubinsPolynomial trajectories to completely automate the planning procedure. Furthermore, we are currently optimizing the Dubins-Polynomial trajectory associated with each 3-segment Dubins word individually. It would also be straightforward to jointly optimize the entire sequence of polynomials along an entire trajectory to obtain lower cost trajectories.
In this paper, we have focused entirely on planning complete trajectories in pre-mapped environments. However, given the speed with which we can plan trajectories, these tools may apply equally well to the task of planning partial trajectories in a receding-horizon fashion for cases where the environment is not entirely known but is periodically updated during execution.
Acknowledgements
The support of the ARO MAST CTA and ONR under MURI N00014-09-1-1052 and NDSEG is gratefully acknowledged.
52

A Polynomial Trajectory Cost Matrix and Constraints

The square of a polynomial, P 2, can be written using a convolution sum

N
(P 2)n = pj pn−j .
j=0
The rth derivative is given by

(104)

N r−1

P (r)(t) =

(n − m) pntn−r.

n=r m=0

(105)

Using equations 104 and 105 we can write the rth component of the cost as a quadratic function of the polynomial coeﬃcients:

τ

Jr = P (r)(t)2dt

0

τ N r−1

2

=

(n − m) pntn−r dt

0 n=r m=0

τ 2N N r−1

=

(j − m)(n − j − m) pj pn−j tn−2rdt

0 n=0 j=0 m=0

2N N r−1

τ n−2r+1

=

(j − m)(n − j − m) pjpn−j (n − 2r + 1) .

n=0 j=0 m=0

(106) (107) (108) (109)

We ﬁnd Qr matrices by taking the Hessian of this expression:

∂Jr = ∂ 2N N ∂pi ∂pi n=0 j=0

r−1
(j − m)(n − j − m)
m=0

τ n−2r+1 pjpn−j (n − 2r + 1)

2N r−1

τ n−2r+1

=2

(i − m)(n − i − m) pn−i (n − 2r + 1)

n=0 m=0

∂2Jr

2N
=2

r−1
(i − m)(n − i − m)

∂pn−i

τ n−2r+1

∂pi∂pl

n=0 m=0

∂pl (n − 2r + 1)

r−1

τ i+l−2r+1

=2

(i − m)(l − m)

(i + l − 2r + 1)

m=0

Qirl = 2

rm−=10(i − m)(l − m)

: τ i+l−2r+1
(i+l−2r+1)

i ≥ r∧l ≥ r

0:

i < r ∨ l < r.

(110) (111) (112) (113) (114)

We form the complete cost matrix as a weighted sum of all Qr matrices, where the weights cr indicate the penalty on the rth derivative:

N
Q = crQr.
r=0

(115)

53

The constraints on the endpoint values of P and its derivatives can be written as linear functions of the coeﬃcients:

Ap − b = 0.

(116)

The value of the rth derivative at τ is given by:

N r−1

P (r)(τ ) =

(n − m) pnτ n−r.

n=r m=0

(117)

For a polynomial segment spanning from 0 to τ satisfying derivative constraints on both ends of the interval, A and b are constructed as:

A= A0rn =

A0 Aτ

,b =

b0 bτ

r−1 m=0

(r

−

m)

:

r=n

0:

r=n

b0r = P (r)(0)

Aτrn =

r−1 m=0

(n

−

m)

0:

τ n−r :

n≥r n<r

bτr = P (r)(τ ).

(118) (119) (120) (121) (122)

The A matrix simply maps the polynomial coeﬃcients to the derivatives at the endpoints of the polynomial. The vector b is used to specify or constrain certain derivative values. These constraints are useful, for example, when we want to enforce that velocity and acceleration and higher derivatives are zero at the beginning of a quadrotor trajectory, or when we want to match the values of derivatives at the junction between two polynomial trajectory segments.

B Fixed-Wing Diﬀerentially Flat Control Input
Conversion
The trajectory stabilization algorithm outlined in Section 7.1 provides us with ωvx , a˙ vz , and s(3). The remaining challenge is to translate these quantities into aileron, elevator, throttle, and rudder inputs such that coordinated ﬂight is achieved at the desired settings. Since we have a path parameter taking the place of a˙ vx in the diﬀerentially ﬂat representation, we can use the the throttle to maintain a desired cruise speed.
Using traditional linear analysis for aircraft dynamics, roll rate can be shown to be a stable ﬁrst order system with aileron input, and normal acceleration (effectively angle of attack or normal velocity) a stable second order system with elevator as input [42]. Thus one possibility would be to diﬀerentiate equation 71 to get ﬂat inputs at the same system order as elevator and aileron. However, feedback for such an approach would require the third derivative of the actual system motion which is not directly available (derivative of acceleration). Further, the dynamics in pitch from elevator to normal acceleration and aileron to roll are fast relative to the derivatives of the path.

54

The approach we use for control is to integrate a˙ vz and maintain avz (normal acceleration) as a controller state. Desired roll rate and normal acceleration are then translated algebraically into elevator, aileron, and rudder commands. Using basic results from aircraft stability and control, we can convert desired normal acceleration, steady-state roll rate (p), and steady-state yaw rate (r) to control surface deﬂections as follows:

δe

=

c0

avz V2

+ c1

p

r

δa = c2 V + c3 V

p

r

δr = c4 V + c5 V

(123) (124) (125)

where δe is the elevator deﬂection, δa is the aileron deﬂection, and δr is the rudder deﬂection. Equations 123, 124, and 125 give us the relationships we need. Coeﬃcients c0-c5 can be empirically ﬁt from ﬂight or simulation data and then used to map the desired normal acceleration to actual control inputs.

References
[1] CRRC simulator. http://sourceforge.net/apps/mediawiki/crrcsim/. Accessed: April 2014.
[2] P. Abbeel, A. Coates, M. Montemerlo, A. Y. Ng, and S. Thrun. Discriminative training of Kalman ﬁlters. In Proceedings of Robotics: Science and Systems, Cambridge, USA, 2005.
[3] A. Bachrach, S. Prentice, R. He, and N. Roy. RANGE: Robust autonomous navigation in GPS-denied environments. Journal of Field Robotics, 28(5):644–666, 2011.
[4] A. J. Barry, T. Jenks, A. Majumdar, H.-T. Lin, I. G. Ros, A. Biewener, and R. Tedrake. Flying between obstacles with an autonomous knife-edge maneuver. In IEEE Int. Conf. on Robotics and Automation, 2014.
[5] A. J. Barry and A. Majumdar. Personal communication, 2014.
[6] D. P. Bertsekas. Nonlinear Programming. Athena Scientiﬁc, Belmont, MA, 1999.
[7] J. T. Betts. Practical methods for optimal control and estimation using nonlinear programming, volume 19. Siam, 2010.
[8] A. Bry, A. Bachrach, and N. Roy. State estimation for aggressive ﬂight in GPS-denied environments using onboard sensing. In IEEE Int. Conf. on Robotics and Automation, 2012.
[9] A. Bry and N. Roy. Rapidly-exploring random belief trees for motion planning under uncertainty. In IEEE Int. Conf. on Robotics and Automation, 2011.

55

[10] G. Buskey, J. Roberts, P. Corke, and G. Wyeth. Helicopter automation using a low-cost sensing system. In Proceedings of the Australasian Conf. on Robotics and Automation, 2003.
[11] H. Chitsaz and S. LaValle. Time-optimal paths for a dubins airplane. In IEEE Conf. on Decision and Control, pages 2379–2384, 2007.
[12] M. Cutler and J. P. How. Actuator constrained trajectory generation and control for variable-pitch quadrotors. In AIAA Conf. on Guidance, Navigation, and Control, 2012.
[13] M. Drela and H. Youngren. Athena vortex lattice (AVL). http://web. mit.edu/drela/Public/web/avl/, April 2014. Accessed: April 2014.
[14] N. Faiz, S. K. Agrawal, and R. M. Murray. Trajectory planning of diﬀerentially ﬂat systems with dynamics and inequalities. Guidance, Control, and Dynamics, 24(2):219–227, 2001.
[15] D. Ferguson, T. M. Howard, and M. Likhachev. Motion planning in urban environments. Journal of Field Robotics, 25(11-12):939–960, 2008.
[16] T. Fraichard. Smooth trajectory planning for a car in a structured world. In IEEE Int. Conf. on Robotics and Automation, pages 318–323. IEEE, 1991.
[17] E. Frazzoli, M. Dahleh, and E. Feron. Real-time motion planning for agile autonomous vehicles. Guidance, Control, and Dynamics, 25(1):116–129, 2002.
[18] E. Frazzoli, M. A. Dahleh, and E. Feron. Maneuver-based motion planning for nonlinear systems with symmetries. IEEE Trans. Robotics, 21(6):1077– 1091, 2005.
[19] S. Grzonka, G. Grisetti, and W. Burgard. Towards a navigation system for autonomous indoor ﬂying. In IEEE Int. Conf. on Robotics and Automation, 2009.
[20] G. Guennebaud, B. Jacob, et al. Eigen v3. http://eigen.tuxfamily.org, 2010.
[21] J. Hauser and R. Hindman. Aggressive ﬂight maneuvers. In IEEE Conf. on Decision and Control, 1997.
[22] M. Hehn, R. Ritz, and R. D’Andrea. Performance benchmarking of quadrotor systems using time-optimal control. Autonomous Robots, 33(1-2):69–88, 2012.
[23] J. Hesch, F. Mirzaei, G. Mariottini, and S. Roumeliotis. A laser-aided inertial navigation system L-INS for human localization in unknown indoor environments. In IEEE Int. Conf. on Robotics and Automation.
[24] S. Hrabar and G. Sukhatme. Vision-based navigation through urban canyons. Journal of Field Robotics, 26(5):431–452, 2009.
56

[25] J. hwan Jeon, S. Karaman, and E. Frazzoli. Anytime computation of timeoptimal oﬀ-road vehicle maneuvers using the RRT*. In IEEE Decision and Control and European Control Conf. (CDC-ECC), pages 3276–3282, 2011.
[26] S. Karaman and E. Frazzoli. Optimal kinodynamic motion planning using incremental sampling-based methods. In IEEE Conf. on Decision and Control, pages 7681–7687, 2010.
[27] S. Karaman and E. Frazzoli. Sampling-based algorithms for optimal motion planning. Int. Journal of Robotics Research, 30(7):846–894, 2011.
[28] J. Kelly, S. Saripalli, and G. Sukhatme. Combined visual and inertial navigation for an unmanned aerial vehicle. pages 255–264. 2008.
[29] J. Kim and S. Sukkarieh. SLAM aided GPS/INS navigation in GPS denied and unknown environments. In The 2004 International Symposium on GNSS/GPS, Sydney, 2004.
[30] D. B. Kingston and R. W. Beard. Real-time attitude and position estimation for small uavs using low-cost sensors. In AIAA Unmanned Unlimited Technical Conf., Workshop and Exhibit, pages 2004–6488, 2004.
[31] T. J. Koo and S. Sastry. Output tracking control design for a helicopter model based on approximate linearization. In IEEE Conf. on Decision and Control, pages 3635–3640, 1998.
[32] J. H. Kotecha and P. M. Djuric. Gaussian particle ﬁltering. IEEE Trans. Signal Processing, 51(10):2592–2601, 2003.
[33] Y. Kuwata, J. Teo, S. Karaman, G. Fiore, E. Frazzoli, and J. How. Motion planning in complex environments using closed-loop prediction. In AIAA Conf. on Guidance, Navigation, and Control, Honolulu, HI, 2008.
[34] S. M. LaValle. Planning Algorithms. Cambridge University Press, Cambridge, U.K., 2006. Available at http://planning.cs.uiuc.edu/.
[35] S. M. LaValle and J. J. Kuﬀner. Randomized kinodynamic planning. Int. Journal of Robotics Research, 20(5):378–400, 2001.
[36] T. Lee, M. Leoky, and N. H. McClamroch. Geometric tracking control of a quadrotor UAV on SE(3). In IEEE Conf. on Decision and Control, pages 5420–5425, 2010.
[37] R. Mehra. On the identiﬁcation of variances and adaptive Kalman ﬁltering. IEEE Trans. Automatic Control, 15(2):175 – 184, 1970.
[38] D. Mellinger and V. Kumar. Minimum snap trajectory generation and control for quadrotors. In IEEE Int. Conf. on Robotics and Automation, 2011.
[39] M. Milam, K. Mushambi, and R. Murray. A new computational approach to real-time trajectory generation for constrained mechanical systems. In IEEE Conf. on Decision and Control, volume 1, pages 845–851 vol.1, 2000.
57

[40] R. M. Murray, M. Rathinam, and W. Sluis. Diﬀerential ﬂatness of mechanical control systems: A catalog of prototype systems. In ASME International Mechanical Engineering Congress and Exposition. Citeseer, 1995.
[41] J. Pan, L. Zhang, and D. Manocha. Collision-free and smooth trajectory computation in cluttered environments. Int. Journal of Robotics Research, 31(10):1155–1175, 2012.
[42] W. F. Phillips. Mechanics of Flight. John Wiley and Sons, Hoboken, NJ, 2004.
[43] M. Pivtoraiko and A. Kelly. Kinodynamic motion planning with state lattice motion primitives. In IEEE Int. Conf. on Intelligent Robots and Systems, 2011.
[44] N. Ratliﬀ, M. Zucker, J. A. Bagnell, and S. Srinivasa. Chomp: Gradient optimization techniques for eﬃcient motion planning. In IEEE Int. Conf. on Robotics and Automation, pages 489–494, 2009.
[45] C. Richter, A. Bry, and N. Roy. Polynomial trajectory planning for aggressive quadrotor ﬂight in dense indoor environments. In Int. Symposium on Robotics Research, 2013.
[46] S. Scherer, S. Singh, L. Chamberlain, and M. Elgersma. Flying fast and low among obstacles: Methodology and experiments. Int. Journal of Robotics Research, 27(5):549–574, 2008.
[47] J. Schulman, J. Ho, A. Lee, I. Awwal, H. Bradlow, and P. Abbeel. Finding locally optimal, collision-free trajectories with sequential convex optimization. In Proceedings of Robotics: Science and Systems. Citeseer, 2013.
[48] S. Shen, N. Michael, and V. Kumar. Autonomous multi-ﬂoor indoor navigation with a computationally constrained MAV. In IEEE Int. Conf. on Robotics and Automation.
[49] S. Thrun, D. Fox, W. Burgard, and F. Dellaert. Robust Monte Carlo localization for mobile robots. Artiﬁcial Intelligence, 128(1):99–141, 2001.
[50] R. van der Merwe and E. Wan. Sigma-point Kalman ﬁlters for integrated navigation. In Proc. Institute of Navigation (ION), Dayton, OH, 2004.
[51] M. J. Van Nieuwstadt and R. M. Murray. Real-time trajectory generation for diﬀerentially ﬂat systems. Int. J. Robust and Nonlinear Control, 8(11):995–1020, 1998.
[52] K. M. Wurm, A. Hornung, M. Bennewitz, C. Stachniss, and W. Burgard. OctoMap: A probabilistic, ﬂexible, and compact 3D map representation for robotic systems. In Proc. of the ICRA 2010 Workshop on Best Practice in 3D Perception and Modeling for Mobile Manipulation, Anchorage, AK, USA, 2010.
58

