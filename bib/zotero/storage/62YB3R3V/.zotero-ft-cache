Motion Planning with Sequential Convex Optimization and Convex Collision Checking
John Schulman, Yan Duan, Jonathan Ho, Alex Lee, Ibrahim Awwal, Henry Bradlow, Jia Pan, Sachin Patil, Ken Goldberg, Pieter Abbeel

Abstract—We present a new optimization-based approach for

robotic motion planning among obstacles. Like CHOMP, our

algorithm can be used to ﬁnd collision-free trajectories from

na¨ıve, straight-line initializations that might be in collision. At the

core of our approach are (i) A sequential convex optimization pro-

cedure, which penalizes collisions with a hinge loss and increases

the penalty coefﬁcients in an outer loop as necessary. (ii) An

efﬁcient formulation of the no-collisions constraint that directly

considers continuous-time safety Our algorithm is implemented

in a software package called TrajOpt.

We report results from a series of experiments comparing

TrajOpt with CHOMP and randomized planners from OMPL,

(a)

(b)

with regard to planning time and path quality. We consider

motion planning for 7 DOF robot arms, 18 DOF full-body

robots, statically stable walking motion for the 34 DOF Atlas

humanoid robot, and physical experiments with the 18 DOF PR2.

We also apply TrajOpt to plan curvature-constrained steerable

needle trajectories in the SE(3) conﬁguration space and multiple

non-intersecting curved channels within 3D-printed implants for

intracavitary brachytherapy. Details, videos, and source code is

freely available at http://rll.berkeley.edu/trajopt/ijrr.

I. INTRODUCTION
The increasing complexity of robots and the environments that they operate in has spurred the need for high-dimensional motion planning. Consider, for instance, a PR2 personal robot operating in a cluttered household environment or an Atlas humanoid robot performing navigation and manipulation tasks in an unstructured environment. Efﬁcient motion planning is important to enable these high DOF robots to perform tasks, subject to motion constraints while avoiding collisions with obstacles in the environment. Processing time is especially important where re-planning is necessary.
Sampling-based motion planners [21, 25] are very effective and offer probabilistic completeness guarantees. However, these planners often require a post-processing step to smooth and shorten the computed trajectories. Furthermore, considerable computational effort is expended in sampling and connecting samples in portions of the conﬁguration space that might not be relevant to the task. Optimal planners such as RRT* [20] and discretization-based approaches [29, 28] are very promising but are currently computationally inefﬁcient for solving high-dimensional motion planning problems.
Trajectory optimization is fundamental in optimal control where the objective is to solve for a trajectory encoded as a sequence of states and controls that optimizes a given objective subject to constraints [1]. Optimization plays two important roles in robot motion planning. First, it can be used to smooth and shorten trajectories computed by other

(c)

(d)

(e)

(f)

Fig. 1. TrajOpt applied to several motion planning scenarios: (a) planning an arm trajectory for the PR2 in simulation, (b) PR2 opening a door with a full-body motion, (c) industrial robot picking boxes, subject to an orientation constraint on the end effector, (d) humanoid robot model (DRC/Atlas) ducking underneath an obstacle while obeying static stability constraints, (e) multiple bevel-tip ﬂexible needles inserted through the perineum to reach targets deep within the prostate following high-quality constant curvature trajectories, and (f) optimized layout for bounded curvature channels within 3D-printed vaginal implants for delivering radiation to OB/GYN tumors [14].

planning methods such as sampling-based planners. Second, it can be used to compute locally optimal, collision-free trajectories from scratch starting from na¨ıve (straight-line) trajectory initializations that might collide with obstacles.
Even though trajectory optimization has been successfully used for optimal control in a number of domains, it has traditionally not been used for robot motion planning because the presence of obstacles in the environment and other constraints

1

requires solving a non-convex, constrained optimization problem. However, CHOMP (Covariant Hamiltonian Optimization for Motion Planning) [41, 61] revived interest in trajectory optimization methods by demonstrating the effectiveness on several robotic platforms including the HERB mobile manipulation platform, the LittleDog quadruped, and the PR2 robot. CHOMP has the following key features: (1) formulation of trajectory costs that are invariant to the time parameterization of the trajectory, (2) using pre-computed signed distance ﬁelds for collision checking, and (3) using pre-conditioned gradient descent for numerical optimization.
Our approach uses optimization in the same spirit as CHOMP, with the following key differences: (1) the numerical optimization method used, and (2) the method of checking for collisions and penalizing them. We use sequential convex optimization, which involves solving a series of convex optimization problems that approximate the cost and constraints of the original problem. The ability to add new constraints and costs to the optimization problem allows our approach to tackle a larger range of motion planning problems, including planning for underactuated, nonholonomic systems. For collisions, we use signed distances using convex-convex collision detection, and safety of a trajectory between time steps i.e., continuoustime safety, is taken into account by considering the sweptout volume of the robot between time steps. This formulation has little computational overhead in collision checking and allows us to use a sparsely sampled trajectory. Our method for handling collisions yields a polyhedral approximation of the free part of conﬁguration space, which is directly incorporated into the convex optimization problem that is solved at each optimization iteration. This precludes the need for precomputation of signed distance ﬁelds and is computationally efﬁcient in practice.
We performed a quantitative comparison between TrajOpt and several implementations of motion planning algorithms, including sampling based planners from OMPL [47], as well as a recent implementation of CHOMP [61]. Overall, our experimental results indicate that TrajOpt was computationally faster than the alternatives on the considered benchmark (around 100 − 200 ms on arm-planning problems and solves full body 18 DOF planning problems for the PR2 robot in under a second on an Intel i7 3.5 GHz CPU), and solved a larger fraction of the problems given a speciﬁed time limit. We also applied TrajOpt to high-DOF motion problems, including physical experiments with the PR2 robot where we simultaneously need to plan for two arms along with the base and torso (Fig. 1(b)), and for planning foot placements with 28 DOF (+ 6 DOF pose) of the Atlas humanoid robot as it maintains static stability and avoids collisions (Fig. 1(d)).
In this work, in addition to providing a revised and extended version of our work [43], (i) we describe an extension to the algorithm described in the RSS paper to plan trajectories in SE(3), and (ii) we provide a discussion on cases where trajectory optimization fails to ﬁnd a feasible solution. Regarding (i), we consider the problem of planning curvatureconstrained trajectories in 3D environments. This involves

trajectory optimization over manifolds such as the SE(3) Lie group, instead of just vector spaces of the form Rn. We accomplish this by iteratively optimizing over increments to the trajectory, deﬁned in terms of the corresponding Lie algebra — se(3) in our case [2]. We applied this extension of TrajOpt to two real-world clinical applications. First, we considered the problem of planning collision-free, constant curvature trajectories that avoid obstacles in the environment and optimize clinically relevant metrics for ﬂexible, bevel-tip medical needles [55, 42] (Fig. 1(e)). Our second application considers the problem of planning multiple, mutually collisionfree, curvature-constrained channels within 3-D printed implants [14] for intracavitary brachytherapy (HDR-BT).
II. RELATED WORK
Trajectory optimization: Khatib proposed the use of potential ﬁelds for avoiding obstacles, including dynamic obstacles [22]. Warren [54] used a global potential ﬁeld to push the robot away from conﬁguration space obstacles, starting with a trajectory that was in collision. Quinlan and Khatib [40] locally approximated the free part of conﬁguration space as a union of spheres around the current trajectory as part of a local optimization that tries to shorten the trajectory. Brock and Khatib [3] improved on this idea, enabling trajectory optimization for a robot in 3D, by using the Jacobian to map distances from task space into conﬁguration space. These approaches locally approximate the free space using a union of spheres, which is a overly conservative approximation and may not ﬁnd feasible trajectories even if they exist.
While the motivation for the presented work is very similar to the motivation behind CHOMP [41, 61, 8], which is most similar in terms of prior art, our algorithm differs fundamentally in the following two ways:
1) Distance ﬁelds versus convex-convex collision checking: CHOMP uses the Euclidean distance transform—a precomputed function on a voxel grid that speciﬁes the distance to the nearest obstacle, or the distance out of an obstacle. Typically each link of the robot is approximated as a union of spheres, since the distance between a sphere and an obstacle can be bounded based on the distance ﬁeld. The advantage of distance ﬁelds is that checking a link for collision against the environment requires constant time and does not depend on the complexity of the environment. On the other hand, spheres and distance ﬁelds are arguably not very well suited to situations where one needs to accurately model geometry, which is why collision-detection methods based on meshes and convex primitives are more prevalent in applications like realtime physics simulation [7] for speed and accuracy. Whereas convex-convex collision detection takes two colliding shapes and computes the minimal translation to get them out of collision, the distance ﬁeld (and its gradient) merely computes how to get each robot point (or sphere) out of collision; however, two points may disagree on which way to go. Thus convex-convex collision detection arguably provides a better local approximation of conﬁguration space, allowing us to formulate a better shaped objective.

2

The CHOMP objective is designed to be invariant to reparametrization of the trajectory. This invariance property makes the objective better shaped, helping the gradient pull the trajectory out of an obstacle instead of encouraging it to jump through the obstacle faster. Our method of collision checking against the swept-out robot shape achieves this result in a completely different way.
2) Projected gradient descent versus SQP: CHOMP uses (preconditioned) projected gradient descent, i.e., it takes steps x ← Proj(x−A−1∇f (x)), whereas our method uses sequential quadratic programming (SQP), which constructs a locally quadratic approximation of the objective and locally linearizes constraints. Taking a projected gradient step is cheaper than solving a QP. However, an advantage of sequential quadratic programming is that it can handle infeasible initializations and other constraints on the motion using penalties and merit functions, as described in Sec. III. We note that popular nonconvex optimization solvers such as KNITRO and SNOPT also use an SQP variant. Another advantage of using SQP is that there is additional ﬂexibility in adding other cost terms to the objective and constraints, which allows TrajOpt to tackle a larger range of planning problems, including planning for underactuated, nonholonomic systems.
Other recent work in robotics uses sequential quadratic programming for trajectory optimization and incorporates collision avoidance as constraints, in a similar way to this work. Lampariello et al. [24] incorporate signed distances between polytopes as inequality constraints in an optimal control problem. Werner et al. [56] use sequential quadratic programming to optimize walking trajectories, also incorporating obstacle avoidance as hard constraints, along with stability constraints. However, these methods have not considered continuous-time collision checking or dealt with infeasible trajectory initializations that start deeply in collision. Finally, there recently has been considerable progress in trajectory optimization for dynamical systems [32, 26, 39, 51, 12]. These approaches have obtained promising results but rely on a simpliﬁed, though conservative, representation of the robot geometry (e.g., union of spheres) to obtain solutions to planning problems.
Trajectory smoothing: Sampling-based motion planners can sometimes generate non-smooth trajectories that may contain unnecessary turns [25]. Many techniques have been proposed in the literature to generate smooth paths. Shortcutbased methods [17, 19, 36] replace non-smooth portions of a trajectory shorter linear or curved segments (e.g., parabolic arcs, Be´zier curves). These methods tend to be fast and simple, and can produce high quality paths in many cases. However, they may not provide enough ﬂexibility in terms of generating collision-free smooth trajectories in the presence of obstacles. TrajOpt and other optimization approaches such as CHOMP [41, 61] can be used for trajectory smoothing in such cases.
3D curvature-constrained planning: This ﬁnds applications in a wide variety of domains, including motion planning for ﬂexible, bevel-tip medical needles [55, 42], planning multiple curvature-constrained channels in 3D printed implants for brachytherapy dose delivery [14] or channels for cooling

turbine blades [16], and path planning for unmanned aerial vehicles (UAVs) [60, 45]. Computing collision-free, curvatureconstrained trajectories is challenging in 3D environments because it requires planning in the SE(3) conﬁguration space consisting of the 6D pose (position and orientation).
Duindam et al. proposed a fast, optimal planner based on inverse kinematics in 3D environments without obstacles [10]. Xu et al. [57, 58] used rapidly-exploring random trees (RRT) [25] which offers a probabilistically-complete, but computationally expensive, algorithm to search for collisionfree trajectories. Duindam et al. [9] formulated planning for steerable needles as a non-convex optimization problem, which computes collision-free solutions in a few seconds but collision avoidance is treated as a cost and not as a hard constraint. Patil et al. [37] proposed a fast RRT planner which uses duty-cycling spinning of the needle during insertion [11] to move the needle along bounded curvature trajectories, which can cause excessive tissue damage [11]. This approach was also used for designing bounded curvature channels within implants [14] but the issue of optimality was not addressed. Fast trajectory correction methods have been proposed to compensate for uncertainty during insertion [44, 38] but it is not clear if they can be used to plan trajectories from scratch.
Extensions to planning curvature-constrained trajectories in 3D have been proposed for unmanned aerial vehicles (UAVs) in environments without obstacles [48, 59, 45] and with obstacles [18, 60]. These methods are specialized for bounded curvature trajectory planning and have not considered planning of constant curvature trajectories in 3D environments.
While specialized planners have been proposed for underactuated, nonholonomic systems, TrajOpt can be generalized to this case (in our case, the SE(3) conﬁguration space) by considering optimization over increments.

III. BACKGROUND: SEQUENTIAL CONVEX OPTIMIZATION
Robotic motion planning problems can be formulated as non-convex optimization problems, i.e., minimize an objective subject to inequality and equality constraints:

minimize f (x)

(1a)

subject to

(1b)

gi(x) ≤ 0, i = 1, 2, . . . , nineq

(1c)

hi(x) = 0, i = 1, 2, . . . , neq

(1d)

where f, gi, hi, are scalar functions. In kinematic motion planning problems, the optimization is
done over a T ×K-dimensional vector, where T is the number of time-steps and K is the number of degrees of freedom. We
denote the optimization variables as x1:T , where xt describes the conﬁguration at the tth timestep. To encourage minimum-
length paths, we use the sum of squared displacements,

T −1

f (x1:T ) =

xt+1 − xt 2 .

(2)

t=1

Besides obstacle avoidance, common inequality constraints in motion planning problems include joint limits and joint

3

angular speed limits. Common equality constraints include the end-effector pose (i.e., reach a target pose at the end of the trajectory) and orientation constraints (keep a held object upright). For underactuated, nonholonomic motion planning problems, additional equality constraints are added to ensure that the kinematics are consistent. We will discuss some of these constraints in Sec. VII.
Sequential convex optimization solves a non-convex optimization problem by repeatedly constructing a convex subproblem—an approximation to the problem around the current iterate x. The subproblem is used to generate a step ∆x that makes progress on the original problem. Two key ingredients of a sequential convex optimization algorithm are: (1) a method for constraining the step to be small, so the solution vector remains within the region where the approximations are valid; (2) a strategy for turning the infeasible constraints into penalties, which eventually drives all of the constraint violations to zero. For (1), we use a trust region modeled as a box constraint around the current iterate. For (2) we use 1 penalties: each inequality constraint gi(x) ≤ 0 becomes the penalty |gi(x)|+, where |x|+ = max (x, 0); each equality constraint hi(x) = 0 becomes the absolute value penalty |hi(x)|. In both cases, the penalty is multiplied by some coefﬁcient µ, which is sequentially increased, usually by multiplying by a constant scaling factor at each step, during the optimization to drive constraint violations to zero. Note that 1 penalties are non-differentiable but convex, and convex optimization algorithms can efﬁciently minimize them. Our implementation uses a variant of the classic 1 penalty method [34], which is described in Algorithm 1.
In the outer loop (PenaltyIteration, line 1) we increase the penalty coefﬁcient µ by a constant scaling factor (k = 10 in all our experiments) until all the constraints are satisﬁed, terminating when the coefﬁcient exceeds some threshold. The next loop (ConvexifyIteration, line 2) is where we repeatedly construct a convex approximation to the problem and then optimize it. In particular, we approximate the objective and inequality constraint functions by convex functions that are compatible with a quadratic program (QP) solver, and we approximate the nonlinear equality constraint functions by afﬁne functions. The nonlinear constraints are incorporated into the problem as penalties, while the linear constraints are directly imposed in the convex subproblems. The next loop (TrustRegionIteration, line 4) is like a line search; if the true improvement (TrueImprove) to the non-convex merit functions (objective plus constraint penalty) is a sufﬁciently large fraction of the improvement to our convex approximations (ModelImprove), then the step is accepted.
The use of 1 penalties is called an exact penalty method, because if we multiply the penalty by a large coefﬁcient (tending to inﬁnity but the value is smaller in practice), then the minimizer of the penalized problem is exactly equal to the minimizer of the constrained problem. This is in contrast to the typical 2 penalty method that penalizes squared error, i.e., gi(x) ≤ 0 → (|gi(x)|+)2 and hi(x) = 0 → hi(x)2. 1 penalty methods give rise to numerically-stable algorithms that drive

Algorithm 1 1 penalty method for sequential convex opti-
mization. Parameters:
µ0: initial penalty coefﬁcient s0: initial trust region size
c: step acceptance parameter τ +, τ −: trust region expansion and shrinkage factors k: penalty scaling factor ftol, xtol: convergence thresholds for merit and x ctol: constraint satisfaction threshold

Variables:

x current solution vector

µ penalty coefﬁcient

s trust region size

1: for PenaltyIteration = 1, 2, . . . do

2: for ConvexifyIteration = 1, 2, . . . do

3:

f˜, g˜, h˜ = ConvexifyProblem(f, g, h)

4:

for TrustRegionIteration = 1, 2, . . . do

nineq

neq

5:

x ← arg min f˜(x) + µ |g˜i(x)|+ + µ |h˜i(x)|

x

i=1

i=1

subject to trust region and linear constraints

6:

if TrueImprove / ModelImprove > c then

7:

s ← τ+ ∗ s

Expand trust region

8:

break

9:

else

10:

s ← τ− ∗ s

Shrink trust region

11:

if s < xtol then

12:

goto 15

13: if converged according to tolerances xtol or ftol then

14:

break

15: if constraints satisﬁed to tolerance ctol then

16:

break

17: else

18:

µ←k∗µ

the constraint violations to zero. Note that the objective we are optimizing contains non-
smooth terms like |a · x + b| and |a · x + b|+. However, the subproblems solved by our algorithm are quadratic programs—a quadratic objective subject to afﬁne constraints. We accommodate these non-smooth terms while keeping the objective quadratic by adding auxilliary slack variables [34]. To add |a · x + b|+, we add slack variable t and impose constraints

0≤t

a·x+b≤t

(3)

Note that at the optimal solution, t = |a · x + b|+. Similarly, to add the term |a · x + b|, we add s + t to the objective and
impose constraints

0 ≤ s, 0 ≤ t

s−t=a·x+b

(4)

At the optimal solution, s = |a · x + b|+, t = | − a · x − b|+, so s + t = |a · x + b|.

4

A. Sequential Convex Optimization over SE(3)

The optimization method outlined above operates in vector spaces of the form Rn. However, motion planning for under-

actuated, nonholonomic systems such as bevel-tipped ﬂexible

needles, or steerable needles, involves planning over mani-

folds. In this work, we consider the trajectory optimization

problem deﬁned over the special Euclidean group SE(3),

which is a 6D conﬁguration space consisting of the robot

pose (3D position and 3D orientation) i.e., at each time step

t ∈ T , the conﬁguration xt is parameterized as a pose

Xt =

Rt pt 0T3 1

∈ SE(3), where pt ∈ R3 is the position and

Rt ∈ SO(3) is the rotation matrix that encodes the orientation

of the waypoint frame relative to a world coordinate frame.

The Lie group SE(3) is a smooth manifold. To perform

local optimization over SE(3), we will need to form a local

coordinate parametrization of the manifold. This parametriza-

tion is provided by the Lie algebra se(3), which is deﬁned

as the tangent vector space at the identity of SE(3), and,

informally, consists of inﬁnitesimal rotations. The SE(3)

group and se(3) algebra are related via the exponential and

log maps, exp : se(3) → SE(3) and log : SE(3) → se(3),

where exp and log correspond to the matrix exponential and

log operations.

Given

a

vector

x¯

=

[

p¯ ¯r

]

∈

R6

that

represents

the

incremental

twist, the corresponding Lie algebra element is given by the

mapping ∧ : R6 → se(3) as

x¯∧ =

[¯r] p¯ 0T3 0

,

(5)

where the notation [¯r] for the vector ¯r = [¯rx ¯ry ¯rz]T ∈ R3 is the 3 × 3 skew-symmetric matrix given by

0 −¯rz ¯ry

[¯r] = ¯rz 0 −¯rx .

(6)

−¯ry ¯rx 0

Intuitively, ¯r represents the incremental rotation and p¯ rep-

resents the incremental translation to be applied to a nominal

pose. The inverse is deﬁned by the operator ∨ : se(3) → R6

to recover x¯ given a Lie algebra element, i.e.,

[¯r] p¯ 0T3 0

∨
= x¯.

The local neighborhood X of a nominal pose Xˆ ∈ SE(3) is

deﬁned in terms of x¯ ∈ R6 as

X = Xˆ · exp(x¯ ∧),

(7)

where exp(x¯∧) can be explicitly computed as [33]:

exp(x¯∧) =

I p¯ 0T3 1

, ¯r = 03

or

e¯r Ap¯ 0T3 1

, ¯r = 03

(8)

where

e¯r = I +

[¯r] ¯r

sin

¯r

+

[¯r]2 ¯r 2

(1

−

cos

¯r ),

(9)

A=I+

[¯r] ¯r 2

(1

−

cos

¯r

)+

[¯r]2 ¯r 3

(

¯r

− sin

¯r )

(10)

Note that an alternative approach would be to use a global parameterization of the rotation group, such as axis-angle coordinates or Euler angles. The drawback of those parameterizations is that they distort the geometry—for example,

consider how a map of the world is distorted around the poles. This distortion can severely slow down an optimization algorithm, by reducing the neighborhood where local (ﬁrst and second-order) approximations are good.
We now describe how to generalize sequential convex optimization to the case where the domain is a differentiable manifold rather than Rn. There is an extra step in constructing each convex subproblem: we ﬁrst form a local coordinate parametrization of the manifold around the current solution (a point on the manifold). Then we approximate the merit function fµ(θ) in terms of this parameterization.
In this work, at the ith iteration of SQP our trajectory consists of a sequence of nominal poses Xˆ(i) = {Xˆ0(i), . . . , XˆT(i)}. To construct the QP subproblem, we parametrize each pose in terms of increments to the previous solution: Xˆ(i+1) = {Xˆ0(i) · exp(x¯(0i) ∧), . . . , XˆT(i) · exp(x¯(Ti) ∧)} where X¯(i) = {x¯0(i), . . . , x¯(Ti)} is the sequence of incremental twists.
IV. NO-COLLISIONS CONSTRAINT
This section describes how the no-collisions constraint can be efﬁciently formulated for a discretely-sampled trajectory that ensures that a given robot conﬁguration x is not in collision. We can use this constraint to encourage the robot to be collision-free at each time step. We later show how this can be extended to encourage continuous-time safety i.e., the robot stays collision-free between time steps.
A. Discrete-time no-collisions constraint
Let A, B, O be labels for rigid objects, each of which is a link of the robot or an obstacle. The set of points occupied by these objects are denoted by calligraphic letters A, B, O ⊂ R3. We sometimes use a superscript to indicate the coordinate system of a point or a set of points. Aw ⊂ R3 denotes the set of points in world coordinates occupied by A, whereas AA denotes the set of points in a coordinate system local to object A. The poses of the objects A, B are denoted as FAw, FBw, where FAw is a rigid transformation that maps from the local coordinate system to the global coordinate system.
Our method for penalizing collisions is based on the notion of minimum translation distance, common in collision detection [13]. The distance between two sets A, B ⊂ R3, which is nonzero for non-intersecting sets, is deﬁned as
dist(A, B) = inf{ T (T + A) ∩ B = ∅} (11)
Informally, it’s the length of the smallest translation T that puts the shapes in contact. The penetration depth, which is nonzero for overlapping shapes, is deﬁned analogously as the minimum translation that takes two shapes out of contact:
penetration(A, B) = inf{ T (T + A) ∩ B = ∅} (12)
The signed distance is deﬁned as follows:
sd(A, B) = dist(A, B) − penetration(A, B) (13)
Note that these concepts can also be deﬁned using the notion of a conﬁguration space obstacle and the Minkowski difference between the shapes—see e.g. [13].

5

A
pA
T
pB
B
sd > 0

A

pB

T

B

pA

sd < 0

penalty

0

sd dsaf e dcheck

Fig. 2. Minimal translational distance and closest points.

Fig. 3. Hinge penalty for collisions

The convex-convex signed distance computation can be performed efﬁciently. The distance between two shapes can be calculated by the Gilbert-Johnson-Keerthi (GJK) algorithm [15], while the penetration depth is calculated by a different algorithm, Tuesday, January 29, 13 the Expanding Polytope Algorithm (EPA) [52]. One useful feature of these two algorithms, which makes them so generally applicable, is that they represent an object A by its support mapping, i.e., a function that maps vector v to the point in A that is furthest in direction v:

sA(v) = arg max v · p

(14)

p∈A

This representation makes it possible to describe convex shapes implicitly without considering explicit polyhedral representations of their surfaces. We will exploit this fact to efﬁciently check for collisions against swept-out volumes of the robot between time steps.
Two objects are non-colliding if the signed distance is positive. We will typically want to ensure that the robot has a safety margin dsafe. Thus, we want to enforce the following constraints at each timestep

sd(Ai, Oj ) ≥ dsafe

∀i ∈ {1, 2, . . . , Nlinks},

∀j ∈ {1, 2, . . . , Nobstacles}

(obstacle collisions)

sd(Ai, Aj ) ≥ dsafe

∀i, j ∈ {1, 2, . . . , Nlinks} (15)

(self collisions)

where {Ai} is the collection of links of the robot, and {Oj} is the set of obstacles. These constraints can be relaxed to the following 1 penalty

Nlinks Nobs
|dsafe − sd(Ai, Oj )|+

i=1 j=1

Nlinks Nlinks

+

|dsafe − sd(Ai, Bj )|+

i=1 j=1

(16)

A single term of this penalty function |dsafe − sd(Ai, Oj)|+ is illustrated in Fig. 3.
Note that in practice, we do not consider all pairs of objects for the collision penalty (Eq. (16)) since the penalty corresponding to most pairs of faraway objects is zero. For computational efﬁciency, we query a collision checker for all pairs of nearby objects in the world with distance smaller than

a user-deﬁned distance dcheck between them where dcheck > dsafe, and formulate the collision penalty based on these pairs.
We can form a linear approximation to the signed distance
using the robot Jacobian and the notion of closest points. Let AA, BB ⊂ R3 denote the space occupied by A and B in local coordinates, and let pA ∈ AA and pB ∈ BB denote the local positions of contact points. FAw and FBw denote the objects’ poses.
To deﬁne Saturday, February 2, 13 closest points and our derivative approximation,
ﬁrst note that the signed distance function is given by the
following formula, which applies to both the overlapping and
non-overlapping cases:

sd({A, FAw}, {B, FBw}) =

max
nˆ =1

min
pA ∈A,

nˆ

·

(FAw pA

−

FBw pB )

pB ∈B

(17)

The closest points pA, pB and normal nˆ are deﬁned as a triple for which the signed distance is optimum, as described in Eq. (17). Equivalently, the contact normal nˆ is the direction of the minimal translation T (as deﬁned in Eqs. (11) and (12)), and pA and pB are a pair of points (expressed in local coordinates) that are touching when we translate A by T (Fig. 2).
Let’s assume that the pose of A is parameterized by the conﬁguration vector x (e.g., the robot’s joint angles), and B is stationary. (This calculation can be straightforwardly extended to the case where both objects vary with x, which is necessary
for dealing with self-collisions.) Then we can linearize the signed distance by assuming that the local positions pA, pB are ﬁxed, and that the normal n is also ﬁxed, in Eq. (17).
We ﬁrst linearize the signed distance with respect to the
positions of the closest points:

sdAB(x) ≈ nˆ · (FAw(x)pA − FBwpB)

(18)

By calculating the Jacobian of pA with respect to x, we can linearize this signed distance expression at x0:

∇x sdAB(x) ≈ nˆT JpA (x0)
x0

(19)

sdAB(x) ≈ sdAB(x0) + nˆT JpA (x0)(x − x0)

The above expression allows us to form a local approximation of one collision cost term with respect to the robot’s degrees of freedom. This approximation is used for every pair of nearby objects returned by the collision checker. After we linearize the signed distance, this cost can be incorporated into a quadratic program (or linear program) using Eq. (3).

6

Consider a moving object A and a static object B, for 0 ≤ t ≤ 1. The motion is free of collision if the sweptout volume ∪tA(t) does not intersect B. First suppose that A undergoes only translation, not rotation. (We will consider
rotations below.) Then the swept-out volume is the convex hull
of the initial and ﬁnal volumes [52]

A(t) = convhull(A(t), A(t + 1))

(20)

t∈[0,1]

Thus we can use the same sort of collision cost we described in Section IV-A, but now we calculate the signed distance between the swept-out volume of A and the obstacle B:

sd(convhull(A(t), A(t + 1)), B)

(21)

Fig. 4. Illustration of the non-differentiability of the signed distance function. Here, a square is rotated about its center by angle θ. The true function is shown by a solid line, and the linearization is shown by a dotted line. It is correct to ﬁrst-order in non-degenerate situations, however, in degenerate situations where the signed distance is non-differentiable, it gives an erroneous gradient estimate. Empirically, the optimization works well despite this issue.
Note that Eq. (19), which assumes that the normal nˆ and the closest points are ﬁxed, is correct to ﬁrst order in nondegenerate situations involving polyhedra. However, in degenerate cases involving face-face contacts, the signed distance is non-differentiable as a function of the poses of the objects, and the above formula deviates from correctness. Empirically, the optimization does not seem to get stuck at the points of non-differentiability. Fig. 4 illustrates this phenomenon for two squares. An interesting avenue for future work would be to develop approximations to the the signed distance penalty that provide a better local approximation.
B. Continuous-Time Trajectory Safety
The preceding discussion formulates the no-collisions constraint for a discretely-sampled trajectory. However, when such a trajectory is converted to a continuous-time trajectory for execution, e.g., by linear interpolation or cubic splines, the resulting continuous-time trajectory might have collisions between time steps—see Fig. 5.
We can modify the collision penalty from Section IV-A to give a cost that enforces the continuous-time safety of the trajectory (though it makes a geometric approximation). It is only twice as computationally expensive than the discrete-time collision cost of the previous section since it involves twice as many narrow-phase collision queries.

A(t+1)

A(t)

T

B

We perform the necessary signed distance computation without having to calculate the convex hull of shapes A(t), A(t + 1), since (as noted in Sec. IV-A) the signed distance cost can be calculated using the support mappings. In particular, the support mapping is given by

sconvhull(C,D)(v) =

sC (v) sD (v)

if sC (v) · v > sD(v) · v otherwise
(22)

Calculating the gradient of the swept-volume collision cost
is slightly more involved than discrete case described in Eqs. (18) and (19). Let’s consider the case where object A is moving and object B is stationary, as in Fig. 5. Let’s suppose that A and B are polyhedral. Then the closest point pswept ∈ convhull(A(t), A(t + 1)) lies in one of the faces of this polytope. convhull(A(t), A(t + 1)) has three types of faces: (1) all the vertices are from A(t), (2) all of the vertices are from A(t + 1), and (3) otherwise. Cases (1) and (2) occur when the deepest contact in the interval [t, t + 1] occurs at one of the endpoints, and the gradient is given by the discrete-time
formula. In case (3), we have to estimate how the closest point varies as a function of the poses of A at times t and t + 1.
We use an approximation for case (3) that is compu-
tationally efﬁcient and empirically gives accurate gradient
estimates. It is correct to ﬁrst order in non-degenerate 2D
cases, but it is not guaranteed to be accurate in 3D. Let pswept, pB, denote the closest points and normals between convhull(A(t), A(t + 1)) and B, respectively, and let nˆ be the normal pointing from B into A.
1) Find supporting vertices p0 ∈ A(t) and p1 ∈ A(t + 1) by taking the support map of these sets along the normal −nˆ.
2) Our approximation assumes that the contact point pswept is a ﬁxed convex combination of p0 and p1. In some cases, p0, pswept, and p1 are collinear. To handle the other cases, we set

α=

p1 − pswept p1 − pswept + p0 − pswept

,

(23)

where we make the approximation

Fig. 5. Illustration of swept volume for use in our continuous collision cost.

pswept(x) ≈ αp0 + (1 − α)p1

(24)

7

3) Calculate the Jacobians of those points

V. MOTION PLANNING BENCHMARK

Jp0 (xt0)

=

d dxt

p0,

Jp1 (xt0+1)

=

d dxt+1 p1

(25)

4) Similarly to Eq. (19), linearize the signed distance around the trajectory variables at timesteps t and t + 1

sdAB(xt, xt+1) ≈ sdAB(xt0, xt0+1) + αnˆT Jp0 (xt0)(xt − xt0) + (1 − α)nˆT Jp1 (xt0+1)(xt+1 − xt0+1) (26)

The preceding discussion assumed that the shapes undergo
translation only. However, the robot’s links also undergo
rotation, so the convex hull will underestimate the swept-out
volume. This phenomenon is illustrated in Fig. 6. We can
calculate a simple upper-bound to the swept-out volume, based on the amount of rotation. Consider a shape A undergoing translation T and rotation angle φ around axis kˆ in local coordinates. Let A(t) and A(t + 1) be the occupied space at the initial and ﬁnal times, respectively. One can show that if we expand the convex hull convhull(A(t), A(t + 1)) by darc = rφ2/8, where r is the maximum distance from a point on A to the local rotation axis, then the swept-out volume is contained inside.

Our evaluation is based on four test scenes included with the MoveIt! distribution — bookshelves, countertop, industrial, and tunnel scenes; and a living room scene imported from google sketchup. The set of planning problems was created as follows. For each scene we set up the robot in a number of diverse conﬁgurations. Each pair of conﬁgurations yields a planning problem. Our tests include 198 arm planning problems and 96 full-body problems (Fig. 7). We ran all the experiments on a machine with an Intel i7 3.5 GHz CPU. The complete source code necessary to reproduce this set of experiments or evaluate a new planner is available at https://github.com/joschu/planning benchmark.

Fig. 7. Scenes in our benchmark tests. Left and center: two of the scenes used for the arm planning benchmark. Right: a third scene, showing the path found by our planner on an 18-DOF full-body planning problem.

Fig. 6. Illustration of the difference between swept out shape and convex hull. The ﬁgure shows a triangle undergoing translation and uniform rotation. The swept-out area is enclosed by dotted lines, and the convex hull is shown by a thick gray line.
In summary, we can ensure continuous time safety by ensuring that for each time interval [t, t + 1]
sd(convhull(A(t), A(t + 1)), O) > dsafe + darc (27)
One could relax this constraint into a penalty as described in Sec. IV-A, by approximating φ(xt, xt+1). In practice, we ignored the correction darc, since it was well under 1 cm in all of the problems we considered.
The no-collisions penalty for the continuous-time trajectory safety is only twice as expensive as the discrete no-collisions penalty since we have to calculate the support mapping of a convex shape with twice as many vertices. As a result, the narrow-phase collision detection takes about twice as long. The upshot is that the continuous collision cost solves problems with thin obstacles where the discrete-time cost fails to get the trajectory out of collision. An added beneﬁt is that we can ensure continuous-time safety while parametrizing the trajectory with a small number of time steps, reducing the computational cost of the optimization.

We compared TrajOpt to open-source implementations of bi-directional RRT [23] and a variant of KPIECE [46] from OMPL/MoveIt! [4, 6], that is part of the ROS motion planning libraries. All algorithms were run using default parameters and post-processed by the default smoother used by MoveIt!. We also compared TrajOpt to a recent implementation of CHOMP [61] on the arm planning problems. We did not use CHOMP for the full-body planning problems because they were not supported in the available implementation.
Initialization: We tested both our algorithm and CHOMP under two conditions: single initialization and multiple initializations. For the single initialization, we used a straight line initialization in conﬁguration space by linearly interpolating between start and goal conﬁgurations. For multiple initializations, we used the following methodology.
Arm planning problems: Prior to performing experiments, we manually selected four waypoints W1, W2, W3, W4 in joint space. These waypoints were ﬁxed for all scenes and problems. Let S and G denote the start and goal states for a planning problem. Then we used the four initializations SW1G, SW2G, SW3G, SW4G, which linearly interpolate between S and Wi for the ﬁrst T /2 time-steps, and then linearly interpolate between Wi and G for the next T /2 timesteps.
Full-body planning problems: We randomly sampled the environment for base positions (x, y, θ) with the arms tucked. After ﬁnding a collision-free conﬁguration W of this sort, we initialized with the trajectory SW G as described above. We generated up to 5 initializations this way. Note that even though we initialize with tucked arms, the optimization typically untucks the arms to improve the cost.

8

success fraction avg. time (s)
avg. norm length

OMPL-RRTConnect
0.85 0.62 1.56

OMPL-LBKPIECE
0.76 1.30 1.61

CHOMP-HMC
0.65 4.91 2.04

CHOMP-HMC-Multi
0.83 9.27 1.97

TrajOpt
0.82 0.19 1.16

TABLE I Results on 198 arm planning problems for a PR2, involving 7 degrees of freedom.

TrajOpt-Multi
0.96 0.30 1.15

success fraction avg. time (s)
avg. norm length

OMPL-RRTConnect
0.41 20.3 1.54

OMPL-LBKPIECE
0.51 18.7 1.51

TrajOpt
0.73 2.2 1.06

TrajOpt-multi
0.88 6.1 1.05

TABLE II Results on 96 full-body planning problems for a PR2, involving 18 degrees of freedom (two arms, torso, and base).

Implementation details: Our current implementation of the continuous-time collision cost does not consider selfcollisions, but we penalized self-collisions at discrete times as described in Sec. IV-A. For collision checking, we took the convex hull of the geometry of each link of the robot, where each link is made of one or more meshes. The termination conditions we used for the optimization were (i) maximum of 40 iterations, (ii) minimum merit function improvement ratio of 10−4, (iii) minimum trust region size 10−4, and (iv) constant penalty scaling factor k = 10. We used the Bullet collision checker [7] for convex-convex collision queries. We used T = 11 timesteps for the arm and T = 41 timesteps for the full-body trajectories. The sampling-based planners were limited to 30 seconds on full-body planning problems.
Results: The results for arm planning are shown in Table I and for full-body planning are shown in Table II. We evaluated TrajOpt and compared it with other planners in terms of (1) average computation time for all successful planning runs computed over all problems, and (2) average normalized trajectory length over all problems that is computed as the average of the trajectory lengths normalized by dividing by the shortest trajectory length for that problem across all planners (value of 1 for a planner indicates that the shortest trajectory was found by the planner for all problem instances). TrajOpt solves a higher percentage of problems on this benchmark, is computationally more efﬁcient, and computes shorter trajectories on average. TrajOpt with multiple initializations outperformed the other approaches in both sets of problems. Multiple trajectory initializations are important to guide the optimization out of local minima and improves the success rate for both TrajOpt and CHOMP. Sec. IX presents a discussion of why multiple trajectory initializations are important.
VI. PHYSICAL EXPERIMENTS
A. Environment preprocessing
One of the main challenges in porting motion planning from simulation to reality is creating a useful representation of the environment’s geometry. Depending on the scenario, the geometry data might be live data from a Kinect or laser range ﬁnder, or it might be a mesh produced by an ofﬂine mapping procedure. We used our algorithm with two

different representations of environment geometry: (1) convex decomposition, and (2) meshes.
Convex decomposition: Convex decomposition seeks to represent a general 3D volume approximately as a union of convex bodies [27]. Hierarchical Approximate Convex Decomposition (HACD) [30] is a leading method for solving this problem, and it is similar to agglomerative clustering algorithms. It starts out with each triangle of a surface mesh as its own cluster, and it repeatedly merges pairs of clusters, where the choice of which clusters to merge is based on an objective function. The algorithm is terminated once a sufﬁciently small number of clusters is obtained. We used Khaled Mammou’s implementation of HACD, which, in our experience, robustly produced good decompositions, even on the open meshes we generated from single depth images. Example code for generating meshes and convex decompositions from Kinect data, and then planning using our software package TrajOpt, is provided in a tutorial at http://rll.berkeley.edu/trajopt.
Meshes: Our algorithm also can be used directly with mesh data. The mesh is viewed as a soup of triangles (which are convex shapes), and we penalize collision between each triangle and the robot’s links. For best performance, the mesh should ﬁrst be simpliﬁed to contain as few triangles as possible while faithfully representing the geometry, e.g. see [5].
B. Experiments
We performed several physical experiments involving a mobile robot (PR2) to explore two aspects of TrajOpt: (1) applying it to the “dirty” geometry data that we get from depth sensors such as the Kinect, and (2) validating if the full-body trajectories can be executed in practice. Our end-to-end system handled three full-body planning problems:
1) Grasp a piece of trash on a table and place it in a garbage bin under a table (one arm + base).
2) Open a door, by following the appropriate pose trajectory to open the handle and push (two arms + torso + base).
3) Drive through an obstacle course, where the PR2 must adjust its torso height and arm position to ﬁt through overhanging obstacles (two arms + torso + base).
The point clouds we used were obtained by mapping out the environment using SLAM and then preprocessing the map to obtain a convex decomposition. Videos of these experiments are available at http://rll.berkeley.edu/trajopt/ijrr.

9

VII. EXAMPLE APPLICATIONS WITH DIFFERENT CONSTRAINTS
A. Humanoid walking: Static stability
Fig. 8. The Atlas humanoid robot in simulation walking across the room while avoiding the door frame and other obstacles in the environment, and pushing a button. Each footstep was planned for separately using TrajOpt while maintaining static stability. Five time steps of the trajectory are shown.

the log map, where log(X) can be explicitly computed for a matrix X ∈ SE(3) as [33]:

log(X) =

Ip 03 0

,R = I

or

θωˆ A−1p 0T3 0

,R = I

(30)

where

θ

=

arccos

trace(R) 2

−

1

,

ωˆ =

2

1 sin

θ

(R

−

RT

)

(31)

A−1

=

I

−

1 2

θωˆ

+

2

sin

θ

− 2

θ(1 + sin θ

cos θ) ωˆ2

(32)

One can also impose partial orientation constraints. For
example, consider the constraint that the robot is holding a
box that must remain upright. The orientation constraint is an equality constraint, namely that an error vector (vxw, vyw)(x) vanishes. Here, v is a vector that is ﬁxed in the box frame
and should point upwards in the world frame.

We used TrajOpt to planning a statically stable walking

motion for the Atlas humanoid robot model. The degrees of

freedom include all 28 joints and the 6 DOF pose, where

we used the axis–angle (exp map) representation for the

orientation. The walking motion is divided into four phases (1)

left foot planted, (2) both feet planted (3) right foot planted,

and (4) both feet planted. We impose the constraint that the center of mass constantly lies above the convex hull of the planted foot or feet, corresponding to the zero-moment point

Fig. 9. Several stages of a box picking procedure, in which boxes are taken from the stack and moved to the side. The box, and hence the end effector of the robot arm, is subject to pose constraints.

stability criterion [53]. The convex support polygon is now Fig. 9 shows our algorithm planning a series of motions that

represented as an intersection of k half-planes, yielding k pick boxes from a stack. Our algorithm typically plans each

inequality constraints:

motion in 30 − 50 ms.
Saturday, February 2, 13

aixcm(θ) + biycm(θ) + ci ≤ 0, i ∈ {1, 2, . . . , k}, (28)
where the ground-projection of the center of mass (xcm, ycm) is a nonlinear function of the robot conﬁguration.
Using this approach, we use TrajOpt to plan a sequence of steps across a room, as shown in Fig. 8. Each step is planned separately using the phases described above. The robot is able to satisfy these stability and footstep placement constraints while ducking under an obstacle and performing the desired task of pushing a button.

B. Pose constraints

TrajOpt can readily incorporate kinematic constraints, for

example, the constraint that a redundant robot’s end effector is

at a certain pose at the end of the trajectory. A pose constraint

can be formulated as follows. Let Ftarg =

Rtarg ptarg 0T3 1

∈

SE(3) denote the target pose of the gripper, and let Fcur(x)

be the current pose. Then Ft−ar1gFcur(x) gives the pose error,

measured in the frame of the target pose. This pose error can

be represented as the six-dimensional error vector:

h(x) = log(Ft−ar1gFcur(x)) = (tx, ty, tz, rx, ry, rz) (29)

VIII. NEEDLE STEERING AND CHANNEL LAYOUT PLANNING
We formulate the curvature-constrained planning problem in 3D environments as a nonlinear, constrained optimization problem. Depending on the speciﬁc application, the trajectory may be required to have a constant curvature κmax for all time steps, as required for planning trajectories for bevel-tip ﬂexible needles, or a bounded curvature 0 ≤ κt ≤ κmax for each time step for given κmax, as required for planning curvatureconstrained channels within 3D-printed implants. Although the following formulation is speciﬁc to needle steering and channel planning, it can be easily generalized to other curvatureconstrained planning problems.

X0

Oi

Ptarget

X1

Xt

XT −1

XT

Oj

where (tx, ty, tz) is the translation part, and (rx, ry, rz) is the axis-angle representation of the rotation part obtained using

Fig. 10. A discretized curvature-constrained trajectory is parameterized as
{X0, . . . , Xt, . . . , XT }, where Xt ∈ SE(3) is the pose of the waypoint frame relative to a world coordinate frame at each time step t.

10

The state at each time step is denoted as Xt =

Rt pt 0T3 1

∈

SE(3), where where pt ∈ R3 is the position and Rt ∈ SO(3)

is the rotation matrix that encodes the orientation of the frame

relative to a world coordinate frame.

The trajectory optimization problem can then be stated as:

Objective: Given an entry zone Pentry and a target zone Ptarget, determine a locally optimal and curvature-constrained trajectory Xt : t ∈ T which starts from the entry zone and
reaches the target zone while avoiding obstacles.

Input: Obstacle deﬁnitions Oi ∈ O, an entry zone Pentry, a target zone Ptarget, the constant curvature or the maximum curvature κmax, and the discretization parameter T .
Output: Returns a feasible, collision-free trajectory Xt : t ∈ {1, . . . , T } with X0 ∈ Pentry and XT ∈ Ptarget, or reports
that no feasible trajectory can be found.

Metrics: For applications like medical needle steering, it is

important to address the issue of optimality of the computed

trajectories since sub-optimal trajectories might cause exces-

sive tissue damage during the procedure, leading to delayed

recovery times. We consider the following metrics in our work

to quantify plan optimality:

1) Minimizing the total needle insertion length: This metric

is relevant to procedures in vital organs such as the brain where

limiting tissue damage is important.

2) Minimizing the total twist: Unnecessary twisting of

the needle causes tissue damage and also induces torsion in

the needle shaft, which leads to errors while planning and

controlling the motion of the needle [49].

3) Maximizing the minimum clearance from obstacles:

Short trajectories often pass in close proximity to obstacles,

thereby increasing the likelihood of collisions. Trajectories that

have a greater minimum clearance from obstacles, on the other

hand, are safer because they are less likely to collide with

anatomical obstacles when deviations occur but tend to be

longer. This metric could be useful when obstacle avoidance

is critical but other tissue damage is manageable.

The optimization problem is formulated as follows:

min
X¯,U

α∆Cost∆ + αφCostφ + αOCostO,

(33a)

s.t. log((Xt · exp(wt∧) · exp(vt∧))−1 · Xt+1)∨ = 06,

(33b)

sd(Xt, Xt+1, Oi) ≥ dsafe + darc,

(33c)

X0 ∈ Pentry, XT ∈ Ptarget,

(33d)

− π ≤ φt ≤ π,

(33e)

κt = κmax or 0 ≤ κt ≤ κmax,

(33f)

T −1
∆ κt ≤ cmax for channel planning,
t=0

(33g)

where U is the set of all control variables and X¯ = {x¯0, . . . , x¯T } is the sequence of incremental twists.
The constraints and costs are described in detail below.
1) Kinematics constraint: We use a “stop-and-turn” strategy

1 for the kinematics model. At each time step t : 0 ≤ t ≤ T −1, we apply a rotation φt to the pose Xt and then propagate the frame by a distance ∆ to arrive at Xt+1. We require this distance to be the same for all time steps. See Fig. 11 for
illustration. For a feasible trajectory, the poses at adjacent time steps Xt and Xt+1 are related as:

Xt · exp(wt∧) · exp(vt∧) = Xt+1,

(34)

where wt = [ 0 0 0 0 0 φt ]T and vt = [ 0 0 ∆ ∆κt 0 0 ]T . We transform this constraint in SE(3) to a constraint in se(3) using the log map to get Eq. (33b).

yt+1 xt+1

Xt+1

zt+1 [x, y, z]T

∆

z

zt xt √ x2 + y2 yt

φt
Xt

[0,

0,

0]T

κt θ ≡ ∆κt

Fig. 11. Stop and turn strategy: Apply a rotation φt to the pose Xt at time step t and then propagate the frame by a distance ∆ to arrive at Xt+1.

2) No-collision constraint: We impose constraints (Eq.
(33c)) for the trajectory to be collision-free, where sd(Xt, Xt+1, Oi) is the signed distance between the trajectory segment in time interval [t, t + 1] and the ith obstacle Oi. We approximate the segment by the convex hull of the object (the
needle tip or a small segment on the channel) between time t and t + 1, and we account for the approximation error in rotation by adding an error correction term darc. Instead of numerically computing the gradient, we linearize the signed distance using the contact normal nˆ. The signed distance
linearization is given by

sd(Xt, Oi) ≈ sd(Xˆt, Oi) + nˆT Jpt (06)x¯,

(35)

where the Jacobian matrix Jpt (06) = [ Rˆt 03×3 ]. The expression for the Jacobian follows from the fact that we get pt = RˆtAp¯t + pˆt (Eqs. (7)–(10)), where A is deﬁned in the exponential map with respect to r and is the identity matrix for ¯r = 03. Hence

∂pt ∂ p¯ t

(06)

=

Rˆt,

and

∂pt ∂¯rt

(06)

=

03×3.

(36)

We include the continuous-time non-convex no-collisions constraint is included as a 1 penalty in the optimization, as described in Sec. IV-B.

1This is a natural choice for needle steering, since it corresponds to ﬁrst twisting the base of the needle, and then pushing it forward, which induces less damage than constantly twisting the needle tip while pushing it. This strategy also results in channels that are easier for catheters to go through.

11

3) Total curvature constraint: For channel planning, we impose a constraint (Eq. (33g)) on the total curvature of the trajectory. This is done to ensure that catheters carrying the radioactive source can be pushed through the channels [14]. We choose cmax = 1.57 rad for all of our experiments.
4) Costs: To penalize tissue damage for needle steering and to make the trajectory more efﬁcient for channel planning, we add costs on the total length of the trajectory and the twists to the objective at each time step:

T −1

Cost∆ = T ∆ and Costφ = φ2t .

(37)

t=0

For needle steering, we add an extra term to favor large minimum clearance from obstacles to deal with expected needle deﬂections:

CostO = − min sd(Xt, Xt+1, Oi). 0≤t≤T −1 Oi ∈O

(38)

Instead of directly optimizing over CostO, we insert an auxiliary variable dmin and reformulate the cost term as:

CostO = −dmin, dmin ≤ sd(Xt, Xt+1, Oi). (39)

The objective (Eq. (33a)) is a non-negative weighted sum of the costs above, where α∆, αφ, αO ≥ 0 are user-deﬁned coefﬁcients to leverage different costs. A relatively large αO, for instance, may result in trajectory with larger clearance from obstacles, at the expense of a longer trajectory.
Shooting vs. Collocation: For trajectory optimization problems, especially ones involving differential constraints, there are two ways to construct locally convex approximations of the costs and constraints for setting up the QP subproblem. Shooting-based methods ﬁrst integrate the current controls and then construct the convex approximation around the integrated trajectory, which is guaranteed to satisfy all differential constraints. Collocation-based methods, on the other hand, approximate the cost and constraints directly around the current solution, which might correspond to an infeasible trajectory that does not satisfy differential constraints.
In the context of optimization on SE(3), shooting-based methods satisfy the curvature constraints, but the integrated trajectory might violate the constraints on the entry zone and target zone. It is easier to satisfy constraints on the start and target zones with collocation-based methods but the differential curvature constraint is difﬁcult to satisfy. We refer the reader to [1] for details on these methods.

A. Simulation Experiments
We experimentally evaluated TrajOpt on two real-world applications involving medical needle steering and designing channel layouts for brachytherapy. We ran all the experiments on a machine with an Intel i7 3.5 GHz CPU.
1) Medical needle steering: We used an anatomical model of the human male pelvic region to simulate needle insertion in tissue for delivering radioactive doses to targets within the prostate. We considered randomly sampled targets within the prostate for our experiments. We set the entry zone to be

a 0.1 cm × 5 cm × 2.5 cm region on the perineum (skin) through which needles are typically inserted for needle-based
prostate procedures. The target zones were modeled as spheres
around the target points with radius 0.25 cm, within the range of average placement errors (≈ 0.63 cm) encountered during procedures performed by experienced clinicians [50]. The
average distance between the entry zone and the target zone is 10 cm and and we set κmax = 0.125cm−1. We used T = 10 time steps for our experiments, such that the step length was roughly 1cm. For the objective function, we used α∆ = αφ = 1, and we compared the planned trajectory with different choices of the clearance coefﬁcient αO. Figs. 12(a) and 12(b) show examples of planned trajectories with different values of αO = 1 and αO = 10.

(a)

(b)

Fig. 12. Changing the value of the parameter αO inﬂuences the clearance of the trajectory from obstacles in the environment. Zoomed in view of the male
prostate region (target inside prostate shown in red). (a) Smaller clearance from obstacles (Cowper’s glands) with αO = 1 resulting in a potentially unsafe trajectory. (b) Larger clearance from obstacles with αO = 10.

We compared the performance of shooting and collocation-

based methods for optimization. We also compared the per-

formance of TrajOpt with a sampling-based rapidly-exploring

random tree (RRT) planner [57]. The RRT planner was modi-

ﬁed to plan backwards starting from target zones because it is

easier to compute feasible constant curvature trajectories that

reach a larger entry region. Planning for a single needle: We analyzed the planned tra-
jectory for single needle insertion using 400 sampled points in

the prostate. For each task, we repeatedly ran the optimization

initialized by a perturbed solution of the previous run, and we allowed up to 5 reruns. We evaluated the performance of

collocation versus shooting in terms of the average running

time and percentage of solved problems for the converged

solutions. As shown in Table III, we observed that shooting

outperforms collocation in terms of the fraction of problems

solved and running times. Using a larger clearance coefﬁcient

results in trajectories farther away from obstacles, at the

expense of slightly longer paths. TrajOpt outperforms the RRT planner in terms of the

number of problems solved. The trajectories computed using

the RRT planner have a very high twist cost, which is a result

of the randomized nature of the planning algorithm. Since

the twist cost is directly correlated with tissue damage, the

trajectories computed using TrajOpt are preferable over those

computed by a randomized planner.

12

success fraction time (s)
path length twist cost clearance

RRT
0.67 9.8 ± 8.1 11.1 ± 1.5 34.9 ± 10.0 0.5 ± 0.4

Collocation αO = 1
0.76 1.8 ± 1.2 11.3 ± 1.4 1.4 ± 1.4 0.7 ± 0.5

TrajOpt

Shooting αO = 1

Collocation αO = 10

0.80

0.79

1.6 ± 1.7 1.9 ± 1.3

11.6 ± 1.7 11.9 ± 1.7

1.0 ± 1.0 1.6 ± 1.6

0.5 ± 0.3 1.3 ± 0.4

Shooting αO = 10
0.89 1.8 ± 1.7 13.1 ± 2.3 1.0 ± 1.0 1.2 ± 0.5

TABLE III Single needle planning: Sampling-based RRT planner versus TrajOpt.

Simulation: To evaluate the feasibility and performance of TrajOpt under uncertainty, we ran 100 simulations for a speciﬁc target with increasing noise levels. System uncertainty was modeled by perturbing the incremental twists with additive Gaussian noise. We assumed that the pose of needle is measured accurately by a Kalman ﬁlter or sensing equipment, and we re-planned after every time step based on the estimated state. We considered a simulation to be successful if it was both collision free and if it reached the target zone. To ensure path safety, we chose αO = 10 for all tasks. We examined the effect of increasing noise level on the success rate (Fig. 13).

100% 50%

Collocation w/ re-planning Shooting w/ re-planning Collocation open loop Shooting open loop

Success%

0% 0% 100% 200% 300% 400% Noise level%
Fig. 13. Effect of noise level on the success rate.

500%

Re-planning after each time step greatly increases the probability of success. Collocation consistently outperforms shooting in terms of success rate for all noise levels. Since shooting-based methods integrate the trajectory after each iteration of the optimization, the state at the last time step deviates from the target region, making it difﬁcult to ﬁnd a feasible solution. We also observed a signiﬁcant difference in the total running time for the simulation, where collocation takes 2.3 seconds on average, and shooting takes 6.7 seconds on average. This suggests that it might be easier to perform local error corrections to an existing trajectory using collocation as compared to shooting based methods. In this regard, TrajOpt can be considered as a replacement for local trajectory correction approaches suggested by [44, 38]. We do not consider comparison with the RRT planning method since it computes trajectories working backwards from the target and hence is not suitable for re-planning in the forward direction.
Planning for multiple needles: We analyzed the performance of TrajOpt for planning for 5 needle trajectories using 1000 sampled points within the prostate (200 trials). We computed multiple collision-free trajectories by planning them sequentially such that the computed trajectories were mutually collision-free. We compared the result of collocation versus

shooting-based strategies. For the multiple needle planning experiments, shooting offered an advantage over collocation in terms of computational time required to compute a feasible solution and the quality of trajectories computed. Fig. 1(e) shows planned trajectories for a single trial. Table IV summarizes our result, which shows that TrajOpt outperforms the RRT planner both in terms of computation time and the fraction of problems solved. The trajectories computed using the sampling-based RRT planner have a very high twist cost, which is also undesirable.

success fraction time (s)
path length twist cost clearance

RRT
0.48 50.0 ± 19.0 54.6 ± 3.1 168.3 ± 28.4 0.1 ± 0.08

TrajOpt Collocation Shooting

0.75

0.79

18.0 ± 9.0 15.3 ± 15.2

53.9 ± 2.5 3.8 ± 1.5 0.1 ± 0.03

56.5 ± 3.4 2.5 ± 1.8 0.1 ± 0.06

TABLE IV Multiple needle planning: Sampling-based RRT planner versus TrajOpt.

2) Channel layout planning: We considered a scenario where 3D-printed implant is prepared for treatment of OB/GYN tumors (both vaginal and cervical), as shown in Fig. 1(f). The implant was modeled as a cylinder of height 7 cm and radius 2.5 cm, with a hemisphere on top with radius 2.5cm. The implant was designed based on dimensions reported by Garg et al. [14]. We set the entry region to be the base of the implant. We require that the curvature along the path is at most 1cm−1 and that the total curvature on the trajectory (Eq. 33g) is at most 1.57. This constraint is necessary to ensure that catheters carrying the radioactive seed can be pushed through the channels. Instead of planning forward from the entry to the target, we planned backwards from the target to the entry zone using the shooting method, since the entry constraint is much easier to satisfy than the target constraint. Fig. 1(f) shows an optimized channel layout computed using our method.
The experiment results are summarized in Table V. We compared the performance of TrajOpt with a highly-optimized RRT-based planner [14]. Both the RRT-based approach and TrajOpt have a randomization aspect associated with them – while the RRT uses random sampling, our multi-trajectory planning procedure uses random perturbations to initialize the optimization. We solved the same problem 100 times to account for the random nature. TrajOpt is able to compute a feasible solution in almost all cases, whereas the RRT planner fails more often to ﬁnd a feasible solution and computes plans that have a higher cumulative path length and twist cost as compared to the solution computed using TrajOpt.

success fraction time (s)
path length twist cost

RRT
0.74 30.8 ± 17.9 41.3 ± 0.3 65.5 ± 8.4

TrajOpt
0.98 27.7 ± 9.8 38.9 ± 0.1 4.1 ± 1.1

TABLE V Channel layout planning: Sampling-based RRT planner versus TrajOpt.

13

(a)

(b)

x1 n2
x2

x3

n3

x4

(a)

x1 x2
x3 x4
(b)
n3 l3

x1

x2

x3

x4

x5

n2

l2

(c)

(d)

Fig. 14. Failure cases when using TrajOpt. (a) shows the initial path for full-body planning. (b) is the trajectory optimization outcome, which is stuck in an infeasible condition. (c) shows the initial path for the arm planning and the collision cannot be resolved in the ﬁnal trajectory shown in (d).

IX. IMPORTANCE OF TRAJECTORY INITIALIZATION
Trajectory optimization for motion planning is a challenging non-convex constrained optimization problem. Given an initial trajectory that may contain collisions and violate constraints, trajectory optimization methods such as TrajOpt and CHOMP can often quickly converge to a high-quality, locally-optimal solution. However, these methods suffer from a critical limitation: their performance heavily depends on the provided trajectory initialization and they are not guaranteed to ﬁnd a collision-free solution as the no-collisions constraints in the optimization are non-convex.
For instance, certain initializations passing through obstacles in unfavorable ways may get stuck in infeasible solutions and cannot resolve all the collisions in the ﬁnal outcome, as illustrated in Fig. 14. Fig. 15 shows some scenarios illustrating how trajectory optimization tends to get stuck in local optima that are not collision-free. It is important whether the signed distance normal is consistent between adjacent links or adjacent waypoints in an initial trajectory, else a bad initialization tends to have adjacent waypoints which push the optimization in opposing directions. As a consequence, these methods typically require multiple initializations. This explains why the use of multiple trajectory initializations performs better for challenging planning problems (Tables I, II).

X. SOURCE CODE AND REPRODUCIBILITY
All of our source code is available as a BSD-licensed open-source package called TrajOpt that is freely available here http://rll.berkeley.edu/trajopt. Optimization problems can be constructed and solved using the underlying C++ API or through Python bindings. Trajectory optimization problems

l1

(c)

(d)

Fig. 15. Illustration of typical reasons for trajectory optimization to get stuck in local optima that are not collision-free. (a) The gradient based on penetration depth may push waypoints in in-consistent directions. (b) The gradient based on distance ﬁelds has the same problem. (c) When a robot collides simultaneously with multiple obstacles, the robot may get stuck in an infeasible local optimum as different obstacles push the robot in different directions. (d) For a robot with multiple links, the gradient may result in inconsistent directions for different links. xi in these ﬁgures denote conﬁgurations at different time steps along the trajectory.

can be speciﬁed in JSON string that speciﬁes the costs, constraints, degrees of freedom, and number of timesteps. We are also working on a MoveIt plugin [4] so our software can be used along with ROS tools.
For robot and environment representation, we use OpenRAVE, and for collision checking we use Bullet, because of the high-performance GJK-EPA implementation and collision detection pipeline. Two different backends can be used for solving the convex subproblems: (1) Gurobi, a commercial solver, which is free for academic use [35]; and (2) BPMPD [31], a free solver included in our software distribution.
The benchmark results presented in this paper can be reproduced by running scripts provided at http://rll.berkeley.edu/ trajopt/ijrr. Various examples, including humanoid walking and arm planning with orientation constraints, are included with our software distribution.

XI. CONCLUSION
We presented TrajOpt, a trajectory optimization approach for solving robot motion planning problems. At the core of our approach is the use of sequential convex optimization with 1 penalty terms for satisfying constraints, an efﬁcient formulation of the no-collision constraint in terms of the signed distance, which can be computed efﬁciently for convex objects, and the use of support mapping representation to efﬁciently formulate the continuous-time no-collision constraints.

14

We benchmarked TrajOpt against sampling-based planners from OMPL and CHOMP. Our experiments indicate that TrajOpt offers considerable promise for solving a wide variety of high-dimensional motion planning problems. We also presented a discussion of the importance of trajectory initialization for optimization based approaches. The source code has been made available freely for the beneﬁt of the research community.

XII. ACKNOWLEDGEMENTS
We thank Jeff Trinkle, Dmitry Berenson, Nikita Kitaev, and anonymous reviewers for insightful discussions and comments on the paper. We thank Kurt Konolige and Ethan Rublee from Industrial Perception Inc. for supporting this work and providing valuable feedback. We thank Ioan Sucan and Sachin Chitta for help with MoveIt!, and we thank Anca Dragan, Chris Dellin, and Siddhartha Srinivasa for help with CHOMP. This research was supported in part by the National Science Foundation (NSF) under award # IIS-1227536: Multilateral Manipulation by Human-Robot Collaborative Systems, by Air Force Ofﬁce of Scientiﬁc Research (AFOSR) under Young Investigator Program (YIP) award # FA9550-12-1-0345, by a Sloan Fellowship, and by the Intel Science and Technology Center on Embedded Computing.

REFERENCES

[1] J.T. Betts. Practical methods for optimal control and estimation

using nonlinear programming, volume 19. Society for Industrial

& Applied Mathematics, 2010.

[2] J. Blanco. A tutorial on SE(3) transformation parameterizations

and on-manifold optimization. Technical report, University of

Malaga, 2010.

[3] O. Brock and O. Khatib. Elastic strips: A framework for motion

generation in human environments. Int. Journal of Robotics

Research, 21(12):1031–1052, 2002.

[4] S. Chitta, I. Sucan, and S. Cousins. Moveit![ROS topics].

Robotics & Automation Magazine, IEEE, 19(1):18–19, 2012.

[5] P. Cignoni, C. Montani, and R. Scopigno. A comparison of

mesh simpliﬁcation algorithms. Computers & Graphics, 22(1):

37–54, 1998.

[6] B. Cohen, I. Sucan, and S. Chitta. A generic infrastructure for

benchmarking motion planners. In Proc. Int. Conf. on Intelligent

Robots and Systems (IROS), pages 589–595, 2012.

[7] E. Coumanns.

Bullet physics library, 2012.

www.bulletphysics.org.

[8] A.D. Dragan, N.D. Ratliff, and S.S. Srinivasa. Manipulation

planning with goal sets using constrained trajectory optimiza-

tion. In Proc. Int. Conf. Robotics and Automation (ICRA), pages

4582–4588, 2011.

[9] V. Duindam, R. Alterovitz, S. Sastry, and K. Goldberg. Screw-

based motion planning for bevel-tip ﬂexible needles in 3D

environments with obstacles. In Proc. Int. Conf. Robotics and

Automation (ICRA), pages 2483–2488, 2008.

[10] V. Duindam, J. Xu, R. Alterovitz, S. Sastry, and K. Goldberg.

Three-dimensional motion planning algorithms for steerable

needles using inverse kinematics. Int. Journal of Robotics

Research, 29(7):789–800, 2010.

[11] J.A. Engh, D.S. Minhas, D. Kondziolka, and C.N. Riviere.

Percutaneous intracerebral navigation by duty-cycled spinning

of ﬂexible bevel-tipped needles. Neurosurgery, 67(4):1117–

1122, 2010.

[12] T. Erez and E. Todorov. Trajectory optimization for domains with contacts using inverse dynamics. In Proc. Int. Conf. on Intelligent Robots and Systems (IROS), pages 4914–4919, 2012.
[13] C. Ericson. Real-time collision detection. Morgan Kaufmann, 2004.
[14] A. Garg, S. Patil, T. Siauw, J. Cunha, I-C. Hsu, P. Abbeel, J. Pouliot, and K. Goldberg. An algorithm for computing customized 3d printed implants with curvature constrained channels for enhancing intracavitary brachytherapy radiation delivery. In IEEE Int. Conf. on Automation Science and Engg. (CASE), pages 3306–3312, 2013.
[15] E. Gilbert, D. Johnson, and S. Keerthi. A Fast Procedure for Computing the Distance between Complex Objects in ThreeDimensional Space. IEEE Journal of Robotics and Automation, 4(2):193–203, 1988.
[16] J. Han, S Datta, and S Ekkad. Gas turbine heat transfer and cooling technology. CRC Press, 2013.
[17] K. Hauser and V. Ng-Thow-Hing. Fast smoothing of manipulator trajectories using optimal bounded-acceleration shortcuts. In Proc. Int. Conf. Robotics and Automation (ICRA), pages 2493– 2498, 2010.
[18] M. Hwangbo, J. Kuffner, and T. Kanade. Efﬁcient two-phase 3D motion planning for small ﬁxed-wing UAVs. In Proc. Int. Conf. Robotics and Automation (ICRA), pages 1035–1041, 2007.
[19] M. Kallmann, A. Aubel, T. Abaci, and D. Thalmann. Planning collision-free reaching motions for interactive object manipulation and grasping. Computer Graphics Forum, 22(3):313–322, 2003.
[20] S. Karaman and E. Frazzoli. Sampling-based algorithms for optimal motion planning. Int. Journal of Robotics Research, 30 (7):846–894, 2011.
[21] L. Kavraki, P. Svestka, J-C Latombe, and M.H. Overmars. Probabilistic roadmaps for path planning in high-dimensional conﬁguration spaces. IEEE Transactions on Robotics and Automation, 12(4):566–580, 1996.
[22] O. Khatib. Real-time obstacle avoidance for manipulators and mobile robots. Int. Journal of Robotics Research, 5(1):90–98, 1986.
[23] J. Kuffner and S. LaValle. Rrt-connect: An efﬁcient approach to single-query path planning. In Proc. Int. Conf. Robotics and Automation (ICRA), volume 2, pages 995–1001, 2000.
[24] R. Lampariello, D. Nguyen-Tuong, C. Castellini, G. Hirzinger, and J. Peters. Trajectory planning for optimal robot catching in real-time. In Proc. Int. Conf. Robotics and Automation (ICRA), pages 3719–3726, 2011.
[25] S. LaValle. Planning algorithms. Cambridge University Press, 2006.
[26] S. Lengagne, J. Vaillant, E. Yoshida, and A. Kheddar. Generation of whole-body optimal dynamic multi-contact motions. Int. Journal of Robotics Research, 2013, (to appear).
[27] J.M. Lien and N.M. Amato. Approximate convex decomposition of polyhedra. In Proc. ACM symposium on Solid and physical modeling, pages 121–131, 2007.
[28] M. Likhachev and A. Stentz. R* search. In Proc. National Conference on Artiﬁcial Intelligence (AAAI), pages 344–350, 2008.
[29] M. Likhachev, G. Gordon, and S. Thrun. ARA*: Anytime A* with provable bounds on sub-optimality. In Advances in Neural Information Processing Systems (NIPS), 2003.
[30] K. Mamou and F. Ghorbel. A simple and efﬁcient approach for 3D mesh approximate convex decomposition. In IEEE Int. Conf. on Image Processing (ICIP), pages 3501–3504, 2009.
[31] C. Me´sza´ros. The BPMPD interior point solver for convex quadratic problems. Optimization Methods and Software, 11 (1-4):431–449, 1999.
[32] I. Mordatch, E. Todorov, and Z. Popovic. Discovery of complex behaviors through contact-invariant optimization. ACM SIG-

15

GRAPH, 31(4):43, 2012. [33] Richard M Murray and S Shankar Sastry. A mathematical
introduction to robotic manipulation. CRC press, 1994. [34] J. Nocedal and S.J. Wright. Numerical optimization. Springer
Verlag, 1999. [35] Gurobi Optimization. Gurobi optimizer reference manual.
http://www.gurobi.com, 2012. [36] J. Pan, L. Zhang, and D. Manocha. Collision-free and smooth
trajectory computation in cluttered environments. Int. Journal of Robotics Research, 31(10):1155–1175, 2012. [37] S. Patil and R. Alterovitz. Interactive motion planning for steerable needles in 3D environments with obstacles. In Int. Conf. Biomedical Robotics and Biomechatronics (BioRob), pages 893–899, 2010. [38] Q. Pham. Fast trajectory correction for nonholonomic mobile robots using afﬁne transformations. Robotics: Science and Systems (RSS), 2011. [39] M. Posa and R. Tedrake. Direct trajectory optimization of rigid body dynamical systems through contact. In Algorithmic Foundations of Robotics X, pages 527–542. Springer, 2013. [40] S. Quinlan and O. Khatib. Elastic bands: Connecting path planning and control. In Proc. Int. Conf. Robotics and Automation (ICRA), pages 802–807, 1993. [41] N. Ratliff, M. Zucker, J.A. Bagnell, and S. Srinivasa. CHOMP: Gradient optimization techniques for efﬁcient motion planning. In Proc. Int. Conf. Robotics and Automation (ICRA), pages 489– 494, 2009. [42] K. Reed, A. Majewicz, V. Kallem, R. Alterovitz, K. Goldberg, N. Cowan, and A. Okamura. Robot-assisted needle steering. IEEE Robotics & Automation Magazine, 18(4):35–46, 2011. [43] J. Schulman, J. Ho, A. Lee, H. Bradlow, I. Awwal, and P. Abbeel. Finding locally optimal, collision-free trajectories with sequential convex optimization. In Robotics: Science and Systems (RSS), 2013. [44] K.M. Seiler, S.P.N. Singh, S. Sukkarieh, and H. Durrant-Whyte. Using Lie group symmetries for fast corrective motion planning. Int. Journal of Robotics Research, 31(2):151–166, 2012. [45] M. Shanmugavel, A. Tsourdos, R. Zbikowski, and B. White. 3D path planning for multiple UAVs using Pythagorean hodograph curves. In AIAA Guidance, Navigation, and Control Conference, pages 20–23, 2007. [46] I.A. Sucan and L.E. Kavraki. Kinodynamic motion planning by interior-exterior cell exploration. In Algorithmic Foundation of Robotics VIII, pages 449–464. Springer, 2009. [47] I.A. Sucan, M. Moll, and L.E. Kavraki. The open motion planning library. Robotics & Automation Magazine, IEEE, 19 (4):72–82, 2012. [48] H.J. Sussmann. Shortest 3-dimensional paths with a prescribed curvature bound. In IEEE Conf. on Decision and Control, volume 4, pages 3306–3312, 1995.

[49] J. Swensen and N.J. Cowan. Torsional dynamics compensation enhances robotic control of tip-steerable needles. In Proc. Int. Conf. Robotics and Automation (ICRA), pages 1601–1606, 2012.
[50] R. Taschereau, J. Pouliot, J. Roy, and D. Tremblay. Seed misplacement and stabilizing needles in transperineal permanent prostate implants. Radiotherapy and Oncology, 55(1):59–63, 2000.
[51] Y. Tassa, T. Erez, and E. Todorov. Synthesis and stabilization of complex behaviors through online trajectory optimization. In Proc. Int. Conf. on Intelligent Robots and Systems (IROS), pages 4906–4913, 2012.
[52] G. van den Bergen. Proximity Queries and Penetration Depth Computation on 3D Game Objects. In Game Developers Conference (GDC), 2001.
[53] M. Vukobratovic´ and B. Borovac. Zero-moment pointthirty ﬁve years of its life. Int. Journal of Humanoid Robotics, 1(1):157–
173, 2004. [54] C.W. Warren. Global path planning using artiﬁcial potential
ﬁelds. In Proc. Int. Conf. Robotics and Automation (ICRA), pages 316–321, 1989. [55] R. J. Webster III, J. S. Kim, Noah J. Cowan, G. S. Chirikjian, and Allison M. Okamura. Nonholonomic modeling of needle steering. Int. Journal of Robotics Research, 25(5-6):509–525, 2006. [56] A. Werner, R. Lampariello, and C. Ott. Optimization-based generation and experimental validation of optimal walking trajectories for biped robots. In Proc. Int. Conf. on Intelligent Robots and Systems (IROS), pages 4373–4379, 2012. [57] J. Xu, V. Duindam, R. Alterovitz, and K. Goldberg. Motion planning for steerable needles in 3D environments with obstacles using rapidly-exploring random trees and backchaining. In IEEE Int. Conf. on Automation Science and Engg. (CASE), pages 41–46, 2008. [58] J. Xu, V. Duindam, R. Alterovitz, J. Pouliot, J. A. Cunha, I. Hsu, and K. Goldberg. Planning ﬁreworks trajectories for steerablemedical needles to reduce patient trauma. In Proc. Int. Conf. on Intelligent Robots and Systems (IROS), pages 4517– 4522, 2009. [59] G. Yang and V. Kapila. Optimal path planning for unmanned air vehicles with kinematic and tactical constraints. In IEEE Conf. on Decision and Control (CDC), volume 2, pages 1301–1306, 2002. [60] K. Yang and S. Sukkarieh. An analytical continuous-curvature path-smoothing algorithm. IEEE Trans. on Robotics, 26(3):561– 568, 2010. [61] M. Zucker, N. Ratliff, A.D. Dragan, M. Pivtoraiko, M. Klingensmith, C.M. Dellin, J.A. Bagnell, and S.S. Srinivasa. CHOMP: Covariant hamiltonian optimization for motion planning. Int. Journal of Robotics Research, 2012.

16

