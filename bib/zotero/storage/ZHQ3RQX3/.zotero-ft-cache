108,

IEEE TRANSACTIONS ON COMPUTERS, VOL. c-32, NO. 2, FEBRUARY 1983

Gordon K. Lin (S'78-M'80) was born in Taipei, Taiwan, Republic of China in 1951. He received
the B.S. degree from National Taiwan University, Taipei, in 1973, the M.S. degree from the State
University of New York, Stony Brook, in 1976 and the Ph.D. degree from the Illinois Institute of
Technology, Chicago, in 1980, all in electrical engineering.
From 1975 to 1976 he was a Teaching Assistant of Electrical Engineering at the State University
of New York at Stony Brook. From 1976 to 1979 he was a Teaching Assistant of Electrical Engineering at the Illinois Institute of Technology. From May 1977 to March 1980 he was also with the Association of American Railroad, Research Center, Chicago, IL, where he participated in the track circuit analysis project. Since March 1980 he has been with Bell Laboratories, Naperville, IL. His current interests include digital signal processing, microprocessor system design, and fault diagnosis.

Premachandran R. Menon (M'70) received the
B.Sc. degree from Banaras Hindu University, Ba-
naras, India, in 1954, and the Ph.D. degree from the University of Washington, Seattle, in 1963,
both in electrical engineering.
From 1957 to 1963 he was with the Department
of Electrical Engineering, University of Washington, where he became an Acting Assistant Professor in 1962. He joined the Computing Techniques Research Department of Bell Laboratories, Mur-
ray Hill, NJ in 1963 and transferred to Bell Labo-
ratories, Naperville, IL in 1971, where he is involved in developing a digital simulation and test generation system. He is a coauthor of Fault Detection in Digital Circuits (Englewood Cliffs, NJ: Prentice-Hall, 1971) and Theory and Design ofSwitching Circuits (Woodland Hills, CA: Computer Science, 1975).

Spatial Planning: A Configuration Space Approach
TOMAS LOZANO-PEREZ

Abstract-This paper presents algorithms for computing constraints on the position of an object due to the presence ofother objects. This problem arises in applications that require choosing how to arrange or how to move objects without collisions. The approach presented here is based on characterizing the position and orientation of an object as a single point in a configuration space, in which each coordinate represents a degree of freedom in the position or orientation of the object. The configurations forbidden to this object, due to the presence of other objects, can then be characterized as regions in the configuration space, called configuration space obstacks. The paper presents algorithms for computing these configuration space obstacles when the objects are polygons or polyhedra.
Index Terms-Computational geometry, obstacle avoidance, robotics.
I. INTRODUCTION
INCREASINGLY, computer applications deal with models of two- and three-dimensional objects. Partly because of
this, there has been rapid growth of interest in efficient algo-
Manuscript received August 15, 1980; revised June 29, 1981 and June 15, 1982. This work was supported in part by the Office of Naval Research under Contract N00014-81 -K-0334 and in part by the Defense Advanced Research Projects Agency under Office of Naval Research Contracts N00014-80-C0505, NOOOI 4-82-K-0494.
The author is with the Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, MA 02139.

rithms for geometric problems. For example, research has focused on algorithms for 1) computing convex hulls [16], [32], 2) intersecting convex polygons and polyhedra [6], [27], [36], [38], 3) intersecting half-spaces [11], [33] 4) decomposing polygons [35], and 5) closest-point problems [37].I Another class of geometric problems involves placing an object among other objects or moving it without colliding with nearby objects. We call this class of problems: spatial planning problems. The following are representative applications where spatial planning plays an important role:
1) the layout of templates on a piece of stock [1]-[3], [13] so as to minimize the area of stock required:
2) machining a part using a numerically controlled machine tool [50], which requires plotting the path of one or more cutting surfaces so as to produce the desired part;
3) the layout of an IC chip [48] to minimize area, subject to geometric design constraints;
4) automatic assembly using an industrial robot [22], [23], [43], which requires grasping objects, moving them without collisions, and ultimately bringing them into contact.
One common spatial planning problem is to determine where an object A can be placed, inside some specified region
R, so that it does not collide with any of the objects Bj already
I The references cited here are representative of the current literature; they are by no means a complete survey.

0018-9340/83/0200-0108$01.00 © 1983 IEEE

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

I,OZANO-PEREZ: SPATIAL PLANNING

1-09

placed there. We call this the Findspace problem. Finding where to place another suitcase in the trunk of a car is an ex-
ample of Findspace, where the new suitcase is A, the previous
suitcases are the Bj, and the inside of the trunk is R. A related
problem is to determine how to move A from one location to
another without causing collisions with the Bj. We call this the
Findpath problem. For example, moving the suitcase men-
tioned above from its initial position outside the trunk to the desired position in the trunk, requires computing a path for the suitcase (and the mover's arms) that avoids the rest of the car. These two geometric problems, Findspace and Findpath, are the subject of this paper. Previous work on Findspace and Findpath is surveyed in Section VIII.
Findspace and Findpath can be defined more formally as follows.
Definition: Let R be an object that completely contains kB
other, possibly intersecting, objects Bj.
1) Findspace-Find a position for A, inside R, such that
for all Bj, A n Bj = 0. This is called a safe position.
2) Findpath -Find a path for A from position s to position g such that A is always in R and all positions of A on the path are safe. This is called a safe path.
Throughout this paper, the objects R and Bj are fixed con-
vex polyhedra (or polygons). We take A to be the set union of kA (possibly intersecting) convex polyhedra (or polygons) Ai. For example, A may be a convex decomposition of a nonconvex polyhedron [35]. Fig. 1 illustrates the definitions of Findspace and Findpath for convex polygons.
The algorithm presented here for the Findspace and Findpath problems has two main steps: 1) building a data structure that captures the geometric constraints and 2) searching the data structure to find the solution. In this paper we focus on algorithms for constructing the appropriate data structure. In this sense, the approach is similar to many geometric search algorithms, for example, the Voronoi polygon approach to closest-point problems [37]. In the Findspace and Findpath algorithms described here, we build geometric objects, called configuration space obstacles, that represent all the positions
of the object A that cause collisions with the Bj. Given these
objects, Findspace and Findpath correspond to the simpler problems of finding a single point (a position of A) or a path (a sequence of positions of A), outside of the configuration space obstacles. The advantage of this formulation is that the intersection of a point relative to a set of objects is easier to deal with than the intersection of objects among themselves.
Representing the positions of rigid objects requires specifying all their degrees of freedom, both translations and rotations. We will use the notion of configuration to unify our treatment of degrees of freedom. The configuration of a polyhedron is a set of independent parameters that characterize
the position of every point2 in the object. The configuration of
2 In what follows, all geometric entities-points, lines, edges, planes, faces, and objects-will be treated as (infinite) sets of points. All of these entities will be in some Rn, an n-dimensional real Euclidean space. a, b, x, and y shall
denote points of Bn, as well as the corresponding vectors. A, B, and C shall denote sets of points in _n, while I and K shall denote sets of integers. y, 0,
and ,B, shall denote reals, while i,j, k, 1, m, n shall be used for integers. The
coordinate representation of a point c e Bn, shall be c = ('yi) = (y1, * * ,
flYn)-

R
B3 9
.---
Fig. 1. R, Bj, and A for Findspace and Findpath problems in two dimensions.
(a) The Findspace problem is to find a configuration for A where A does
not intersect any of the Bj. (b) The Findpath problem is to find a path for
A from s to g that avoids collisions with the Bj.
a polyhedron is defined relative to an initial configuration. In this initial configuration, by convention, a fixed vertex of the polyhedron coincides with the origin of the global coordinate frame. For a polyhedron A, this vertex is called the reference vertex ofA, or rvA.
The number of parameters required to specify the configuration of a k-dimensional polyhedron, A, relative to its initial
configuration, is d, where d = k + (2) [7, p. 10]; k parameters are required to specify the position of rvA in N k and (2) are
required to specify the orientation3 of A. Thus, the configuration of A can be regarded as a point x E j? d; this d-dimensional space of configurations of A is denoted CspaceA. A in
configuration x is (A)x; A in its initial configuration is (A)o.
When an object's configuration is fixed, e.g., the Bj mentioned
earlier, we leave it unspecified. If A is a polygon in ]2, the configuration of A is specified
by (x, y, 0), where (x, y) is the position of rVA and 0 is the rotation of A, about rvA, relative to (A)O. That is, for polygons in ]2, k = 2, configurations are elements of ]I3, d = 2 + 1. If the orientation of A is fixed, (x, y) alone is sufficient to specify the polygons configuration; therefore, CspaceA is simply the (x, y) plane. If A is a polyhedron in ]?3, k = 3, the configurations of A are elements of j76, d = 3 + 3. That is, three translations and three rotations are needed to specify the position and orientation of a rigid three-dimensional object [7].
Not all possible configurations in CspaceA represent legal configurations of A; in particular, configurations of A where
A n Bj 0 are illegal because they would cause collisions.
3 The relative rotation of one coordinate system relative to another can be
(k) specified in terms of angles usually referred to as Euler angles [7]. These
angles indicate the magnitude of three successive rotations about specified axes. Many conventions for the choice of axes exist, any of which is suitable for our purposes.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

110
S

IEEE TRANSACTIONS ON COMPUTERS, VOL. C-32, NO. 2, FEBRUARY 1983 ~~~~~~~~~~~XrvA

Fig. 2. The CspaceA obstacle due to B, for fixed orientation of A.

Fig. 3. The Findpath problem and its formulation using the COt(Bj). The
shortest collision-free paths connect the origin and the destination via the

vertices of the COY(Bj) polygons. These illegal configurations are the result of a mapping of the

B1 into CspaceA. This mapping exploits two fundamental properties of objects: 1) their rigidity, which allows their configurations to be characterized by a few parameters and 2) their solidity, which requires that a point not be inside more than one object.
Definition: The CspaceA obstacle due to B, denoted
COA (B), is defined as follows:

the shortest4 safe paths for A are piecewise linear paths connecting the start and the goal configurations via the vertices
of the CON(Bj) polygons; see Fig. 3. Therefore, Findpath can
be formulated as a graph search problem. The graph is formed
by connecting all pairs of COZ(Bj) vertices (and the start and
goal) that can "see" each other, i.e., can be connected by a straight line that does not intersect any of the obstacles. The

COA (B) E{x E CspaceA I (A)X n B 0}.
Thus, if x E COA (B) then (A), intersects B, therefore x is not
safe. Conversely, any configuration x 0 COA (Bj) (for all objects Bj) is safe. If A is a convex polygon with fixed orien-
tation, the presence of another convex polygon B constrains the configuration of A, in this case simply the position of rvA, to be outside of COA (B), a larger convex polygon, shown as the shaded region in Fig. 2. The choice of a different vertex as rvA would result in translating COA (B) relative to B in the
figure.
Just as COA (B) defines those configurations for which A intersects B, CIA (B) defines those configurations for which A is completely inside B.
Definition: The CspaceA interior of B, denoted CIA (B), is defined as follows:

shortest path from the start to the goal in this visibility graph
(Vgraph) is the shortest safe path for A among the Bj [24].
This algorithm solves two-dimensional Findpath problems when the orientation of A is fixed, but the paths it finds are very susceptible to inaccuracies in the object model. These paths touch the CspaceA obstacles; therefore, if the model were exact, an object moving along this type of path would just touch the obstacles. Unfortunately, an inaccurate model or a slight error in the motion may result in a collision. Furthermore, the Vgraph algorithm does not find optimal paths among threedimensional obstacles [24]. Alternative techniques for pathfinding are treated in [23].
Here is a brief summary of the rest of the paper. Section II
presents algorithms for computing COY(B). Section III
characterizes COY0(B), the CspaceA obstacle for polygons
that are allowed to rotate. Section IV describes an algorithm
for computing COYZ(B), the CspaceA obstacle for polyhedra

CIA(B) Ix E CspaceA (A)X BJ.

with fixed orientation. Section V characterizes COA (B), the

CspaceA obstacle for polyhedra that are allowed to rotate.

Clearly, CIA (B) C COA (B). Moreover, it is easy to see that Section VI deals with slice projection, an approximation

for A to be inside B, it must be outside of B's complement. technique for higher dimensional CspaceA obstacles, for ex-

Therefore, letting -X represent the complement of the set X, ample, those obtained when a polyhedron is allowed to rotate.

CIA (B) = -COA (-B).

Section VII discusses the extensions to the Findspace and

A superscript to COA (B) and CIA (B) will be used to indi- Findpath algorithms needed to plan the motions of industrial

cate the coordinates of the configurations in the sets, e.g., robots. Section VIII discusses related work in spatial plan-

CON'(B) and COtt(B) denote sets of (x, y) and (x, y, 0) ning.

values, respectively. When no superscript is used, as in

COA(B), we mean sets of configurations in the complete

II. COMPUTING COY(B)

CspaceA for a polyhedron of A's dimension, e.g., Y?6 for a three-dimensional polyhedron.
Using the definitions of Cspace obstacle and Cspace interior, Findspace and Findpath can be expressed as equivalent problems that involve placing one point, the configuration of
A, relative to the CspaceA objects COA (Bj) and CIA (R). In-
general, these problems are equivalent to finding either a single configuration of A or a connected sequence of configurations of A (a path), outside all of the COA (B1), but inside CIA (R)

The crucial step in the Cspace approach to Findspace and
Findpath is computing the CspaceA obstacles for the Bj. Thus
far, we have only provided an implicit definition of COA (B);
we now provide, in Theorem 1, a characterization of COY(B)
and CIG(B) in terms of set sums that will lead us to an efficient algorithm for computing CspaceA obstacles.
Set sum, set difference, and set negation are defined on sets of points, eqivalently vectors, in Sin as follows:

If A and all of the B1 are polygons and if the orientation of 4 This assumes Euclidean distance as a metric. For the optimality conditions

CO¶Y4(Bj) A is fixed, then the

are also polygons. In that case, using a rectilinear (Manhattan) metric, see [19].

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

LOZANO-PEREZ: SPATIAL PLANNING

III

Fig. 4. Illustration of Theorem 1. Any location of rvA, denoted c, for which A and B have a point in common (expressible as b and a'), can be expressed
as c = b - a'. Therefore, COY(B) = B e (A)o.

7n(A,U)
I//M\\
/

7C AGO, u)
.+ b

.. /

I

X P.
- Ii\ 7Ctm.u)

Fig. 5. Illustration for Lemma 1.

A @DB = la + bja E A, b e B)
A e B = la-bja e A, b E B}
eA =f-aa s A.
If a set A consists of a single point a, then a S B = la) E B =
A E B. Also, A e B = A CD (EB). Note that, typically A S
A {I2aIa e A} andA EA $ 0,althoughA SB = BS
A. We can characterize the CspaceA obstacle for objects with
fixed orientation as a set difference of the objects' point sets:
Theorem 1: For A and B, sets in B2, COY(B) = B e
(A)o.
Proof: If c is an (x, y) configuration of A, then (A)c = c S (A)o. Therefore, if a E (A), then there exists a' E (A)o such that a = c + a'; see Fig. 4. Thus, if b E B n (A), and therefore b E (A), then, for some a' E (A)o, b = c + a' and
therefore c = b - a'. Clearly, the converse is also true. U This theorem extends naturally to higher dimensions, e.g.,
COYZ'(B), as long as the orientation of A is fixed. If A and B are convex, then A S B and A e B are also
convex [16, p. 9]; therefore COY(B) is convex. In fact, if A
and B are convex polygons,'then COY(B) is also a convex
polygon. We can now use well-known properties of convex polygons and the set sum operation [5] to state an O(n) algo-
rithm for computing COY (B) when A and B are convex n-
gons.
Let ir(A, u) denote the supporting line [5] of A with outward normal u. All of A is in one of the closed half-spaces bounded by ir(A, u) and u points away from the interior of A. ir(A, u) n A is the set of boundary points of A on the supporting line.
Lemma 1 [5]: If A and B are convex sets and u is an arbitrary unit normal, then
ir(A S B, u) n (A S B)
= (w(A, u) n A) a (ix(B, u) n B). (1)
Fig. 5 illustrates this lemma. Lemma 2[5]:
a) Let s(al, a2) be a line segment and b a point, then s(al, a2) S b = s(aI + b, a2 + b) is a line segment parallel to s(ai, a2) and of equal length. See Fig. 6(a).
b) Let s(a1, a2) and s(bi, b2) be parallel line segments such that (a2 - a,) = k(b2 -b1) for k > 0. Then s(ai, a2) S s(b1,

a,+ b2

a2+ bj

U2

a,

ab2 ab + b

a,+ b
\a, \\b,

al

Fig. 6. Illustration for Lemma 2.

b2) = s(aI + bI, a2 + b2) and the length of the sum is the sum
of the lengths of the summands. See Fig. 6(b).
Theorem 2: For A a convex n-gon and B a convex m-gon,
CO7(B) can be computed in time O(n + m).
Proof: For a polygon P, assume the jth edge, s%(v, v1+ 1),
makes the angle 0j with the x-axis. If O(u) is the angle u makes
with the x axis, then

Vj,(V.
ir(P, u) n P = s(v1, 1j+ 1),
V+ I ,

if 0j-I <0(U) <Oj
if 0(u) = fj if 0j < 0(u) < j+1.

We now apply Lemmas 1 and 2. Depending on the angle
0(u), each term on the right-hand side of (1) is either a line
segment (edge) or a single point (vertex). It follows from Lemma 2 that the term on the left of (1) is one of:
a) a new vertex, when two vertices are combined; b) a displaced edge, when an edge and a vertex are combined (Lemma 2a); c) an edge, corresponding to a pair of displaced end-to-end edges, when two edges are combined (Lemma 2b). As u rotates counterclockwise, the boundary of A CD B is formed by joining a succession of these elements. Note that, because of the convexity of A and B, each edge is encountered exactly once [25, p. 13]. Polygons are stored as lists of vertices in the same order as they are encountered by the counterclockwise sweep of u. This is equivalent to a total order on the edges, based on the angle that the edge makes with the x axis. These lists for A and B can be merged into a single total order on the angle in linear time, as they are traversed. At each step, we construct a new vertex (edges need not be represented explicitly) by the method indicated in the lemmas. The time for constructing the new vertices is bounded by a constant, since it involves at most two

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

112

IEEE TRANSACTIONS ON COMPUTERS, VOL. c-32, NO. 2, FEBRUARY 1983

,X

ia3

-1

UA1U;b, ,,,LU1i.

-

.

_- -,//_GA\
I]-'2~4~~~C~~~~~~~~5

Ua2
Ub3
Fig. 7. The edges of B_e (A)o, when A and B are convex polygons, are found
by merging the edge lists of B and e(A)o, ordered on the angle their normals
make with the positive x axis.

1- --
.S7

CjW b2

II B

b4 I%'
L-O.k,~

%---_a3

14

IT

i

_._

vector additions. Thus A @D B can be computed in linear time

b3-

during a scan of the vertices of A and B; see Fig. 7. An imple-
mentation of this algorithm is included in Appendix I. Thus, B e (A)o can be computed in linear time by first converting each vertex ai to rvA - a1; see Fig. 7.

Fig. 8. When A (and E(A)O) rotates by 0, the e' rotate around bj and the ej are displaced. When an eg is aligned with an eb for some 0, any additional
rotation of A will interchange the order in which they are encountered during the counterclockwise scan of Theorem 2. For example, in the top figure a., appears before b2 on the boundary of COY(B) and is (nearly)

This algorithm is similar to Shamos' diameter algorithm
using antipodal pairs [36], but- instead of dealing with two
supporting lines on one polygon, it deals with two polygons and

aligned with b2; in the bottom figure, after additional rotation of A, al appears after b2 on the boundary of COY(B). Therefore, the top figure illustrates A in the orientation 0!J.

one supporting line on each. An algorithm, essentially identical

to the one in Theorem 2, has been recently described in [39]. The proof Theorem 2, however, will be used in subsequent sections to derive characterizations and algorithms for other Cspace entities.
When A or B are nonconvex polygons, COY(B) can be
computed by an extension of the algorithm above. The ex-
tension relies on decomposing the boundaries of the polygons into a sequence of polygonal arcs whose internal angles, i.e., the angle facing the inside of the polygon, are each less than ir. The algorithm of Theorem 2 can then be applied to pairs

A and B are convex, by examining changes in its cross section as 0 changes.
For fixed 0, we know from Theorem 2 that the edges of
COY(B) are either displaced edges of A or displaced edges of
B. Therefore, for a small rotation of A, we expect that those
edges of COY(B) corresponding to the edges of A will rotate,
but the edges corresponding to edges in B will not. As A ro-
tates, however, the rate of displacement of these edges changes discontinuously when edges of A and B become parallel, as illustrated below.

of arcs; the result is a polygon whose boundary, in general, intersects itself. The algorithm requires, in the worst case, O(n X m) steps.
An alternative method of computing COY(B) for nonconvex
A and B can be used when convex decompositions of A and B are available, e.g., the objects may have been designed by set

Let vert(B) denote the set of vertices- of a polygon B, bj be
the position vector of the jth member of vert(B), and as(O) be
the position of the ith member of vert(e(A)o), which depends on 0. Assume that A and B have no parallel edges. For fixed
0, the proof of Theorem 2 shows that each edge of COY(B) can
be expressed as one of

operations on convex primitives. If A is represented as the

union of kA objects Ai, and B is the union of kB objects Bj, then
Theorem 3 follows directly from the definition of COA (B).
Theorem 3: If A = U 1A Ai and B ,- U1 Bj:
kA kB
COA (B) = U U COA,(Bj). i=l j=l

e = bj @ s(ai (0), ai+ (0))

(2a)

eb = ai(6) @ s(b , bj+1).

(2b)

The order in which the ai and bj are encountered in the
counterclockwise scan described in Theorem 2 determines the
(i, j) pairings of vertices and edges. For example, in (2b), ai(0)

This theorem simply says that the set of configurations that is the vertex of E(A)o that is on the supporting line of E(A)o

cause a collision between A and B are those for which any part which is parallel to s(bj, bj+1), i.e., if uj is the normal to s(bj,

of A intersects any part of B.

bj+1), then ai = wr(E(A)o, u1) n e(A)o.

Equation (2) shows that, for a given pairing of edges and

III. CHARACTERIZING COYO(B)

vertices, the e? rotate around bj, while the ej are simply dis-
placed by the vector ai(O); see Fig. 8. The discontinuous

We have so far restricted our attention to cases where A changes occur at values of 0, denoted 06 , where the ith edge

remains in a fixed orientation. In these cases, all the geometric of A becomes parallel to the jth edge of B. For values of 6 just

constraints for spatial planning are embodied in COY(B). greater than these 06 , some pair of edges has a different order

However, COY(B) is only the cross section, for fixed 0, of the in the scan of Theorem 2 from what they had when 6 was just

three-dimensional full configuration space obstacle for poly- less than 0! ; see Fig. 8. Therefore, at each 6k,, the pairings
gons, COV0(B). In this section, we consider COAY(B), when between edges and vertices change. For A a convex n-gon and

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

LOZANO-PfEREZ: SPATIAL PLANNING

113

,P*rvA_
bj+, U1

\

/

</\

a1V
Eb)

Fig. 9. Illustration of terms used in (3).

B a convex m-gon, there are O(n X m) such 0 j in

COXY(B).
Between discontinuities, the lines defined by e' edges have

a simple dependence on 6. The edge s(bj, bj+1) is on a line whose vector equation5 is: (uj, x) = (uj, bj), where uj is the constant unit normal to s(bj, bj+ 1). Let ai (O) make the angle

mq withgi + with the x axis,

constant, and u1 make the angle

Oj with the x axis. Then, if | ai | represents the vector magni-

tude of ai, the equation for the line including eb is

(uj,x) = (uj,a,(6) +bj)
= Ilai cos (O + qi- qj) + (bj, uj). (3)
The terms are illustrated in Fig. 9. This equation holds between discontinuities.
The equation for the e' edges is not as simple, because the orientation of the edge changes with 0, i.e., the edge is a cross
section of a curved surface in (x, y, 0) space. Let vi(6) be the normal vector to s(a,(6), ai+I(6)); then the vector equation
of this curved surface is

(vi(6), x) = (vi(6), ai(6) + bj).

(4)

This equation also holds only between discontinuities, i.e., for each pairing of vertices and edges.
Equations (3) and (4) define the shape of COY'(B). Since
the resulting object is not polyhedral, however, it cannot be used for the Vgraph algorithm. Section VI discusses a technique for constructing lower dimension polyhedral approximations of CspaceA obstacles and an extended Vgraph algorithm to use them (see also [23]). These equations for
COY'(B) are the basis for the Findpath algorithm described
in [10].

IV. ALGORITHM FOR COyZ(B)
Theorem 1 applies also to COYZ(B), but the algorithm of Theorem 2 cannot be extended to polyhedra, since there is no similar total ordering of the faces of a polyhedron. However, Theorem 4 below follows easily from Theorem 1 and provides
a way to compute COYZ(B) for convex polyhedra A and B.
The method of Theorem 4 also applies to polygons, but is much less efficient than the linear algorithm of Theorem 2. Theorem
4 provides the basis for approximating COyz(B) when A and
B are nonconvex, simply by replacing A or B by their convex hulls.
Let conv(A) denote the convex hIll of a polygon A, i.e., the
5 The scalar (dot) product of vectors a and b will be denoted (a, b).

smallest convex polygon enclosing A. We know that conv(A),
for a nonempty set A c _d, iS {12; yixiIxi e A, yi > 0, Z2=l
yi = 11, for some n [16, p. 15] . This definition says that every point in the convex hull of A can be written as a convex linear combination of points in A.
Theorem 4: For polyhedra A and B,
conv(A @ B) = conv(A) C conv(B)
= conv(vert(A) @ vert(B)).
Proof: First show that conv(A @ B) = conv(A) @ conv(B).
(v): By the definition of @, if x E conv(A) @ conv(B), then there exist a E conv(A) and b E conv(B) such that x = a + b. The definition of convex hull states that any a e conv(A) can be expressed as a convex linear combination of points in A; likewise for any b e conv(B). Therefore, there
exist ai e A, bi e B, 1i yi = 1, yi > O, 2jOj = 1, and lj >
0 such that a = 2i -yiai and b = Yj3jbj and thus

x = a + b = (E yiai) + b = E yi(ai + b)

yj(i + i111

=E i

fyi3a+i E

31jbb)

= E 'Yi E Ojyai + E Oj,bj\

= E yi 31j(ai + bj) = E Ei 'yi,#3(a1 + bj). i Ii

But, since Xi jy io = 1 and yyifi > 0, x is a convex linear
combination of points in A @ B and therefore belongs to its convex hull. Therefore conv(A) @ conv(B) c conv(A @ B).
(c): If x E conv(A E B), then there exist -yi > 0 with
Ii7i = 1, a; e A, and bi E B, such that

x = , oyi(ai + b,) = Eyiai + E yibi.

1.

i

i

Therefore, x E conv(A) (D conv(B).

This establishes that conu(A $ B) = conv(A) $ conv(B).

Replacing A by vert(A) and B by vert(B), and using the fact

that conv(A) = conv(vert(A)) [16], shows that conv(vert(A)

E vert(B)) = conv(A) CD conv(B).

U

Corollary: For convex polyhedra A and B, COXAYZ(B) =

conv(vert(B) e vert((A)O)).

Proof: A $D B is convex, when A and B are both convex;

thus, A $ B = conv(A D B). By Theorem 4, A $ B = conv-

(vert(A) CD vert(B)). Using Theorem 1 establishes the corol-

lary.

-

Several algorithms exist for finding the convex hull of a fi-

nite set of points on the plane, e.g., [15] and [32]. The latter

[32] also describes an efficient algorithm for points in V3.

These algorithms are known to run in worst case time O(v log

v), where v is the size of the input set. Therefore, Theorem 4

leads immediately to an algorithm for computing COYJZ(B)

and an upper bound on the computational complexity of the

problem or convex polyhedra.

Theorem 5: For convex polyhedra A, B c ?3, each with

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

14

IEEE TRANSACTIONS ON COMPUTERS, VOL. C-32, NO. 2, FEBRUARY 1983

0(n) vertices, COY'Z(B) can be computed in time 0(n2 log
n).
Proof: The set vert(B) e vert((A)O) is of size 0(n2). Applying an 0(v log v) convex hull algorithm to this set gives an 0(n2 log n) algorithm for computing CO"YZ(B). U
The Vgraph algorithm discussed in Section I can be extended directly to deal with three-dimensional CspaceA ob-
stacles, COYz(Bj). However, the paths found are not, in
general, optimal paths [24]. Furthermore, with three-dimensional obstacles, the Vgraph algorithm is not even guaranteed to find a solution when one exists. This happens when the
vertices of the COYZ(Bj) are inaccessible, because they are outside of CIYz(R). In that case, there may exist collision-free
paths (via edges of the COz(Bj)), but the Vgraph algorithm
will not find them. An alternative suboptimal, but complete, path searching strategy is described in [23]. A path searching algorithm based on mathematical optimization of a path along a fixed set of edges is described in [ 12].

V. CHARACTERIZING COA (B)

The surfaces of COA (B), when A is three-dimensional and allowed to rotate, can be characterized in the same manner as
the surfaces of CO'(B) were characterized in Section III.
There are three types of surfaces that need to be considered,
rather than two types as in two-dimensional objects. Letf1(O)
be the ith face of the convex polyhedron A, with 0 being the
vector of three Euler angles indicating the orientation of A
relative to its initial orientation. Similarly, let gj be the jth face of the convex polyhedron B. As before, we let as(0) and bj
denote vertices of A and B, respectively. Each face of COA (B) can be expressed as one of

f = bj @f1(0)

(5a)

Pi = as (O) 03 gj

(5b)

fijXb = s(ai(0), ai+1(0)) @ s(bj, bj+1). (5c)

The faces defined by (5a) and (5b) are parallel to the faces of
A and B, respectively. Each face defined by (5c) is a paral-
lelogram, with edges parallel to the edges of A and B that give rise to the face. The vector equation for each type of surface follows the pattern of (3) and (4) above:

(N, x) = (N, ai(0) + bj)

(6)

where N is 1) the normal tof1(0) for (5a) faces, 2) the normal

to gj for (5b) faces, or 3) the cross product of the vectors along s(ai(0), ai+1(0)) and s(bj, bj+1) for (5c) faces. As above, this
characterization only holds between discontinuities.

VI. APPROXIMATING HIGH-DIMENSION Cspace OBSTACLES
We have seen that when A is a three-dimensional solid
which is allowed to rotate, COA (B) is a complicated curved object in a six-dimensional CspaceA. An alternative to computing these objects directly is to use a sequence of low-dimensional projections of the high-dimensional CspaceA ob-
stacles. For example, a three-dimensional (x, y, 6) CspaceA

I...........
I 11
......
-
%,
Fig. 10. Slice projections of CspaceA obstacles computed using the (x, y)-area swept out by A over a range of0 values. Each of the shaded obstacles is the (x, y)-projection of a 0-slice of COA(B). The figure also shows a polygonal approximation to the slice projection and the polygonal approximation to the swept volume from which it derives.
obstacle can be simply approximated by its projection on the, (x, y) plane, and any path of A that avoided the projection would be safe for all orientations of A. On the other hand, there may be no paths that completely avoid the projection. A better approach is to divide the complete range of 0 values into k smaller ranges and, for each of these ranges, find the section of the (x, y, 6) obstacle in that range of 6. These are called 0-slices of the obstacle. The projection of these slices serves as an approximation of the obstacle. Paths that avoid individual slices are safe for orientations of A in the 0-range defining the slice.
The shaded areas in Fig. 10 are the (x, y) projection of 0-slices of COA (B) when A and B are rectangles. These slices represent configurations where A overlaps B for some orientation of A in the specified range of 0. We will show that these slice projections are the CspaceA obstacles of the area swept out by A over the range of orientations of the slice. The swept area under rotation of a polygon is not pologonal. To use the
COY(B) algorithm developed earlier, we approximate the
swept area as the union of polygons [23]. This polygonal approximations leads to a polygonal approximation for the projected slices, as shown in Fig. 10. Similar considerations apply to polyhedra.
The crucial properties of slice projection are: 1) a solution to a Findspace or Findpath problem in any of the slices is a solution to the original problem, although not all actual solutions can be found in the slices; and 2) the degree of approximation can be controlled by choosing the range of parameters of the slice, in particular the approximation need not be uniform across the range of parameters.
The Vgraph algorithm for Findpath, has been extended [24], by means of slice projection, to find paths when A and
all the Bj are three-dimensional polyhedra that are allowed to
rotate. Fig. 11 illustrates the basic idea of this algorithm. An alternative path-searching technique, also using slice projection is described in [23]. Because the slice projections are approximations to the CspaceA obstacles, neither of these algorithms is guaranteed to find solutions to Findpath problems. Paths found by Findpath algorithms that use slice projections are composed of sequences of translations interspersed with rotations, but where the rotations happen in quantized increments corresponding to the ranges of orientations that define the slices. Not all paths can be expressed in this fashion. For

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

LOZANO-PEREZ: SPATIAL PLANNING

115

Zi/v+ii7 A3

Fig. 12. Linked polyhedra can be used to model the gross geometry of

A2

industrial robot manipulators.

Al
Fig. 11. An illustration of the Findpath algorithm using slice projection described by Lozano-P6rez and Wesley in [24]. A number of slice projections of the Cspace obstacles are constructed for different ranges of orientations of A. The problem of planning safe paths in the high-dimensional
CspaceA is decomposed into 1) planning safe paths via COY'Z(Bj) vertices
within each slice projection and 2) moving between slices, at configurations that are safe in both slices. Al represents A in its initial configuration, A3 represents A in its final configuration and A2 is a simple polyhedral approximation to the swept volume of A between its initial and final orientation.

Equivalently, COA[C,C'JK(B) is the I -K projection of the [c, C]K slice of COA (B). If the configurations of the swept volume
are one of (x, y), (x, y, z), or (x, y, 6) then the algorithms of
the previous sections can be used to compute COA [C,C'LK(B) and
thereby compute the required slice projections.6
A formal statement and proof of this result is included in
Appendix II as Theorem 6. This theorem is of practical im-
portance since it provides the mechanism underlying the Findspace and Findpath implementations described in [23]
and [24].

VII. AUTOMATIC PLANNING OF INDUSTRIAL ROBOT

example, the classic problem of moving a rectangular sofa

MOTIONS

through a rectangular bend in a hallway that just fits the sofa requires continuous rotation during translation. However, a
large class of useful problems can be solved using slice projection.
In the rest of the section we show how slice projections of
COA (B) may be computed using the CO7(B) and COAY'Z(B)
algorithms of Section IV. The idea is simply that if a collision would occur for A in some orientation, it would also occur for
a swept volume of A that includes A in that orientation. More formally, a j-slice of an object C e I? n is defined to
be t(li, 3,n) E C 1yj < /j < 'y)l, where yj and % are the
lower and upper bounds of the slice, respectively. Then, if I = $1, nn, and K I, then a K-slice is the intersection of the j-slices for ] E K. Note that a K-slice of C is an object of the same dimension as C. Slices can then be projected onto those coordinates in I not in K, i.e., I - K, to obtain objects of lower dimension. A j-cross section is a j-slice whose lower and upper bounds are equal, e.g., COj(B), for some orientation of A, is the projection on the (x, y) plane of a 0-cross-section of CO?0(B).
Slice projections are related to cross-section projections by the swept volume of an object. Intuitively, the swept volume of A is all the space that A covers when moving within a range of configurations. In particular, given two configurations for
A, called c and c', then the union of (A), for all c < a < c' is
the swept volume of A over the configuration range [c, c']. Generally, c and c' differ only on some subset, K, of the configuration coordinates. For example, if c and c' are of the form
(/31, 02, /3) and K = 13j, then the swept volume of A over the
range [c, C']K refers to the union of A over a set of configurations differing only on /33. The swept volume of A over a configuration range is denoted A [c, C']K.

One application of the algorithms for Findspace and Findpath developed above is in the automatic planning of industrial robot motions [23], [43]. However, some extensions of the results for polyhedra are needed. In this section, we briefly discuss these extensions.
Industrial robots are open kinematic chains in which adjacent links are connected by prismatic or rotary joints, each with
one degree of freedom [29]. We model them by linked polyhedra, kinematic chains with polyhedral links, each of which has either a translational or rotational degree of freedom relative to the previous joint in the chain; see Fig. 12. The relative
position and orientation of adjacent links, Ai and A+1, is de-
termined by the ith joint parameter [29], [7]. The set ofjoint parameters of a linked polyhedron completely specifies the position and orientation of all the links. This type of model is clearly an approximation to the actual geometry; in particular, the shape of the joints is not represented and some values of the joint parameters may cause overlap of adjacent links.
The natural CspaceA for a linked polyhedron is that defined by the set ofjoint parameters. A point in this space determines the shape of the linked polyhedron and the configuration of each of its links. Unfortunately, the presence of rotary joints prevents the use of the COYZ(B) algorithm of Section IV to plan the motions of linked polyhedra. However, there is an increasingly popular class of industrial robots, known as Cartesian robots, where the translational degrees of freedom of the robot are separate from the rotational. With this class of robots, we can use the COYZ'(B) algorithm and slice projection approach to plan collision-free paths and to plan how to grasp objects [23]. Actually doing this requires constructing the swept volume, over the rotational parameters, of the linked

If A [c, C']K overlaps some object B then, for some configuration a in that range, (A)a overlaps B. The converse is also
true. COA[c,cI]K(B) is the set of I - K projections of those
configurations of A within [c, C']K for which A overlaps B.

6 Of course, this requires computing a convex polyhedral approximation
to the swept volume of A. Simple approximations are not difficult to compute [231, but this is an area where better algorithms are required. Nevertheless, the swept volume computation is a three-dimensional operation which can be defined and executed without recourse to six-dimensional constructs.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

116

IEEE TRANSACTIONS ON COMPUTERS, VOL. C-32, NO. 2, FEBRUARY 1983

02

A2

'3

Fig. 13. Changes in the second joint angle from 02 to O'2 causes changes in the configurations of both link A2 and link A3.
polyhedron modeling the robot. The resulting swept volume can be viewed as a polyhedron with only translational degrees
of freedom, for which the COYf(B) algorithm is applicable.
Using swept volumes of linked polyhedra for slice projection requires taking into consideration the interdependence of the joint parameters. Note that for a linked polyhedron, the po-
sition of link j typically depends on the positions of links k <
j, which are closer to the base than linkj. Let K = {i, c = (0i),
c= (6;), and [c, C']K define a range of configurations differing
on the jth CspaceA parameter. Since joint j varies over a range of values, links 1 > j will move over a range of positions which
depend on the values of c and c', as shown in Fig. 13. The union of each of the link volumes over its specified range of positions is the swept volume of the linked polyhedron. The swept vol-
ume of links j through n can be taken as defining a new jth link. The first j- 1 links and this new jth link define a new manipulator whose configuration can be described by the first j
- 1 joint parameters. On the other hand, the shape of the new
link j depends not only on the K-parameters of c and c', i.e.,
Oi and O", but also on 61 for 1 > j. This implicit dependence on
parameters of c and c' that are not in K is undesirable, since
it means that the shape of the new jth link will vary as the
swept volume is displaced, i.e., the (I - K)-parameters are
changed. If we let K = U, * *, n}, then the shape of the swept
volume depends only on the K-parameters of c and c', while its configuration is determined by the (I - K)-parameters. A swept volume that satisfies this property is called displaceable. This property plays a crucial role in proving the fact, mentioned in Section VI, that slice projections of a CspaceA obstacle can be computed as the CspaceA obstacles of the swept volume of A (see Theorem 6 in Appendix II).
In summary, with the extensions discussed in this section, the spatial planning algorithms developed for the case of rigid polyhedra can serve as the basis for planning the motions of industrial robots.
VIII. RELATED WORK IN SPATIAL PLANNING
The definition of the Findspace problem used here is based on that in [49]. One previous approach to this problem is described in [30]; it is an application of the Warnock algorithm [47] for hidden line elimination. The idea is to recursively subdivide the workspace until an area "large enough" for the object is found. This approach has several drawbacks: l) any nonoverlapping subdivision strategy will break up potentially useful areas and 2) the implementation of the predicate "large enough" is not specified (in general, the CIA (B) computation is required to implement this predicate). However, once the CspaceA obstacles have been computed, the Warnock search

provides a good way of solving Findspace; since we only need
space for a point, any free area is "large enough" [ 10]. The work by Udupa, reported in [45], [46], was the first to
approach Findpath by explicitly using transformed obstacles
and a space where the moving object is a point. Udupa used
only rough approximations to the actual Cspace obstacles and
had no direct method for representing constraints on more than
three degrees of freedom. A survey of previous heuristic approaches to the Findpath problem for manipulators, for example, [20], [31], has been given in [46]. An early paper on Shakey [28] describes a technique for Findpath using a simple object transformation that defines safe points for a circular approximation to the mobile robot and uses a graph search formulation of the problem. More recent papers on navigation of mobile robots are also relevant to two-dimensional Findpath [14], [26] [44]. An early paper [18] reports on a program for planning the path of a two-dimensional sofa through a corridor. This program does a brute-force graph search through a quantized Cspace.
The Cspace approach to Findspace and Findpath described here is an extension of that reported in [24]. In that paper, an approximate algorithm for COXP(B) is described and the Vgraph algorithm for high-dimensional Findpath is first represented. An application of the Findpath and Findspace approach described in the current paper to automatic planning of manipulator motions is described in [23]. Alternative approaches to path searching in the presence of obstacles are described in [19], [12], [23] . The visibility computation needed in Vgraph is treated, in the context of hidden-line elimination, in [4], [51].
The basic idea of representing position constraints as geo-
metric figures, e.g., COY(B), has been used (independently) in [1]-[3], where an algorithm to compute COY(B) for non-
convex polygons is used in a technique for two-dimensional layout. The template packing approach described in [13] uses a related computation based on a chain-code description of figure boundaries. Algorithms for packing of parallelopipeds, in the presence of forbidden volumes, using a construct
equivalent to the COXYz(B), but defined as "the hodograph of the close positioning function" are reported in [42]. The only use of this construct in the paper is for computing COXY(B) for aligned rectangular prisms.
An extension of the approach in [24] to the general Findpath problem is proposed in [34]. The proposal is based on the use of an exact representation of the high-dimensional Cspace obstacles. The basic approach is to define the general configuration constraints as a set of multinomials in the position parameters of A. However, the proposal still requires elaboration. It defines the configuration space constraints in terms of the relationships of vertices of one object to the faces of the other. This is adequate for polygons, but the equations in the paper only express the constraints necessary for vertices of A to be outside of B, i.e., they are of the form-of (3). They do not account for the positions of A where vertices of B are in contact with A [see (4)]. The new equations will have terms of the form x cos 6 and y cos 0. Furthermore, the approach of defining the
configuration constraints by examining the interaction of vertices and faces does not generalize to three-dimensional

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

LOZANO-PEREZ: SPATIAL PLANNING

1 17

polyhedra. It is not enough to consider the interaction of ver- angles that the edges make with the positive x axis. The edges

tices and faces; the interaction of edges and faces must also be and vertices are ordered in counterclockwise order, i.e., by

taken into account (see Section V and [8]).

increasing angle. The implementation assumes that a POLY-

Two recent papers describe solutions for the Findpath GON record is available with the following components:

problem with rotations in two [40] and three dimensions [41]. 1) size-number of edges in the polygon.

In [41], the Cspace surfaces are represented as algebraic 2) vert [1 :size + 1, 1:2] -an array of vectors representing

manifolds in a 12-dimensional space; in this way the surfaces the coordinates of a vertex. The ith edge, i = 1, , size, has

can be described as polynomials, allowing the use of some the endpoints vert[i, k] and vert[i + 1, k], for k E 11, 21. Note

powerful mathematical machinery. The resulting algorithm that vert[size + 1, k] = vert[1, k].

has (large) polynomial time complexity, for fixed dimension- 3) angle [0:size]-the edge normal's angle (in the range

ality of the Cspace.

[0, 27]) with the x axis, monotonically increasing. For con-

A Cspace algorithm is described in [10] for solving Find- venience angle [0] = 27r - angle [size].

path, allowing rotations of the moving objects. The algorithm References to the components of a polygon, a, are written

is based on recursively subdividing Cspace until a path of cells as one of a.size, a.vert, and a.angle.

completely outside of the obstacles is found.

The algorithm implements the angle scan in the proof of

An alternative approach to two-dimensional Findpath with Theorem 2; in particular, the edges of the input polygons, a and

rotations is described in [9]. The algorithm is based on rep- b, are examined in order of angle. The algorithm determines

resenting the empty space outside the objects Bj explicitly as the position of the vertices of c. It is clear that vertices can

generalized cones. Motions of A are restricted to be along the occur only at angles where there is either a vertex of a, or a

spines of the cones. The algorithm bounds the moving object vertex of b, or both. From Lemmas 1 and 2, it is easy to see that

by a convex polygon and characterizes the legal rotations of the position of the vertex of c is the sum of the positions of the

the bounding polygon along each spine.

corresponding vertices of a and b. The algorithm starts the scan

at the angle determined by the first edge of b, the first loop in

the program below serves to find the edges of a that straddle

APPENDIX I

that angle. From there, the algorithm increments the edge index into a or b depending on which makes the smaller angle

ALGORITHM FOR COY(B)

increment. In general, the algorithm requires incrementing the angle beyond 2wr so as to consider all the edges of a before

This Appendix shows an algorithm for computing A @ B, the edge found by the first loop of the program. Since the edges

called SET-SUM(A, B, C), when A and B are convex polygons. are stored with angles between 0 and 2r, an offset variable is

Section II used this operation to compute COj(B).

used to add 2r to the angle when the wraparound on polygon

Each polygon is described in terms of its vertices and the a is detected.

PROCEDURE setsum (a, b, c);
POLYGON a, b, c;
BEGIN INTEGER ea, eb, vc, i; REAL ang, offset; COMMENT Initialize an index into a, one into b, and one into c. The value of offset will be either 0 or 2*pi, and it is used to handle angle wraparound as described above;
ea:= 1; eb:= 1; vc : -1; offset := 0; COMMENT Find adjacent edges in a whose angles straddle the angle
of the first edge of b; WHILE (a.angle[ea] <= b.angle[1] OR a.angle[ea - 1] >= b.angle[1])
DOea:= ea + 1;
FOR i := 1 STEP 1 UNTIL 2 DO
c. vert[1, i] := a.vert[ea, i] + b.vert[1, i]; COMMENT This loop implements the scan of Theorem 2 in the body of the
paper. The result of the loop is to fill the vertex array of c; WHILE (eb <= b.size) DO
BEGIN
vc := vc + 1;
ang := offset + a.angle[ea]; IF (ang <= b.angle[eb])

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

118

IEEE TRANSACTIONS ON COMPUTERS, VOL. C-32, NO. 2, FEBRUARY 1983

THEN IF (ea >= a.size) THEN BEGIN offset := 2*pi; ea 1 END ELSE ea:= ea + 1;
IF (ang >= b.angle[eb])
THEN eb:=eb + 1;
FOR i := 1 STEP 1 UNTIL 2 DO
c.vert[vc, i] := a.vert[ea, il + b.vert[eb, i]
END;
c.size := vc,j-
FOR i:= 1 STEP 1 UNTIL 2 DO c.vert[vc + 1, i] c.vert[1, i];
END

APPENDIX II PROOF OF THEOREM 6

Assume that CspaceA a y?d, let I = 11, 2, , d}and K a I. Let I, K and I - K denote sets of indexes for the coordinates of a E CspaceA. Define the following vectors, all in CspaceA:
b = (/3i),c = ('yi) and c' = (,y) for i E I. Then,

(PK (C, C')-b E Jdl A Yk < /k < k

4K (C) 4K (C, C)

OK(C, C') E-K(C, c') n P1_K(C, C)

These definitions are illustrated in Fig. 14.

PK[-]: The projection operator, denoted

_ d =l

KI iS

defined, for vectors and sets of vectors, by

PK[b] = (0k) k E K
PK[B] = $PK[b]Ib e B)

Superscripts on vectors indicate projection, e.g., bK = PK [b].
In addition, the vector in WI composed from one vector in
_4lKI and one in ]jII-KI is denoted (aI-K: bK), where Pl_K[(aI : bK)] = aIK and PK[(as K: bK)] =bK.
In this notation, precise definitions for the notions of cross
section projection and slice projection can be provided. The
cross section projection of a CspaceA obstacle is written as
follows:

PI-K[COA(B) n +X(c)]

The slice projection, is similar to the cross section projection,

I(P-K C IC)

c~

P2

_

(cI

;2

c _ ~~~~~~~~(-)K(C,4)

but carried out for all configurations between two cross sections:
PI-K[COA(B) n tK(C, C)]
The K-parameters of the two configurations, c and c', define the bounds of the slice. Similarly, the swept volume can be defined in this notation.
Definition: The swept volume of A over the configuration
range [c, C'IK iS

(A[c, C']K)c- U (A)a.
a e OK(c,c')
The requirement discussed in Section VII that the swept volume of A be displaceable is embodied in the following condition:

Va: U (A)(aI-K:xK) = (A[c, c']K)(al-K:CK) (7)
X E OK(C,C')
Note that the I - K parameters may be changed, as in (7), but not those parameters in K. Therefore, (A[c, C']K)a is defined only if a e <K>(C).
Theorem 6: If (7) holds, then
PI-K[COA(B) r) 'K(C, C)]
PI-KK[COA[c,c']K(B) n 4 K(C)]
Proof of Theorem: Assume that the configuration a is in the slice projection of COA (B), that is,
a E PI-K [COA (B) nlK(C, C')
This assumption and the definition of the projection operator allows us to deduce that some configuration in CspaceA, whose I -K-projection is a, is in COA(B):
¢}3X1 E (kK(C, C'):((a' K:XK) E, COA(B)).
In fact, since we are only interested in the K-parameters of xl and OK(C, c') tK(c, c'), we can assume without loss of generality that xi is in the smaller set, i.e.,

3x]

:((a'

KXi)

COA(B)).

Simply using the definition of COA (B), it follows that

Al

1=11,2 1

K=1 2 >

Fig. 14. Illustration of the definition of 'I)K(c,c') and OK(c,c').

4 (A)(aI-xKX) n B
but if A in this configuration intersects B, then any set including A in that configuration will also intersect B. In particular,

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

LOZANO-PEREZ: SPATIAL PLANNING

1 19

-=* U (A)(abK:xK) r B < 0
XE OK(C,C')
We are assuming that swept volumes are displaceable, i.e., that
(7) holds. Therefore, using (7), we get

(A[c, C']K)(al-K:cK) n B0 $

Hence, by the definitions of COA (B) and 4.K(C),

(aI-K:cK) e COA[C,C'](B) and (aI1K.cK) E (PK(C)

Applying the definition of the projection operator completes the proof:

a e PI-K[CoA[c,c']K(B) nfK(C)].

.

ACKNOWLEDGMENT
The author would like to thank M. Brady, R. Brooks, J. Hollerbach, B. Horn, T. Johnson, M. Mason, P. Winston, B. Woodham, and the referees for their suggestions on the content and presentation of this paper. J. Hollerbach suggested the proof of Theorem 6 in the current version of the paper, which
is much simpler than the original proof.
REFERENCES
[1] M. Adamowicz, "The optimum two-dimensional allocation of irregular, multiply-connected shapes with linear, logical and geometric constraints," Ph.D. dissertation, Dep. Elec. Eng., New York Univ., 1970.
[2] M. Adamowicz and A. Albano, "Nesting two-dimensional shapes in rectangular modules," Computer Aided Design, vol. 8, pp. 27-32, Jan. 1976.
[3] A. Albano and G. Sapuppo, "Optimal allocation of two-dimensional irregular shapes using heuristic search methods," IEEE Trans. Syst., Man., Cybern., vol. SMC-10, pp. 242-248, May 1980.
[4] D. Avis and G. T, Toussaint, "An optimal algorithm for determining the visibility of a polygon from an edge," Sch. Comput. Sci., McGill Univ., Rep. SOCS-80.2, Feb. 1980.
[51 R. V. Benson, Euclidean Geometry and Convexity. New York:
McGraw-Hill, 1966. [6] J. 1. Bentley and T. Ottman, "Algorithms for reporting and counting
geometric intersections," IEEE Trans. Comput., vol. C-28, Sept. 1979. [7] 0. Bottema and B. Roth, Theoretical Kinematics. Amsterdam: North-Holland, 1979. [8] J. W. Boyse, "Interference detection among solids and surfaces," Commun. Ass. Comput. Mach., vol. ACM 22, pp. 3-9, Jan. 1979. [9] R. A. Brooks, "Solving the Find-Path problem by representing free space as generalized cones," M.I.T. Artificial Intell. Lab., Rep. AIM-674, May 1982. [10] R. A. Brooks and T. Lozano-Perez, "A subdivision algorithm in configuration space for Findpath with rotation," M.I.T. Artificial Intell. Lab., Rep. AIM-684, Dec. 1982. [11] K. Q. Brown, "Fast intersection of half spaces," Dep. Comput. Sci., Carnegie-Mellon Univ., Rep. CS-78-129, June 1978. [12] C. E. Campbell and J. Y. S. Luh, "A preliminary study on path planning of collision avoidance for mechanical manipulators," Sch. Elec. Eng., Purdue Univ., Rep. TR-EE 80-48, Dec. 1980. [13] H. Freeman, "On the packing of arbitrary-shaped templates," in Proc. 2nd USA-Japan Comput. Conf., 1975, pp. 102-107. [14] G. Giralt, R. Sobek, and R. Chatila, "A multilevel planning and navigation system for a mobile robot," in Proc. 6th Int. Joint Conf: Artificial Intell., Tokyo, Japan, Aug. 1979, pp. 335-338. [15] R. L. Graham, "An efficent algorithm for determining the convex hull of a finite planar set," Inform. Processing Lett., vol. 1, pp. 132-133, 1972.
[161 B. Grunbaum, C-onvex Polytopes. New York: Wiley-Interscience,

1967.
[17] L. J. Guibas and F. F. Yao, "On translating a set of rectangles," in Proc. 12th Annu. ACM Symp. Theory ofComputing, Los Angeles, CA, Apr.
1980, pp. 154-160. [18] W. E. Howden, "The sofa problem," Comput. J., vol. 11, pp. 299-301,
Nov. 1968. [19] R. C. Larson and V. 0. K. Li, "Finding minimum rectilinear distance
paths in the presence of obstacles," Networks, vol. 11, pp. 285-304, 1981.
[20] R. A. Lewis, "Autonomous manipulation on a robot: Summary of ma-
nipulator software functions," Jet Propulsion Lab., California Inst. Technol., TM 33-679, Mar. 1974.
[21] L. Lieberman and M. A. Wesley, "AUTOPASS: An automatic programming system for computer controlled assembly," IBM J. Res.
Develop., vol. 21, July 1977. [22] T. Lozano-Prez, "The design of a mechanical assembly system," M.I.T.
Artificial Intell. Lab., Rep. TR-397, Dec. 1976. [23] ,"Automatic planning of manipulator transfer movements," IEEE
Trans. Syst., Man., Cybern., vol. SMC-l 1, pp. 681-698, Oct. 1981. [241 T. Lozano-Perez and M. A. Wesley, "An algorithm for planning colli-
sion-free paths among polyhedral obstacles," Commun. Ass. Comput. Mach., vol. ACM 22, pp. 560-570, Oct. 1979. [25] L. Lyusternik, Convex Figures and Polyhedra. Dover, 1963, original
copyright, Moscow, 1956. [26] H. P. Moravec, "Visual mapping by a robot rover," in Proc. 6th Int. Joint
Conf: Artificial Intell., Tokyo, Japan, Aug. 1979. [27] D. Mueller and F. Preparata, "Finding the intersection of two convex
polyhedra," Coordinated Sci. Lab., Univ. Illinois, Urbana, Rep. R-793,
Oct. 1977. [28] N. Nilsson, "A mobile automaton: An application of artificial intelli-
gence techniques," in Proc. 2nd Int. Joint Conf Artificial Intell., 1969, pp. 509-520. [29] R. P. Paul, "Manipulator Cartesian path control," IEEE Trans. Syst., Man., Cybern., vol. SMC-9, pp. 702-71 1, Nov. 1979.
[30] G. Pfister, "On solving the FINDSPACE problem, or how to find where things aren't," M.I.T. Artificial Intell. Lab., Working Paper 113, Mar.
1973.
[31] D. L. Pieper, "The kinematics of manipulators under computer control,"
Stanford Artificial Intell. Lab., AIM-72, Oct. 1968. [32] F. Preparata and S. Hong, "Convex hulls of finite sets of point in two
and three dimensions," Commun. Ass. Comput. Mach., vol. 20, pp.
87-93, Feb. 1977. [33] F. Preparata and D. Mueller, "Finding the intersection of a set of half
spaces in time O(n log n)," Coordinated Sci. Lab., Univ. Illinois, Ur-
bana, Rep. R-803, Dec. 1977. [34] J. Reif, "On the movers problem," in Proc. 20th Annu. IEEE Symp.
Foundation of Comput. Sci., 1979, pp. 421-427. [35] B. Schachter, "Decomposition of polygons into convex sets," IEEE
Trans. Comput.,vol. C-27, pp. 1078-1082, Nov. 1978.
[36] M. I. Shamos, "Geometric complexity," in Proc. 7th Annu. ACMSymp.
Theory of Computing, 1975, pp. 224-233. [37] M. I. Shamos and D. Hoey, "Closest-point problems," in Proc. 16th
Annu. IEEE Symp. Foundation of Comput. Sci., 1975, pp. 151-161. [38] , "Geometric intersection problems," in Proc. 17th Annu. IEEE
Symp. Foundation of Comput. Sci., 1976, pp. 208-215. [39] J. T. Schwartz, "Finding the minimum distance between two convex
polygons," Inform. Processing Lett., vol. 13, pp. 168-170, 1981. [40] J. T. Schwartz and M. Sharir, "On the piano movers' problem I. The
case of a two-dimensional rigid polygonal body moving amidst polygonal barriers," Dep. Comput. Sci., Courant Inst. Math. Sci., New York Univ., Rep. 39, 1981. [41] , "On the piano movers' problem II. General techniques for computing topological properties of real manifolds," Dep. Comput. Sci., Courant Inst. Math. Sci., New York Univ., Rep. 41, 1982. [42] Y. G. Stoyan and L. D. Ponomarenko, "A rational arrangement of geometric bodies in automated design problems," Eng. Cybern., vol. 16, Jan. 1978.[43] R. Taylor, "A synthesis of manipulator control programs from task-level specifications," Stanford Artificial Intell. Lab., Rep. AIM-282, July 1976.
[44] A. M. Thompson, "The navigation system of the JPL robot," in Proc. 5th Int. Joint Conf. Artificial Intell., Massachusetts Inst. Technol., 1977.
[45] S. Udupa, "Collision detection and avoidance in computer controlled manipulators," in Proc. 5th Int. Joint Conf. Artificial Intell., Massachusetts Inst. Technol., 1977.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

IEEE TRANSACTIONS ON COMPUTERS, VOL. c-32, NO. 2, FEBRUARY 1983

[46] , "Collision detection and avoidance in computer controlled manipulators," Ph.D. dissertation, Dep. Elec. Eng., California Inst.
Technol., 1977. [47] J. E. Warnock, "A hidden line algorithm for halftone picture repre-
sentation," Dep. Comput. Sci., Univ. Utah, Rep. TR4-5, May 1968.
[48] J. Williams, "STICKS-A new approach to LSI design," S.M. thesis, Dep. Elec. Eng., Massachusetts Inst. Technol., 1977.
[49] T. Winograd, UnderstandingNatural Language. New York: Aademic, 1972.
[50] T. C. Woo, "Progress in shape modelling," IEEE Computer, vol. 10,
Dec. 1977. [51] F. F. Yao, "On the priority approach to hidden-surfa'ce algorithms,"
in Proc. 21st Symp. Foundation of Comput. Sci., 1980, pp. 301-307.

I Tomas Lozano-Perez was born in Guantanamo, Cuba, on August 21, 1952. He received the S.B.
degree in 1973, the S.M. degree in 1977, and the Ph.D. degree in 1980, all in computer science from the Massachussetts Institute of Technology, Cam-
bridge.
In 1981 he joined the Department of Electrical Engineering and Computer Science, Massachus-
setts Institute of Technology, where he is currently
an Assistant Professor. He has been associated with the M.I.T. Artificial Intelligence Laboratory since 1973. His research interests include robotics, geometric modeling, computational geometry, computer vision, and artificial intelligence.

Structured Specification of Communicating Systems
GREGOR V. BOCHMANN AND MICHEL RAYNAL

Abstract-Specification methods for distributed systems is the underlying theme of this paper. A model of communicating processes with rendezvous interactions is assumed as a basis for the discussion. The possible interactions by a process, and the interconnection between several subprocesses within a process are specified using the concept of ports, which are specified separately. Step-wise refinement of process specifications and associated verification rules are considered. The step-wise refinement of port specifications and associated interactions is considered as well. After the presentation of an introductory example, the paper discusses the basic concepts of the specification method. They are then applied to more complex examples. The stepwise refinement of ports and interactions is demonstrated by a hardware interface for which an abstract specification and a more detailed implementation is given. Proof rules for verifying the consistency of detailed and more abstract specifications are discussed in some detail.
Index Terms-Communication processes, design verification, distributed system design, interface specifications, parallel processing, ports, specification consistency, specification language, specification
methods, step-wise refinement.
I. INTRODUCTION
M UCH work has been done in recent years in the area of design methods for distributed systems. This in-
Manuscript received January 14,1982; revised July6,1982. This workwas supported in part by the Natural Sciences and Engineering Research Council of Canada and IRISA-INRIA, France.
G. V. Bochmann is with the Departement d'lnformatique et de Recherche Operationnalle, Universite de Montreal, Montreal, P.Q. H3C 3J7, Canada.
M. Raynal is with the ENST de Bretagne, BP 856, 29279 Brest-Cedex, France.

cludes the development of languages for distributed systems, the choice of appropriate interaction mechanisms (message
transmission, rendezvous interactions, remote procedure calls, etc.), communication protocol design for long distance and
local computer networks, as well as for the communication between several VLSI components within a single computer system. As in the case of nondistributed software systems, the notion of step-wise refinement seems to be an important design tool for distributed systems. Some difficulty is encountered, however, if some sort of indivisible interaction primitives are assumed.
The specification method discussed in this paper indicates how the step-wise refinement of distributed systems may be described with the concept of process substructure and the concept of interactions that may be refined. The method is based on the concepts "process" and "port." A process is an entity that performs some data processing and is assumed to be the unit of specification. A port is a part of a process and serves for the communication of that process with its environment, i.e., other processes in the system. A process may
possess several ports for communication with different parts
of its environment. The specification of the properties of a process or port is given at an abstract level, in the sense that
only the externally visible behavior of a process or port is de-
scribed (i.e., its communication behavior), but not the way this
behavior is realized by an internal structure of the process or
port. Process and port implementations are specified separately as the elements for one step in the step-wise refinement of a system description.

0018-9340/83/0200-0120$01.00 © 1983 IEEE

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on July 11,2022 at 13:44:29 UTC from IEEE Xplore. Restrictions apply.

