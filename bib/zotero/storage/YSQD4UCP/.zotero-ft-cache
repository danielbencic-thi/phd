Zotero automatically redirected your request to ieeexplore.ieee.org through the proxy at thi.idm.oclc.org. Don’t Proxy This Site Proxy Settings ✕
IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

        Cart 
        Create Account
        Personal Sign In 

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
ADVANCED SEARCH
Journals & Magazines > IEEE Transactions on Automati... > Volume: 17 Issue: 4
EB-RRT: Optimal Motion Planning for Mobile Robots
Publisher: IEEE
Cite This
PDF
Jiankun Wang ; Max Q.-H. Meng ; Oussama Khatib
All Authors
25
Paper
Citations
1910
Full
Text Views

    Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Related Work
    III.
    Problem Formulation
    IV.
    EB-RRT Algorithm
    V.
    Results of Simulation Experiments

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
Abstract:
In a human-robot coexisting environment, it is pivotal for a mobile service robot to arrive at the goal position safely and efficiently. In this article, an elastic band-based rapidly exploring random tree (EB-RRT) algorithm is proposed to achieve real-time optimal motion planning for the mobile robot in the dynamic environment, which can maintain a homotopy optimal trajectory based on current heuristic trajectory. Inspired by the EB method, we propose a hierarchical framework consisting of two planners. In the global planner, a time-based RRT algorithm is used to generate a feasible heuristic trajectory for a specific task in the dynamic environment. However, this heuristic trajectory is nonoptimal. In the dynamic replanner, the time-based nodes on the heuristic trajectory are updated due to the internal contraction force and the repulsive force from the obstacles. In this way, the heuristic trajectory is optimized continuously, and the final trajectory can be proved to be optimal in the homotopy class of the heuristic trajectory. Simulation experiments reveal that compared with two stateof-the-art algorithms, our proposed method can achieve better performance in dynamic environments.
Published in: IEEE Transactions on Automation Science and Engineering ( Volume: 17 , Issue: 4 , October 2020 )
Page(s): 2063 - 2073
Date of Publication: 30 April 2020
ISSN Information:
INSPEC Accession Number: 20023421
DOI: 10.1109/TASE.2020.2987397
Publisher: IEEE
Funding Agency:
SECTION I.
Introduction

In robotics, a fundamental task is to plan collision-free motions for the robot for some specific tasks among a number of static or moving obstacles [1] . Lots of efforts have been devoted to the motion planning problem over the last few decades. Many kinds of motion planning algorithms are proposed and have widespread success in different robotic applications, which can be broadly classified into three categories. The artificial potential field [2] algorithms find the feasible trajectory by following the direction of the steepest descent of the potential. However, they often end up in a local minimum. The grid-based algorithms, such as the A* [3] , are resolution complete and resolution optimal, meaning that they can always find the optimal trajectory if it exists. However, they do not perform well as the problem scale increases. Sampling-based algorithms use the collision detector to compute whether a randomly sampled configuration is collision-free and construct a data structure to store collision-free trajectories. Therefore, these algorithms can avoid the exact geometric modeling of the configuration space. With this level of abstraction, sampling-based planners, such as the rapidly exploring random tree (RRT) [4] , the probabilistic roadmap method (PRM) [5] , and their many variants, are applicable to a wide variety of problems. It is noted that the sampling-based algorithms only provide a weaker form of completeness (also called probabilistic completeness). In addition, the generated trajectories from the RRT and the PRM are nonoptimal.

In a dynamic environment, the planned trajectory may become invalid due to the change in the current environment. Therefore, it is necessary for the planner to have the ability of real-time response to the current environment. The elastic band (EB) method [6] can be used to quickly adjust the current trajectory in the dynamic environment. As shown in Fig. 1(a) , with a three-level framework, the heuristic trajectory from the path planner is updated by the EB module, and then, the final control command is obtained in the control planner. However, the EB method needs an initial trajectory and construction of the configuration space. In the dynamic environment, generating a feasible trajectory as quickly as possible is necessary for the path planner. When the working scenario is pretty large, such as an airport, constructing the configuration space costs a lot of computation resource and it becomes much harder to generate a feasible initial trajectory quickly. The sampling-based algorithms are suitable for their fewer requirements on computation resources and good scalability. Moreover, they can avoid the exact modeling of the configuration space. The time-based RRT algorithms, such as Risk-RRT [7] , provide a solution to achieve real-time motion planning in the dynamic environment. However, the generated trajectories are far from optimal, and it is difficult to optimize these time-based trajectories in real time.
Fig. 1.

Framework of the EB and the EB-RRT algorithm. (a) EB framework. (b) EB-RRT framework.

Show All

Therefore, in this article, by combining the EB method and the time-based RRT algorithm, we propose the EB-RRT algorithm to achieve real-time motion planning while optimizing the current trajectory. As shown in Fig. 1(b) , for a specific task, the global planner generates the time-based RRT tree and a feasible initial trajectory according to the world model and the local obstacle. Then, the dynamic replanner optimizes the generated trajectory, and control commands are sent to the robot. The optimization procedure is similar to the EB method. Finally, the position and velocity of the robot will be updated, and this information will be transferred to the global planner again.

Our contributions are summarized as follows:

    a hierarchical motion planning framework for mobile robot navigation in human–robot coexisting environments;

    a real-time optimization strategy for the time-based RRT tree by combing the EB method;

    a proof of the probabilistic completeness and homotopy optimality of the proposed EB-RRT algorithm.

The rest of this article is organized as follows. We introduce the related work in Section II and formulate the motion planning problem in Section III . Then, we describe our EB-RRT algorithm in Section IV . In the following, the results of the simulation experiments and some discussions are presented in Sections V and VI . Finally, we draw conclusions and discuss our future work in Section VII .
SECTION II.
Related Work

The RRT algorithms have been widely used in robotic motion and path planning area since the 1990s. However, they converge surely to nonoptimal values. Karaman and Frazzoli [8] propose an asymptotically optimal algorithm named RRT*. However, the convergence speed of the RRT* algorithm is slow. Gammell et al. [9] propose the Informed-RRT* algorithm to achieve faster convergence. Salzman and Halperin [10] propose the low-bound tree RRT (LBT-RRT) to produce a high-quality trajectory more quickly. There are also other variants of the RRT and RRT* [11] – [15] , which do some improvements from different aspects.

For motion planning in dynamic environments, there are a number of different RRT algorithms. These algorithms can be divided into two categories: reactive algorithms and active algorithms. The reactive algorithms compute just one next motion in every instant based on the current condition, which means that they only need to consider the moving obstacles at the current time. Replaning is required whenever the environment changes, but they can cope with highly dynamic and unpredictable environments. Therefore, many variants of the RRT algorithms focus on quickly replanning new trajectories. Bruce and Veloso [16] propose execution extended RRT to achieve real-time randomized path planning. In [17] , the multipartite RRT algorithm is presented to deal with the high-dimensional spaces and the time-constrained systems. Otte and Frazzoli [18] introduce the RRTX algorithm to achieve quick replanning in the unpredictably dynamic environment. However, the replanning algorithms are required to maintain a high frequency of updates to cope with moving obstacles.

The active algorithms utilize the trajectory prediction of the moving obstacles in the dynamic environment and generate the trajectory, which can actively avoid the moving obstacles in the future. Ferguson and Stentz [19] propose anytime RRTs to repair the tree branches. Due to the influence of the moving obstacles, the invalid nodes are deleted, and new nodes are searched to connect the root with the branches that have been isolated. In partial motion planning [20] , time constraints are explicitly taken into account. The node that is safe with respect to the known trajectories of moving obstacles will be added to the tree. At the same time, another partial path is generated from the end of the previously generated path. Inspired by these two methods, Fulgenzi et al. [7] propose a time-based RRT algorithm named Risk-RRT to link the planning and navigation methods with a probabilistic collision risk function. However, the optimization of the planned trajectory is not considered. Compared with the reactive algorithms, the active algorithms can guarantee global optimization to an extent, but a fast and efficient optimization of the planned trajectory is required to deal with the dynamic environment.

Both the reactive and active algorithms are widely used in the robot motion planning field, and they focus on different emphases. In this article, we concentrate on the further improvement of the planned trajectory for the active algorithms.
SECTION III.
Problem Formulation

In this section, we first briefly formulate the motion planning problem and then use the Risk-RRT as an example to introduce the time-based RRT trees.
A. Motion Planning

The basic motion planning problem, known as the piano mover’s problem, can be defined as follows. Let X ∈ R n be the state space. The obstacle space and the free space are denoted as X obs and X free , respectively. In a dynamic environment, the state space is time-varying, so they are denoted as X obs ( t ) and X free ( t ) . Let x init be the initial state and x goal be the goal state. Usually, a goal region G ( x goal , t ) = { x ∈ X free ∣ ∣ | | x − x goal | | < r } is used. The aim is to compute a trajectory σ : [ 0 , T ] → X free such that σ ( 0 ) = x init and σ ( T ) ∈ G ( x goal , T ) .

Let U ∈ R m be the control space for the robot. The planned trajectory corresponds to a set of control inputs u : [ 0 , T ] → U . The robot dynamics is represented as
σ ( t + 1 ) = g ( σ ( t ) , u ( t ) ) (1)
View Source Right-click on figure for MathML and additional features. \begin{equation*} \sigma (t+1) = g(\sigma (t), u(t))\tag{1}\end{equation*} where σ ( t ) and σ ( t + 1 ) are two adjacent states.

Let Σ be the set of all feasible trajectories. The cost function c ( σ ) maps each feasible trajectory σ to a positive real number R . Therefore, the optimal motion planning problem can be defined as
σ ∗ = arg min σ ∈ Σ   c ( σ ) s.t.   σ ( 0 ) = x init s.t.   σ ( T ) ∈ G ( x goal , T ) s.t.   σ ( t ) ∈ X free ( t ) ∀ t ∈ [ 0 , T ] . (2)
View Source Right-click on figure for MathML and additional features. \begin{align*} \sigma ^{*}=&\underset {\sigma \in \Sigma }{\arg \min } ~c(\sigma) \\&\text {s.t.} ~\sigma (0) = x_{\text {init}} \\&\hphantom {\text {s.t.} ~} \sigma (T) \in \mathcal {G}(x_{\text {goal}}, T) \\&\hphantom {\text {s.t.} ~} \sigma (t) \in \mathcal {X}_{\text {free}}(t)\quad \forall t \in [0,T].\tag{2}\end{align*}

In this article, the cost function between two states is defined as follows:
Cost ( x 1 , x 2 , v 1 ) = α 1 | | x 2 − x 1 | | + α 2 arccos v 1 → ⋅ x 1 x 2 − → − | v 1 → | | x 1 x 2 − → − | (3)
View Source Right-click on figure for MathML and additional features. \begin{equation*} \text {Cost}(x_{1}, x_{2}, v_{1}) = \alpha _{1} ||x_{2} - x_{1}|| + \alpha _{2} \arccos \frac {\overrightarrow {v_{1}} \cdot \overrightarrow {x_{1} x_{2}}}{|\overrightarrow {v_{1}}||\overrightarrow {x_{1} x_{2}}|}\tag{3}\end{equation*} where α 1 and α 2 are two predefined constants, v 1 is the robot linear velocity at x 1 , | | ⋅ | | is the Euclidean distance between x 1 and x 2 , and x 1   x 2 − → − − is the vector from x 1 to x 2 . α 1 and α 2 are used to balance the effect of the Euclidean distance and angle difference. In this article, α 1 = 0.5 and α 2 = 0.5 . Therefore, the cost function of the planned trajectory is
c ( σ ) = ∑ t = 0 T − 1 Cost ( σ ( t ) , σ ( t + 1 ) , v ( t ) ) . (4)
View Source Right-click on figure for MathML and additional features. \begin{equation*} c(\sigma) = \sum _{t=0}^{T-1} \text {Cost}(\sigma (t), \sigma (t+1), v(t)).\tag{4}\end{equation*}

B. Time-Based RRT Tree

The basic structure of a time-based tree and its reconnection process are shown in Fig. 2 . The information on each node can be defined as a tuple ( x , x p , x c , n , t , u , U , P ( t ) ) .

    The state (position and orientation) of the robot. For simplification, we also use x to denote the state.

    The parent and child node, x p and x c , of the current node. For the node x 2 in Fig. 2 , x 0 and x 5 are its parent and child node, respectively.

    The depth n , which measures the depth distance between the root node and the current node. In Fig. 2 , n ( x 0 ) = 0 and n ( x 3 ) = 2 .

    The timestamp t = t 0 + n ∗ Δ t . The tree root x 0 has a timestamp t 0 , and the time increment between two nodes is Δ t .

    The control input u and possible control outputs U . With u , the robot can move from the state of its parent node to current state: x = g ( x p , u ) . U means all the possible control outputs from the state of the current node.

    The probabilistic collision risk P ( t ) [7] at timestamp t due to the static and moving obstacles
    P ( t ) = P s + ( 1 − P s ) ⋅ P d ( t ) (5)
    View Source Right-click on figure for MathML and additional features. \begin{equation*} P(t) = P_{s} + (1 - P_{s}) \cdot P_{d}(t)\tag{5}\end{equation*} and
    P d ( t ) = 1 − ∏ m = 1 M ( 1 − P d ( p m ( t ) ) ) (6)
    View Source Right-click on figure for MathML and additional features. \begin{equation*} P_{d}(t) = 1 - \prod _{m=1}^{M}(1 - P_{d}(p_{m}(t)))\tag{6}\end{equation*} where P s denotes the collision probability due to the static obstacles, P d ( t ) denotes the collision probability due to the moving obstacles at timestamp t (the trajectory of moving obstacle is represented by the Gaussian process), and P d ( p m ( t ) ) denotes the collision probability due to the planned trajectory of the moving obstacle p m at timestamp t .

Fig. 2.

Reconnection of the time-based tree in dynamic environment.

Show All

Just like the basic RRT tree, the time-based RRT tree continuously grows by sampling random nodes. However, it deletes the node that has a high probabilistic collision risk or has a smaller timestamp than that of the current tree root. Obviously, the generated trajectory is nonoptimal, e.g., the trajectory σ ( σ ( 0 ) = x 0 , σ ( T ) = x 9 ) in Fig. 2 . To optimize the generated trajectory, an intuitive idea is to reconnect the nodes on the trajectory with less cost. However, the reconnection process is difficult.

As shown in Fig. 2 , all branches related to the reconnected nodes need to update their information, which brings a large increment on the computation. For example, x 6 is reconnected to the tree root through the new node x ′ 1 . Then, x 6 becomes x ′ 2 , and all information needs to be updated. Similarly, the nodes x 7 , x 8 , and x 9 are also influenced by the reconnection process, and they are updated to be x ′ 3 , x ′ 4 , and x ′ 5 , respectively. In addition, some branches need to be deleted after the reconnection. As shown in Fig. 2 , the edge linking x 4 to x ′ 2 needs to be deleted because x 4 and x ′ 2 have the same timestamp. In terms of the obstacle prediction, at the timestamp t = t 0 + 2 Δ t , x ′ 2 has a high collision risk so all branches generated from x ′ 2 need to be deleted. Therefore, many useful branches are wasted, and we need to explore again the areas covered by these branches, which brings some repeated work and increases the computation.

In order to avoid the aforementioned problems, we propose the EB-RRT algorithm with the two-level planner. The generation of the initial feasible trajectory and its optimization is implemented in the global planner and dynamic replanner, respectively. The structure of the original tree is not destroyed, and the dynamic replanner will output control commands to direct the robot to move in the dynamic environment.
SECTION IV.
EB-RRT Algorithm

In this section, we introduce the EB-RRT algorithm on the basis of the Risk-RRT algorithm [7] in Section IV-A . Then, the completeness and optimality of the EB-RRT algorithm are proved in Section IV-B .
A. EB-RRT

As shown in Algorithms 1 and 3 , the EB-RRT algorithm consists of two planners. The global planner focuses on perceiving the dynamic environment and planning a feasible heuristic trajectory, while the dynamic replanner is responsible for optimizing the heuristic trajectory. Finally, the robot is directed to move along the optimized trajectory. In fact, the robot has a limited time to perform trajectory planning in a dynamic environment because of the moving obstacles. Therefore, the partial motion planning method [20] is used to implement the trajectory planning and robot execution in parallel. In each time step, the robot x r moves along the generated partial trajectory σ for one step, while the environment Map, the time-based tree T , the heuristic trajectory σ heu , and the optimized trajectory σ are all updated with the information from the robot perception. When the time step is over, σ is used for robot execution, and a new round of planning and execution begins.
Algorithm 1

EB-RRT: Global Planner

Show All
Algorithm 3

EB-RRT: Dynamic Replanner

Show All

In Algorithm 1 , the robot first perceives the current environment and obtains its state x r . The nodes whose timestamps are earlier than t 0 and their child nodes are deleted. In the following, the moving obstacles are predicted in N time steps, where N is the maximum depth of the time-based tree. The environment changes due to the moving obstacles and the robot movement, and then, all related variables are updated. Then, T grows during the time step Δ t , and the details of the growing process are provided in Algorithm 2 . First, the global planner randomly samples a node in the whole state space as x r a n d . Second, a node located on the existing tree T is selected as the nearest node x nearest to try connecting x rand in terms of (3) . In the following, x r a n d is adjusted to x new through a steering function. Third, if there is no obstacle between x new and x nearest and the probabilistic collision risk of x new at timestamp t does not exceed the threshold P threshold , then x new is connected, and T is extended to become a new T . By querying the current tree, a heuristic trajectory σ heu is obtained. The dynamic replanner optimizes σ heu and outputs the optimized trajectory σ , which directs the robot to move for one-time step. The whole procedure is iterated until the robot reaches the goal region. The function brake() indicates that if there is no feasible trajectory, the robot will stop in place until a newly feasible trajectory is generated.
Algorithm 2

EB-RRT: Grow( T )

Show All

In Algorithm 3 , the dynamic replanner optimizes the heuristic trajectory σ heu based on the EB method [6] . It is noted that different from the general reconnection method, the optimization procedure does not affect the time-based tree structure. With σ heu , the dynamic replanner obtains a new trajectory σ to direct the robot navigation, while the time-based tree grows continuously to update σ heu . In this way, no nodes on the tree are wasted, and no extra computation is required compared with the general reconnection method.

In the EB method, a trajectory is considered as an EB consisting of a series of bubbles. Then, with the internal contraction force and the external repulsive force from the obstacles, the EB is deformed until equilibrium. In the EB-RRT algorithm, the heuristic trajectory σ heu is also optimized using the internal contraction force and the external repulsive force.

First, the global planner continuously samples nodes to construct a trajectory. Based on the collision detection algorithm, each node is collision-free in the current configuration space. In addition, as we mentioned in Section III-B , each node x has a property called the probabilistic collision risk P ( t ) at any timestamp. In the EB method, the boundary of the bubble cannot touch the obstacles in the deformation process. Similarly, in the EB-RRT algorithm, the function computeRisk ( x new , t ) in Line 17 computes the probabilistic collision risk for each node. If the probabilistic collision risk is larger than the threshold, the corresponding node will be not added to the optimized trajectory σ . It guarantees that each node on σ is safe for robot navigation. Therefore, the probabilistic collision risk plays a role of external repulsive force to make the node far away from the obstacles.

Second, we apply the internal contraction force in these nodes located on the heuristic trajectory, which is continuously deformed until equilibrium. The internal contraction force f is defined as
f = k ⋅ ( x i − 1 − x i | | x i − 1 − x i | | + x i + 1 − x i | | x i + 1 − x i | | ) (7)
View Source Right-click on figure for MathML and additional features. \begin{equation*} f = k \cdot \left ({\frac {x_{i-1}-x_{i}}{||x_{i-1}-x_{i}||} + \frac {x_{i+1}-x_{i}}{||x_{i+1}-x_{i}||}}\right)\tag{7}\end{equation*} and then each node located on the heuristic trajectory σ heu is continuously adjusted in terms of the following equation:
x new = x i + α f (8)
View Source Right-click on figure for MathML and additional features. \begin{equation*} x_{\text {new}} = x_{i} + \alpha f\tag{8}\end{equation*} where k and α are two positive scaling factors. In this article, k = 1 and α = 1 . Theoretically, increasing the value of k and α should accelerate the optimization process of motion planning. However, when we enlarge k to 3 and 5, or enlarge α to 3 and 5, or enlarge them together, the improvement of the program time cost is smaller than 1%. The reason is that the heuristic trajectory σ heu consists of a small number of nodes, and the execution speed of the program is very fast. The physical interpretation of the internal contraction force is a series of springs between the nodes. Consider σ heu as an EB, and the force from each spring is normalized to reflect a uniform tension along σ heu . Then, x i is updated to x new using f .

Fig. 3 illustrates the optimization process. The red line, orange line, and yellow line denote the heuristic trajectory σ 1 , the intermediate trajectory σ 2 , and the final trajectory σ 3 , respectively. In the first round, σ 1 is updated to σ 2 with the internal contraction force f . Similarly, σ 2 is updated to σ 3 in the second round. At the timestamp t 0 + 4 Δ t , the black node x ′ ′ ′ 4 is detected with a high probabilistic collision risk due to the prediction of the moving obstacle. Therefore, x ′ ′ ′ 4 is not valid, and the optimization process is terminated. σ 3 becomes the final optimized trajectory.
Fig. 3.

Illustration of the EB-RRT algorithm. The gray polygons and blue triangles denote the static and moving obstacles, respectively. Three lines with different colors denote the generated trajectory in the optimization process.

Show All

The functions geodesicCheck ( σ heu ) in Line 1 and controlCheck ( x free , x new , x i + 1 ) in Line 16 are also associated with the optimization process. In general, any optimal trajectory in a metric space is a geodesic. Thus, in the function geodesicCheck ( σ heu ) , if the internal contraction force f satisfies the following condition:
f i < f threshold ∀ i ∈ [ 1 , I − 1 ] (9)
View Source Right-click on figure for MathML and additional features. \begin{equation*} f_{i} < f_{\text {threshold}}\quad \forall i \in [{1, I-1}]\tag{9}\end{equation*} where I − 1 denotes the number of nodes on the heuristic trajectory σ heu , it means that the current trajectory is already geodesic. Then, the function geodesicCheck ( σ heu ) will return false. The function controlCheck ( x free , x new , x i + 1 ) detects the feasibility that the robot moves from x free to x i + 1 via x new . If the required linear velocity, linear acceleration, angular velocity, and angular acceleration do not exceed the limits, it means that robot can successfully achieve the aforementioned movement. Then, the function controlCheck ( x free , x new , x i + 1 ) returns true. In this article, the constraints include the linear velocity v ∈ [ 0 , 1.0 ]   (m/s) , the linear acceleration a ∈ [ 0 , 1.0 ]   ( m/s 2 ) , the angular velocity ω ∈ [ 0 , 0.5 ]   (rad/s) , and the angular acceleration α ∈ [ 0 , 0.5 ]   ( rad/s 2 ) .

Therefore, the optimization process will be terminated due to three reasons.

    The internal contraction force between any two neighbor nodes on the trajectory is less than f threshold , which means that the function geodesicCheck ( σ heu ) returns false.

    The kinematic and dynamic constraints make the optimization process not going further, which means that the function controlCheck ( x free , x new , x i + 1 ) returns false.

    The probabilistic collision risk of the new generated node exceeds the threshold, which means that the value of P ( t ) from the function computeRisk ( x new , t ) is larger than P threshold and the generated node x new is not valid.

We can see that in the whole optimization process, the structure of the original time-based tree does not change, and no branches are wasted. In addition, no extra computation is required to modify the node information on the time-based tree. Compared with general reconnection methods, we obtain a relatively independent final trajectory based on σ heu and avoid the aforementioned problems.
B. Completeness and Optimality Analysis

As we all know, the RRT algorithm is probabilistic complete, which means that the probability of finding a feasible trajectory approaches to one if it exists with the number of iterations approaching infinity. In this article, the EB-RRT algorithm uses the RRT trajectory as the heuristic trajectory. Therefore, the EB-RRT algorithm retains the same probabilistic completeness as that of the RRT.

In [8] and [21] , the proposed RRT* algorithm is proven to be asymptotically optimal. The EB-RRT algorithm also has a similar property, namely homotopy optimality. In the robot navigation progress, the heuristic trajectory is partially planned in each time step. Thus, the homotopy optimality of the EB-RRT algorithm refers to the current partially planned trajectory instead of the whole trajectory connecting the start and goal positions. In other words, based on the current heuristic trajectory, the EB-RRT algorithm can generate an optimized trajectory guaranteeing the homotopy optimality. In the following, we prove that the EB-RRT algorithm is optimal in the homotopy class of the current heuristic trajectory.

First, we give the definition of the homotopy class of trajectories and the homotopy optimal trajectory.

Definition 1 (Homotopy Class of Trajectories [22] ):

Two trajectories, σ 1 and σ 2 , are said to be in the same Homotopy Class iff one can be smoothly deformed into the other without intersecting obstacles. Otherwise, they belong to different homotopy classes.

Let Σ ^ denote a homotopy class of trajectories, and σ ^ is an arbitrary trajectory in Σ ^ . A homotopy optimal trajectory σ ^ ∗ is defined as
σ ^ ∗ = arg min σ ^ ∈ Σ ^   c ( σ ^ ) s.t.   σ ^ ( 0 ) = x init s.t.   σ ^ ( T ) ∈ G ( x goal , T ) s.t.   σ ^ ( t ) ∈ X free ( t ) ∀ t ∈ [ 0 , T ] . (10)
View Source Right-click on figure for MathML and additional features. \begin{align*} \hat {\sigma }^{*}=&\underset {\hat {\sigma } \in \hat {\Sigma }}{\arg \min }~ c(\hat {\sigma }) \\&\text {s.t.} ~\hat {\sigma }(0) = x_{\text {init}} \\&\hphantom {\text {s.t.} ~} \hat {\sigma }(T) \in \mathcal {G}(x_{\text {goal}}, T) \\&\hphantom {\text {s.t.} ~}\hat {\sigma }(t) \in \mathcal {X}_{\text {free}}(t)\quad \forall t \in [0,T].\tag{10}\end{align*} Then, we need to prove the following lemma.

Lemma 1:

The generated trajectory σ ^ ∗ from the EB-RRT algorithm is the optimal trajectory in the homotopy class consisting of the heuristic trajectory.

Proof:

As shown in Algorithm 2 , we use the EB method to optimize the heuristic trajectory. When the optimization process is over, we obtain an optimized trajectory σ ^ ∗ . In fact, the shape of the heuristic trajectory has a big impact on the optimization process. Thus, we discuss the homotopy optimality according to different shapes of the heuristic trajectory.

First Case: The Heuristic Trajectory Is a Geodesic: For two arbitrary nodes, a geodesic connecting them is the optimized trajectory in its homotopy class if there is no obstacle between them. Therefore, if the heuristic trajectory is a geodesic, the function geodesicCheck ( σ heu ) returns false. Therefore, the optimization process is not executed, and the final trajectory σ ^ ∗ is the same as the heuristic trajectory. Since the heuristic trajectory is optimal in its homotopy class, σ ^ ∗ is optimal in its homotopy class.

Second Case: The Heuristic Trajectory Is Not a Geodesic: Generally, the trajectory between two nodes is not a geodesic due to the kinematic and dynamic constraints or the existence of the obstacles. As shown in Fig. 4 , there are two types of final optimized trajectory. Here, we use reduction to absurdity to prove the homotopy optimality of σ ^ ∗ in its homotopy class. Suppose that there is another trajectory σ ^ z such that σ ^ z ≠ σ ^ ∗ and c ( σ ^ z ) < c ( σ ^ ∗ ) , where c ( ) refers to the cost function defined in Section III-A .
Fig. 4.

Two types of the final optimized trajectory. The blue arrow denotes the current velocity of the robot at x start , and the magenta arrow denotes the maximum acceleration of the robot. (a) Acceleration constraint. (b) Obstacle constraint.

Show All

In Fig. 4(a) , the optimization process is terminated due to the maximum acceleration constraint. Because c ( σ ^ ) z < c ( σ ^ ∗ ) , σ ^ z must be located between σ ^ ∗ and σ s , where σ s is a geodesic connecting the start and end nodes. Obviously, σ ^ z does not satisfy the kinematic and dynamic constraints. Therefore, such a trajectory does not exist, which is conflicted with the hypothesis. In Fig. 4(b) , the optimization process is terminated because the probabilistic collision risk of the newly generated node exceeds the threshold. Again, if σ ^ z exists, it should be located between σ ^ ∗ and σ s . However, the nodes on σ ^ z cannot pass the collision check. Then, such a trajectory does not exist, and the hypothesis is not true.

In conclusion, we prove that σ ^ ∗ is the optimal trajectory in its homotopy class.

According to the conclusions from the first and second cases, the proof is finished.
SECTION V.
Results of Simulation Experiments

In this section, we conduct the simulation experiments in three different scenarios (as shown in Fig. 5 ) on the basis of robot operating system (ROS). We use Ubuntu 16.04 on an Intel i5-4590 with 8-GB RAM as our experimental platform. The robot parameters in the simulation experiments are listed in the following table:
Fig. 5.

Simulation scenarios. Each scenario consists of some obstacles and pedestrians, which moves around the current scenario. The initial poses of the robot in three scenarios are (−1.5, −10, 90°), (−12, 1, 0°), and (8, 9, −90°), while the coordinates of the goal are (0, 10), (10, −3) and (−4, −12), respectively. The red, green, and blue lines denote the trajectory generated by Risk-RRT algorithm, Risk-RRT* algorithm, and our proposed EB-RRT algorithm at different timestamps, respectively. (a) Scenario 1, t = 10.0 s. (b) Scenario 1, t = 20.0 s. (c) Scenario 1, t = 29.4 s. (d) Scenario 2, t = 20.0 s. (e) Scenario 2, t = 40.0 s. (f) Scenario 2, t = 51.2 s. (g) Scenario 3, t = 12.0 s. (h) Scenario 3, t = 24.0 s. (i) Scenario 3, t = 34.8 s.

Show All

Here, v m , a m , ω m , and α m represent the maximum linear velocity, the maximum linear acceleration, the maximum angular velocity, and the maximum angular acceleration, respectively. As shown in Fig. 5 , the sizes of both scenario 1 and scenario 2 are 26 m × 23 m , and the size of scenario 3 is 28 m × 30 m . Three, two and eight pedestrians in each scenario are walking forth and back with the specified velocity, v p = 0.5 m/s . The goal region is defined as G ( x goal , t ) = { x ∈ X free ∣ ∣ | | x − x goal | | < 0.2 m } . In other words, the robot is defined as having arrived at its goal region when its distance to the goal position is smaller than 0.2 m.

We compare our proposed EB-RRT algorithm with two state-of-the-art risk-based motion planning algorithms, Risk-RRT and Risk-RRT*. In each scenario, the execution is repeated 50 times. We use the navigation time (including the planning time and the robot execution time) and the length of the generated trajectory as the metrics to evaluate the performance of each algorithm.
A. Simulation Experiment Results

The experimental performance of 50 simulation trials is shown in Fig. 6 . First, Fig. 6(a) shows the length of the generated trajectory of three different algorithms in three different scenarios. The average trajectory lengths of the EB-RRT algorithm are the shortest among these three methods. Also, the smallest deviation means that the EB-RRT algorithm performs most stably. Second, Fig. 6(b) shows the navigation time cost of three different algorithms in three different scenarios. Compared with the Risk-RRT and Risk-RRT* algorithms, the EB-RRT algorithm uses the shortest time, and the standard deviation of the time cost is also the smallest.
Fig. 6.

Simulation experimental results in different scenarios. (a) Trajectory length. (b) Navigation time cost. The circle and cross mark denote the mean value, and the line denotes the standard deviation.

Show All

B. Analysis of Simulation Experiment Results

The Risk-RRT* algorithm, as a traditional reconnection method, reduces the trajectory length, but this improvement is limited. Since the robot moves in a dynamic environment, dynamic motion planning requires a real-time response. Therefore, the time allocated for the reconnection process is limited. However, as mentioned in Section III , the Risk-RRT* algorithm needs to do much extra computation to finish the whole reconnection process step by step, which is similar to the RRT* algorithm. Thus, the reconnection process cannot be finished completely in a limited time step, and the improvement is not significant. In Fig. 5 , we can also see that in the early time, the Risk-RRT* algorithm performs very well because there are only a small number of nodes and the reconnection process can be finished easily. As the number of nodes increases, the Risk-RRT* does not perform well. However, the EB-RRT algorithm always performs well in the whole navigation process. Depending on the heuristic trajectory, the EB-RRT algorithm quickly obtains an optimized trajectory with the EB method, and the number of nodes (the length of the heuristic trajectory) does not affect the optimization process. This optimized trajectory is independent of the Risk-RRT time-based tree structure, so the tree structure is not affected and no extra computation is required compared with the Risk-RRT* algorithm. Therefore, we can find that the length of the final trajectory generated from the EB-RRT algorithm is much shorter than those from the Risk-RRT and the Risk-RRT* algorithm.

We can also find that in different trials, the performance of the EB-RRT algorithm is different. The reason is that the EB optimization process is based on the partially planned heuristic trajectory on each timestamp and the heuristic trajectories at the same timestamp in different trials are different. The standard deviation of the navigation time cost and the length of the final trajectory indicates that the difference of the heuristic trajectories has an impact on the EB optimization process. In conclusion, compared with the other state-of-the-art algorithms, the EB-RRT algorithm costs the least navigation time and generates the shortest trajectory, which reveals the efficiency and effectiveness of our proposed EB-RRT algorithm.
SECTION VI.
Discussion

In the time-based RRT tree algorithm, there are mainly three predefined parameters, including the maximum depth N , the time step Δ t , and the maximum velocity v max . In order to show the robustness of our algorithm, we further discuss the performance of the Risk-RRT, the Risk-RRT*, and the EB-RRT algorithms under different parameter settings via simulation experiments. We carry out the simulation experiments in scenario 1, as shown in Fig. 5 . The start state is (−1.5, −10, 90°), and the goal region is a circle centered at (0, 10) with a radius 0.2 m. For each different parameter setting, 50 times of repeated experiments are carried out, and the navigation time and the length of the generated trajectory are used to evaluate the performance of different algorithms.

In addition, we also test our algorithm in a more challenging environment to further evaluate its performance.
A. Different Maximum Depth N

The maximum depth N is the maximum growth depth of the tree from the current node. As mentioned earlier, the probabilistic collision check will be implemented in a limited period [ t , t + N ∗ Δ t ] . If N is small, the result of the probabilistic collision check is more confident, but the tree can only grow within a small size. As shown in Fig. 5(a), (d), and (g) , all algorithms can only provide a partially generated trajectory due to the limitation of the maximum depth N . If N is large, a big collision check estimation may cause a failure of the motion planning, but the tree can grow within a big size. Therefore, it is a tradeoff to set the value of the maximum depth N in terms of the quality of the trajectory and the accuracy of the collision check estimation.

In Fig. 7(a) and (d) , four different maximum depths N are used to evaluate the performance of three algorithms. The bar denotes the mean value, and the line denotes the standard variation of 50 times simulation experiments. In general, when N = 80 , 100 , and 120, the performance of the three algorithms does not change too much. However, when N increases to 150, the standard variations of the Risk-RRT and the Risk-RRT* become larger obviously. The reason is that when N becomes larger, the accuracy of the collision check estimation begins to decline, and the length of the generated trajectory is longer at the present time; then, the quality of the trajectory cannot be guaranteed. However, the EB-RRT still performs well when N = 150 . Moreover, the navigation time decreases a little because the EB method can optimize a relatively long trajectory at each timestamp and the optimization result becomes better.
Fig. 7.

Simulation experimental results in scenario 1 under a different maximum depth N , time step Δ t , and maximum velocity v max . The bar denotes the mean value, and the line denotes the standard variation of 50 times simulation experiments. (a) Navigation time under a different value of N . (b) Navigation time under a different value of Δ t . (c) Navigation time under a different value of v max . (d) Trajectory length under a different value of N . (e) Trajectory length under a different value of Δ t . (f) Trajectory length under a different value of v max .

Show All

In conclusion, under a different maximum depth N , the EB-RRT always achieves the best performance compared with the other algorithms, which reveals the robustness of the EB-RRT algorithm.
B. Different Time Step Δ t

First, the time step Δ t is the time increment between two nodes. With the same maximum velocity v max , when the Δ t is large, the distance between two nodes also becomes large. Second, Δ t also denotes the planning time in the navigation process. In the time-based tree algorithm, the planning and execution processes are carried out in parallel. Within Δ t , the robot moves from one node to its child node, while the trajectory is updated using the latest information. In order to get a real-time response, the time step Δ t is required to be set to a small value.

In Fig. 7(b) and (e) , three different time step Δ t are used to evaluate the performance of three algorithms. The bar denotes the mean value, and the line denotes the standard variation of 50 times simulation experiments. We can find that the Risk-RRT and Risk-RRT* algorithms are sensitive to the change of Δ t . When Δ t = 0.4 s , both the mean value and the standard variation of the navigation time cost obviously increase. The reason is that the generated trajectory becomes rough when Δ t is large and the quality of the generated trajectory declines. However, the change of Δ t has little effect on the EB-RRT algorithm. Among these three algorithms, the EB-RRT algorithm achieves the best performance, which shows the robustness of the EB-RRT algorithm again.
C. Different Maximum Velocity v max

The maximum velocity v max is an important parameter in the time-based tree algorithm. It directly affects the navigation time cost. Also, when v max becomes larger, it has a higher requirement for the robot to maintain a real-time response.

In Fig. 7(c) and (f) , four different maximum velocities v max are used to evaluate the performance of three algorithms. The bar denotes the mean value, and the line denotes the standard variation of 50 times simulation experiments. As for the length of the generated trajectory, all algorithms are not very sensitive to the change of v max . The navigation time cost naturally decreases as v max increases. We can find that the EB-RRT algorithm always performs best in the navigation time cost and the trajectory length for each different maximum velocity v max , which reveals the stability and robustness of the EB-RRT algorithm.
D. Simulation Experiment in a Challenging Scenario

In order to further reveal the robustness of our algorithm, we test our algorithm in a more challenging scenario, crowded environment. As shown in Fig. 8 , 16 pedestrians are adopted to demonstrate the crowded environment. They move along the black dotted line, and the magenta arrow denotes the current moving direction. It is noted that their moving direction changes in Fig. 8(c) . We test our algorithm 50 times, and the success rate is 86%. For the other 14% of trails that are not successful, the reason is that the global planner cannot compute a feasible trajectory due to insufficient reaction time. Therefore, the robot cannot avoid the collision, which is considered as a failure.
Fig. 8.

Simulation experiment in a challenging environment. The red and blue dotted lines denote the heuristic trajectory and optimized trajectory, respectively; 16 pedestrians are moving along the black dotted line, and the magenta arrow denotes the current moving direction. (a) t = 10.1 s. (b) t = 27.2 s. (c) t = 31.4 s.

Show All

In our algorithm, the global planner continuously searches the feasible trajectory at each iteration. When there is no feasible trajectory due to the influence of the moving pedestrian, the robot will stay in place until the global planner finds a new feasible trajectory. However, sometimes, the global planner will fail due to insufficient reaction time before the collision. A failure example is shown in Fig. 8 . First, in Fig. 8(a) and (b) , the planner can generate a collision-free trajectory for the robot with the trajectory prediction for the moving pedestrians, where a probabilistic prediction method using a Gaussian process is implemented. However, in Fig. 8(c) , there is a sudden reversal of motion of the pedestrians, and the robot cannot quickly make a correct prediction. Therefore, the collision is not avoided, and path planning fails.

In order to solve this problem, we consider two improved methods in future work. The first method is taking into account the uncertainty in the path planning process. The uncertainty includes the pedestrian trajectory prediction uncertainty, measurement uncertainty from the sensors, and robot execution uncertainty, among others. These uncertainties should be considered to generate a safe trajectory. The second method is increasing the clearance between the robot and the obstacles in the path planning process. In this way, the robot can get more time to avoid the coming collision. However, the trajectory length will also increase. More time and energy are required for the robot to achieve the designated path planning work. Thus, it is a tradeoff between increasing the clearance and maintaining an energy-optimal or time-optimal trajectory.
SECTION VII.
Conclusion and Future Work

In this article, the EB-RRT algorithm consisting of two planners is proposed to deal with the mobile robot motion planning in dynamic environments. In the global planner, a heuristic trajectory is obtained, and in the dynamic replanner, the heuristic trajectory is optimized with the EB method. The final generated trajectory has been proven to be homotopy optimal. Simulation experiments indicate that our algorithm achieves the best performance in the navigation time cost and the trajectory length compared with the other state-of-the-art algorithms.

Essentially, in the EB-RRT algorithm, the EB optimization process provides a new cost function to guide the tree growth. However, different from the conventional method where a large number of old nodes are deleted and many new nodes are added, our algorithm only adds some new nodes along the generated trajectory to the tree to form a better trajectory. It not only considers the Euclidean distance and the angle difference between any two neighbor nodes on the trajectory but also takes into account the internal contraction force and external repulsive force acting on the current trajectory.

Recently, the inverse reinforcement learning methods [23] – [25] are widely used to learn a new cost function from the demonstrations in the robot social navigation. In the future, we plan to apply the inverse reinforcement learning method into our global planner to guide the generation of the initial trajectory. The learned cost function can satisfy different requirements in different scenarios. For example, sometimes, the clearance with the obstacles is more important, or the smooth level of the trajectory is required. For different initial trajectories, we still can use our dynamic replanner to optimize it. Naturally, another intuitive prospect is to use the reinforcement learning method to imitate humans to optimize the initial trajectory.
ACKNOWLEDGMENT

This work was finished when the first author visited the Robotics Laboratory, Stanford University, whose hosting is gratefully acknowledged. The authors also appreciate Shameek Ganguly and Margot Vulliez’s advice on this work.

Authors
Figures
References
Citations
Keywords
Metrics
More Like This
Path Planning for Mobile Robots in Dynamic Environments Using Particle Swarm Optimization

2009 International Conference on Advances in Recent Technologies in Communication and Computing

Published: 2009
Mobile robot path planning using Ant Colony Optimization

2016 2nd IEEE International Symposium on Robotics and Manufacturing Automation (ROMA)

Published: 2016
Show More
References
1.
B. Siciliano and O. Khatib, Springer Handbook of Robotics, Berlin, Germany:Springer, 2016.
Show in Context CrossRef Google Scholar
2.
O. Khatib, "Real-time obstacle avoidance for manipulators and mobile robots", Int. J. Robot. Res. , vol. 5, no. 1, pp. 90-98, 1986.
Show in Context CrossRef Google Scholar
3.
P. Hart, N. Nilsson and B. Raphael, "A formal basis for the heuristic determination of minimum cost paths", IEEE Trans. Syst. Sci. Cybern. , vol. 4, no. 2, pp. 100-107, 1968.
Show in Context View Article
Google Scholar
4.
S. M. LaValle and J. J. Kuffner, "Randomized kinodynamic planning", Int. J. Robot. Res. , vol. 20, no. 5, pp. 378-400, May 2001.
Show in Context CrossRef Google Scholar
5.
L. E. Kavraki, P. Svestka, J.-C. Latombe and M. H. Overmars, "Probabilistic roadmaps for path planning in high-dimensional configuration spaces", IEEE Trans. Robot. Autom. , vol. 12, no. 4, pp. 566-580, Aug. 1996.
Show in Context View Article
Google Scholar
6.
S. Quinlan and O. Khatib, "Elastic bands: Connecting path planning and control", Proc. IEEE Int. Conf. Robot. Autom. , pp. 802-807, May 1993.
Show in Context View Article
Google Scholar
7.
C. Fulgenzi, A. Spalanzani, C. Laugier and C. Tay, "Risk based motion planning and navigation in uncertain dynamic environment", pp. 14, 2010, [online] Available: https://hal.inria.fr/inria-00526601.
Show in Context Google Scholar
8.
S. Karaman and E. Frazzoli, "Sampling-based algorithms for optimal motion planning", Int. J. Robot. Res. , vol. 30, no. 7, pp. 846-894, Jun. 2011.
Show in Context CrossRef Google Scholar
9.
J. D. Gammell, S. S. Srinivasa and T. D. Barfoot, "Informed RRT*: Optimal sampling-based path planning focused via direct sampling of an admissible ellipsoidal heuristic", Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. , pp. 2997-3004, Sep. 2014.
Show in Context Google Scholar
10.
O. Salzman and D. Halperin, "Asymptotically near-optimal RRT for fast high-quality motion planning", IEEE Trans. Robot. , vol. 32, no. 3, pp. 473-483, Jun. 2016.
Show in Context View Article
Google Scholar
11.
J. Wang, W. Chi, C. Li, C. Wang and M. Q.-H. Meng, "Neural RRT*: Learning-based optimal path planning", IEEE Trans. Autom. Sci. Eng. , Mar. 2020.
Show in Context View Article
Google Scholar
12.
J. D. Gammell, S. S. Srinivasa and T. D. Barfoot, "Batch informed trees (BIT*): Sampling-based optimal planning via the heuristically guided search of implicit random geometric graphs", Proc. IEEE Int. Conf. Robot. Autom. (ICRA) , pp. 3067-3074, May 2015.
Show in Context View Article
Google Scholar
13.
J. Wang, W. Chi, M. Shao and M. Q.-H. Meng, "Finding a high-quality initial solution for the RRTs algorithms in 2D environments", Robotica , vol. 37, no. 10, pp. 1677-1694, 2019.
Show in Context CrossRef Google Scholar
14.
F. Islam, J. Nasir, U. Malik, Y. Ayaz and O. Hasan, "RRT-smart: Rapid convergence implementation of RRT towards optimal solution", Proc. IEEE Int. Conf. Mechatronics Autom. , pp. 1651-1656, Aug. 2012.
Show in Context Google Scholar
15.
J. Wang and M. Q.-H. Meng, "Optimal path planning using generalized Voronoi graph and multiple potential functions", IEEE Trans. Ind. Electron. , Jan. 2020.
Show in Context View Article
Google Scholar
16.
J. Bruce and M. M. Veloso, "Real-time randomized path planning for robot navigation", Robot Soccer World Cup , pp. 288-295, 2002.
Show in Context View Article
Google Scholar
17.
M. Zucker, J. Kuffner and M. Branicky, "Multipartite RRTs for rapid replanning in dynamic environments", Proc. IEEE Int. Conf. Robot. Autom. , pp. 1603-1609, Apr. 2007.
Show in Context View Article
Google Scholar
18.
M. Otte and E. Frazzoli, "RRTX: Asymptotically optimal single-query sampling-based motion planning with quick replanning", Int. J. Robot. Res. , vol. 35, no. 7, pp. 797-822, Jun. 2016.
Show in Context CrossRef Google Scholar
19.
D. Ferguson and A. Stentz, "Anytime RRTs", Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. , pp. 5369-5375, Oct. 2006.
Show in Context View Article
Google Scholar
20.
S. Petti and T. Fraichard, "Safe motion planning in dynamic environments", Proc. IEEE/RSJ Int. Conf. Intell. Robots Syst. , pp. 2210-2215, Aug. 2005.
Show in Context View Article
Google Scholar
21.
K. Solovey, L. Janson, E. Schmerling, E. Frazzoli and M. Pavone, "Revisiting the asymptotic optimality of RRT*", arXiv:1909.09688 , 2019, [online] Available: http://arxiv.org/abs/1909.09688.
Show in Context Google Scholar
22.
S. Bhattacharya, V. Kumar and M. Likhachev, "Search-based path planning with homotopy class constraints", Proc. 3rd Annu. Symp. Combinat. Search , pp. 1-8, 2010.
Show in Context Google Scholar
23.
N. D. Ratliff, J. A. Bagnell and M. A. Zinkevich, "Maximum margin planning", Proc. 23rd Int. Conf. Mach. Learn. (ICML) , pp. 729-736, 2006.
Show in Context CrossRef Google Scholar
24.
K. Shiarlis, J. Messias and S. Whiteson, "Rapidly exploring learning trees", Proc. IEEE Int. Conf. Robot. Autom. (ICRA) , pp. 1541-1548, May 2017.
Show in Context View Article
Google Scholar
25.
N. Pérez-Higueras, F. Caballero and L. Merino, "Teaching robot navigation behaviors to optimal RRT planners", Int. J. Social Robot. , vol. 10, no. 2, pp. 235-249, Apr. 2018.
Show in Context CrossRef Google Scholar
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
