TOPOLOGICAL AND GEOMETRIC TECHNIQUES IN GRAPH SEARCH-BASED ROBOT PLANNING
Subhrajit Bhattacharya
A DISSERTATION in
Mechanical Engineering and Applied Mechanics Presented to the Faculties of the University of Pennsylvania
in Partial Fulﬁllment of the Requirements for the
Degree of Doctor of Philosophy
2012

Supervisor of Dissertation

Co-Supervisor

Vijay Kumar, Professor, Department of Mechanical Engineering and Applied Mechanics, University of Pennsylvania.
Graduate Group Chairperson

Maxim Likhachev, Research Assistant Professor, School of Computer Science, Robotics Institute, Carnegie Mellon University.

Jennifer Lukes, Associate Professor, Department of Mechanical Engineering and Applied Mechanics.
Dissertation Committee George J. Pappas, Professor, Department of Electrical and Systems Engineering. Daniel E. Koditschek, Professor, Department of Electrical and Systems Engineering. Robert Ghrist, Professor, Department of Mathematics.

TOPOLOGICAL AND GEOMETRIC TECHNIQUES IN GRAPH SEARCH-BASED ROBOT PLANNING
COPYRIGHT 2012 Subhrajit Bhattacharya
This work is licensed under the Creative Commons Attribution-NonCommercialShareAlike 3.0 License. To view a copy of this license, visit http://creativecommons.org/licenses/by-ncsa/3.0/.

Acknowledgments
I would like to express my sincere gratitude towards my advisors, Dr. Vijay Kumar and Dr. Maxim Likhachev, for their continuous support and guidance. Their mentoring and help all these years have been indispensable in my research that has culminated in this thesis.
I would like to thank the rest of my thesis committee, Dr. George J. Pappas, Dr. Daniel E. Koditschek and Dr. Robert Ghrist, for their valuable time, eﬀort and suggestions.
My sincere gratitude goes to Dr. Robert Ghrist and Dr. David Lipsky for sharing their valuable insights into topics on algebraic topology, and for collaborating on the work related to homology of punctured Euclidean spaces. I would also like to thank Dr. Nathan Michael and Dr. Luciano Pimenta for their collaboration on the work on exploration and coverage.
My sincere thanks to the Department of Mechanical Engineering and Applied Mechanics, and the GRASP laboratory of University of Pennsylvania for providing such a wonderful opportunity and an amazing academic experience throughout my doctoral studies.
My special thanks goes to the Wikimedia foundation for providing easy and quick reference to a vast amount of knowledge through Wikipedia. Much of this thesis, especially the illustrations in it, wouldn’t have been made possible without the amazing community-maintained software provided by the Blender foundation, Apache software foundation and other open-source software – my sincere appreciation and thanks to them. I would also like to thank Dr. N. J. Wildberger, UNSW, for his online video lectures on algebraic topology, and Mr. D. Simeonov and Mr. M. Fleder, MIT, for providing the example in Figure 3.3(a) of this thesis.
Finally, my heartiest thanks goes to my parents, friends and family for their support and encouragement all along.
iii

ABSTRACT
TOPOLOGICAL AND GEOMETRIC TECHNIQUES IN GRAPH SEARCH-BASED ROBOT PLANNING
Subhrajit Bhattacharya
Vijay Kumar and Maxim Likhachev
Search-based techniques have been widely used in robot path planning for ﬁnding optimal or closeto-optimal trajectories in conﬁguration spaces. They have the advantages of being complete, optimal (up to the metric induced by the discretization) and eﬃcient (in low dimensional problems), and broadly applicable, even to complex environments. Continuous techniques, on the other hand, that incorporate concepts from diﬀerential and algebraic topology and geometry, have the ability to exploit speciﬁc structures in the original conﬁguration space and can be used to solve diﬀerent problems that do not lend themselves to graph-search based techniques. We propose several novel ideas and develop new methodologies that will let us bring these two separate techniques under one umbrella. Using tools from algebraic topology we deﬁne diﬀerential forms with special properties whose integral reveal topological information about the solution path allowing us to impose topological constraints on the planning problems. Metric information can be used along with search-based techniques for creating Voronoi tessellations in coverage and exploration problems. In particular, we use entropy as a metric for multi-robot exploration and coverage of unknown or partially known non-convex environments. Finally, in multi-robot constrained planning problems we exploit certain special product structure in the high dimensional conﬁguration space that combine the advantages of graph search methods and gradient descent algorithms allowing us to develop powerful tools to solve very high-dimensional planning problems.
iv

Contents

1 Introduction

1

1.1 Conﬁguration Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

1.1.1 Continuous Approaches to Robot Motion Planning . . . . . . . . . . . . . . . 2

1.1.2 The Discrete Approach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4

1.2 Contributions of this Thesis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

2 Preliminaries

9

2.1 Basic Algebraic Topology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.1.1 Background: Point-set Topology . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.1.2 Motivation of Algebraic Topology . . . . . . . . . . . . . . . . . . . . . . . . . 12

2.1.3 Formal Description of Homology . . . . . . . . . . . . . . . . . . . . . . . . . 16

2.1.4 Properties of Homology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

2.1.5 Cohomology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

2.2 Elementary Riemannian Geometry . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

2.2.1 Manifolds, Coordinate Charts, Atlases and Tangent Space . . . . . . . . . . . 24

2.2.2 Riemannian Metric, Geodesics and Curvature . . . . . . . . . . . . . . . . . . 29

2.3 Graph Search Algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

2.3.1 Dijkstra’s Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

2.3.2 A* Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

3 Search-based Path Planning with Topological Constraints in 2 and 3 Dimensional

Euclidean Spaces

38

3.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

3.1.1 Motivation: Homotopy Classes of Trajectories . . . . . . . . . . . . . . . . . . 38

3.1.2 Capturing Topological Information in Search-based Planning . . . . . . . . . 39

3.1.3 H-signature as Class Invariants for Trajectories . . . . . . . . . . . . . . . . . 40

3.2 Homotopy and Homology Classes of Trajectories . . . . . . . . . . . . . . . . . . . . 41

3.3 H-signature in 2-dimensional Euclidean Conﬁguration Space . . . . . . . . . . . . . 43

3.3.1 Background: Complex Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . 43

3.3.2 Designing a H-signature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

3.3.3 Computation for a Line Segment . . . . . . . . . . . . . . . . . . . . . . . . . 46

3.4 H-signature in 3-dimensional Euclidean Conﬁguration Space . . . . . . . . . . . . . 47

v

3.4.1 Background: Electromagnetism . . . . . . . . . . . . . . . . . . . . . . . . . . 48 3.4.2 Designing a H-signature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 3.4.3 Computation for a Line Segment . . . . . . . . . . . . . . . . . . . . . . . . . 52 3.5 H-signature Augmented Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 3.5.1 Uses of the H-signature Augmented Graph . . . . . . . . . . . . . . . . . . . 56 3.5.2 Theoretical Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 3.6 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57 3.6.1 Two-dimensional Conﬁguration Space . . . . . . . . . . . . . . . . . . . . . . 57 3.6.2 Three-dimensional Conﬁguration Space . . . . . . . . . . . . . . . . . . . . . 64

4 Identiﬁcation of Homology Classes in Euclidean Spaces with Punctures

68

4.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68

4.2 Simplifying the Problem by Taking (D − N )-dimensional Equivalents of Obstacles . 69

4.2.1 Reduced Problem Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

4.3 Preliminaries on Linking Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

4.3.1 Deﬁnitions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

4.3.2 Propositions on Linking Number . . . . . . . . . . . . . . . . . . . . . . . . . 76

4.3.3 Computation of Intersection/Linking Number for Given Cycles . . . . . . . . 77

4.4 Computation in Our Speciﬁc Problem . . . . . . . . . . . . . . . . . . . . . . . . . . 78

4.4.1 Computation of the integral in φS . . . . . . . . . . . . . . . . . . . . . . . . 80 4.4.2 Incorporating Multiple Connected Components of S . . . . . . . . . . . . . . 82

4.5 Validations in Low Dimensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

4.5.1 D = 2, N = 2 : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

4.5.2 D = 3, N = 2 : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

4.5.3 D = 3, N = 3 : . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

4.6 Examples and Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

4.6.1 An Example for D = 5, N = 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

4.6.2 Exploring Paths in Diﬀerent Homotopy Classes in a 4-dimensional Space . . 89

4.7 From Homology to Homotopy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

4.7.1 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93

5 Coverage and Exploration Using Search-based Methods

95

5.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95

5.2 Background: Coverage Functional, Voronoi Tessellation and Continuous-time Lloyd’s

Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

5.3 Generalization to non-Euclidean Distance Function . . . . . . . . . . . . . . . . . . . 98

5.4 Graph-search Based Lloyd’s Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . 103

5.4.1 Graph-search Based Voronoi Tessellation . . . . . . . . . . . . . . . . . . . . 104

5.4.2 Algorithm for Tessellation and Control Computation . . . . . . . . . . . . . . 106

5.4.3 Overall Algorithm: Adapted Lloyd’s Algorithm . . . . . . . . . . . . . . . . . 107

5.4.4 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

5.5 Application to Simultaneous Coverage and Exploration Problem . . . . . . . . . . . 110

5.5.1 Entropy as Density Function . . . . . . . . . . . . . . . . . . . . . . . . . . . 111

vi

5.5.2 5.5.3 5.5.4

Entropy-Based Metric . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111 Time Dependence of Entropy, Coverage, and Convergence . . . . . . . . . . . 112 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115

6 Dimensional Decomposition for Eﬃcient Planning

119

6.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119

6.2 Problem Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

6.2.1 The Optimization Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

6.2.2 Problem Assumptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

6.3 The Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 122

6.4 Theoretical Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

6.4.1 Notations and Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

6.4.2 Theorems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125

6.5 Discrete Solution for the Sub-problems . . . . . . . . . . . . . . . . . . . . . . . . . . 127

6.5.1 Basic Graph Construction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

6.5.2 Product with Task Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

6.6 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

6.6.1 An Exact Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130

6.6.2 A Discrete Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

6.6.3 Additional Complexity with Tasks . . . . . . . . . . . . . . . . . . . . . . . . 135

7 Coordinate Transformation for Eﬃcient Optimal Planning in Environments with

Non-Euclidean Metric

139

7.1 Introduction and Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139

7.1.1 Problem Deﬁnition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140

7.1.2 A Motivating Example in Two Dimensions . . . . . . . . . . . . . . . . . . . 141

7.2 Embeddings in Euclidean Spaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144

7.2.1 Isometric Embedding in Euclidean Space . . . . . . . . . . . . . . . . . . . . 144

7.2.2 Non-isometric Embedding with Geodesics Mapping to ‘Straight Lines’ . . . . 145

7.3 Orthogeodesic Embedding of Spaces of Constant Intrinsic Curvatures . . . . . . . . . 145

7.3.1 Motivating Example: Gnomonic Projection of Half-sphere . . . . . . . . . . . 145

7.3.2 Klein-Beltrami Model of the Hyperbolic Plane . . . . . . . . . . . . . . . . . 147

7.3.3 Coordinate Charts that Induce Orthogeodesic Embedding . . . . . . . . . . . 151

8 Conclusion

153

A Looping and Non-looping trajectories in 3-dimensional Conﬁguration Space 155

B Proofs Related to Homology of Punctured Euclidean Spaces

158

B.1 Proof of Proposition 4.2.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 158

B.2 Proof of Proposition 4.3.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160

B.3 Proof of Proposition 4.4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161

vii

C Proofs Related to Distributed Optimization

163

C.1 Proof of Theorem 6.4.2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163

C.2 Proof of Theorem 6.4.4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166

C.3 Proof of Theorem 6.4.5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 166

viii

List of Tables
3.1 Statistics of searching least-cost paths in ﬁrst 10 homotopy classes in 10 randomly generated environments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
6.1 Performance of the algorithm tested for extended rendezvous in the scenario described in Figure 6.6. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
6.2 Performance of the algorithm tested in the scenario of Figure 6.11. The table shows the min, max and average time required for ﬁnding solution over 10 runs. . . . . . . 138
ix

List of Figures
1.1 Examples of simple conﬁguration spaces. . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.2 Conﬁguration space of a unicycle point robot, and actions due to kinematic con-
straints. For simplicity we have eliminated obstacles in the environment. . . . . . . . 3 1.3 Navigation function for robot path planning in R2 − O. . . . . . . . . . . . . . . . . 3 1.4 Graph created by uniform discretization of an environment. This speciﬁc type of
graph shown in the ﬁgures is referred to as the 8-connected grid. . . . . . . . . . . . 5 1.5 Some vertices and edges emanating from them in a lattice graph created by discretiz-
ing the conﬁguration space of a dynamic, non-holonomic car. . . . . . . . . . . . . . 6
2.1 Homeomorphic spaces and homotopic functions. . . . . . . . . . . . . . . . . . . . . . 10 2.2 A deformation retraction of X to A ⊆ X. For each t, the green area is F (X, t). . . . 11 2.3 A cylinder (hollow, without lids) and a solid torus are homotopy equivalent. Each of
them is homotopy equivalent to a circle. . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.4 Boundary operator acting on a chain twice gives an empty chain. . . . . . . . . . . . 13 2.5 Distributivity of Boundary Operator. . . . . . . . . . . . . . . . . . . . . . . . . . . . 14 2.6 A 2-chain and its boundary, with coeﬃcients (which includes direction information)
represented by colors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.7 A schematic representation of a chain complex. . . . . . . . . . . . . . . . . . . . . . 17 2.8 Illustration of chain, cycle and boundary. . . . . . . . . . . . . . . . . . . . . . . . . 18 2.9 Cycles in same and diﬀerent homology classes. Discretization and color coding of
coeﬃcients similar to before (Figure 2.8). . . . . . . . . . . . . . . . . . . . . . . . . 19 2.10 Relative chains on C1(X, S), and chains that are relative cycles and relative boundaries. 20 2.11 The rank of homology group gives the Betti number. . . . . . . . . . . . . . . . . . . 21 2.12 Two cocycles, α1, α2 : C1(X) → R, acting on various cycles, σ. . . . . . . . . . . . . 23 2.13 Topological spaces that are manifolds (a) and that are not manifolds (b). . . . . . . 25 2.14 A chart and an atlas on the topological circle. . . . . . . . . . . . . . . . . . . . . . . 26 2.15 Chart Transition. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27 2.16 An inﬁnitesimal element on a curve. . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 2.17 Curvature: Extrinsic vs. Intrinsic. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 2.18 Illustration of progress of Dijkstra’s algorithm. . . . . . . . . . . . . . . . . . . . . . 35 2.19 Illustration of progress of A* algorithm. The open set is marked by empty blue circles. 36 2.20 The two diﬀerent types of heuristics for an 8-connected grid graph. . . . . . . . . . . 37
x

3.1 Additivity of integration can be exploited in graph search algorithm. . . . . . . . . . 40 3.2 Illustration of homotopy and homology equivalences. In this example τ1 and τ2 are
both homotopic as well as homologous. . . . . . . . . . . . . . . . . . . . . . . . . . . 42 3.3 Examples where the trajectories are homologous, but not homotopic . . . . . . . . . 42 3.4 Cauchy Integral Theorem and Residue Theorem . . . . . . . . . . . . . . . . . . . . 44 3.5 Two trajectories in same and diﬀerent homotopy classes . . . . . . . . . . . . . . . . 46 3.6 Application of Biot-Savart law and Ampere’s law to robot path planning with topo-
logical constraints in 3-D. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48 3.7 Examples of obstacles in 3-D. (a-e) induce homotopy classes, (f) does not. . . . . . . 49 3.8 Illustration of Constructions 3.4.3 and 3.4.4. . . . . . . . . . . . . . . . . . . . . . . 50 3.9 Closed-form computation of magnetic ﬁeld. . . . . . . . . . . . . . . . . . . . . . . . 53 3.10 A trajectory in the original conﬁguration space is represented by a path in the discrete
graph. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54 3.11 The topology of the augmented graph, GH (right), compared against G (left), for a
cylindrically discretized 2-dimensional conﬁguration space around a circular obstacle 56 3.12 Exploring homotopy classes in 1000 × 1000 discretized environments to ﬁnd least cost
paths in each . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58 3.13 Exploring homotopy classes by blocking the class obtained from previous search. The
blue shaded region shows the projection of the nodes expanded in GH on to G. . . . 58 3.14 Homotopy class constraint determined using suboptimal key-point generated trajectory. 59 3.15 100 × 100 discretized environment with 2 representative points on the central large
connected walls. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60 3.16 Planning with non-Euclidean length as cost as well as homotopy class constraint . . 60 3.17 Planning with time as an additional coordinate. The postion of the agent is denoted
by R in ﬁgures (c)-(h). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61 3.18 Exploring homotopy classes using a Visibility Graph . . . . . . . . . . . . . . . . . . 62 3.19 The arm end eﬀector fails to follow the shorter trajectory due to limited length of
the arm. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 3.20 The longer trajectory can be followed by the end eﬀector. . . . . . . . . . . . . . . . 63 3.21 The arm end eﬀector fails to follow the shorter trajectory due to joint angle limits. . 64 3.22 The arm end eﬀector succeeds in following the longer trajectory. . . . . . . . . . . . 64 3.23 Exploring homotopy classes in X − Y − Z space. . . . . . . . . . . . . . . . . . . . . 65 3.24 An environment with 7 unbounded pipes. . . . . . . . . . . . . . . . . . . . . . . . . 66 3.25 Cumulative time taken and number of states expanded while searching GH for 10
homotopy classes in the problem of Figure 3.24(a). . . . . . . . . . . . . . . . . . . . 66 3.26 Screen-shots from an example with two moving obstacles showing the exploration of
4 homotopy classes in a dynamic environment. . . . . . . . . . . . . . . . . . . . . . 67
4.1 Obstacles, O, can be replaced by their equivalents, S, and that will not alter the homology class of the (N − 1)-cycles in the complement space. . . . . . . . . . . . . 69
4.2 A solid torus, and its valid/invalid replacements. . . . . . . . . . . . . . . . . . . . . 70
xi

4.3 A hollow (or thickened) torus as an obstacle in a D = 3 dimensional space, with N = 2 for our problem. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
4.4 Illustration of intersection number in R3 with N = 2 in light of Deﬁnition 4.3.1. . . . 73 4.5 A simpliﬁed illustration of intersection number and linking number in R3 with N = 2. 75 4.6 Examples and counter-examples of uniqueness of linking number – a consequence of
Proposition 4.3.3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76 4.7 The speciﬁc problem under consideration, illustrated for D = 3, N = 2. . . . . . . . . 79 4.8 Schematic illustration of some lower dimensional cases of the problem. . . . . . . . . 82 4.9 A coarse triangulation using parameters θ , φ , θ and φ for creating a simplicial
complex for the example in Section 4.6.1. . . . . . . . . . . . . . . . . . . . . . . . . 87 4.10 Screenshots from exploration of 3 homotopy classes in a X − Y − Z − T ime conﬁg-
uration space. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88 4.11 An arbitrary map f : S1 → (RD −S) is homotopic to summation of maps, f1 +f2 +f3,
such that ˜ik ◦ fj is non-trivial for exactly one k (= κj). . . . . . . . . . . . . . . . . . 90 4.12 Graphical proof for the fact that the proposed algorithm computes the semitopy class
of f . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93 4.13 The ﬁrst 10 homology classes (Deﬁnition 3.2.2) of trajectories. They are in diﬀerent
homotopy classes as well. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94 4.14 The ﬁrst 10 homotopy classes of trajectories. The trajectory in the 9th homotopy
class was missing from Figure 4.13. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
5.1 Voronoi tessellation of a rectangular region with n = 10 robots. . . . . . . . . . . . . 97 5.2 Presence of holes/punctures (due to obstacles) in the Euclidean space changes the
distance function in the punctured space. . . . . . . . . . . . . . . . . . . . . . . . . 98 5.3 Relationship between tangent to a geodesic and the derivative of the distance function. 99 5.4 The ‘geodesic Voronoi tessellation’ of non-convex workspaces. . . . . . . . . . . . . . 104 5.5 Illustration of progress of the Basic Tessellation algorithm in a environment with
an L-shaped obstacle. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 5.6 Adapted Lloyd’s algorithm in a L-shaped environment. . . . . . . . . . . . . . . . . . 109 5.7 Adapted Lloyd’s algorithm in a real indoor environment. . . . . . . . . . . . . . . . . 110 5.8 Radii of the sensor footprints of the robots in simulation of Fig. 5.7. . . . . . . . . . 110 5.9 Entropy-weighted Voronoi tessellation. . . . . . . . . . . . . . . . . . . . . . . . . . 112 5.10 The sensor model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113 5.11 Exploration and coverage of an unknown environment . . . . . . . . . . . . . . . . . 115 5.12 Exploration and coverage of a large unknown environment. Green indicates uncertainty.116 5.13 ROS implementation of coverage and exploration. . . . . . . . . . . . . . . . . . . . . 117
6.1 Demonstration of convergence of the proposed distributed algorithm towards global optimal solution with progress of iterations. . . . . . . . . . . . . . . . . . . . . . . . 121
6.2 The task graph Υi, and its product with Hi. . . . . . . . . . . . . . . . . . . . . . . 129 6.3 Converged Solutions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131 6.4 Planning in environment with three interconnected rooms . . . . . . . . . . . . . . . 132 6.5 Extended rendezvous in environment with three interconnected rooms . . . . . . . . 133
xii

6.6 Extended rendezvous in a real environment . . . . . . . . . . . . . . . . . . . . . . . 134 6.7 Rendezvous to exchange information in a 3-dimensional environment. . . . . . . . . . 135 6.8 Planning for two robots each with two tasks and a constraint to meet during their
travel. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136 6.9 Two robots exploring certain rooms and rendezvousing to exchange information. . . 137 6.10 Three robots exploring certain rooms and rendezvousing to exchange information. . 137 6.11 Two robots with one task each. This is the solution from one of the randomized runs. 138 7.1 Suboptimality due to discretization. . . . . . . . . . . . . . . . . . . . . . . . . . . . 140 7.2 The planning problem in a zero-curvature space. . . . . . . . . . . . . . . . . . . . . 142 7.3 Gnomonic projection gives an orthogeodesic embedding of the half sphere. . . . . . 146 7.4 The metric in a constant positive curvature space, and gnomonic projection of the
space. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148 7.5 Robot planning problem in a metric space with constant positive curvature. . . . . . 149 7.6 The hyperbolic plane. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150 A.1 Looping and non-looping trajectories. . . . . . . . . . . . . . . . . . . . . . . . . . . 156 A.2 An inﬁnitely long skeleton and h-signature of a straight line segment. . . . . . . . . . 157
xiii

Chapter Dependencies

Ch. 2 Sec. 2.1

Ch. 1
Ch. 2 Sec. 2.2

Ch. 2 Sec. 2.3

Ch. 3

Ch. 4

Ch. 5

Ch. 6

Ch. 7

Appx. A

Appx. B

Appx. C

Ch. 8
Legend:
Topology, Algebraic Topology Riemannian Geometry Graph Search Algorithm, Optimization

Weak dependency Strong dependency

The above diagram gives an overview of how the chapters and sections in this thesis depend on each other. The Chapter 2 discusses some of the preliminary mathematical and algorithmic tools used in this thesis. How much depth those discussions attain is approximately indicated by the length of the gray bar below each section of the chapter in the above diagram. The colored bars below each chapter approximately indicate how much the corresponding chapter uses the respective mathematical/algorithmic tools.

xiv

Chapter 1
Introduction
1.1 Conﬁguration Spaces
Many problems in robotics involve a conﬁguration space. Conﬁguration space or C-space of a robot or a system of robots is the abstract space of possible states or conﬁgurations that the system can attain. Thus each point in the C-space corresponds to a possible state of the robot(s) in the real environment. Robotics problems, especially planning problems, typically involve navigation of the system through the C-space space in order to achieve certain tasks or objectives. This translates to ﬁnding a 1-dimensional curve (a trajectory) in the C-space that the system needs to follow. Typically C-spaces are smooth manifolds and any curve on it is a possible trajectory for the system. However, presence of kinematic and dynamic constraints may require that the tangent at any point on the trajectory lies within a speciﬁc subset of the tangent space at the point of the C-space. Furthermore, in presence of a metric in the C-space or a more general measure for 1-dimensional curves in the space, one can talk about optimality of the trajectory.
Typically the C-space of a system can be parametrized by the diﬀerent state variables corresponding to the diﬀerent degrees of freedom. For example, the conﬁguration space of a single point mobile robot navigating in a unbounded 2-dimensional ﬂat plane with obstacles is simply R2 − O, where O represents the set of points on the plane that make up the obstacles (Figure 1.1(a)). Similarly, the conﬁguration space of a planar robot arm with two links and no joint angle limits (Figure 1.1(b)) is a torus, T = S1 × S1, each point on which correspond to an unique pair of joint angles θ1, θ2 (Figure 1.1(c)). One can generalize the notion of C-space for a system with multiple robots. For example, if C = R2 − O is the conﬁguration space of a point robot as described in Figure 1.1(a), the presence of n robots in the environment will result in a joint conﬁguration space for the system of n robots described by C = C × C × · · · × C − ∆ = Cn − ∆, where we take the product of n copies of the C-spaces corresponding to each robot, and remove from it the diagonal that represents collision of the robots (i.e., ∆ = {[p1, p2, · · · , pn] ∈ Cn | pi = pj for some i = j} ). Clearly, the joint conﬁguration space is a 2n dimensional manifold.
We now impose a very simple additional structure to the C-space of a point robot. Let us consider a unicycle model of the point robot [20], which means, in addition to the position (x, y), the robot has an orientation (θ). Thus the conﬁguration space of the robot is now (R2 − O) × S1
1

o1
o2
The robot (a) The conﬁguration space of a point robot navigating on a plane with obstacles o1 and o2 is R2 − (o1 ∪ o2)

θ2 θ1

θ2 θ1

(b) A 2-link robotic arm is described (c) The conﬁguration space of a 2by the state variables θ1 and θ2. link robotic arm is the 2-torus.

Figure 1.1: Examples of simple conﬁguration spaces.

(a subset of SE(2)). Moreover, the unicycle model of the robot is non-holonomic since the robot can only move forward along the direction it is oriented, or rotate at a ﬁxed place (i.e. x, y remains ﬁxed, while θ changes). So at point p = (x, y, θ) in its conﬁguration space, the robot can move along (x˙ , y˙, θ˙) = (v cos(θ), v sin(θ), ω), for some v ∈ R+ and ω ∈ R (representing forward and angular speeds). Thus the possible directions of motion is a 2-dimensional manifold generated by v and ω. This is the space of possible actions at (x, y, θ), which, in general, may not be a vector space, and in this particular example is a half space (a subset of the tangent space TpC). Attaching this space of possible actions to every point of the C-space (Figure 1.2(a)), we obtain a ﬁber bundle. The ﬁber bundle itself is a 5-dimensional manifold, sections of which give vector ﬁelds in the conﬁguration space. A valid trajectory in the C-space needs to be such that the tangent at every point on it lies in the set of possible actions at that point (Figure 1.2(c)).

1.1.1 Continuous Approaches to Robot Motion Planning
The problem of navigating a robot (or a system of robots) from a start coordinate to a goal coordinate in the C-space is of much interest in robotics [55] and is typically referred to as “goal directed navigation”. In continuous planning methods, one tries to derive either open loop trajectories [87] or closed loop feedback policies [69, 15] that avoid obstacles while satisfying constraints on the robot dynamics. However, it is diﬃcult to establish completeness and convergence results except in special cases. One school of approach in solving the problem of goal directed navigation for a ﬁxed goal coordinate in the C-space is to generate a vector ﬁeld in the entire C-space that would drive the system towards the goal coordinate. However in most C-spaces, non-trivial topology and the presence of obstacles result in great challenges in generating such vector ﬁelds. In addition, kinematic and dynamic constraints pose additional diﬃculties.
For a point robot navigating on a ﬂat plane, one may hope to ﬁnd a potential function, the gradient of which would give the desired vector ﬁeld. However, initial attempts to construct potential functions like that suﬀered from lack of global convergence due to presence of local minima [51, 52, 15]. One of the most intriguing and elegant constructions to deal with the problem successfully was that of a navigation function introduced in [70]. The basic version of this machinery lets one
2

2π ≡ 0 7π/4 3π/2 5π/4
θπ
3π/4 π/2 π/4 0
x

θ = 2π ≡ 0 θ = 7π/4

identify

θ = 3π/4 θ = π/2 θ = π/4 θ=0

y

θ = 3π/2 θ = 5π/4 θ=π
Y
X

Invalid trajectories
2π ≡ 0
7π/4
3π/2
5π/4
θπ
3π/4 π/2 π/4 0

Valid trajectories

(1,0,0)
x

(4,3,0)
y

(a) The conﬁguration space R2 × S1, and the action space attached to every point in it (the arrows in the ﬁgure are some representative actions – the action spaces themselves are half-spaces).

(b) Closer

look at how

the

space

of possible

actions change

with θ.

(c) Some valid and invalid trajectories in the Cspace. The tangent at every point on the trajectory must lie inside the action ﬁber at the point.

Figure 1.2: Conﬁguration space of a unicycle point robot, and actions due to kinematic constraints. For simplicity we have eliminated obstacles in the environment.

(a) Navigation function in a spherical environment with star-shaped obstacles.

(b) A robot following the gradient of the navigation function reaches goal.

Figure 1.3: Navigation function for robot path planning in R2 − O.

construct a potential function in a spherical environment with star-shaped obstacles such that it has an unique stable minima at the the goal coordinate (Figure 1.3). While this ensures that in presence of a very small noise the robot will converge to its goal, the method suﬀers from issues of computational complexity, numerical diﬃculties and slow convergence. Besides, the approach works for a very limited variety of obstacle, and it is diﬃcult to incorporate additional constraints in the problem. Generalizing such an approach for more complex nonlinear dynamical systems becomes increasingly challenging [60].
Vector ﬁelds have also been used for applications other than goal directed navigation. In problems like generation of patterns using mobile robots [44], surveillance [45] and transportation of objects via caging [29], vector ﬁelds have been successfully generated and employed for navigation of teams of robots in environments with simple obstacles or abstracted obstacles.
3

In environments with a metric, typically the problem that one is faced with is to ﬁnd an optimal path. One can attempt to solve the Geodesic equation in a metric space [48]. However, even in metric spaces without discontinuities, the computation of the geodesic passing through two given points is highly non-trivial. One can employ a method like shooting method [82] for solving the Geodesic equation posed as a boundary value problem. However, in general, such methods are expensive. In presence of discontinuities due to obstacles, solving for the shortest path (which is informally called the generalized geodesic) between two points becomes practically infeasible.
A more general optimal path planning problem arises when, instead of a metric, a general measure in terms of a cost or action integral is provided. In such problems, often the method of calculus of variation is adopted [31, 24, 54]. However, such approaches typically require an initial guess of a suboptimal trajectory, are computationally expensive, and compromise on the optimality when there are discontinuities in the environment (such as obstacles).
A related but diﬀerent problem arises in robot coverage of an environment (i.e. how evenly the robots are distributed in an environment). Typically this is a multi-robot problem, in which an initial/start coordinates of the robots are provided (a single coordinate in the joint state-space). However there is no speciﬁc single goal coordinate as in goal directed navigation. Instead, a ﬂow (a vector ﬁeld) is given that governs the motion of the system. The vector ﬁeld is typically a simple gradient of a potential function (which is designed such that it gives a measure of how bad the coverage is). This is the continuous-time version of the Lloyd’s Algorithm [58] due to Cortez, et al. [18]. As with any potential function based approach, such a method suﬀers from problems of local minima. In fact Lloyd’s algorithm only guarantees that the system will converge to a local minima of the potential. In a convex environment without obstacles this local minima is at least guaranteed to be one where the gradient is zero. However obstacles and non-convexity can result in creation of highly suboptimal local minima. Moreover in non-convex environments and environments with obstacles, the generalization of the potential function proposed in [18, 58] and computation of its gradient, becomes highly non-trivial and extremely computationally expensive.
Planning in conﬁguration spaces with arbitrary shaped obstacles, and in presence of nonholonomic constraints, kinematic constraints and dynamic constrains using any continuous approach is generally diﬃcult. Vector ﬁeld construction and calculus of variation can be employed, but it is diﬃcult to provide guarantees and robustness.
1.1.2 The Discrete Approach
A robust alternative to the continuous approaches described above is the discrete approach of graph search-based planning. The basic idea behind the approach is to sample points from the conﬁguration space, and construct a graph by considering those points as vertices of the graph and edges being sampled possible actions that can take the system from one vertex (a state) to another. A simple example is that of a point robot navigating on a plane with obstacles modeled as a 8-connected grid. The conﬁguration space R2 − O can be partitioned into uniform square cells, and a vertex of the graph is placed at the center of each cell (Figure 1.4(a)). Edges are established between 8 neighboring vertices of each vertex, representing the possible transitions of the robot (the actions).
4

(a) A graph created by uniform square partitioning/discretization of an environment. The brown cells represent obstacles. Each vertex is connected to its 8 neighbors (except inaccessible vertices).

(b) A trajectory in the continuous conﬁguration space can be approximated by a path in the graph.

Figure 1.4: Graph created by uniform discretization of an environment. This speciﬁc type of graph shown in the ﬁgures is referred to as the 8-connected grid.

Following this construction, any trajectory in the original conﬁguration space can be approximated by a path in the graph [7] (Figure 1.4(b)). This simple approximation eliminates much of the problems that continuous methods suﬀer from. Firstly, for goal directed navigation, the problem reduces to ﬁnding paths in the graph. One can then employ any search algorithm like Dijkstra’s [26], A* [39], D* [81], ARA* [38] or R* [57] to search for the optimal path (or path with bounded sub-optimality depending on the chosen algorithm) in the graph from the start vertex to the goal vertex. Such algorithms are complete with guarantees on optimality or bounds on sub-optimality. Moreover in the graph, it is easy to incorporate metric information by assigning weights to edges. Thus, such discrete approaches work very well for planning trajectories in non-Euclidean metric spaces. Moreover, since actions in a graph are modeled by discrete set of edges, systems with non-holonomic constraints are eﬀectively and easily modeled using this approach.
For example, in [28, 85], in order to eﬀectively model the dynamics and non-holonomic constraints of a car, a lattice graph was used. The state variables consist of the position, orientation and forward speed of the vehicle, making the conﬁguration space SE(2) × R+. As discussed earlier, depending on the current state of the vehicle, (x, y, θ, v), the possible actions (x˙ , y˙, θ˙, v˙) are limited by the non-holonomic and dynamic constraints. This is diﬃcult to model using a continuous approach, and even more diﬃcult to ﬁnd trajectories in such conﬁguration space using any continuous approach. However a discrete approach of discretization of the conﬁguration space and construction of a graph deals with this very eﬀectively. The graph is constructed by partitioning the 4-dimensional conﬁguration space into cells (may be an uniform partition with hypercubic cells). A vertex is associated with each cell, and edges emanating from the vertex are created so that they are samples from the space of possible actions at the vertex. Two conﬁgurations are considered to be the same if they fall in the same partition of the conﬁguration space.
It is quite evident that a graph created in such a way may be too large for eﬀective computation
5

(a) A discrete sample from the set of possible actions at a vertex at (x, y, θ, v) make up the edges emanating from the vertex.

(b) Actions from a vertex at (x, y, θ , v). Note that the orientation is diﬀerent from the one shown in (a), but the speed is the same.

(c) Actions from a vertex at (x, y, θ , v ), with v < v. Note that due to lower speed, it is possible for the car to take sharper turns.

Figure 1.5: Some vertices and edges emanating from them in a lattice graph created by discretizing the conﬁguration space of a dynamic, non-holonomic car. A vertex is associated with each discretized cell. From each vertex, edges emanate such that the actions corresponding to the edges are sampled from the space of possible actions from the vertex. The ﬁgures show points and actions in conﬁguration space projected to the X − Y plane.

or even storage. However, as we will discuss later, graph search algorithms typically do not require that we explicitly create the graph and store it in memory before starting to solve the problem. In fact, in solving a goal directed navigation problem (i.e. searching for shortest path in the graph) it may not even be necessary to create the full graph. A well-informed heuristic function can guide heuristic searches to expand a small subset of the vertices in the graph. Moreover, eﬃcient graph construction algorithms like Rapidly-exploring Random Tree (RRT) [56] and Probabilistic Roadmaps (PRM) [50] are often employed for eﬃcient sampling of vertices and creating the graph in high dimensional conﬁguration spaces [13].
In spite of having all such tools at hand, it is worth mentioning that given a ﬁxed algorithm, the size of the graph (number of vertices and edges) as well as the complexity of the search algorithms increase exponentially with the dimensionality of the conﬁguration space (number of state variables). While this does not pose a major problem for planning in low dimensional conﬁguration spaces, in higher dimensional conﬁguration spaces (e.g. in multi-robot problems, the joint conﬁguration space of all the robots), this becomes a severe computational bottleneck.
Moreover, the process of discretization and sampling themselves tend to undermine much of the richness that was present in the original conﬁguration space. For example, much of the topological information present in the original conﬁguration space gets lost since the graph is rather indiﬀerent to the global topology of the space. Moreover, metric of the original conﬁguration space gets restricted to the graph. Thus, the shortest path in the graph need not necessarily be the shortest path in the original continuous metric space (Figure 1.4(b)). There has been some recent very interesting developments for addressing this later issue [21]. However such methods work reliably only in Euclidean metric spaces.
Most practical implementations in robotics, however, widely employ graph search-based approaches. The ease of implementation, robustness, completeness and guarantees on optimality
6

within the graph most of the time outweigh the problems of sub-optimality due to discretization and loss of geometric and topological information due to graph construction. For example, almost every team in the DARPA Urban Challenge, 2007, used graph-search based planning approaches [85, 62, 42] for ﬁnding optimal paths in complex cluttered environments. Planning for robotic arms like that of the PR2 in cluttered environments has been achieved successfully using graph search-based planning [14].
1.2 Contributions of this Thesis
We thus observe that search-based techniques have been widely used in robot path planning for ﬁnding optimal trajectories in conﬁguration spaces. They have the advantages of being complete, optimal (up to the metric induced by the discretization), robust and eﬃcient (in low dimensional problems), even in complex environments. Moreover, there is a wide class of search-based techniques that allow one to trade-oﬀ optimality (with guaranteed bounds on sub-optimality) at substantial gain on search eﬃciency. Continuous techniques, on the other hand, lending concepts from diﬀerential and algebraic geometry and topology, have the ability of exploit speciﬁc structures in the original conﬁguration space and help in solving a host of diﬀerent problems that rarely come under the scope of graph-search based techniques. The main objective of this thesis is to propose certain ideas and methods that will let us bring these two separate techniques under one umbrella.
The ﬁrst contribution of the thesis lies in the characterization of the topology of the conﬁguration space and the solution using applications of algebraic topology. Search-based techniques, by virtue of discretization and graph construction, ignore the topological properties of the underlying conﬁguration space and the solution trajectories. We try to account for that by deﬁning diﬀerential forms whose integrals reveal topological information about the solution path. Appropriately deﬁned 1-forms allow us to establish equivalence classes of trajectories (e.g., homotopy or homology classes) and use it to guide the search. We show how to ﬁnd trajectories that are constrained to lie in speciﬁed homotopy/homology classes or that avoid other speciﬁed classes.
The second contribution is to use search techniques to follow gradient of a potential function that is a generalization of the one used by Lloyd’s Algorithm in coverage problems. We use graph search technique to partition the conﬁguration space based on a metric, and hence create generalized Voronoi tessellations. The same search technique is used to compute gradient of the function that is to be minimized for attaining good coverage. We show application of this method to multi-robot coverage and exploration tasks in unknown or partially known non-convex environments.
In our third contribution we address the curse of dimensionality that is inherent in path planning for multi-robot systems. One of the main drawbacks of graph search algorithms is that with increase in the dimensionality of the conﬁguration space, the number of nodes and edges in the graph increase exponentially. This poses a major challenge for ﬁnding optimal paths in high dimensional conﬁguration spaces using graph search techniques. While gradient descent approaches scale much better with the dimensionality of the conﬁguration space, these methods suﬀer from local minima, especially in non-convex environments. However, multirobot problems endow a special product structure to the conﬁguration space allowing us to decouple robot directions and parallelize the search. Such decompositions can let us use a combination of graph search methods and gradient
7

descent algorithms in complementary directions. We demonstrate how such decompositions are particularly suitable for multi-robot path planning problems with communication constraints.
Finally we address the problem of determining optimal trajectories for speciﬁed metrics. Trajectories found by discrete graph representations and searches suﬀer from sub-optimality induced by the discretization. However there are certain metric spaces (a trivial example being the Euclidean metric) in which we can conveniently use the notion of visibility to obtain the optimal trajectory with respect to the metric in the original space from the optimal trajectory on the graph. Our goal is to identify such special metric spaces and study the conditions under which we can transform a given non-Euclidean metric space into such special metric spaces.
8

Chapter 2
Preliminaries
2.1 Basic Algebraic Topology
2.1.1 Background: Point-set Topology
Set theory is the study of collections of some objects. In many cases that collection can be inﬁnite and uncountable. For example, one may talk about the set of all the points on the surface of a sphere. However, set theory does little in establishing relationship between the objects in a set. For example, if we consider the set consisting of the points on a sphere, it’s just a collection of points, each of which is distinct and there is no way of telling which point is “connected” to which other point in the set to give the sphere its familiar shape. That’s where topology comes to the rescue. A topology consists of a set, along with the additional information on “grouping”/“collection” of the objects inside the set. Such “groupings” are called open subsets of the set.
Deﬁnition 2.1.1 (Topology [63]). A topology on a set X is a collection, T , of subsets of X, containing both X and ∅, and closed under the operations of intersection and union. Together, the tuple (X, T ) is called a topological space, and the elements of T are called open sets of the topological space.
Often, when there is a standard topology, by convention, for a space X, one can refer to the topological space simply as X. One of the most important consequences of deﬁning topology is that we now have the notion of continuity.
Deﬁnition 2.1.2 (Continuous Functions Between Topological Spaces [63]). Given two topological spaces, (X1, T1) and (X2, T2), consider a map f : X1 → X2. For any subset U ⊆ X2, deﬁne f −1(U ) = {x ∈ X1 | f (x) ∈ U } (note that if f −1 : Y → X exists, this deﬁnition simply generalizes it to subsets of Y ). Then f is said to be continuous if for each open set V ∈ T2, the set f −1(V ) is in T1 (i.e. an open set).
Note that for continuity, f need not map open sets to open sets. That is, for W ∈ T1, its image f (W ) need not be in T2. When a continuous function is also injective, it is called an embedding (embedding of X in Y ).
9

f1 f2
O1

O2 f3

(a) Homeomorphic spaces (both equivalent to S1). The apparent diﬀerence between the two spaces is due to their embedding in R2. The spaces themselves are topologically equivalent.

(b) Continuous functions, fi : S1 → (R2 − O1 ∪ O2), which are also embeddings (injective). f1 can be continuously deformed to f2 (they are homotopic), but not to f3 (f1 and f3 are not homotopic).

Figure 2.1: Homeomorphic spaces and homotopic functions.
Starting with these basic deﬁnitions, one can make assertions on certain properties of the topological space, construct one topological space from another, and establish relationships between them. This is the primary aﬀair of the ﬁeld of point-set topology. However, one can do little algebra or actual computation on a topological space using this. That’s where the ﬁeld of algebraic topology gets introduced.
Before we proceed to algebraic topology, we state a few deﬁnitions that follow from basic pointset topology.
Homeomorphism, Homotopy, Deformation Retract and Homotopy Equivalence
The ﬁrst fundamental equivalence relation among topological spaces is that of homeomorphism. Topologically, two topological spaces are homeomorphic if they essentially are the same topological space (with, possibly, ‘renaming’/‘relabeling’ of the items in one of the set and its topology to obtain the other). In presence of an embedding, informally, two spaces are homeomorphic if one can be continuously deformed into the other without causing cuts or tears in the space (i.e. open sets remain open). This is popularly exempliﬁed using a donut and a coﬀee cup with a handle, and how, to a topologist, they are one and the same. Figure 2.1(a) shows a more modest example of homeomorphism.
Deﬁnition 2.1.3 (Homeomorphism [63], Fig. 2.1(a)). Two topological spaces X and Y are homeomorphic if there exists a bijective function f : X → Y (which implies the inverse, f −1 : Y → X, exists and is bijective) such that both f and f −1 are continuous. f (which may not be unique) is called a homeomorphism between the spaces.
A fundamental equivalence relation among continuous functions deﬁned between two ﬁxed topological spaces is homotopy. Informally, two functions are homotopic if one can be continuously changed into another.
Deﬁnition 2.1.4 (Homotopy [40], Fig. 2.1(b)). Two continuous function between the same topological spaces, f1, f2 : X → Y , are called homotopic if there exists a continuous function F : X × [0, 1] → Y (where, [0, 1] is assumed to have the standard Euclidean topology, and ‘×’
10

X

A

A

(a) t = 0.0

(b) t = 0.3

(c) t = 0.7

(d) t = 1.0

Figure 2.2: A deformation retraction of X to A ⊆ X. For each t, the green area is F (X, t).
induces the product topology to the product space) such that F (x, 0) = f1(x) and F (x, 1) = f2(x), for all x ∈ X. Concisely we express this relationship as f1 f2. The function F (which may not be unique) is call a homotopy between f1 and f2. Informally, we say that f1 can be homotoped to f2 and vise-versa.
The idea of deformation retract is that given a topological space X, and a subspace A (a subset with subspace topology [63]), we ask the question whether or not the space X may be continuously ‘shrunk’ and ‘deformed’ to A without causing any ‘cut’ or ‘tear’. If it can, we call A a deformation retract of X (Figure 2.2). Consider the identity map idX : X → X (Figure 2.2(a)). Now start ‘shrinking’ X gradually to ‘collapse’ on to A. At every step of the shrinking process what we have is an embedding of X into itself such that the image of the embedding is the ‘shrunk’ version of X at that step (Figure 2.2(b,c)). Eventually we ‘shrink’ X to A (Figure 2.2(d)).
Deﬁnition 2.1.5 (Deformation Retract [40], Fig. 2.2). A subspace A (with subspace topology) is called a deformation retract of a topological space X if there exists a continuous function F : X × [0, 1] → X such that
• F (x, 0) = x, ∀x ∈ X (i.e. F (·, 0) ≡ idX is the identity map on X), • F (a, t) = a, ∀a ∈ A, t ∈ [0, 1], and, • F (x, 1) ∈ A, ∀x ∈ X. F (which may not be unique) is called a deformation retraction from X to A. Since A is a subspace of X, we can interpret F as a homotopy between the identity map idX and the map f1 ≡ F (·, 1) whose image is in A.
It is important to note that f1 ≡ F (·, 1) : X → X is homotopic to the identity map on X. Had A not been given beforehand, and instead, we were given a function f1 : X → X that is homotopic to idX , the image of f1 would clearly be a deformation retract of X.
The fact that A needs to be a subspace of X in the deﬁnition of deformation retract essentially implies that there is an embedding i : A → X, called the inclusion. However A, as an independent topological space, should not require an embedding in X to be described (e.g A in Figure 2.2 is topologically just a circle S1). We still should be able to describe a similar relationship between them. That’s where a generalization of a deformation retract, called homotopy equivalence, comes into the picture.
The idea of homotopy equivalence is that instead of explicitly mentioning a subspace A of X, we look at the continuous functions from X to itself via a second space Y (the ﬁnal image is of course a subspace of X). We then ask if this combination map is homotopic to the identity map
11

A=g○f(X)

g B=f○g(Y)

f X

Y

Figure 2.3: A cylinder (hollow, without lids) and a solid torus are homotopy equivalent. Each of them is homotopy equivalent to a circle.

on X. We do the same thing with the role of X and Y reversed. If the answer is ‘yes’ in both the cases, the spaces X and Y are said to be homotopy equivalents.
Deﬁnition 2.1.6 (Homotopy Equivalence [40], Fig. 2.3). Two topological spaces X and Y are called homotopy equivalent if there exists continuous functions f : X → Y and g : Y → X such that g ◦ f is homotopic to the identity map idX , and f ◦ g is homotopic to the identity map idY . The function f (and likewise g) is called a homotopy equivalence. X and Y are said to have same homotopy type, and informally we say one can be homotoped to the other.
If A is a deformation retract of X, then they are of course homotopy equivalents. However the converse is not always true. Out of many ways of determining if two spaces X and Y are homotopy equivalents, one approach is to check if each of them deformation retracts to a subspace that is topologically equivalent (homeomorphic). Then they are homotopy equivalent (Figure 2.3). The other, more formal, approach is to check if there exists a larger space with embeddings of X and Y into it, such that this larger space deformation retracts to both X and Y .
Contractible Space
Deﬁnition 2.1.7 (Contractible Space [40]). A topological space X is called contractible if the identity map on it, idX , is homotopic to a constant map (a function taking every points in X to a ﬁxed point x0 ∈ X).
The intuition behind contractibility is that the space can be pulled (contracted) continuously towards a point inside it. It is important to note that a contractible space need not be ﬁnite. For example, RD is contractible for any ﬁnite D. This is because, for any point p ∈ RD one can construct a map fp : [0, 1] → RD so that fp(0) = p, fp(0) = 0 (the origin), and F (p, t) = fp(t) is continuous.

2.1.2 Motivation of Algebraic Topology
Algebraic topology imparts certain algebraic (primarily group) structures to a topological space, and allows interpretation of the structure of the topological space by analysis of the algebraic structures.
12

A3 A2
A1

A5 A4

l6 l7

l1

l4

l2 l5
l3

(a) An area (a 2-chain).

(b) The boundary of the area (a 1- (c) The boundary of the boundary is

cycle).

empty.

Figure 2.4: Boundary operator acting on a chain twice gives an empty chain.

In this section we will motivate some basic ideas behind algebraic topology without going into too much technical details. Instead, we will use some simple illustrations to explain them.
The ﬁrst step in imparting an algebraic structure to a topological space is to describe the space in terms of a sequence of groups (in simple cases, vector spaces, which are themselves groups with additional structures), and maps between them. This algebraic object will be called a chain complex. While it is not necessary to discretize/triangulate a topological space to describe a chain complex on it (as we will shortly do), for ease of understanding we make this simplifying discretization. Each discrete element in this discritization is called a simplex (Figure 2.4) – the vertices will be called 0-simplices, the edges 1-simplices, the triangles 2-simplices, tetrahedrons 3-simplices, etc. Formally, a n-simplex on a topological space, X, is a map from a standard n-simplex [40] to X. However, most often, we will informally refer to the image of a n-simplex as the n-simplex itself.

Boundary Operator: Consider a patch of area on the plane that is discretized into simplices as

in Figure 2.4. Out of all the 2-simplices (triangles), we pick a few – ones marked by green color as

in Figure 2.4(a). We simply call those triangles A1, A2, · · · , A5 (note that by Ai we do not mean the ‘area’, but the whole triangle as an abstract object/set). Thus the region they cover is denoted

by A1 + A2 + · · · + A5 (where, for now, we can interpret ‘+’ as an union). Figure 2.4(b) shows

the boundary of the chosen area and is likewise represented by

7 i=1

li

(each

1-simplex

or

edge

is

arbitrarily labeled li). However, if we now look at the boundary of

7 i=1

li,

it

is

clearly

empty

(in

general, such boundary could have been made up of 0-simplices or vertices). This last observation

is a key motivation behind constructing a chain complex. This observation extends to higher

dimensions and any topological space as well. For example, in a 3 dimensional space discretized

into tetrahedrons, if we pick a few of those tetrahedrons (3-simplices) to deﬁne a volume, and take

the boundary of that volume (which will be a closed surface), this boundary will itself have an

empty boundary. Thus, boundary of a boundary is always empty. In a naive notation, if ∂2(A)

represents the boundary of an area A, and ∂1(l) represents the boundary of a curve l, what we just

stated can be summarized as ∂2(

5 j=1

Aj )

=

7 i=1

li,

and

∂1(

7 i=1

li)

=

0

= ∂1 ◦ ∂2(

5 j=1

Aj

).

In general, ∂n ◦ ∂n+1 = 0.

13

l12 A2 l15
l11

l14 l13 A3
-l12

l14 l13 A3
A2 l15 l11

(a) In the boundary of A2 we have already labeled the edge l12.

(b) The boundary of A3 needs to have −l12 as an edge. We can relabel it to, say, l21, but then we will need to equate it to −l12 to ensure distributivity of ∂2.

(c) Upon adding the boundaries of A2 and A3, the edges l12 and −l12 cancel out, and we obtain the boundary of A2 + A3.

Figure 2.5: Distributivity of Boundary Operator.

Distributivity of Boundary Operator and Orientation: One of the properties that we would like the boundary operator, ∂n, to have is distributivity. That is, for example, we would like to be able to write ∂2(Ai + Aj) = ∂2(Ai) + ∂2(Aj). This will let us assert that boundary of boundary is empty, purely from algebraic conditions, without looking at a picture: ∂1 ◦ ∂2( i Ai) = i ∂1 ◦ ∂2(Ai) =
i 0 = 0 (since boundary of boundary of an individual triangle is always empty). This would enable us develop a linear algebra. This requires that we assign some sign (directionality) to each of li. Consider a single 2-simplex, A2, as shown in Figure 2.5(a). Its boundary is l11 + l15 + l12. Now consider the 2-simplex A3 (Figure 2.5(b)). Since A2 and A3 share the common edge, l12, which will lie inside A2 + A3, we need to make sure that somehow this edge gets canceled out when we add ∂2(A2) to ∂2(A3) to obtain ∂2(A2 +A3) (Figure 2.5(c)). This is attained by giving a directionality of every segment li, represented as ±li, and noting that li + (−li) = 0. There is nothing special about the dimension 1 of the 1-simplices, and we can in fact assign directionality to simplices of every dimension (vertices, edges, triangles, tertahedrons, etc.). The deﬁnition of direction has to be such that it admits distributivity of the boundary operators ∂n. For example, if one considers −A2 in Figure 2.5(a), in order to be consistent with the fact that ∂2(A2 + (−A2)) = ∂2(A2) + ∂2(−A2) = 0, we need to have the boundary of −A2 (i.e. ∂2(−A2)) as (−l11) + (−l15) + (−l12), that is the original line segments with reverse orientation.
Group Construction: By now it is easy to see a group structure emerging. For example, for every line segment li we have deﬁned an inverse element, −li so that they add up to 0, the identity element. Also, we have developed the intuition of how the binary operator ‘+’ works between li and lj for i = j or lj = −li. All that we now need to do to make the set of possible combinations of the 1-simplices (e.g. li1 + li2 + · · · is an arbitrary combination – called a 1-chain) an algebraic group is to close it under the operation of addition. Earlier we have related li + lj with taking union of the line segments li and lj. However, if we write li + li, an interpretation in terms of union, will simply mean li. This will not be consistent with our attempt to deﬁne a group. Thus,
14

A3

-A5

2A2

l14 -l4

l13 l12

-l9 -l7

2l11 2l15

lA

(a) A graphical representation of A3 + 2A2 + (−A5) ∈ C2(X). Colors represent the integer coeﬃcients – green positive, red negative, darker is higher. Note how the coeﬃcient for the other 2-simplices is 0 represented by light blue. This type of arbitrary combination is called a chain (a 2chain in this case). Thus, one can interpret this as a order set of coefﬁcients, [0, 2, 1, 0, −1, 0, 0, 0, · · · ], for the corresponding 2-simplices.

(b) The boundary of the 2-chain shown in (a). The boundary is l13 + l14 + l12 + 2l11 + 2l15 − l4 − l9 − l7. Note that we no more use an ‘arrow’ to represent the direction of the 1simplices. Since we can now have arbitrary integer coeﬃcients, color representation of the coeﬃcients is the preferred way of visualization. Green indicates positive, red indicates negative. Note how a −l12 from ∂2(A3) adds to 2l12 from ∂(A2) to give the l12 in the ﬁgure.

(c) However, one can set lA = l13 + l14 + l12 + 2l11 + 2l15 − l4 − l9 − l7, and considered to be a generating el-
ement of C1(X) (by change of basis). Then we will be using light
green to represent lA with coeﬃcient 1. Then, for example, lA + l12 will be represented by this same ﬁgure as
above, except with the edge corre-
sponding to l12 being marked with darker green.

Figure 2.6: A 2-chain and its boundary, with coeﬃcients (which includes direction information) represented by colors.

we deﬁne a new element 2li := li + li. This can be interpreted as taking the line segment two times on top of itself (similar to disjoint union). However it is to be kept in mind that this is absolutely an algebraic construction. Following along similar lines, we can deﬁne 2li, 3li, 4li, · · · , and the corresponding inverses −2li, −3li, −4li, · · · . In general nli := li + li + · · · (n times), and −mlj := (−lj) + (−lj) + · · · (m times). Thus we have constructed an abelian group that is freely generated by l1, l2, l3, · · · . We represent this group by C1(X) (where, X is the topological space which we discretized to create the simplices), where the subscript 1 refers to the dimension of the simplices. Of course we can do similar treatment for simplices of all dimensions (e.g. Figure 2.6). The group for the n-dimensional simplices is written as Cn(X).
Coeﬃcients: One further generalization of the said group construction is that with arbitrary coeﬃcients. The idea can be described as follows: So far we have constructed elements like 2li, 3li, · · · (i.e. li with integer coeﬃcients). However, very often, one may come across problems where noninteger coeﬃcients arise very naturally. One typical inspiration comes from an electrical network that can be modeled as a simplicial 1-complex (the coeﬃcients on the 1-simplices represent the currents passing through them, and the coeﬃcients on the 0-simplices represent the voltage at the nodes). Then, because of Kirchhoﬀ’s law, the sum of the incoming currents at any node is equal to the sum of the outgoing currents at the node. Consequently, any closed loop of current represents a 1-cycle in the complex [34]. However, note that now we need to deﬁne coeﬃcients over R since the currents can assume any real number (e.g. 2.56 li). Moreover, due to the superposition theorem
15

for electrical circuits [11], one can add currents, and hence add the 1-cycles. For such additions we naturally borrow the deﬁnition of additions from the real numbers, R (which is a group under ‘+’ operator with 0 as identity element), and the additions happen simply on the coeﬃcients of li. In fact we can generalize the coeﬃcients to arbitrary algebraic structures (like groups, rings, ﬁelds, etc.). Thus, if G is an algebraic structure and an abelian group under an addition operation, ‘+’, then we deﬁne C1(X; G) (as a generalization of C1(X)) to be abelian group in which every element is represented by an ordered set of coeﬃcients [g1, g2, g3, · · · ], gi ∈ G (these are the coeﬃcient of l1, l2, l3, · · · ), that inherits the operator ‘+’ from G by the element-wise operation [g1, g2, g3, · · · ] + [g1, g2, g3, · · · ] = [g1 + g1, g2 + g2, g3 + g3, · · · ]. It is to be noted that the addition operator is a chosen preferred operator of G. The inheritance of other operators from G to C1(X; G) are subject to independent deﬁnitions. Of course, once again, this is general for arbitrary dimensions, and for n-dimensional simplices we have the algebraic structures Cn(X; G).
The boundary operator, which was distributive, is extended to being linear (informally. More precisely it is a group homomorphism) when we have the coeﬃcients (this is mostly by deﬁnition than anything else – by extending the deﬁnition of boundary operator to chains with coeﬃcients). Thus, from our previous example, if A = gaA2 + gbA3 ∈ C2(X; G) for ga, gb ∈ G, we have ∂2(A) = ga∂2(A2)+gb∂2(A3) = ga(l11 +l15 +l12)+gb(l13 −l12 +l14) = ga(l11 +l15)+gb(l13 +l14)+(ga −gb)l12. Substituting ga = gb = 1 for G = Z, we obtain our previous result. Also, by linearity, ∂1 ◦∂2(A) = ga∂1◦∂2(A2) + gb∂1◦∂2(A3) = ga0 + gb0 = 0. In general ∂n ◦ ∂n+1 = 0 due to linearity and the fact that for a (n + 1)-simplex σn+1, ∂n ◦∂n+1σn+1 = 0. More precisely, the boundary operator is a group homomorphism.
Vector Space: One can very well compare Cn(X) to a vector space (especially when the coeﬃcients are in ﬁeld R). For example, in Figure 2.6, each li may be thought to be an basis vector forming a basis set in a N -dimensional vector space (where N is the total number of ‘edges’ or 1-simplices in the discretization of X). Thus, any linear combination of the basis vectors, σ = a1l1 + a2l2 + · · · + aN lN , will represent some 1-chain (Figure 2.6(b)). Then, Cn(X) is very much like a vector space spanned by those basis vectors. One can even talk about change of basis (Figure 2.6(c)). In particular, if the coeﬃcients are in a ﬁeld, then Cn(X) is indeed a vector space. If elements from this vector space can be represented by coeﬃcient vectors [a1, a2, a3, · · · , aN ]T (as described earlier, and assuming there are N numbers of n-simplices in the representation of X), and the elements of the vector space Cn−1(X) is represented by coeﬃcient vectors [b1, b2, b3, · · · , bM ]T (where we assume that there are M numbers of (n − 1)-simplices in the ﬁnitely discretized representation of X), then the boundary operator ∂n may be represented by a M × N matrix. Thus, when a N -dimensional coeﬃcient vector representing a vector from from Cn(X) is left-multiplied by this matrix, we obtain a M -dimensional coeﬃcient vector representing a vector in Cn−1(X). Then the kernel and image of ∂n have simple interpretations borrowing the corresponding concepts from linear algebra.
2.1.3 Formal Description of Homology
Once we have established the motivation behind deﬁning chain complexes, we can formally deﬁne it in the most general way as follows.
16

Cn+1 ∂n+1 Img(∂n+1) ⊆ Ker(∂n) ∂n 0 ∈ Cn-1

. . .

. . .

. . .

Cn+1 ∂n+1

Cn

∂n

Cn-1

. . .

Figure 2.7: A schematic representation of a chain complex (see [34]). It consists of the sequence of groups, C•, along with homomorphisms ∂•, with the property that ∂n ◦ ∂n+1(σ) = 0 for any σ ∈ Cn+1.
Deﬁnition 2.1.8 (Chain Complex [40], Fig. 2.7). A chain complex is a sequence of abelian groups, · · · , C3, C2, C1, C0, C−1, · · · , along with homomorphisms ∂n : Cn → Cn−1 such that ∂n−1 ◦∂n = 0 for all n = · · · , 3, 2, 1, 0, −1, · · · . It is commonly represented using the following diagram:
· · · −−→ Cn+3 −−∂n−+−3→ Cn+2 −−∂n−+−2→ Cn+1 −−∂n−+−1→ Cn −−∂−n→ Cn−1 −−∂−n−−→1 · · ·
with, ∂n−1 ◦ ∂n = 0, ∀n.
Note that in general, chain complexes need not be related to any topological space, as in the independent deﬁnition stated above. It is simply a sequence of abelian groups C• with the operators ∂• (by subscript ‘•’ we informally mean the collection for all n). Such independent studies of chain complex without any reference to topology is known as homological algebra and is a ﬁeld of study by its own right. Algebraic topology borrows signiﬁcant amount of tools from that ﬁeld.
In algebraic topology, these groups Cn obviously corresponds to the groups freely generated by the n-simplices on the topological space X, and are written as Cn(X). Chain complexes generated by a ﬁnite number of simplices as described earlier are known as simplicial complex. However there are other, and more general forms of chain complex that one can deﬁne on a topological space – ∆-complex, singular complex, cellular complex, cubical complex, etc.
Since ∂n ◦ ∂n+1 = 0, we have (see Figure 2.7)
Img(∂n+1) ⊆ Ker(∂n) ⊆ Cn(X)
Deﬁnition 2.1.9 (Subgroup of Boundaries [40]). Bn(X) := Img(∂n+1) ⊆ Cn(X) is called the group of n-boundaries (a subgroup of Cn), and is the image of the whole of Cn+1(X) under the action of ∂n+1. Elements in Bn(X) (called n-boundaries) are n-chains, each of which are boundaries of some (n + 1)-chains in X (Figure 2.8(c)).
Deﬁnition 2.1.10 (Subgroup of Cycles [40]). Zn(X) := Ker(∂n) ⊆ Cn(X) is called the group of n-cycles (a subgroup of Cn), and is the kernel of ∂n (i.e. all the elements in Cn that maps to the identity element in Cn−1(X) under the action of ∂n). Elements in Zn(X) (called n-cycles) are nchains that have empty boundary under the action of ∂n (Figure 2.8(b)). Of course all n-boundaries are n-cycles as well, but the converse is not true.
17

X

X

X

A

σ

z

b

(a) A 1-chain. The boundary of this chain is not empty since the curves have end-points (0-chains). This is an arbitrary element of C1(X).

(b) A 1-chain without a boundary is a 1-cycle. This is an element of Z1 (X ).

(c) A chain which is boundary of a 2-chain (the one marked by A). This is an element of B1(X).

Figure 2.8: Illustration of chain, cycle and boundary. The topological space X is shown in blue. The ﬁgures do not show a discretization explicitly, however one can think it to be discretized into very small simplices (much like what we had in Figure 2.5 or 2.6) in order to accommodate almost arbitrary-shaped chains. Every 1-chain shown in this ﬁgure are made of 1-simplices, being labeled for the ﬁrst time, with coeﬃcients as 1 (indicated by the color light green – refer to Figure 2.6(b)).
It is easy to see that both Zn(X) and Bn(X) are closed under addition and also the inverse of elements in each of them belong to the sets themselves. Thus they are subgroups.
As discussed earlier, an element σ ∈ Cn(X) is an arbitrary linear combination of n-simplices on X (Figure 2.8(a)). However, a subset of those will be such that the boundary operator, ∂n, acts on them to give zero (i.e. they are in Ker(∂n)). These are elements z ∈ Zn(X) ⊆ Cn(X) (Figure 2.8(b)). Furthermore, some out of those are such that they themselves are boundaries of some one higher dimensional chain (i.e. they are in Img(∂n+1)). Those are elements b ∈ Bn(X) ⊆ Zn(X) (Figure 2.8(c)).
Since, by deﬁnition, for any b ∈ Bn(X) we can ﬁnd a ω ∈ Cn+1(X) such that ∂n(b) = ∂n ◦ ∂n+1(ω) = 0 (by deﬁnition of chain complex), we have Bn(X) a subgroup of Zn(X). Thus, one can now construct the following quotient group,
Deﬁnition 2.1.11 (Homology Groups [40]). We deﬁne the nth homology group of X as ,
Hn(X) = Zn(X) / Bn(X)
The intuitive description of Hn(X) is as follows: We look at two n-cycles z1, z2 ∈ Zn(X) (Figure 2.9). If their diﬀerence is boundary of some one-dimensional higher chain (i.e. z1 − z2 ∈ Bn(X)), we say that they belong to the same homology class or are homologous (Figure 2.9(a) and 2.9(d)), otherwise we say that they are in diﬀerent homology classes (Figure 2.9(b) and 2.9(c)). Thus, we have several diﬀerent homology classes of n-cycles. Hn(X) essentially is the set of all those homology classes. This can be seen clearly by the deﬁnition of group quotient. Each element of Hn(X) is a partition of Zn(X) such within each partitions (i.e. a homology class) two elements z1 and z1 can be related as z1 = z1 + b for some b ∈ Bn(X).
Group Structure of Hn(X): For a given z ∈ Zn(X), we write [z] ∈ Hn(X) for the homology class of Z. The addition operator of Hn(X) is inherited from Zn(X) in a rather natural way – we deﬁne
18

X

X

z2

A

z1

z2 z'1

(a) z1 and z2 are 1-cycles that are in the same homology class. This is because z1 and −z2 (z2 with reversed orientation) forms the boundary of a 2-chain, A, (one consisting of all the 2simplices in the annular region with unit coefﬁcients). That is, z1 − z2 = ∂2(A) ∈ B1(X)

(b) z1 and z2 are 1-cycles that are in diﬀerent homology classes. This is because one cannot
ﬁnd a 2-cycle A such that z1 − z2 = ∂2(A) ∈ Bn (X )

2A' A1 A2 A3

X

X

A
z2 2z1

z'2 2z1

(c) 2z1 (where z1 is the same as in (a)) and z2 are 1-cycles that are in diﬀerent homology classes. The coeﬃcient 2 for z1 (which may be thought of as 2 copies of z1 placed on top of one another) is indicated by the darker color (refer
to Figure 2.6(b)).

(d) 2z1 and z2 are 1-cycles that are in same homology classes. This is because we can write
2z1 − z2 = ∂2(2A − A1 − A2 − A3) ∈ B1(X).

Figure 2.9: Cycles in same and diﬀerent homology classes. Discretization and color coding of coeﬃcients similar to before (Figure 2.8).
[z1] + [z2] = [z1 + z2], where the ﬁrst addition is the one in Hn(X) (one we are deﬁning), while the addition on the right is well-known for Zn(X). Also, the identity element (or ‘zero’) of Hn(X) is the homology class of the boundaries (elements of BN (X)). This can be observed as follows: If z1 and z1 belong to the same homology class (i.e. z1 = z1 + b for some b ∈ Bn(X)), then by deﬁnition, [z1] = [z1] =⇒ [z1 + b] = [z1] =⇒ [z1] + [b] = [z1] =⇒ [b] = 0.
Resorting brieﬂy to our earlier comparison of Cn(X) with a vector space, we can see that Zn(X) is like a vector subspace (a vector space by its own right). Thus, Bn(X) is a subspace of Zn(X).
19

X

X

X

S

S

S

(a) Relative chains. The 1-chains in X have some boundary (end point, 0-chain) lying outside S.

(b) Relative cycles. The 1-chains in X have boundaries lying inside S. Thus in the relative form (i.e. their image under quotient map j), they have no boundary. Hence these are relative cycles.

(c) Relative boundaries. For these 1chains in X, either the whole of it lies inside S, thus making it trivial, or they are boundaries of some relative 2-chain.

Figure 2.10: Relative chains on C1(X, S), and chains that are relative cycles and relative boundaries.
Then Hn(X) may be thought of as the vector subspace of Zn(X) which is orthogonal to Bn(X) such that Hn(X) and Bn(X) spans the whole of Zn(X).
Relative Homology: Given C•(X), a chain complex on X, and a subspace S of X (S and X are together written as (X, S) and is called a pair of spaces), one can construct the subcomplex C•(S), where each Cn(S) is a subgroup of Cn(X) freely generated by the n-simplices that fall inside S. Then one can talk about quotient groups Cn(X)/Cn(S). These quotient groups are written as Cn(X, S) for brevity. Thus, there is a quotient map j : Cn(X) → Cn(X, S) such that given any nchain σ ∈ Cn(X), if we trivialize the part of the chain that lies inside S, we obtain j(σ) ∈ Cn(X, S). It is analogous to taking projection of σ on the subspace orthogonal to the subspace Cn(S). One can then extend the boundary operator ∂n quite naturally to deﬁne ∂n : Cn(X, S) → Cn−1(X, S). Then it is not diﬃcult to see that C•(X, S) form a chain complex,
· · · −−→ Cn+1(X, S) −−∂n−+−1→ Cn(X, S) −−∂−n→ Cn−1(X, S) −−∂−n−−→1 · · ·
with ∂n−1 ◦ ∂n = 0, ∀n. The image of a n-chain σ ∈ Cn(X) under the action of j is typically called a relative chain and is an element of Cn(X, S). We can compute homology groups for the above chain complex. Those are called relative homology groups, and are represented by Hn(X, S). It is to be noted that these, in general, are not same as Hn(X)/Hn(S). Any σ ∈ Cn(X) lying inside completely S will be a trivial relative chain j(σ) = 0 ∈ Cn(X, S) and is a relative boundary (Figure 2.10(c)). And any n-chain σ ∈ Cn(X) with boundary lying completely inside S will be a relative n-cycle j(σ) ∈ Zn(X, S) (Figure 2.10(b)).
2.1.4 Properties of Homology
In this section we will mostly state some results and explain their implications, but without detailed proofs. The reader may refer to [40] for the proofs and detailed discussion.
Interpretation of Homology Groups: Each element of the nth homology group, Hn(X), as we 20

X

X

X

za zb

zq

zp

(a) [za] is a generator of H1(X).

(b) [zb] is another generator of (c) z = azp + bzq ∈ Z1(X) is an ar-

H1 (X ).

bitrary 1-cycle. Its homology class

however is [z] = a[zp] + b[zq] =

a[za] + b[zb], i.e. can be expressed as a linear combination of the gener-

ating homology classes.

Figure 2.11: The rank of homology group gives the Betti number. The homology class of an arbitrary cycle can be expressed as the linear combination of the generators of the homology group.
just saw, represents a class of n-cycles that diﬀer by n-boundaries. There is however an even more intuitive and useful interpretation of the homology groups – the rank (or informally, the dimensionality) of the group tells us about the nth Betti number (informally, the number of (n + 1)-dimensional ‘holes’ when n > 0, and number of connected components when n = 0) of the topological space X. This is not diﬃcult to see from the example in Figure 2.9. One can see that corresponding to the two holes in the space X, there are two distinct types of cycles that are not boundary (called non-trivial cycles) – one that goes around the right hole (Figure 2.11(a)), and other that goes around the left hole (Figure 2.11(b)). These are the generators of H1(X). In fact a direct computation of H1(X) reveals that it is isomorphic to the group Z2 (direct sum of two copies of the integers’ group, which is a group under addition) – thus, the ﬁrst Betti number of the space, b1, is 2. The homology class of any other cycle in the space can be expressed as a linear combination of these two homology classes (Figure 2.11(c)).
Indiﬀerence to Method of Construction of Chain Complex: The homology groups of a topological space are indiﬀerent to the method of construction of the chain complex used to compute the homology groups. The intuitive idea is that given a topological space X, one can create a chain complex in many diﬀerent ways on it. Even a ﬁnite simplicial discretization (e.g. Figure 2.6) can be created in inﬁnite variety. Besides, there are other types of chain complexes that can be constructed on a topological space (like ∆-complex, singular complex, cellular complex, cubical complex – see [40] for details). Although these create vastly diﬀerent chain complexes, {C•(X), ∂•}, the homology groups Hn(X) computed using any of them will however be the same as long as we stick to the same coeﬃcient group. This may be intuitive from the discussion in the previous paragraph, where we saw that the homology groups provide information about the Betti numbers of X – a topological invariant of X. However a rigorous proof of this fact is quite elaborate and involved [40].
Functoriality: Homology is a functor from the category of topological spaces to the category of groups [40]. The simple meaning of this statement is that if there are two topological spaces X and
21

Y , and if there is a continuous function f : X → Y , then there exists a group homomorphism f∗:n : Hn(X) → Hn(Y ), ∀n such that for a cycle z ∈ Zn(X) the following holds: f∗:n([z]X ) = [f (z)]Y . Here, by f (z) we mean the image of z in Y under the action of f (which will still be a cycle), and by the subscripts X and Y of the square brackets we mean the homology class of the cycle in the respective topological space (i.e. elements of Hn(X) or Hn(Y ) respectively). We say that the map f induces the homomorphisms f∗ between the homology groups (where, by the subscript ‘∗’ we mean the collection of all the induced homomorphisms · · · , f∗:2, f∗:1, f∗:0). Also, due to functionality, if there are maps f : X → Y and g : Y → Z, then (g ◦ f )∗ = g∗ ◦ f∗.
Homotopy Invariance: If two spaces X and Y are homotopy equivalent (Deﬁnition 2.1.6), then their homology groups are isomorphic (i.e. they essentially are the same groups). In notation, Hn(X) Hn(Y ), ∀n. This is an important result in algebraic topology.
However, if we know that the nth homology groups of two spaces are isomorphic (i.e. Hn(X) Hn(Y )), it is often nontrivial to ﬁnd a map f : X → Y that induces the isomorphism. For example we can have Hn(X) Hn(Y ) Zp, but if f : X → Y is such that every point on X is mapped to a single point y0 ∈ Y (i.e. a constant map), then the map f∗:n is a zero map (which is still a homomorphism, but not an isomorphism). On the other hand, if f is a homotopy equivalence between X and Y , then f∗ are isomorphisms.
Long Exact Sequence (LES): A long exact sequence is a special type of chain complex consisting of sequence of abelian groups, A•, and chain maps between the groups, p•, with the property that Img(pn+1) = Ker(pn), ∀n (instead of just being subset as it was the case for chain complex). Thus long exact sequences are obviously chain complexes as well. The sequence can be ﬁnite or inﬁnite as in the case of chain complex.
An important result in algebraic topology is that given a pair of spaces, (X, S), the following sequence is a LES:
· · · −−→ Hn(S) −−i∗→ Hn(X) −−j∗→ Hn(X, S) −−∂−∗→ Hn−1(S) −−i∗→ Hn−1(X) −−j∗→ · · ·
where, by the subscripts ‘∗’ we mean the corresponding induced homomorphism to be used for appropriate value of n. i∗ is the homomorphism induced (due to functoriality of homology) by the inclusion map i : S → X. j∗ is induced by the quotient map at the chain level (as opposed to the topological space) j : Cn(X) → Cn(X)/Cn(S). And ∂∗ is a homomorphism that maps the homology class of relative cycles in (X, S) to the homology class of its boundary in S. A more detailed discussion on properties of LES can be found in pp. 114 of [40].
2.1.5 Cohomology
Before we conclude, we will brieﬂy describe the concept of cohomology [40] and in particular, the de Rham cohomology [8]. The concept of cohomology is very closely related to homology, and most of the concepts in cohomology (e.g. cochain, cocycle and coboundary) are derived from the related concepts in homology.
Given a chain complex {C•, ∂•} (with coeﬃcients in group G), consider a homomorphism (informally, a linear function) α : Cn → G for some group G . That is, given any chain σ ∈ Cn we can
22

3 α1(σ)

2

X

1

0 -1

-2 R

α2(σ) 3
2 1 0 -1 R -2

Figure 2.12: Two cocycles, α1, α2 : C1(X) → R, acting on various cycles, σ. The cohomology class of these two cocycles are generators of H1(X). In this example, H1(X) R2 as well as H1(X) R2 (with all coeﬃcients in R).
compute α(σ), which will give us a value in G . Now consider the set of all such linear functions Cn → G that are possible, and call this set Cn. Thus α ∈ Cn. One can deﬁne an addition, , on elements of Cn: For α1, α2 ∈ Cn, we deﬁne (α1 α2)(σ) = α1(σ) + α2(σ), where ‘+ ’ is the addition operator in G . It is easy to see that Cn, along with the addition , forms a group. Concisely one writes Cn = Hom(Cn, G ) and call it the dual group of Cn. Elements of Cn are called n-cochains, which essentially are functions from Cn to G . Thus, for every cochain α ∈ Cn and every chain σ ∈ Cn, the evaluation of α on σ, i.e., α(σ), gives a value in G .
Also, corresponding to every ∂n in the chain complex, one can deﬁne a dual map δn−1 : Cn−1 → Cn as follows: Consider a β ∈ Cn−1 (which is a function from Cn−1 to G ). Then δn−1(β) is an element of Cn such that for every σ ∈ Cn the following holds: (δn−1(β))(σ) = β(∂n(σ)). It is easily seen that {C•, δ•} forms a sequence
· · · ←−− Cn+3 ←−δn−+−2− Cn+2 ←−δn−+−1− Cn+1 ←−δ−n− Cn ←−δn−−−1− Cn−1 ←−δ−n−−−1 · · ·
with δn+1 ◦ δn = 0, ∀n. This, in fact, is a chain complex with a increasing sequence of indices (which is no diﬀerent from a standard chain complex since it can always be converted to a decreasing sequence by a variable substitution). This chain complex is however called a cochain complex, the dual of a chain complex. Just as in a chain complex, we can compute the homologies. Such groups are called the cohomology groups: Hn(X) = Ker(δn)/Img(δn−1).
n-cocycles are elements of the group Zn := Ker(δn). They have the property that they evaluate to zero on every n-boundary. n-coboundaries are elements of the group Bn := Img(δn−1). They have the property that they evaluate to zero on every n-cycle and n-boundary. Cohomology classes of cocycles have similar interpretation as homology classes: Each cohomology class contains the
23

cocycles that diﬀer by a coboundary. Thus, two cocycles from the same cohomology class will evaluate to give the same value on two cycles from the same homology class. Figure 2.12 illustrates how two cocycles evaluate on diﬀerent cycles in the space X.
De Rham Cohomology Groups
A related concept is that of the De Rham Cohomology. Here, instead of looking at functions from Cn(X) to a group G (functions that can be evaluated on n-cycles), we look at diﬀerential n-forms [8] that can be integrated on n-cycles. In fact, due to the linearity of the cochains (i.e. the functions Cn(X) → G ), one would expect that the cochains can be written as some form of an integral – for example, σ1+σ2 ω = σ1 ω + σ2 ω lets us deﬁne a cochain α(σ) = σ ω. It can in fact be shown that there is a 1-to-1 correspondence between the cohomology classes of n-cocycles and the de Rham cohomology classes of closed diﬀerential n-forms. This is formalized by the de Rham theorem that gives an isomorphism between the cohomology groups with coeﬃcients in R (i.e. H∗(X; R)) and the de Rham cohomology groups, Hd∗R(X), of a space X.
2.2 Elementary Riemannian Geometry
Topology, due to its invariance to homeomorphism, does not tell us anything about the distance between points on a topological space. One needs to deﬁne a metric or distance function on a topological space for that.
Deﬁnition 2.2.1 (Distance Function [47]). A distance function on a topological space X is a function d : X × X → R such that, for any p, q ∈ X, the following conditions are satisﬁed,
i. d(p, q) ≥ 0,
ii. d(p, q) = 0 if and only if p = q,
iii. d(p, q) = d(q, p), and,
iv. d(p, q) ≤ d(p, r) + d(r, q) for all p, q, r, ∈ X (this is called the triangle inequality).
A distance function is also called a metric. However, we will reserve that term for informally referring to Riemannian metric, and will avoid using the term to indicate a distance function in order to avoid confusion.
Simple example of distance functions include the p-norm in the familiar vector space of RD (which is a topological space with the standard Euclidean topology, with additional structure of a vector space). Thus, if x = [x1, x2, · · · , xD] and y = [y1, y2, · · · , yD] are points in RD, then d(x, y) = |x1 − y1|p + |x2 − y2|p + · · · + |xD − yD|p 1/p , p > 0, deﬁnes a distance function on RD .
2.2.1 Manifolds, Coordinate Charts, Atlases and Tangent Space
In Riemannian Geometry we will mostly be concerned with a speciﬁc class of topological spaces, namely manifolds.
24

P

P

P

P

(a) A circle is a 1-manifold. A open neighborhood of every point on it resembles an open segment of R.

(b) Topological spaces that are not manifolds. The spaces look locally Euclidean everywhere, except for the points marked as ‘P ’.

Figure 2.13: Topological spaces that are manifolds (a) and that are not manifolds (b).

Deﬁnition 2.2.2 (Manifold [47]). A manifold is a topological space that locally looks like an Euclidean space everywhere. That is, if M is a topological space, and p ∈ M is a point in it, then there exists a open neighborhood U of p (i.e. an open set U with p ∈ U ), such that one can construct homeomorphisms ψ : U → RD for some nonnegative integer D. The minimum value of D for which it is possible to construct such homeomorphisms is called dimension of the manifold.
Of course all manifolds are topological spaces, but the converse is not true. A circle is a 1dimensional manifold since the neighborhood of every point on it resembles a line segment, a subset of R1 (Figure 2.13(a)). Similarly a sphere or a torus are 2-dimensional manifolds. A solid ball is a 3-dimensional manifold with boundary (i.e. points on the boundary locally looks like half-space instead of R3). Figure 2.13(b) shows some simple topological spaces that are not manifolds. This is because at least at some point in the spaces there does not exist an open neighborhood that resembles an Euclidean space.
Next we proceed towards deﬁning a coordinate chart on a manifold. There are many natural algebraic tools associated with the standard Euclidean space, RD (e.g. its vector-space structure, natural deﬁnition of diﬀerentiation along the axes, etc.). The main purpose of deﬁning a coordinate chart is to borrow those concepts to arbitrary manifolds.
Deﬁnition 2.2.3 (Coordinate Chart). Given an open subset U of a D-dimensional manifold M , and a continuous injective function φ : U → RD, we say C = (U, φ) is a coordinate chart on U . φ in fact needs to be a homeomorphism as well (i.e. have a continuous inverse over its image).
Thus, the polar coordinate θ ∈ (0, 2π) used to describe points on a circle (Figure 2.14(a)) constitutes a coordinate chart. The map φ : (S1 − O) → (0, 2π) maps every points on the circle, except one (exclusion of which makes the pre-image of φ an open subset of S1, and the image an open subset of R1), to the open interval (0, 2π) on R. Similarly, the familiar polar coordinate on a 2-sphere constitutes a coordinate chart. The open subset under consideration here is the entire surface of the sphere except the polar points and one longitudinal line, and the function φ maps every point on it to a point in R2, namely, (θ, γ) – the latitudinal and longitudinal angles.
The variables (θ in case of the circle, (θ, γ) in case of a sphere), natural to RD, can now be used 25

P

φ

θ

O

0θ

2π

A

P

φ2

φ1 θ η

(a) The map φ : (S1 − O) → (0, 2π) constitutes a coordinate chart. Note that (S1 − O) is an open subset of S1.

(b) Two maps, φ1 : (S1 − O) → R and φ2 : A → R, with A being an open subset of S1, constitutes an atlas
on S1. This is because (S1 − O) ∪ A = S1.

Figure 2.14: A chart and an atlas on the topological circle.

to describe points on the pre-image of φ, i.e. the open subset U (since φ has a continuous inverse as well). These are called the coordinate variables of the chart C. Very often, if x = (x1, x2, · · · , xD) are the coordinate variables corresponding to a given chart, one simply writes x to refer to points on U instead of writing φ(x).
Deﬁnition 2.2.4 (Atlas [47], Fig. 2.14(b)). An atlas is a collection of coordinate charts {Uα, φα} on a manifold M , such that the union of the open subsets covers the entire of M (we say Uα is an open covering of M ). That is ∪αUα ⊇ M .
Going back to the example of the chart on a open subset of circle, we were unable to incorporate one single point on the circle for being described by the chart in Figure 2.14(a). However, with an atlas (Figure 2.14(b)), we can have multiple separate charts, using which we can cover the entire circle.
Deﬁnition 2.2.5 (Chart Transition [47], Fig. 2.15). Consider two charts (Um, φm) and (Un, φn), for some open subsets Um and Un of a D-dimensional manifold M such that Um ∩ Un = ∅. Then one can deﬁne the map φn ◦ φ−m1 : φm(Um ∩ Un) → φn(Um ∩ Un). Note that both the pre-image and image of this map are subsets of RD. Such a map is called a chart transition or a coordinate transformation or simply a coordinate change (the later two terms are used more frequently when Um = Un = Um ∩ Un).
Thus, if x ∈ RD are the coordinate variables for (Um, φm), and x ∈ RD are the ones for (Un, φn), then the chart transition is given by x = φn ◦ φ−m1(x). If the charts are assumed to be implicitly deﬁned with the coordinate variables, one simply writes x = f (x), or informally, x = x(x) (i.e. the variables xi are functions of the variables xj).
A manifold is said to be diﬀerentiable if for every pair of charts, (Um, φm) and (Un, φn), the transitions φn ◦ φ−m1 are diﬀerentiable functions of class C∞ (where the notion of diﬀerentiability on RD is natural due to the vector-space structure on it). Most of the manifolds that we will be concerned with in this thesis are diﬀerentiable.

26

Um ∩ Un M

R2

v

φm

x

f := φn ○ φm-1 φn
x v

d(φn ○ φm-1) R2

Figure 2.15: Chart Transition.
Tangent Space
We are familiar with the notion of a tangent to a curve or the tangent plane to a surface embedded in R3. The notion of such tangents is generalized to arbitrary manifolds by tangent space. Consider a chart (Um, φm). A point, p, in Um is represented by its image, x = [x1, x2, · · · , xD] ∈ RD, under the action of φ. By the virtue of the vector-space structure of RD, one can imagine a vector centered at x and having components v1, v2, · · · , vD along the directions of increasing values of x1, x2, · · · , xD (Figure 2.15).
Fundamental to the deﬁnition of such a vector is the notion of transformation of the coeﬃcients, [v1, v2, · · · , vD], under a chart transition. Consider the chart transition x = f (x) as discussed earlier. The vector (sitting at x) with components [v1, v2, · · · , vD] in the un-barred coordinate variables will have certain components [v1, v2, · · · , vD] in the barred coordinates (sitting at x) (Figure 2.15), which is determined by some transformation rule that we are yet to deﬁne. However, whatever that deﬁnition be, the property that such a transformation rule on coeﬃcient vectors attached to points, x or x, must satisfy is invariance under a composition of forward and inverse transformation. That is, if corresponding to the chart transition x = f (x) the transformation of the vector components (at the speciﬁc point p) is given by some function d[]fx : RD → RD such that [v1, v2, · · · , vD] = d[]fx([v1, v2, · · · , vD]), and if corresponding to the inverse chart transition x = g(x) the transformation of the previously transformed vector components is given by some function d[]gx such that [v1, v2, · · · , vD] = d[]gx([v1, v2, · · · , vD]), then we should have [v1, v2, · · · , vD] = [v1, v2, · · · , vD]. That is, d[]gx ◦ d[]fx acts as an identity transformation on the vector components whenever g = f −1. Moreover it should also satisfy the composition property d[](h ◦ f )x = d[]hf(x) ◦ d[]fx, where f and h are two chart transitions. These properties should hold true at every x and every component vector of vector attached to x. The conditions are known as cocycle conditions [53, 8].
27

Contravariant Vectors: One such transformation rule for vectors that satisﬁes the above condi-

tions is vj =

D i=1

∂fj ∂xi

vi
x

(where by f j

we simply mean the jth

component of the vector function

f ). This can be easily seen by noting that [v] = Jf [v] (where Jf is the Jacobian matrix of f at

x, and [v] represents the coeﬃcient vector as a column vector). Then a subsequent transformation

under d[]g will give Jg[v] = JgJf [v] = [v] (since g is the inverse transformation of f , the product of the Jacobian matrices, JgJf , is the identity matrix). Moreover, it is a standard exercise to check

that JhJf = Jh◦f . Such vectors, the coeﬃcients of which follow such transformation rules, are

known as contravariant vectors (or simply, vectors). There are other types of vectors that trans-

form diﬀerently, but satisfy the said properties under composition of transformations. One such

example is that of covariant vectors, which we will not discuss in details in this section.

A

systematic

way of writing contravariant

vectors

is by

choosing

∂ ∂xi

as basis

for such

vectors

(i.e.

quantities to which we ‘multiply’ the said coeﬃcients/components, vi, and take sum to write the

full vector). This is purely done to avoid writing the said transformation rule for vector components

explicitly, and instead take advantage of the standard rule for transformation of partial derivatives

from one set of variables to another. Thus, under this representation, one would write for a vector,

v=

D i=1

vi

∂ ∂xi

(where

as

usual

the

vi

are

the

components

in

the

speciﬁc

chart),

and

asserts

that

this v is independent of the choice of coordinate chart. That is,

v=

D

vi

∂ ∂xi

=

D

vj

∂ ∂xj

i=1

j=1

(2.2.1)

Now, from the property of partial derivatives,

∂

D ∂xj ∂

∂xi =

∂xi ∂xj

j=1

Plugging this in the middle terms of (2.2.1) naturally reveals the transformation rule

vj =

D

∂xj ∂xi

vi

i=1

where, we have used the informal notation for transformation, x = x(x).

(2.2.2)

Deﬁnition 2.2.6 (Tangent Space [47]). Given a coordinate chart (U, φ) on a smooth manifold M ,

the tangent space at a point p on it represented by the coordinate variable x ∈ Ω = Img(φ) ⊂ RD

is

a

D-dimensional

vector

space,

TpM

=

TxΩ,

spanned

by

the

basis

∂ ∂x1

,

∂ ∂x2

,

·

·

·

,

∂ ∂xD

.

The whole point of choosing such a basis is to make the vectors in the tangent space independent of the choice of the coordinate chart, as described earlier, and to make the components of the vectors in each coordinate chart follow certain transformation rule.

Einstein’s Summation Convention for Repeated Indices: Purely for the convenience of writing,

we would often drop the summation sign (capital sigma) inside expressions like

D ∂xj ∂ j=1 ∂xi ∂xj

and

D i=1

vi

∂ ∂xi

,

and

whenever

there

is

a

repeated

index

(j

and

i

in

these

cases

respectively),

we

will

assume the summation to be implied.

Thus, for these expressions we will simply write

∂xj ∂ ∂xi ∂xj

and

28

0
λ φ
M

tm

R

γ(t) Δx1

RD
Δx2

Figure 2.16: An inﬁnitesimal element on a curve.

v

i

∂ ∂xi

respectively.

2.2.2 Riemannian Metric, Geodesics and Curvature
We have previously described the notion of a distance function on a general topological space. There is a more restricted (and probably more intuitive) notion of distance – one that is induced by the ‘length’ of the shortest curve connecting two points. Before we can describe the shortest curve, we need to deﬁne length of a curve. Throughout, we will mostly be working with diﬀerentiable manifolds as our topological spaces.

Informal Description

The deﬁnition of length of a curve on a D-dimensional manifold, M , represented by λ : [0, tm] → M , is closely related with the deﬁnition of the length of an inﬁnitesimal element on the curve. One can

then integrate the inﬁnitesimal lengths to obtain the total length of the curve. While the length of

an inﬁnitesimal element on a curve can have a variety of possible deﬁnitions (including ones based

on arbitrary norms and higher order derivatives of the curve), the type of deﬁnition that we will be

interested in is based on quadratic forms on the tangent spaces of the manifold. Such a deﬁnition

of length arises naturally in many physical and practical applications, and forms the motivation for

Riemannian metric.

For a given coordinate chart C = (U, φ) with coordinate variables xi, such that the curve

λ lies entirely in U , we deﬁne the curve in the given coordinates as γ = φ ◦ λ : [0, tm] → RD (Figure 2.16). The domain of γ is called the parameter space of the curve. A small inﬁnitesimal

element on the curve between t and t +∆t in the parameter space is then represented by γ˙ (t)∆t =:

[∆x1, ∆x2, · · · , ∆xD] (where ∆xi represent the change in the ith coordinate variable across the

inﬁnitesimal element in the chart C). It is not diﬃcult to note that [∆x] := [∆x1, ∆x2, · · · , ∆xD]

behaves like coeﬃcients of a contravariant vector (since in a diﬀerent coordinate chart one would

get

∆xj

=

∂xj ∂xi

∆xi

–

a

consequence

of

elementary

calculus).

29

Then we deﬁne the ‘length’ of the element as

∆s = gij ∆xi∆xj

(2.2.3)

where, as agreed, we have assumed summation over the repeated indices. gij hence represents elements of a matrix, g (which is speciﬁc to the given coordinate chart), such that the length is given by [∆x]T g[∆x] (where we assumed [∆x] to be a column vector of the coeﬃcients).
The condition that the deﬁnition of length must satisfy is that the length of an inﬁnitesimal element should not change upon change of coordinates. Thus, if we are given another coordinate chart with coordinate variables xi, the following condition must hold,

(∆s)2 = gij ∆xi∆xj = gpq∆xp∆xq

(2.2.4)

Using

the

transformation

rule

for

coeﬃcients

of

contravariant

vector,

∆xi

=

∂xi ∂xp

∆xp

,

and

substi-

tuting it in the middle term of the above equation, one gets the relationship between gij and gij,

∂xi ∂xj gpq = ∂xp ∂xq gij

(2.2.5)

This gives a transformation rule for the elements of the matrix used to deﬁne length as in (2.2.3).

The discussion so far indicates the deﬁnition of a bilinear scalar product on contravariant vectors

(e.g.

acting

on

two

copies

of

∆x

=

∆xi

∂ ∂xi

to

give

the

square

of

length

of

the

segment

as

prescribed

by (2.2.4)). It is important to note that the value of this product for two contravariant vectors does

not depend on the choice of the coordinate chart (this is achieved by the way we constructed the

transformation rule (2.2.5)). Thus it is a product deﬁned on the tangent spaces of the manifold

itself.

Deﬁnition 2.2.7 (Riemannian Metric [47]). A Riemannian metric on a diﬀerentiable manifold, M , is a symmetric bilinear scalar product on each tangent space, TpM , for every p ∈ M , such that it varies smoothly with p. That is, it is a bilinear function g(p) : TpM × TpM → R, that is symmetric in its two parameters, and it itself is smooth in p.
g is called the metric tensor, and the gij, from our previous discussion, the matrix representation of the metric in a particular coordinate chart. The symmetry condition implies that the matrix representation is a symmetric matrix in any coordinate chart.
It is important to note that matrix representation of the metric in a particular coordinate chart simply constitutes a collections of D(D + 1)/2 functions in the coordinate variables. That is,

 g11(x) g12(x) · · · g1D(x) 

g=

   

g21(x) ...

g22(x) ...

··· ...

g2D (x)

 

...

 





gD1(x) gD2(x) · · · gDD(x)

with gij(x) = gji(x). We use the following notation to write derivatives of the components of the matrix representation
30

of the metric in a particular coordinate chart,

gij,k

:=

∂gij ∂xk

Thus,

for

a

diﬀerent

coordinate

system,

gij,k

:=

. ∂gij
∂xk

One can write the inverse of the matrix g. The components of the inverse matrix are once again

functions of the coordinate variables. The components of the matrix of g−1 are written as gij (note

that the indices are written as superscript). It is easy to verify that gikgkj gives components of the

product of the two matrices. Thus,

gikgkj = δij

where, δij represents the Kronecker delta (i.e. the components of the identity matrix).

We will next describe a few quantities (speciﬁc to a particular coordinate chart) derived directly from the components of the matrix representation of the metric tensor on a particular coordinate system without detailing their immediate signiﬁcance. We will hence use those quantities in order to state some results. The reader can refer to [47] for more detailed discussion on these quantities.

Deﬁnition 2.2.8 (Christoﬀel Symbols).

Γikl

:=

1 2

gim (gmk,l + gml,k

− gkl,m)

(2.2.6)

Similar to the components of the metric, for notational convenience we deﬁne

Γikl,p

:=

∂Γikl ∂xp

Deﬁnition 2.2.9 (Ricci Scalar Curvature). We deﬁne the Riemannian curvature tensor as

Rρσµν = Γρνσ,µ − Γρµσ,ν + ΓρµλΓλνσ − ΓρνλΓλµσ

We hence deﬁne the Ricci curvature tensor,

Rij = Rkikj

Following that, we deﬁne the Ricci scalar curvature,

R = gij Rij = gij (Γkij,k − Γkik,j + Γlij Γkkl − ΓlikΓkjl)

(2.2.7)

It is to be noted that Ricci scalar curvature is a scalar function on a manifold, and is independent of the choice of the coordinate system.
In spite of all the intricacies in the deﬁnitions and their interpretations, both Γikl and R are essentially functions of the components of the matrix representation of the metric, gij, and their
31

derivatives. Hence both of these quantities can be expressed as functions of the coordinate variables x1, x2, · · · , xD.

Geodesic
Consider the length of a curve γ : [0, tm] → RD on a Riemannian manifold (expressed in a particular coordinate chart – i.e. if λ : [0, tm] → U ⊆ M was the original curve, and (U, φ) is a coordinate chart, then we deﬁne γ = φ ◦ λ),

tm

L(γ) =

gij γ˙ i γ˙ j dt

0

(2.2.8)

where γ˙ i represent the ith component of the coeﬃcients of the tangent vector in the particular

coordinate. Due to the way we deﬁned g and its transformation, the length of a ﬁxed curve on M

is independent of the choice of the coordinate system.

If the start and end points of γ are constrained to two speciﬁc points (i.e. γ(0) = s ∈ RD and γ(tm) = e ∈ RD are the constraints), then one can consider the problem of minimizing L(γ) over the diﬀerent curves, γ, that connect the two points. It can be shown that the γ that minimizes L,

also minimizes the integral

tm

E(γ) =

gij γ˙ i γ˙ j dt

0

Typically a calculus of variation approach is taken to solve this problem. The solution thus obtained

is in form of diﬀerential equation, known as the Geodesic Equation,

d2γi dt2

+ Γijk

dγj dt

dγk dt

=0

(2.2.9)

That is, any curve that minimizes the integral of (2.2.8) between any two points (even arbitrarily close) satisﬁes the geodesic equation (2.2.9), and is called a geodesic.
Geodesics are of course independent of the choice of the coordinate chart – a geodesic computed in one coordinate chart will map to the corresponding geodesic computed in a diﬀerent coordinate chart under the coordinate transformation.
The solution by the calculus of variation approach to obtain (2.2.9) is a locally optimal one, not a globally optimal one. Thus, it is possible that more than one curve connecting two points satisfy the geodesic equation. In fact it can be shown [47] that there is an unique geodesic in every homotopy class of curves connecting two points in a Riemannian metric space.
The length of the shortest geodesic (i.e. minimum over the lengths of all the possible geodesics between those points) between two points describe a distance function.

Curvature
There are essentially two notions of curvature of any metric space – extrinsic and intrinsic. The Ricci Scalar (Deﬁnition 2.2.9) is a measure of intrinsic curvature. Intrinsic curvatures are more fundamental to a metric space, whereas extrinsic curvature arises mostly due to embedding.
Intuitively, a space (or a subset of a space) has zero intrinsic curvature everywhere if it can
32

Figure 2.17: Curvature: Extrinsic vs. Intrinsic. A small patch on the cylinder can be ﬂattened without stretching or compressing any part of it. However that is not possible for a patch from a sphere. Thus the curvature of a cylinder is extrinsic, while that of a sphere is intrinsic. The Ricci scalar curvature computed using any coordinate chart on an open set on the surface of a symmetric cylinder will give a constant value of zero. While the same for a symmetric sphere will be a constant positive value.
be deformed isometrically (i.e. without stretching/squeezing any part) so as to embed it in a ﬂat Euclidean space of same dimension (Figure 2.17).
Topology and Metric
Since metric itself is described by its matrix representation in a speciﬁc chart (and possibly multiple representations in an atlas), in order to describe metric on a topological space independent of a coordinate chart, one often refers to certain description of the Ricci scalar curvature of the space or properties of geodesics on the space (since Ricci scalar curvature and properties, like intersection, of geodesics are independent of the choice of the coordinate chart). For example, one can refer to a metric space with zero Ricci scalar curvature everywhere on it. An example of such a space is a ﬂat Euclidean space with Euclidean metric. The surface of a cylinder also has zero scalar curvature (Figure 2.17). Again, one can refer to a space with constant positive scalar curvature everywhere. A sphere is such a space. Similarly, a hyperbolic space is one with constant negative Ricci scalar curvature everywhere.
However, such a description of a metric using intrinsic curvature, although describes a space locally, is not enough to deﬁne the global topology of a space. The zero curvature of R2 and the cylinder was one such example. Again, the same topological space can admit two totally diﬀerent descriptions of metric. An interesting example of such a case is that of a ﬂat torus. The ﬂat torus is a speciﬁc embedding of the standard topological 2-torus in R4. The metric inherited from the embedding space by the torus due to the speciﬁc embedding turns out to be ﬂat (i.e. the Ricci
33

scalar curvature of the ﬂat torus is zero everywhere). However, in the standard embedding of the torus in R3, it is not possible to achieve zero scalar curvature at every point on it.
A particular topological space can admit a variety of metrics. However it may not admit an arbitrary description of a metric. For example, one cannot construct a metric on a topological 2-sphere so that the Ricci curvature is zero everywhere on it. This is closely related to the notion of total curvature of a space, which is indicative of the global topology of the space.

2.3 Graph Search Algorithms
As discussed in Section 1.1.2, in the discrete approach towards planning path, a graph is constructed by distritizing the conﬁguration space and placing a vertex/node at each discretized cell. Edges are established based on available actions between neighboring vertices.
Thus a graph consists of 3 components: A vertex set V(G), an edge set E(G) ⊆ V(G) × V(G), and a cost function CG : E(G) → R+. An element in V(G) is called a vertex or a node. An element in E(G) is represented by the ordered pair [a, b] ∈ E(G), which implies that there exists an edge in G connecting a ∈ V(G) to b ∈ V(G).

2.3.1 Dijkstra’s Algorithm

Dijkstra’s Algorithm [26] is the most fundamental in ﬁnding minimum cost (or shortest distance) paths between a vertex, p ∈ V(G), in the graph to every other vertex in the graph that is reachable from p. It is complete and guaranteed to be optimal. The intuition behind the Dijkstra’s Algorithm is that starting from the start node p, a ‘wavefront’ of almost equal geodesic distances (i.e. cost of shortest paths) is propagated through the graph. Figure 2.18 illustrates the progress of Dijkstra’s algorithm. Notice the wavefront marked by the empty blue circles. This is the set of nodes {u ∈ Q g(u) is ﬁnite}.

Algorithm 2.3.1

g = Dijkstras (G, p)

Inputs: a. Graph G

b. Start node p ∈ V(G) Outputs: a. The shortest distance map g : V(G) → R+

1 Initiate g: Set g(v) := ∞, for all v ∈ V(G) // Minimum distance

2 Set g(p) = 0

3 Set Q := V(G) // Set of un-expanded nodes

4 while (Q = ∅)

5

q := argminq ∈Q g(q ) // Vertex to expand. Q is maintained by a heap data-structure.

6

if (g(q) == ∞)

7

break

8

Q = Q − q // Remove q from Q

9

for each ({w ∈ NG(q)}) // For each neighbor of q

10

Set g := g(q) + CG([q, w])

11

if (g < g(w))

12

Set g(w) = g

13 return g

where, NG(u) = {w ∈ V(G) [u, w ] ∈ E(G)}, the set of neighbors of u. 34

(a) iter = 0. Start (b) iter = 96. The

node in red.

wave front (empty

blue circles) is visible.

(c) iter = 190.

(d) iter = 286.

(e) iter = 376.

Figure 2.18: Illustration of progress of Dijkstra’s algorithm.

Once one has the map g : V(G) → R+, one can construct a shortest path from any given node, r, to the start node p using Algorithm 2.3.2.

Algorithm 2.3.2

P = Reconstruct Path (G, g, r)

Inputs:

a. Graph G b. The shortest distance map g : V(G) → R+

c. Vertex to which to ﬁnd the shortest path, r ∈ V(G)

Outputs: a. A path (ordered set of vertices) in the graph, P = [ρ1, ρ2, ρ3, · · · , ρn = r]

1 Initiate P = [ ]

2 if (g(r) == ∞) // r unreachable from the start node

3

return P

4 Set v := r

5 while (g(v) = 0)

6

P = v ⊕ P // Insert v at the beginning of P .

7

v = argminw∈NG−1(v) g(w) // back-trace predecessor that led to v.

8 P = v ⊕ P // Insert the ﬁnal vertex (the start node) at the beginning of P .

9 return P

where, NG−1(u) = {w ∈ V(G) [w , u] ∈ E(G)}, the set of vertices in G that has u as a neighbor. Note that for undirected graphs NG−1(u) = NG(u).
Note that the shortest path may not be unique, since in many cases there can be multiple paths
with the same least cost.

2.3.2 A* Algorithm
The A* Algorithm [39] is, in essence, much similar to the Dijkstra’s algorithm. While in Dijkstra’s algorithm one is typically interested in ﬁnding least cost paths to every vertex in the graph from the start vertex, in A* search typically a ﬁxed goal is provided. This allows us to direct the search in a more informed manner. Instead of expanding the ‘wavefront’ (mentioned earlier) uniformly in all direction, we expand it with a bias towards the direction of the goal vertex (Figure 2.19). This bias is governed by what is known as a heuristic function. A heuristic function for a graph G is a function h : V(G) × V(G) → R+, such that h(va, vb) give some estimate of the minimum distance (i.e. total cost of shortest path) between the vertices va and vb. An admissible heuristic function is such a heuristic function that always underestimates the actual minimum cost. It can be shown that the A* algorithm (Algorithm 2.3.3) with an admissible heuristic returns the optimal (least
35

(a) iter = 8. Goal vertex in green.

(b) iter = 57.

(c) iter = 114.

(d) iter = 171.

(e) iter = 376.

Figure 2.19: Illustration of progress of A* algorithm. The open set is marked by empty blue circles.

cost) path to the goal. Of course, the constant function h(va, vb) = 0 is an admissible heuristic, and in that case it can be shown that the A* algorithm becomes equivalent to the Dijkstra’s algorithm. In fact, the only major algorithmic diﬀerence of A* from Dijkstra’s (besides a few other structural diﬀerences) is that in place of line 7 of Algorithm 2.3.1, one selects the vertex q to be expanded as the one with lowest value of f instead of g (line 8 of Algorithm 2.3.3), where the f -value is g-value plus the heuristic from that vertex to the goal.

Algorithm 2.3.3

g = A star (G, p, r, h)

Inputs: a. Graph G

b. Start node p ∈ V(G)

c. Goal node r ∈ V(G) d. An admissible heuristic function h : V(G) × V(G) → R+

Outputs: a. A path connecting start vertex to goal vertex, P = [p = ρ1, ρ2, ρ3, · · · , ρn = r]

1 Initiate g: Set g(v) := ∞, for all v ∈ V(G) // Minimum distance

2 Set g(p) = 0

3 Initiate f : Set f (v) := ∞, for all v ∈ V(G) // f -values

4 Set f (p) = h(p)

5 Set Q := ∅ // Closed set (set of expanded nodes)

6 Set R := {p} // Open set (candidate nodes for expansion)

7 while (R = ∅ && r ∈/ R)

8

q := argminq ∈R f (q ) // Vertex to expand. R is maintained by a heap data-structure.

9

if (q == r) // Goal vertex reached.

10

return Reconstruct Path (G, g, r)

11

R = R − q // Remove q from open set.

12

Q = Q ∪ q // Add q to closed set.

13

for each ({w |w ∈ NG(q) and w ∈/ Q}) // For each neighbor of q that’s not in closed set

14

R = R ∪ w // Add w to open set.

15

Set g := g(q) + CG([q, w])

16

if (g < g(w))

17

Set g(w) = g

18

Set f (w) = g + h(w, r)

19 return [ ] // Goal vertex is not reachable.

Heuristic Function The choice of the heuristic function, h, is extremely crucial in an A* search. A heuristic function is a positive scalar function of the vertices in the search graph. For A* to return an optimal solution,
36

Figure 2.20: The two diﬀerent types of heuristics for an 8-connected grid graph: The green is the start state and red is the goal vertex. Dashed arrow represents hE, solid black arrow represents h8, light blue path represents the actual least cost path. Obstacles are in dark gray.
the heuristic function needs to be an admissible one – that is, it should be such that it never overestimates the actual minimum cost for reaching the goal. However to make the search more eﬃcient and minimize the number of vertices expanded, the heuristic must be as close as possible to the actual minimum cost to the goal. For a graph constructed by discretization of an Euclidean space (like the one in Figure 1.4(a)), one obvious and commonly used heuristic function is the Euclidean distance to the goal, i.e. hE(u, v) = u − v 2 (where, z represent the coordinate of the vertex, z, in the original conﬁguration space). But, for particular types of discretization one can use heuristic functions with tighter bounds. For example, for an 8-connected grid graph (one created by uniform square discretization of a plane as in Figure 2.20), one can use a more eﬃcient heuristic
√ given by h8(u, v) = 2 min(∆x, ∆y) + |∆x − ∆y|, where ∆x = |ux − vx| and ∆y = |uy − vy|, with zx and zy respectively representing the x and y coordinates of the point z in the original coordinate space. This is illustrated in Figure 2.20.
On-the-ﬂy Graph Construction Before we conclude this section, we would like to emphasize an important properties of the search algorithms (not just limited to Dijkstra’s and A*, but generalizes to almost all search algorithms in general): Although in both Algorithms 2.3.1 and 2.3.3, a graph G was mentioned as an input parameter, it is in fact not necessary to construct the entire graph from before and pass it on to the algorithm. If a graph can be constructed from a set of simple rules we may just need to pass those rules to the algorithms. In that case the Dijkstra’s or A* algorithm can construct the graph on-the-ﬂy as it progresses (not very diﬀerent from the way vertices are ‘created’ with the progress of iterations in Figures 2.18 and 2.19). In fact, the entire graph G may very well be inﬁnite, but we still can ﬁnd a path from a given start to a given goal vertex in the graph using either of the algorithms.
37

Chapter 3
Search-based Path Planning with
Topological Constraints in 2 and 3
Dimensional Euclidean Spaces
3.1 Introduction
3.1.1 Motivation: Homotopy Classes of Trajectories
In Euclidean conﬁguration spaces homotopy classes of trajectories arise due to presence of obstacles in an environment. Two trajectories connecting the same start and goal coordinates are in the same homotopy class if they can be smoothly deformed into one another without intersecting any obstacle in the environment, otherwise they are in diﬀerent homotopy classes. In many applications, it is important to distinguish between trajectories in diﬀerent homotopy classes, as well as identify the diﬀerent homotopy classes in an environment (e.g., trajectories that go left around a circle in two dimensions versus right). For example, in order to deploy a group of agents to explore an environment [9], an eﬃcient strategy ought to be able to identify the diﬀerent homotopy classes and deploy one robot in each homotopy class. One may also wish to determine the least cost path for each robot constrained to or avoiding speciﬁed homotopy classes. In many problems the notion of visibility is linked intrinsically with homotopy classes. In tracking of uncertain agents in an environment with dynamic obstacles, the ability to deal with occlusions during a certain time frame is important [89]. A knowledge of the possible homotopy classes of trajectories that a target can take in the environment when it is occluded can help more eﬃcient belief propagation.
Despite being mostly an uncharted research area, homotopy class constraints often appear in path planning problems. For example, in multi-agent planning problems [88, 49], the trajectories often need to satisfy certain proximity or resource constraints or constraints arising due to tasks allocated to agents, which translates into restricting the solution trajectories to certain homotopy classes that respect those constraints. In exploration and mapping problems [9], agents often need to plan trajectories based on their mission or part of the environment they are assigned for mapping
38

or exploration, and hence restrict their trajectories to certain homotopy classes. Classiﬁcation of homotopy classes in two-dimensional workspaces has been studied in the robotics
literature using geometric methods [37, 41], probabilistic road-map construction [75] techniques and triangulation-based path planning [22]. However, eﬃcient planning for least cost trajectories with homotopy class constraints is diﬃcult using such representations even in 2-dimensions. Neither it is possible to eﬃciently explore/ﬁnd optimal trajectories in diﬀerent homotopy classes in an environment.
In this chapter we propose a novel way of classifying and representing homology classes, a close analog of homotopy classes, in two and three dimensional Euclidean conﬁguration spaces, which are the types of conﬁguration spaces we encounter most often in robot planning problems. For the 2-dimensional case we use theorems from complex analysis for developing a compact way of representing homology classes of trajectories, while for 3-dimensional conﬁguration spaces we exploit theorems from electromagnetism. In later chapter we show that the formulae for 2 and 3 dimensional cases can in fact be generalized to arbitrary D-dimensional Euclidean conﬁguration spaces with obstacles.
The novelty of our work lies in the fact that our proposed representation allows us to identify/distinguish trajectories in diﬀerent classes and compute least-cost paths in non trivial conﬁguration spaces with topological constraints using graph search-based planning algorithms. The representation we propose is designed to be independent of the type of the environment, the discretization scheme or cost function. Our proposed representation can also be used in conﬁguration spaces with additional degrees of freedom that do not eﬀect homotopy classes of the trajectories (e.g. for unicycle modes of mobile robots, the conﬁguration space consists of variables x, y and θ. But the last variable, θ, does not eﬀect the homotopy classes of trajectories. Only the projection of the X − Y plane is enough to capture the topological information).
Using such a representation we show that topological constraints can be seamlessly integrated with graph search techniques for determining optimal paths subject to constraints. We also discuss how this method can be used to explore multiple homotopy classes in an environment using a single graph search.
3.1.2 Capturing Topological Information in Search-based Planning
In search-based planning algorithms one typically starts by discretizing a given environment to create a graph G = (V, E). Starting form an initial vertex, vs ∈ V, a typical graph-search algorithm expands the nodes of the graph by traversing the edges. Values are maintained and associated with each expanded node that capture the metric information (distance/cost) of shortest path leading to the expanded node from vs. For example, A* search algorithm (Algorithm 2.3.3) maintains two functions g, f : V → R. g(v) is the cost of the current path from the start node to node v, and f (v) = g(v) + h(v) is an estimate of the total distance from start to goal going through v. The algorithm maintains an open set, the set of nodes to be expanded. Each time it expands a node v, it updates the values of g(v ) for each neighbor v of v, by adding to g(v) the cost of the edge c(vv ) (the update happens only if the newly computed value is lower than the previous value). This process continues until a desired vertex vg ∈ V is reached [39].
39

v2 v1 e

α

β

(a) Given an arbitrary diﬀerential 1-form (or a

measure) “(·)”,

(·) = (·) + (·),

αβ

α

β

where α β is the total curve formed by α and

β together.

Child node

vs

Parent node

(b) We want to design a diﬀerential 1-form, integration of which along curves, give the desired H-signature. In a graph-search setup, due to the additivity property, H(vsv2) = H(vsv1) + e ω – the value for a path up to a vertex can be easily computed from the value up to one of its children.

Figure 3.1: Additivity of integration can be exploited in graph search algorithm.

The fact that the value of g(v ) can be computed from g(v) + c(vv ) is due to the fact that the cost function is additive (Figure 3.1(a)). This is because the metric information about the underlying space is captured using a diﬀerential 1-form, namely the inﬁnitesimal length/cost, dl (strictly speaking, it is a measure, but we will compare it with a 1-form since they share the property of integrability). The cost of an edge, e, of the graph is then computed as an integral of the form c(e) = e J (l) dl (with some scaling function J ). By the virtue of integration, the cost function, c, is additive (i.e. if α and β are two curves that share a common end point, then c(α β) = c(α) + c(β), where “ ” indicates the disjoint union, and represent the total curve formed by the two curves together). This implies, in an arbitrary graph search algorithm, during the expansion of the vertices of the graph, the cost of the shortest path up to a vertex that is being expanded can simply be computed by adding to that of its parent (in terms of sequence of expansions) the cost of the edge connecting to it. This additive property of length/cost is key in developing such graph search algorithms.
While the quantity, J (l) dl, yields metric information, there are other diﬀerential 1-forms that can incorporate other information about the underlying space and can be used for guiding the search algorithm. The main idea in this thesis is to determine a diﬀerential 1-forms that encodes topological information about the space and let us guide the search accordingly. In particular, we will be trying to ﬁnd generators of the De Rham’s cohomology group, Hd1R(RD − O) [8], for the Euclidean space RD punctured by the obstacles O. A more detailed discussion from the algebraic topology view point will be provided in the next chapter. In this chapter we introduce the basic concepts using more familiar tools.

3.1.3 H-signature as Class Invariants for Trajectories
We consider a very general diﬀerential 1-form in a given D-dimensional conﬁguration space C. If x1, x2, · · · , xD are the coordinate variables describing the conﬁguration space, a general diﬀerential 1-form can be written as dh := f1(x) dx1 + f2(x) dx2 + · · · + fD(x) dxD. Thus, for any given trajectory/curve, τ , in this conﬁguration space, one can compute H(τ ) = τ dh. We call this the
40

H-signature of τ (Figure 3.1(b)). We want to design the 1-form dh and the H-signature of a trajectory such that it is an invariant
across trajectories in the same homotopy class. However, because we use 1-forms and their integrals along closed curves to classify trajectories, we naturally obtain invariants for homology classes of trajectories [40, 71, 8]. But in most practical robotics problems the notion of homology and homotopy of trajectories can be used interchangeably, especially when ﬁnding the least cost path. This is discussed in greater detail with examples in Sections 3.5.1 and 3.6.
3.2 Homotopy and Homology Classes of Trajectories
Let C be the D-dimensional conﬁguration space (which exclude the inaccessible regions, e.g. the obstacles). Let x1, x2, · · · , xD be the coordinate variables used to describe the conﬁguration space. A point in C is thus represented by x.
Deﬁnition 3.2.1 (Homotopic trajectories). Two trajectories τ1 and τ2 connecting the same start and end coordinates, xs and xg respectively, are homotopic iﬀ one can be continuously deformed into the other without intersecting any obstacle.
Formally, if τ1 : [0, 1] → C and τ2 : [0, 1] → C represent the two trajectories (with τ1(0) = τ2(0) = xs and τ1(1) = τ2(1) = xg), then τ1 is homotopic to τ2 iﬀ there exists a continuous map η : [0, 1] × [0, 1] → C such that η(α, 0) = τ1(α) ∀α ∈ [0, 1], η(β, 1) = τ2(β) ∀β ∈ [0, 1], and η(0, γ) = xs, η(1, γ) = xs ∀γ ∈ [0, 1]. Alternatively, τ1 and τ2 are homotopic iﬀ τ1 −τ2 belongs to the trivial class of the ﬁrst homotopy group of C, denoted by π1(C). In the notation of [40], [τ1 −τ2] = 0 ∈ π1(C).
Deﬁnition 3.2.2 (Homologous trajectories). Two trajectories τ1 and τ2 connecting the same start and end coordinates, xs and xg respectively, are homologous iﬀ τ1 together with τ2 (the later with opposite orientation) forms the complete boundary of a 2-dimensional manifold embedded in C not containing/intersecting any of the obstacles.
Formally, τ1 and τ2 are homologous iﬀ τ1 −τ2 belongs to the trivial class of the ﬁrst homology group of C, denoted by H1(C) . In the notation of [40], [τ1 −τ2] = 0 ∈ H1(C).
A set of homotopic trajectories form a homotopy class, while a set of homologous trajectories form a homology class.
At an intuitive level the above two deﬁnitions may appear equivalent. For example, in Figure 3.2(a), τ1 is homotopic to τ2 since one can be continuously deformed into the other via a sequence of trajectories marked by the dashed curves. As a consequence, the area swept by this continuous deformation, A, forms a 2-dimensional region in the free conﬁguration space whose boundary is the closed loop τ1 −τ2. Indeed, the one-way implication is true as shown below.
Lemma 3.2.3. If two trajectories are homotopic, they are homologous.
Proof. This follows directly from the Hurewicz theorem [40] that guarantees the existence of an homomorphism from the homotopy groups to the homology groups of an arbitrary space.
41

τ1

xg

O1

-τ2

τ2

O2

xs

τ3

O3

τ1 O1
A
τ2 xs
O3

xg -τ2
O2 τ3

(a) τ1 is homotopic to τ2 since there is a continuous sequence of trajectories representing deformation of one into the other. τ3 belongs to a diﬀerent homotopy class since it cannot be continuously deformed into any of the other two.

(b) τ1 is homologous to τ2 since there exists an area A (shaded region) such that τ1 −τ2 is the boundary of A. τ3 belongs to a diﬀerent homology class since such an area does not exist between τ3 and any of the other two trajectories.

Figure 3.2: Illustration of homotopy and homology equivalences. In this example τ1 and τ2 are both homotopic as well as homologous.
vg

A1

τ1

S1

A2

τ1

vs

τ2

(a) In 2-dimensions

S2 τ2
(b) In 3-dimensions

Figure 3.3: Examples where the trajectories are homologous, but not homotopic
The converse of Lemma 3.2.3, however, does not always hold true. There are subtle diﬀerence between homology and homotopy in spite of their similar notions, and one can create examples where two trajectories are not homotopic in spite of being homologous.
Homotopy equivalence arises naturally in many robotics problems. On the other hand, homology is less natural. However it is much simpler to compute homologies. One can establish direct correspondence between homology groups of trajectories and diﬀerential 1-forms whose integrals yield homology class invariants for trajectories via the De Rham theorem [8]. Since, according to the discussion of Section 3.1.2 we desire such diﬀerential forms, the rest of the paper will be developed with homology classes of trajectories under consideration rather than their homotopy classes. The assumption will be that in many of the practical robotics problems where homotopy classes of trajectories are of greater signiﬁcance, homology classes of trajectories will serve as a fair analog. We will justify this claim in Section 3.5.1 and through experimental results (Section 3.6).
42

To clarify the distinction between homotopy equivalence and homology equivalence of trajectories, we present two examples where homology is not same as homotopy. The ﬁrst example is in 2-dimensions. In Figure 3.3(a) we observe that the trajectories τ1 and τ2 are not homotopic, but they are homologous (since their H-signatures, as deﬁned in Section 3.3.2, are equal). This is seen perhaps more easily by considering the interior deﬁned by the union of the areas marked by A1 and A2 which indeed forms the boundary for τ1 −τ2. In Figure 3.3(b), one can observe that the two trajectories are not homotopic. However, they are homotopic if we only consider S1 or S2 but not both. Hence their H -signatures are the same (i.e. they are homologous). Thus, if we were exploring diﬀerent homotopy classes in this environment using the described method, we would be ﬁnding one trajectory for these two homotopy classes.

3.3 H-signature in 2-dimensional Euclidean Conﬁguration Space
We consider a 2-dimensional subset of R2 as the conﬁguration space. The obstacles are thus punctures or discontinuities in that subset. The approach for designing a H-signature for such a 2-dimensional conﬁguration space is based on theorems from Complex Analysis, speciﬁcally the Cauchy Integral theorem and Residue theorem.

3.3.1 Background: Complex Analysis
Cauchy Integral Theorem
The Cauchy Integral Theorem states that if f : C → C is an holomorphic (analytic) function in some simply connected region R ⊂ C, and γ is a closed oriented (i.e. directed) contour completely contained in R, then the following holds,

f (z) dz = 0
γ

(3.3.1)

Moreover, if z0 is a point inside the region enclosed by γ, which has an anti-clockwise (or positive) orientation, then for the function F (z) = f (z)/(z − z0) with a simple pole at z0, the following holds

f (z) dz γ z − z0 = 2πif (z0)

(3.3.2)

The Residue Theorem
A direct consequence of the Cauchy Integral Theorem, the Residue Theorem, states that, if F : R → C is a function deﬁned in some simply connected region R ⊂ C that has simple poles at the distinct points a1, a2, · · · , aM ∈ R, and holomorphic (analytic) everywhere else in R, and say γ is a closed positively oriented Jordan curve completely contained in R and enclosing only the points

43

R

z1

z0

γ1

γ2 z2

R

ap

ak1

ar ak2

ak3

γ aq

(a) The integrals over contours γ1 (b) Only the poles enclosed by γ inﬂu-

and γ2 are equal

ence the value of the integral of F .

Figure 3.4: Cauchy Integral Theorem and Residue Theorem

ak1 , ak1 , · · · , akm out of the poles of F , then the following holds,

m

γ

F

(z)

dz

=

2πi

l=1

lim (ξ
ξ→akl

−

akl )F (ξ)

(3.3.3)

The scenario is illustrated in Figure 3.4(b). It is important to note that in both the Cauchy Integral Theorem and the Residue Theorem the
value of the integrals are independent of the exact choice of the contour γ as long as the mentioned conditions are satisﬁed (see Figure 3.4(a)).

At this point it is worth mentioning that the Cauchy Integral Theorem and the Residue Theorem are simply particular manifestations of a more general formulation in which one can compute linking numbers between manifolds embedded in Euclidean spaces of arbitrary dimensions. We will in fact discuss this general formulation in Chapter 4, and hence derive the aforesaid theorems as special cases of that formulation.

3.3.2 Designing a H-signature
We exploit the above theorems for designing a diﬀerential 1-form that can be used to construct a homology class invariant for 2-dimensional conﬁguration space.
We start by representing the 2-dimensional conﬁguration space as a subset of the complex plane C. Thus a point in the conﬁguration space, (x, y) ∈ C, is represented as x + iy ∈ C. The obstacles are assumed to be simply-connected regions in C and are represented by O1, O2, · · · , ON .
Deﬁnition 3.3.1 (Representative points). We deﬁne one “representative point” in each connected obstacle such that it lies in the interior of the obstacle. The exact location of the representative points is not of particular signiﬁcance as long as they each lie inside the respective obstacles. Thus we deﬁne the points ζl ∈ Ol, ∀l = 1, · · · , N . Figure 3.5(a) shows such representative points inside three obstacles.
As we will see in results presented in Section 3.6.1, it is not necessary that we choose representative points for all obstacles. We need to choose such points only on the larger and relevant
44

obstacles that contribute towards the practical notion of homotopy classes. In practical scenarios, for example when constructed from sensors on-board a robot, environments often contain small obstacles and noise. It’s important that we choose the ζl carefully only inside relevant (large) obstacles which inﬂuence our notion of homotopy class of the trajectories. This can be achieved by putting a threshold on the minimum diameter of the obstacles on which we put the representative points. Smaller obstacles can be disregarded.

Deﬁnition 3.3.2 (Obstacle Marker Function). For a given set of “representative points”, we deﬁne the “Obstacle Marker Function” function F : C → CN as follows,

 f1(z) 

z−ζ1

 f2(z) 

 F(z) = 
 

z−ζ2
...

   





fN (z)

z−ζN

(3.3.4)

where fl, l = 1, 2, · · · , N are analytic functions over entire C such that fl(ζl) = 0, ∀l. Typical examples of such fl are polynomials in z.
Thus, F is a complex vector function, the lth component of which has a single simple pole/singularity at ζl.
Deﬁnition 3.3.3 (H-signature in 2-dimensional conﬁguration space). For the given conﬁguration space and set of obstacles, we deﬁne the obstacle marker function as described above, and hence deﬁne the H-signature of a trajectory τ the vector function H2 : C1(C) → CN

H2(τ ) = F (z) dz
τ
where C1(C) is the set of all curves/trajectories in C.
Lemma 3.3.4. Two trajectories τ1 and τ2 connecting the same points in the described 2-dimensional conﬁguration space are homologous if and only if H2(τ1) = H2(τ2)
Sketch of Proof. We note that by changing the orientation of a path over which an integration is being performed, we change the sign of the integral. If τ is a path, its oppositely oriented path is represented as −τ . Thus, as we see from Figure 3.5(a), τ1 along with −τ2 forms a positively oriented closed loop.
If τ1 and τ2 are in the same homology class, the area enclosed by τ1 and τ2 does not contain any of the “representative points”, ζi, hence rendering the function F analytic in that region. Hence from the Cauchy Integral Theorem we obtain,

F(z) dz = 0
τ1 −τ2

⇒ F(z) dz + F(z) dz = 0

τ1

−τ2

⇒ F(z) dz − F(z) dz = 0

τ1

τ2

⇒ F(z) dz = F(z) dz

τ1

τ2

45

G
ζ1 -τ2
ζ3

τ2

S

τ1

ζ2

G

ζb ζa
ζκ1
τ2

ζc

ζκ2 τ1

S

(a) In same Homotopy class, forming a (b) In diﬀerent Homotopy classes, enclos-

closed contour

ing obstacles

Figure 3.5: Two trajectories in same and diﬀerent homotopy classes

where the 0 in bold implies that it is a N -vetor of zeros. If τ1 and τ2 are in diﬀerent homology classes, we can easily note that the closed positive contour
formed by τ1 and −τ2 will enclose one or more of the obstacles, and hence their corresponding “representative points”. This is illustrated in Figure 3.5(b). Let us assume that enclosed “representative points” are ζκ1 , ζκ2 , · · · , ζκn . Moreover we note that at least one component of the vector function F has a simple pole at ζl for each l = 1, 2, · · · , N . Thus, by the Residue Theorem and Deﬁnition 3.3.2,

F(z) dz +

F(z) dz =

τ1
2πi

−τ2

  f1(ξ)

ξ−ζ1

f2 (ξ)

n u=1

limξ→ζκu

(ξ

−

ζκu

)

 



ξ−ζ2
...

  

fN (ξ) ξ−ζN
 ··· 

 fκ1 (ζκ1 ) 

 

...

 

⇒

F(z)dz −

F (z)dz

=

 

fκ2 (ζκ2 )

 

=

0

τ1

τ2

  

...

  

 fκn (ζκn ) 
···

Hence proved.

We have hence shown that H2 gives a homology invariant for trajectories in 2-dimensional Euclidean conﬁguration space with obstacles.

3.3.3 Computation for a Line Segment
As discussed earlier in Section 3.1.2, and will be discussed later in Section 3.5, we discretized the given conﬁguration space and create a graph out of it. In many practical implementations we assume
46

that every edge in the graph is a line segment. Thus it is for those line segments that we really need to compute the H-signatures. Thus it is important that we are able to do so eﬃciently. In this section we will show how to compute the H-signature for a small line segment in a 2-dimensional conﬁguration space using a closed-form formula.
Given a line segment e connecting points z1 and z2, we can parametrize the segment using the variable z = (1 − λ)z1 + λz2, where λ ∈ [0, 1] is the parameter. Thus we have,

H2(e) = =

F(z) dz
e 1
F (1 − λ)z1 + λz2
0

(z2 − z1) dλ

(3.3.5)

For computing the H-signature of e = {z1 → z2} analytically, we assume that fl are chosen to be constants. Let fl = Al (const.) for all l = 1, 2, · · · , N .
Now, a standard integration result gives for the lth component of H2(e)

1 0

Al (1 − λ)z1 + λz2 − ζl

(z2 − z1)

dλ

= Al (ln(z2 − ζi) − ln(z1 − ζl))

However we note that the logarithm of a complex number does not have an unique value. For any z ∈ C, ln(z ) = ln(|z |ei(arg(z )+2kπ)) = ln(|z |) + i (arg(z ) + 2kπ) , ∀k = 0, ±1, ±2, . . . (where arg(x + iy) = atan2(y, x)). Hence, following the assumption that e is a small line segment, we choose the smallest of all the possible values over diﬀerent k’s. Thus, the lth component of H2(e) is computed as,
Al ln(|z2 − ζl|) − ln(|z1 − ζl|) +
i absmink∈Z arg(z2 − ζl) − arg(z1 − ζl) + 2kπ
where absmink∈ZG(k) returns the value of G(k) that has the minimum absolute value (i.e. closest to 0) over all k ∈ Z. Typically, we can do away with checking a few values of k around 0 and picking the local minimum, since the value of arg(z2 − ζl) − arg(z1 − ζl) + 2kπ is monotonic in k.

3.4 H-signature in 3-dimensional Euclidean Conﬁguration Space
While in the two-dimensional case, theoretically any ﬁnite obstacle on the plane can induce multiple homotopy and homology classes for trajectories joining two points, the notion of homotopy/homology classes in three dimensions can only be induced by obstacles with genus 1 one or more, or with obstacles stretching to inﬁnity. For example, a torus-shaped obstacle in a threedimensional environment creates two primary homotopy classes, which can be informally described as: i. The trajectories passing through the “hole” of the torus, and ii. the trajectories passing
1The genus of an obstacle refers to the number of handles [63]).
47

S
γ1
dl

γ2

I= 1

x

B

dx

r

Sp
k1 pA
k2

pB -k2
Sq

(a) Magnetic ﬁeld due to current in S, & its integration along closed loop γi.

(b) 2 trajectories, τ1 & τ2, connecting the same points form a closed loop.

Figure 3.6: Application of Biot-Savart law and Ampere’s law to robot path planning with topological constraints in 3-D.

outside the “hole” of the torus. Figure 3.7 shows some examples of obstacles that can or cannot induce such classes for trajectories. A sphere or a solid cube, for example, cannot induce multiple homotopy classes in an environment.

3.4.1 Background: Electromagnetism

Biot-Savart Law

Consider a single hypothetical current-carrying curve (a current conducting wire) embedded in a 3-dimensional space carrying a steady current of unit magnitude (Figure 3.6(a)). There is no source for the current nor any sink - only a steady ﬂow persisting inside the conductor due to absence of any dissipation. It is to be noted that such a steady current is possible iﬀ the curve is closed (or open, but extending to inﬁnity, where we close the curve using a loop at inﬁnity. See Figure 3.8(a) and Construction 3.4.3). We denote the curve by S. Then, according to the Biot-Savart Law [36], the magnetic ﬁeld B at any arbitrary point r in the space, due to the current ﬂow in S, is given by,

B(r) = µ0 4π

(x − r) × dx S x−r 3

(3.4.1)

where, x, the integration variable, represents the coordinate of a point on S, and dx is an inﬁnites-

imal element on S along the direction of the current ﬂow.

Ampere’s Law
While Biot-Savart law gives a recipe for computing the magnetic ﬁeld from a given current conﬁguration, Ampere’s Law [36], in a sense, gives the inverse of it. Given the magnetic ﬁeld B at every point in the space, and a closed loop γ (Figure 3.6(a)), the line integral of B along γ gives the

48

(a) Skeleton of a generic genus (b) A torus-shaped genus 1 1 obstacle is modeled as a obstacle. current-carrying conductor.

(c) A genus 2 obstacle.

(d) An inﬁnite tube is a (e) A knot-shaped obstacle (f) A sphere does not in-

genus 1 obstacle.

with genus 1.

duce homotopy classes and

has genus 0.

Figure 3.7: Examples of obstacles in 3-D. (a-e) induce homotopy classes, (f) does not.

current enclosed by the loop γ. That is,

Ξ(C) := B(l) · dl = µ0Iencl
γ

(3.4.2)

where, l, the integration variable, represents the coordinate of a point on γ, and dl is an inﬁnitesimal element on C.
In Biot-Savart Law and Ampere’s Law one can conveniently choose the constant µ0 to be equal to 1 by proper choice of units. Moreover, by choice, the value of the current ﬂowing in the conductor is unity. Thus, for any closed loop γ, the value of Ξ(γ) is zero iﬀ γ does not enclose the conductor, otherwise it is ±1 (the sign depends on the direction of integration performed on γ). Thus in Figure 3.6(a), Ξ(γ1) = 1 and Ξ(γ2) = 0.
Once again, we would like to emphasize that the above mentioned laws, though appearing naturally in physical systems, are simply special cases of a general formulation in algebraic topology that we will discuss in Chapter 4. We will also explicitly derive these laws from that general formulation.

Deﬁnition 3.4.1 (Simple Homotopy-Inducing Obstacle in 3-dimensional Conﬁguration Space). A Simple Homotopy-inducing Obstacle (SHIO) is a bounded obstacle of genus 1, for example a torus (Figure 3.7(a), 3.7(b)) or a knot (Figure 3.7(e)).

49

O

O2 O1

(a) An unbounded obstacle and its skele- (b) An obstacle with genus 2, O, can be de-

ton can be closed at a large distance to composed into 2 obstacles, each with genus

create a closed loop.

one, O1 and O2.

Figure 3.8: Illustration of Constructions 3.4.3 and 3.4.4.
3.4.2 Designing a H-signature
For the 2-dimensional case, each obstacle on the plane that induces the notion of multiple homotopy classes was assigned a representative point. Analogously, for the 3-dimensional case, we need to deﬁne a skeleton for every SHIO. Intuitively, a skeleton of a 3-dimensional obstacle is a 1-dimensional curve that is completely contained inside the obstacle such that the surface of the obstacle can be “shrunk” onto the skeleton in a continuous fashion without altering the topology of the surface of the obstacle. Formally, we deﬁne the skeleton of an obstacle in terms of deformation retract [40].
Deﬁnition 3.4.2 (Skeleton). A 1-dimensional manifold, S, is called a skeleton of a SHIO, O, iﬀ S is homeomorphic to S1 (a circle), S is completely contained inside O, and if S is a deformation retract (Deﬁnition 2.1.5) of O.
Thus, the fact that τ1 and τ2 are of the same or of diﬀerent homotopy/homology classes is not altered by replacing O by S.
In the literature, algorithms for constructing skeletons of solid objects is a well-studied [6, 46]. However in the present context we have a much relaxed notion of skeleton. While we can adopt any of the diﬀerent existing algorithms for automated construction of skeleton from a 3-dimensional obstacles, this discussion is out of the scope of the present work. Figure 3.7(a) demonstrates skeletons for several genus 1 obstacles.
Conversion of Generic Obstacles into SHIOs
Given a set of obstacles in a three-dimensional environment, we perform the following two constructions/reduction on the obstacles so that the only kind of obstacle we have in the environment are Simple Homotopy-Inducing Obstacles. The Construction 3.4.3 is mostly trivial in the sense that it can be easily automated for arbitrary obstacles. Construction 3.4.4 on the other hand is linked with the construction of skeleton of the obstacles (Deﬁnition 3.4.2).

50

Construction 3.4.3. Closing inﬁnite, unbounded obstacles In most of the problems that we are concerned with, the domain in which the trajectories of the robots lie is ﬁnite and bounded. This gives us the freedom of altering/modifying the obstacles or parts of obstacles lying outside that domain without altering the problem. One consequence of this freedom is that we can close inﬁnite and unbounded obstacles (e.g. Figure 3.7(d)) at a large distance from the domain of interest (Figure 3.8(a)).
Construction 3.4.4. Decomposing obstacles with genus > 1 After closing all inﬁnite, unbounded obstacles in an environment according to Construction 3.4.3, if there is an obstacle with genus k (e.g. Figure 3.7(c)), we can decomposed/split it into k obstacles, possibly overlapping and touching each other, but each with genus 1 (Figure 3.8(b)). This does not change the obstacles or the problem in any way. This construction just changes the way we identify obstacles and construct their skeletons. For example in Figure 3.8(b) the original obstacle O with genus 2 is realized as two obstacles O1 and O2, each with genus 1 and overlapping each other. The decomposition of obstacles into SHIOs allows us deﬁne k skeletons for each obstacle of genus k and simplify computations of h-signatures of trajectories.
Note that neither of these constructions eﬀect the original problem or the result. In the results presented in this thesis we do both constructions manually.

Skeleton of SHIOs as Current Carrying Curves for H-signature Construction
Construction 3.4.5. Modeling skeleton of a SHIO as a current carrying manifold Given m obstacles in an environment, O1, O2, . . . , Om, with genus k1, k2, . . . , km respectively, we can construct M = k1 + k2 + · · · + km skeletons from M SHIOs (obtained using Constructions 3.4.3 and 3.4.4), namely S1, S2, . . . , SM . Each Si is a closed, connected, boundary-less 1-dimensional manifold. We model each of them as a current-carrying conductor carrying current of unit magnitude (Figures 3.7(a), 3.8(a)). The direction of the currents is not of importance, but by convention, each is of unit magnitude.

Deﬁnition 3.4.6 (Virtual Magnetic Field due to a Skeleton). Given Si, the skeletons of a Simple Homotopy-Inducing Obstacle, we deﬁne a Virtual Magnetic Field vector at a point r in the space due to the current in Si using Biot-Savart Law as follows,

1 (x − r) × dx

Bi(r) = 4π Si

x−r 3

(3.4.3)

where, x, the integration variable, represents the coordinates of a point on Si, and dx is an inﬁnitesimal element on Si along the chosen direction of the current ﬂow in Si.

Deﬁnition 3.4.7 (H-signature in 3-dimensional Conﬁguration Space). Given an arbitrary trajectory, τ , in the 3-dimensional environment with M skeletons, we deﬁne the H-signature of τ to be the function H3 : C1(R3) → RM ,

H3(τ ) = [h1(τ ), h2(τ ), . . . , hM (τ )]T

(3.4.4)

51

where, C1(R3) is the space of all curves/trajectories in R3, and

hi(τ ) = Bi(l) · dl
τ

(3.4.5)

is deﬁned in an analogous manner as the integral in Ampere’s Law. In deﬁning hi, Bi is the Virtual Magnetic Field vector due to the unit current through skeleton Si, l is the integration variable that represents the coordinate of a point on τ , and dl is an inﬁnitesimal element on τ .

Lemma 3.4.8. Two trajectories τ1 and τ2 connecting the same points in the described 3-dimensional conﬁguration space are homologous if and only if H3(τ1) = H3(τ2).
Sketch of Proof. Since τ1 and τ2 connect the same points, τ1 −τ2, i.e. τ1 and −τ2 together (where −τ indicates the same curve as τ , but with the opposite orientation) form a closed loop in the 3-dimensional environment (Figure 3.6(b)). We replace the obstacles O1, O2, . . . , Om in the environments with the skeletons S1, S2, . . . , SM .
Consider the presence of just the skeleton Si. By the direct consequence of Ampere’s Law and our construction in which a unit current ﬂows through Si, the value of

hi(τ1 −τ2) =

Bi(l) · dl

τ1 −τ2

is non-zero if and only if the closed loop formed by τ1 −τ2 encloses the current carrying conductor Si (i.e. there does not exist a surface not intersecting Si, the boundary of which is τ1 −τ2). For example, in Figure 3.6(b), hp(τ1 −τ2) = 1 and hq(τ1 −τ2) = 0. Now, by the deﬁnition of line integration we have the following identity,

hi(τ1 −τ2) = τ1 −τ2Bi(l) · dl = τ1 Bi(l) · dl − τ2 Bi(l) · dl = hi(τ1) − hi(τ2)

(3.4.6)

Thus, hi(τ1) = hi(τ2) if and only if the closed loop formed by τ1 and τ2 does not enclose Si (i.e. homologous in presence of Si).
Now in presence of skeletons S1, S2, . . . , SM the same argument extends for each skeleton individually. Thus τ1 and τ2 are homologous if an only if H3(τ1) = H3(τ2).

Hence we have shown that the proposed formula for H-signature is a homology class invariant for trajectories in 3-D.

3.4.3 Computation for a Line Segment

Once again, we are interested in eﬃcient computation of the H-signature for small line segments

since those are the ones that will make up edges of the graph formed by discretization of the

environment. For all practical applications we up of ﬁnite number (ni) of line segments: Si =

assume that −−→ −−→ {s1i s2i , s2i s3i ,

a .

.s.k,el−seni−ti−o−n−1−so→nifi ,an−s−nio−ib→ss1it}ac(Flei,gSuri,e

is made 3.9(a)).

52

s j
s2 s j+1 Bi
s1 sn
(a) A skeleton of an obstacle can be constructed/approximated so that it is made up of n line segments.

d g'

sj

p

g
r

p' n
sj'
(b) Magnetic ﬁeld at r due to the current in a line segment sji sji .

Figure 3.9: Closed-form computation of magnetic ﬁeld.

Thus, the integration of equation (3.4.3) can be split into summation of ni integrations,

1 ni Bi(r) = 4π
j=1

−−−→ sji sji

(x − r) × dx x−r 3

(3.4.7)

where j ≡ 1 + (j mod ni). It is to be notes that a skeleton of an unbounded obstacle created
from Construction 3.4.3 can be made up of ﬁnite and few line segments. The only feature of such a skeleton might be that some of the points that make up the line segments (sji ) might be located at a large distance from the domain of interest, which is used to close the skeleton.
−−−→
One advantage of this representation of skeletons is that for the straight line segments, sji sji , the integration can be computed analytically. Speciﬁcally, using a result from [36] (also, see Fig-
ure 3.9(b)),

(x − r) × dx

−−−→

x−r 3

=

sji sji

=

1 (sin(α ) − sin(α)) nˆ
d

1 d×p d×p

d2

−

p

p

(3.4.8)

where, d, p and p are functions of sji , sji and r (Figure 3.9(b)), and can be expressed as,

p = sji −r,

p = sji −r,

d = (sji

−sji ) × (p×p sji −sji 2

)

(3.4.9)

We deﬁne and write Φ(sji , sji , r) for the RHS of Equation (3.4.8) for notational convenience. Thus

we have,

1 ni Bi(r) = 4π

Φ(sji , sji , r)

j=1

(3.4.10)

where, j ≡ 1 + (j mod ni).

53

τ

Figure 3.10: A trajectory in the original conﬁguration space is represented by a path in the discrete graph.

Given a small line segment, e, we can now compute the H -signature, H(e) = [h1(e), h2(e), . . . , hM (e)]T , where,

1 hi(e) = 4π

ni
Φ(sji , sji , l) · dl
e j=1

(3.4.11)

can be computed numerically. For the numerical integration, in all our experimental results we used the GSL (GNU Scientiﬁc Library), which has a highly eﬃcient implementation of adaptive integration algorithms with desired precision. We used a cache for storing the H-signature of edges that has been computed in order to avoid re-computation.

3.5 H-signature Augmented Graph
Once we have the means of computing H -signature for each edge (small line segments), we introduce the concept of H-signature augmented graph. Typically, a graph, G = {V, E}, is created for the purpose of graph-search based planning by discretization of an environment, placing a vertex at each discretized cell, and by connecting the neighboring cells with edges (See Figure 1.4(a) for an example in 2-dimensional conﬁguration space). Paths in such a graph represent trajectories in the original conﬁguration space (Figure 3.10). However, it should be kept in mind that this representation is approximate, and any arbitrary trajectory in the continuous conﬁguration space will not be faithfully represented at scales smaller than the discretization size.
In the following discussion we perform a construction using G, without distinguishing between 2 and 3-dimensional conﬁguration spaces explicitly, once we have discretized the environment, and perform a general treatment with the graph G. For H-signature trajectories or line segments we use the generic function H, which we understand to be H2 or H3 depending on the dimensionality of the conﬁguration space.
Let vs be the start coordinate in the conﬁguration space, and vg be the goal coordinate (by the boldface v’s, with a slight abuse of notation, we will indicate both the vertex in the graph as well as the coordinate of the vertex in the original conﬁguration space). By Lemma 3.3.4 or 3.4.8, any two trajectories from vs to v that belong to the same homology class will have the same
54

H -signature. The H -signature can assume diﬀerent, but discrete values corresponding on the class of the trajectory. We also write P(vs, v) to denote the set of all trajectories from vs to v, and vsv ∈ P(vs, v) to denote a particular trajectory in that set.
Deﬁnition 3.5.1 (Allowed and Blocked Homology Classes). Suppose it is required that we restrict all our search for trajectories connecting vs and vg to certain homology classes, or not allow some other. We denote the set of allowed H -signatures of trajectories leading up to vg by the set A, and the set of blocked H -signatures as B. A and B are essentially complement of each other (A ∪ B = U, where the universal set, U, is the set of the H -signatures of all the classes of trajectories joining vs and vg), and B can be an empty set when all classes are allowed.
Following the discussion in Appendix A, for the 3-dimensional conﬁguration space it is also possible to restrict search to non-looping trajectories by putting all h-signatures that have at least one element outside (−1, 1) into the set B.
We deﬁne the H-signature augmented graph of G as the graph GH (G) = {VH , EH }, such that each node in this new graph has the H -signature of a trajectory leading up to the coordinate of the node from vs appended to it. That is, each node in this augmented graph is given by {v, H(vsv)}, for some vsv ∈ P(vs, v). Thus, corresponding to a given v ∈ V, since there are discrete homology classes of trajectories from vs to v, there are a discrete number of the augmented states, {v, h} ∈ VH , where h is a M -vector (M being the number of representative points or the number of SHIOs depending on whether it’s a 2 or 3-dimensional conﬁguration space) and assumes the values of the H -signatures corresponding to the discrete homology classes. Thus, we deﬁne the H-signature augmented graph of G as follows,

GH = {VH , EH }

where, 1.


      
VH = {v, h}
      



v ∈ V, and,







h

=

H(vsv)

for

some

trajectory

  



vsv ∈ P(vs, v), and,



h ∈ A (equivalently, h ∈/ B)

 





when v = vg

 

2. An edge {{v, h} → {v , h }} is in EH for {v, h} ∈ VH and {v , h } ∈ VH , iﬀ

i. The edge {v → v } ∈ E, and, ii. h = h + H(v → v ), where, H(v → v ) is the H-signature of the edge {v → v } ∈ E.

3. The cost/weight associated with an edge {{v, h} → {v , h }} is same as that associated with edge {v → v } ∈ E.

The consequence of point 3 in the above deﬁnition is that an admissible heuristics for search in G will remain admissible in GH . That is, if f (v, vg) was the heuristic function in G, we deﬁne fH ({v, h}, {vg, h }) = f (v, vg) as the heuristic function in GH for any h ∈ A.
The consequence of augmenting each node of G with a H -signature is that now nodes are distinguished not only by their coordinates, but also the H -signature of the trajectory followed
55

τ1

{vs , 0}

{vg , h'g}

vg

vs

G

τ2

{vg , hg}
GH

Figure 3.11: The topology of the augmented graph, GH (right), compared against G (left), for a cylindrically discretized 2-dimensional conﬁguration space around a circular obstacle

to reach it. Typically we use graph search algorithms like A* (or variants like D* or D*-lite) where nodes in the graph GH are expanded starting from the node {vs, 0} (where by 0 we mean a M -dimensional vector of zeros).
The topology of this augmented graph for a 2-dimensional case is illustrated in Figure 3.11. A goal state vg is the same in G irrespective for the path (τ1 or τ2) taken to reach it. Whereas in the H-signature augmented graph, the states are diﬀerentiated by the additional value of hg. We can perform a graph search in the augmented graph, GH , using any standard graph search algorithm starting from the state {vs, 0}. The goal state (i.e. the state, upon expansion of which we stop the graph search) is potentially any of the states {vg, hg} for any hg ∈ A (or hg ∈/ B if B is provided instead of A). We can use the same heuristic that we would have used for searching in G, i.e. fH (v, h) = f (v). It is to be noted that GH is essentially an inﬁnite graph, even if G is ﬁnite. However the search algorithm needs to expand only a ﬁnite number of states. Since for a given v, the states {v, h} can assume some discrete values of h (corresponding to the diﬀerent homology classes). To determine if {v, hg} and {v, hg} are the same states, we can simply compare the values of hg and hg.
3.5.1 Uses of the H-signature Augmented Graph
There are primarily two distinct but related ways we would like to use the H-signature augmented graph with search algorithms:
i. Exploration of environment for diﬀerent homotopy classes of trajectories connecting vs and vg: For this problem, whenever we expand a state {vg, h˜} ∈ VH , for some h˜ ∈/ B, we store the path up to that node, and continue expanding more states until the desired number of classes are explored. Although H-signature is a homology class invariant, and not a homotopy class invariant, by Lemma 3.2.3, two trajectories are homotopic implies that they are homologous. Thus, two trajectories that are homotopic will be in the same homology class, and hence their H-signatures will be the same. Thus, in such problems where we ﬁnd least cost trajectories with diﬀerent H-signatures in a conﬁguration space using the said method, we are always
56

guaranteed to obtain trajectories in distinct homotopy classes as well.
ii. Planning with H-signature constraint: For searches with H-signature constraint, we stop upon expansion of a goal coordinate {vg, h˜} for some h˜ ∈/ B (or equivalently, h˜ ∈ A).
3.5.2 Theoretical Analysis
Theorem 3.5.2. If P∗H = {{v1, h1}, {v2, h2}, · · · , {vp, hp}} is an optimal path in GH , then the path P∗ = {v1, v2, · · · , vp} is an optimal path in the graph G satisfying the H-signature constraints speciﬁed by A and B
Proof. By construction of GH , the path {v1, v2, · · · , vp} satisﬁes the given H -signature constraints. Moreover by deﬁnition, P∗H is a minimum cost path in GH . Since the cost function in GH is the same as the one in G and does not involve hj, it follows that the projection of P∗H on G given by P∗ = {v1, v2, · · · , vp} is an optimal path in the graph G satisfying the constraints deﬁned in GH .
3.6 Results
The method described in this paper was implemented in C++ and MATLAB. In the sections below we present results in 2 and 3-dimensional conﬁguration spaces.
3.6.1 Two-dimensional Conﬁguration Space
Path Prediction by Homotopy Class Exploration Figure 3.12(a) shows a large 1000 × 1000 discretized environment with circular and rectangular obstacles. We explore trajectories in diﬀerent classes in order of their path costs using the method ‘i.’ described in Section 3.5.1. The implementation was done in C++ running on an Intel Core 2 Duo processor with 2.1 GHz clock-speed and 4GB RAM. All the diﬀerent trajectories in diﬀerent homotopy classes were determined in a single run of graph search on GH as described earlier. Figure 3.13 shows similar exploration of multiple homotopy classes in a smaller environment.
As discussed earlier, in such exploration problems, although we use the H-signature as the class invariants in the search algorithms, since non-homologous trajectories are guaranteed to be non-homotopic, we are guaranteed to obtain trajectories in diﬀerent homotopy classes.
We also constructed 10 such environments using random circular and rectangular obstacles. Table 3.1 demonstrate the eﬃciency of the searches. The time indicates the cumulative time during the search until a shortest-path trajectory in a particular homotopy class is found. This is relevant to problems of tracking dynamic entities, such as people, where one often needs to predict possible paths in order to bias the tracker or to deal with occlusion by anticipating where the dynamic entity will appear. Since people can choose diﬀerent paths to their destinations, we need to be able to predict least cost paths that lie in diﬀerent homotopy classes.
57

1000

60

900

run time (s)

800

50

states expanded (105)

700 40
600

500

30

400
20 300

200 1234567890123456789 10
100

0 0

0 100 200 300 400 500 600 700 800 900 1000

2

4

6

8

10 12 14 16 18

Homotopy Class (in order of least cost path)

(a) Paths in 20 diﬀerent homotopy classes (b) Run-time & states expanded for ﬁnding the least-cost paths in a particular run

Figure 3.12: Exploring homotopy classes in 1000 × 1000 discretized environments to ﬁnd least cost paths in each

Hmtp. class (i)
1 2 3 4 5 6 7 8 9 10

time ellapsed until ith hmtp. class explored (s) min max mean 1.41 2.01 1.71 3.58 8.58 5.15 5.09 9.69 6.77 6.13 12.46 8.92 7.80 17.74 11.50 10.53 18.56 13.05 10.92 19.74 15.38 13.35 20.32 17.01 15.08 21.76 18.60 15.53 26.28 20.87

states expanded cumulative (106) min max mean 0.021 0.039 0.032 0.099 0.313 0.170 0.180 0.375 0.244 0.237 0.494 0.345 0.285 0.776 0.472 0.422 0.825 0.555 0.473 0.888 0.681 0.604 0.935 0.773 0.693 1.027 0.858 0.720 1.252 0.978

Table 3.1: Statistics of searching least-cost paths in ﬁrst 10 homotopy classes in 10 randomly generated environments. The numbers represent the cumulative values till the ith homotopy class
is explored.

50

zg

45

40

35

30

25

20

15

10

5

0 zs

0

10

20

30

40

50

(a)

50

zg

45

40

35

30

25

20

15

10

5

0 zs

0

10

20

30

40

50

(b)

50

zg

45

40

35

30

25

20

15

10

5

0 zs

0

10

20

30

40

50

(c)

Figure 3.13: Exploring homotopy classes by blocking the class obtained from previous search. The blue shaded region shows the projection of the nodes expanded in GH on to G.
58

50

zg

50

zg

45

45

40

40

35

35 30
30 25
25 20
20
15 15
10 10

5

0 zs

0

10

20

30

40

50

5

0 zs

0

10

20

30

40

50

(a) Suboptimal key-point generated (b) Optimal trajectory in same class

trajectory.

as key-point generated trajectory.

Figure 3.14: Homotopy class constraint determined using suboptimal key-point generated trajectory.

H-signature Constraint: H-signature Deﬁned by Key-points
Figure 3.14(a) demonstrates an example where we deﬁne homology classes using a sample (suboptimal) trajectory speciﬁed by key-points. One can then compute the H-signature for such a trajectory. It can then be used to search GH for an optimal path in the same class (or diﬀerent) as the sample trajectory (Figure 3.14(b)).
Although technically we have imposed homology class constraint by imposing the H-signature constraint, we observe that the optimal trajectory that we obtain is in fact in the same homotopy class as the key-point generated trajectory. In fact we observe that in most robotics planning problems imposing H-signature constraints indeed impose the corresponding homotopy class constraint as well.
Multiple Robot Visibility Problem
The problem of path planning for multiple robots with visibility constraints can also make use of our approach. If one robot needs to plan its path such that it is never obstructed from the view of another robot by some obstacle, we can apply the technique of planning with H-signature constraint to obtain the desired trajectories. In Figure 3.15(a)-(c) two robots plan trajectories to their respective goals. The robot on the right needs to plan a trajectory such that it is in the “visibility” of the robot on the left, whose trajectory is given. Thus, in order to determine the H-signature of the desired homotology class it ﬁrst constructs a suboptimal path by connecting its own start and goal points to the start and goal of the left robot, such that the trajectory of the left robot is completely contained in it (Figure 3.15(b))) as key points. The H-signature of this path gives the desired homology class, thus re-planning with that class as the only allowed class gives the desired optimal plan (Figure 3.15(c)).
The natural constraint in this situation is that of homotopy. But we once again observe that even imposing the H-signature constraint we do obtain trajectory in the desired homotopy class.

59

100

z1g

z2g

100

z1g

z2g

100

z1g

z2g

90

90

90

80

80

80

70

70

70

60

60

60

50

50

50

40

40

40

30

30

30

20

z1s

z2s

10

20

z1s

z2s

10

20

z1s

z2s

10

0

0

20

40

60

80

0

0

20

40

60

80

0

0

20

40

60

80

(a) Unconstrained plans of two robots.

(b) Suboptimal path constructed for robot on the right – used to determine Hsignature of desired homology class.

(c) Optimal plan with visibility constraint satisﬁed.

Figure 3.15: 100 × 100 discretized environment with 2 representative points on the central large connected walls.

100 90 80 70 60 50 40 30 20 10 0 0

1

20

40

60

80

100

(a) w = 0.0, B = {}

100 90 80 70 60 50 40 30 20 10 0 0

100

90

80

70

60

50

40

30

20

10

1

0

20

40

60

80

100

0

1

20

40

60

80

100

(b) w = 0.01, B = {} (c) w = 0.0, B = {h0}

100

90 80 70 60 50

40

30

20

10

1

0

0

20

40

60

80

100

(d) w = 0.01, B = {h0}

Figure 3.16: Planning with non-Euclidean length as cost as well as homotopy class constraint

Arbitrary Cost Functions
Our method is not limited to Euclidean length cost functions. It can deal with arbitrary cost functions. For example, in Figure 3.16 there are two large obstacles and a communication base to the left of the environment marked by the bold dotted line, x = 0. An agent is supposed to plan its path from the bottom to the top of the environment, while minimizing a weighted sum of the length of the trajectory and the distance of the trajectory from the communication base. Thus, in this case, besides the transition costs of the states in G, each state, z = x + iy ∈ G, is assigned a cost w · x, the penalty on separation from the communication base. Thus the net penalized cost of the trajectory, τ , that is being minimized is of the form c = τ ds + w τ x(s)ds, where x is the x-coordinate of the points on the trajectory, parametrized by s, the length of the trajectory. The trajectories in ﬁgures 3.16(a) and (b) with penalty weights w = 0 and w = 0.01 respectively have H-signature of h0. Blocking this class, but having a small penalty over distance from communication base gives the trajectory in 3.16(d) that passes close to the communication base.

60

100

100

90

90

80

80

70

70

60

60

50

50

40

40

30

30

20

20

10

10

R

0

0

0

20

40

60

80

100 0

(a) No dynamic obstacles

120 10
110
40

100

70

100 90

80 70

60

50

40
30 20 10

R

20

40

60

80

100

(b) Dynamic obstacles

100 90 80 70 60 50 40 30 20 10 0 0

100

90

80

70

60

50

40

30

20

10

R

0

20

40

60

80

100 0

100

90

80

70

60

50

40

30

R

20

10

0

20

40

60

80

100 0

R

20

40

60

80

100

(c) t = 1

(d) t = 30

(e) t = 113

100 90 80 70 60 50 40 30 20 10 0 0

100

90

80

70

60

50

40

30

20

10

R

0

20

40

60

80

100 0

100

90

80

70

60

50

40

30

R

20

10

0

20

40

60

80

100 0

R

20

40

60

80

100

(f) t = 1

(g) t = 19

(h) t = 81

Figure 3.17: Planning with time as an additional coordinate. The postion of the agent is denoted by R in ﬁgures (c)-(h).

Planning with Additional Coordinates
In Figure 3.17, besides x and y, we have used time as a third coordinate in G. There are two dynamic obstacles in the environment - the one at the bottom only translates, while one near the top both translates as well as expands in size. We have two representative points on the two static obstacles. Figure 3.17(a) shows the solution upon blocking the ﬁrst homotopy class in the environment without the dynamic obstacles. Figure 3.17(b) shows the planned trajectory in the environment with dynamic obstacles (with the color intensity representing the time coordinate). Figure 3.17(c-e) show the execution of the trajectory at diﬀerent instants of time of the same. Figure 3.17(g-h) show the execution of the plan without H-signature constraint.
However note that in this example the representative points are on the static obstacles. In spite of having a third coordinate, the H-signature of trajectories are being computed on a 2-dimensional plane for the projection of the trajectories on to the plane.

61

20

18

G

16

14

12

10

8

6

4

2

S

0

0

2

4

6

8 10 12 14 16 18 20

Figure 3.18: Exploring homotopy classes using a Visibility Graph

Implementation Using Visibility Graph
To demonstrate the versatility of the proposed algorithm we implemented it using a Visibility Graph as the state graph, G. Figure 3.18 shows the visibility graph generated in an environment with polygonal obstacles and the shortest paths in 9 homotopy classes that we explore. Obstacles were inﬂated in order to incorporate collision safety and circular obstacles were approximated by polygons. Representative points were placed only on the large obstacles (determined by threshold on diameter and marked by blue circles in the ﬁgure) and visibility graph was constructed. A* search was used for searching the H-signatue augmented graph. The implementation was made in MATLAB. The average run-time of the search until the 9th homotopy class was explored was 0.4 seconds and about 100 states were expanded.
Application to Robust and Eﬃcient Path Planning for Robotic Arm End-eﬀector
Typically, planning a trajectory in the joint space of a n-link robot arm, following which end-eﬀector can reach the goal is quite expensive. The search needs to be performed in the n-dimensional conﬁguration space of the arm.
However, one alternative approach is to plan a trajectory in the end-eﬀector space (the 2dimensional plane for a planar arm) and try to incrementally move the arm in small steps (by solving small local optimization problems or by using a simple feedback controller) to make the end eﬀector follow the trajectory while respecting constraints. However, this approach can often fail (especially in presence of obstacles) since the trajectory may be such that the end-eﬀector may not actually be able to traverse it due to joint angle constraints or the fact the total length of the arm is ﬁnite. We try to make this alternate approach more robust as follows: Instead of planning a single end-eﬀector trajectory we plan multiple of them in diﬀerent homotopy classes. We then simulate the arm and try to make the end-eﬀector follow each trajectory incrementally (by solving small local optimization problems at each time step). The hope is that if the robot arm can reach the goal, at least one of those trajectories will be good for doing so. While we do not have any rigorous
62

(a) t = 0s

(b) t = 6s

(c) t = 11s

(d) t = 14s

(e) t = 16s

Figure 3.19: The arm end eﬀector fails to follow the shorter trajectory due to limited length of the arm.

(a) t = 0s

(b) t = 15s

(c) t = 49s

(d) t = 91s

(e) t = 106s

Figure 3.20: The longer trajectory can be followed by the end eﬀector.

theoretical guarantees for this approach, we will exemplify the concept using two scenarios. In Figures 3.19 and 3.20 the end eﬀector of a 4-link robot arm is required to follow a trajectory
from the start coordinate at the left to the goal on the right. The base of the arm is ﬁxed inside the U-shaped obstacle. As described earlier, we do not plan path in the 4-dimensional conﬁguration space of the arm. Instead we plan trajectories in the 2-dimensional plane of the end eﬀector’s position. The arm cannot follow the shortest path (the one that goes above the obstacle) because of the limited length of the arm. This is illustrated in ﬁgures 3.19(a)-(e). However the path in the other homotopy class, though longer, can be followed by the arm (ﬁgures 3.20(a)-(e)).
In Figures 3.21 and 3.22 the 8-link robot arm has joint angle constraints (the angle limits are marked by pink sectors). In particular, all joints, except the one at the base can assume angles in [−π/2, 0]. The shortest path is the one that goes to the right of the obstacle (darker one). However, the robot arm cannot reach the goal following any path in this homotopy class due to the joint angle limitations, and thus it fails (Figure 3.21). However the longer trajectory in the other homotopy class can be followed, and hence the arm succeeds in following it (Figure 3.22).
The advantage of this method becomes apparent only when we consider robot arms with large number of links. Global path planning in such high dimensional conﬁguration space by discretization and graph construction is very expensive. On the other hand, knowing the end-eﬀector trajectory, incremental planning for the joint angles using local gradient-based search is almost indiﬀerent to the dimensionality of the complete conﬁguration space of the arm. Moreover, such local searches are free from most of the problems associated with continuous motion planning approaches (e.g. getting stuck at local minima, slow convergence or divergence). While we don’t yet have a theoretical guarantee from this approach, the computational advantage is deﬁnitely signiﬁcant.

63

(a) t = 0s

(b) t = 13s

(c) t = 23s

(d) t = 28s

(e) t = 36s

Figure 3.21: The arm end eﬀector fails to follow the shorter trajectory due to joint angle limits.

(a) t = 0s

(b) t = 15s

(c) t = 37s

(d) t = 66s

(e) t = 97s

Figure 3.22: The arm end eﬀector succeeds in following the longer trajectory.

3.6.2 Three-dimensional Conﬁguration Space
The ﬁrst 3-dimensional domain in which we implement the planning algorithm is the space of 3 spatial dimensions, X, Y and Z. We also demonstrate the algorithm in the 3-dimensional space of X, Y and time, i.e. an environment with planar dynamic obstacles (Section 3.6.2).
For a problem in 3 spatial dimensions, the domain of interest is bounded by upper and lower limits of the 3 coordinates. The domain is then uniformly discretized into cubic cells and a node of G is placed at the center of each cell. Connectivity is established between a node and its 26 neighbors (all cells that share at least one corner, edge or face with it). Each edge is bi-directional and its cost is the Euclidean length.

Simple environments with Bounded Obstacles
Figure 3.23(a) demonstrates a simple environment, 20 × 20 × 18 discretized, with two torus-shaped obstacles. The skeleton of each obstacle is made up of line segments passing through the central axis of the cylindrical segments. Here we restrict search to non-looping trajectories (See Appendix A for a precise deﬁnition). That is, we set B = h = [h1, h2]T |h1| > 1 or |h2| > 1 . We search for 4 homotopy classes of trajectories connecting a given start and goal coordinate. As shown in Figure 3.23(a), the algorithm ﬁnds four such trajectories: (i) going through hoops 1 and 2; (ii) going through hoop 1 but not through hoop 2; (iii) going through hoop 2 but not through hoop 1; and (iv) not going through either hoops. According to Theorem 3.5.2 each path is the least cost one in the graph and in its respective homotopy class.
Figure 3.23(b) shows the exploration of 4 homotopy classes in and around a room with windows on each wall. The skeletons for this obstacle are deﬁned as loops around each window according to Construction 3.4.4. The trivial shortest path from the given start to goal conﬁguration goes outside the room (the dark violet trajectory). Trajectories in other homotopy classes pass through
64

(a) Two hoops.

(b) A room with windows.

Figure 3.23: Exploring homotopy classes in X − Y − Z space.
the room.
Environment with Unbounded Pipes
Figure 3.24(a) shows a more complex environment consisting of 7 pipes stretching to inﬁnity. The workspace of choice is 44 × 44 × 44 discretized, with the start and goal coordinates at two opposite corners of the discretized space. We used Construction 3.4.3 to close the inbounded obstacles at inﬁnity. In Figure 3.24(a) we ﬁnd the least cost paths in 10 diﬀerent homotopy classes.
Planning with H-signature Constraint
Figure 3.24(b) demonstrates a planning problem with H-signature constraint. The darker trajectory is the global least cost path found from a search in G for the given start and goal coordinates. The H -signature for that trajectory was computed, and hence we computed the signature of the complementary class (i.e the class corresponding to the trajectory that passes on the other side of every SHIO - see Appendix A for a precise deﬁnition), and put only that in A. The lighter trajectory is the one planned with that A as the set of allowed H -signature. This trajectory goes on the opposite side of each and every pipe in the environment as compared to the darker trajectory.
We note that in this example the notion of complementary homology class concurs with that of complementary homotopy class.
Search Speed and Eﬃciency
We now present the running time for the case in Figure 3.24(a). The environment, as described earlier, is 44 × 44 × 44 discretized, and hence G contains 85184 nodes. Due to each node being connected to 26 of its neighbors, there are almost 13 times as many edges in G. The program was run on a Intel Core 2 Duo processor with 2.1 GHz clock-speed and 3GB RAM. We ﬁrst compute the values of H(e) for all edges e ∈ E and store them in a cache, which takes about 2273s. Then we perform the A* search in GH , using the values from the cache whenever required. By doing so we eliminate the requirement of re-computing the h-signatures of the edges every time we perform
65

(a) Exploring 10 distinct homotopy classes.

(b) Plan in the complementary homology class of the least cost path.

Figure 3.24: An environment with 7 unbounded pipes.
60

50

40

30

20

10

nodes expanded (104)

time taken (s)

0

0

2

4

6

8

10

Number of homotopy classes explored

Figure 3.25: Cumulative time taken and number of states expanded while searching GH for 10 homotopy classes in the problem of Figure 3.24(a).
a search, even with changed start and goal coordinates. The search for the 10 homotopy classes in Figure 3.24(a) took about 30s and expansion of 521692 nodes in GH . Figure 3.25 shows the cumulative time required and the number of nodes in GH expanded.
Planning in 2-dimensional Plane with Moving Obstacles
The next 3-dimensional domain that we experiment with is that of the two-dimensional plane, but with dynamic entities. Thus the variables of interest are X, Y and time. The node set was formed by uniform discretization of the domain of interest. The connectivity of the graph is such that the time variable can increase only in the positive direction (each node connected to 9 neighboring nodes in next time step, including the same x & y). The cost of an edge, e, with diﬀerences in the coordinates of its end points ∆x, ∆y and ∆t is computed as c(e) = ∆x2 + ∆y2 + ∆t2, where is a small value for avoiding zero cost edges in GH . The skeleton of the moving obstacles are the curves traced by their centers (yellow dots on the oscillating rectangles in Online Resource 1) in
66

(a) t = 0.4s

(b) t = 8.6s

(c) t = 20.8s

(d) t = 23.7s

(e) t = 26.7s

(f) t = 29.6s

(g) t = 32.5s

(h) t = 37.0s

(i) t = 40.0s

(j) t = 43.1s

Figure 3.26: Screen-shots from an example with two moving obstacles (O1 and O2) showing the exploration of 4 homotopy classes in a dynamic environment. The blue trajectory (3) passes above both O1 and O2. The red trajectory (2) passes above O2, but not O1. The light blue-gray trajectory (1) passes above O1, but not O2. The dark gray trajectory (0) is the trivial shortest path.
the X − Y − T ime space. The skeletons are closed outside and far from the discretized domain (Construction 3.4.3). Note that in doing so, segments of the skeleton may point along negative time. However that does not eﬀect the planning since the X − Y − T ime space itself can be treated no diﬀerently from R3.
Figure 3.26 shows the exploration of 4 homotopy classes in X − Y − T ime domain. The environment is 40 × 40 discretized in X and Y directions, and have 100 discretization cells in time. There are two dynamic rectangular obstacles, that undergo a known oscillatory motion inside a narrow passage between other static obstacles. The 4 diﬀerent trajectories in the diﬀerent homotopy classes are marked by diﬀerent colors as well as diﬀerent numbers at their current locations. The blue trajectory (3) passes above both the obstacles. The red trajectory (2) passes above the right obstacles, but not the left one. The light blue-gray trajectory (1) passes above the obstacle on the left, but not one on the right. The dark gray trajectory (0) is the trivial shortest path. The trajectories in the non-trivial homotopy classes go behind the obstacles, a region that would otherwise not be visited by the least cost path without any H-signature consideration.
67

Chapter 4
Identiﬁcation of Homology Classes
in Euclidean Spaces with
Punctures
4.1 Introduction
The methods developed in the previous chapter relied on ﬁnding a diﬀerential 1-form, the integration of which along trajectories would give homology class invariants. Such 1-forms are elements of the de Rham cohomology group of the conﬁguration space punctured by obstacles, Hd1R(RD − O) [8]. For D-dimensional conﬁguration space we considered (D − 2)-dimensional homotopy equivalents (which were also their deformation retracts) to represent the obstacle – the representative points for the 2-dimensional case, and the skeletons for the 3-dimensional case. What we then ended up computing are linking numbers of closed loops with the homotopy equivalents of each obstacle. Depending on whether or not the closed loop τ1 −τ2 formed by two trajectories τ1 and τ2 has zero or non-zero linking numbers with every obstacle, we could conclude if or not they are homologous (Deﬁnition 3.2.2).
In fact it is not a surprise that linking numbers are closely related to homology groups. Using the deﬁnition of linking number from [27] we will in fact show that the integration along trajectories we compute give homology class invariants for closed loops (something that we had claimed in Chapter 3, but have not proved rigorously).
We will generalize the problem in order to take into account homology classes and linking numbers of arbitrary dimensional manifolds (not just 1-dimensional curves representing trajectories). In particular, we will consider (N − 1)-dimensional closed manifolds as generalization of 1-dimensional curves that constituted the trajectories. Obstacles will be represented by (D − N )-dimensional closed manifolds (which, in many cases will be deformation retracts of the original obstacles). Thus, in light of the contents of Chapter 3, we would set N = 2 for trajectories, and for the 2 and 3 dimensional cases we would have D = 2 and D = 3 respectively.
The aim of this chapter are: 68

O O
S
S
Figure 4.1: Obstacles, O, can be replaced by their equivalents, S, and that will not alter the homology class of the (N − 1)-cycles in the complement space – an assumption that we made in Chapter 3. In either of these ﬁgures, S is a deformation retract of O. The justiﬁcation for this construction is a consequence of Corollary 4.2.2.
1. To ﬁnd certain diﬀerential (N − 1)-forms in the Euclidean space punctured by obstacles, and show that integration of the forms along (N − 1)-dimensional closed manifolds give complete invariants for homology classes of the manifolds in the punctured space (i.e. the value of the integral over two closed manifolds are equal if and only if the manifolds are homologous),
2. To generalize the tools used in Chapter 3 to arbitrary dimensional Euclidean conﬁguration spaces punctured by obstacles.
Throughout this chapter we consider homology and cohomology with coeﬃcients in the ﬁeld R. Also, for simplicity, we will throughout consider N > 1 to avoid the special treatment of the 0th (co)homology groups.
4.2 Simplifying the Problem by Taking (D − N )-dimensional Equivalents of Obstacles
Before we delve into some of the technical details involving linking numbers, we state a few propositions related to replacement of obstacles with their (D − N )-dimensional representatives. The fact that we had used representative points to replace obstacles in 2-dimensions and skeletons in 3-dimensions to perform computations throughout Chapter 3 relied on the fact that replacing obstacle by their homotopy equivalents do not eﬀect the homology groups of the complement space (i.e. free space), neither does it change the homology classes of trajectories in the free space (Figure 4.1). While this assumption may appear intuitive, we need to prove it rigorously. Moreover, often one may come across obstacles which do not have a (D − N )-dimensional deformation retract (e.g. for the D = 3, N = 2 case, a hollow torus does not have a D − N = 1 dimensional homotopy equivalent). We will explore what (D − N )-dimensional equivalents we can use for such obstacles (Figure 4.3).
In the proposition and related corollaries that follow, we represent the conﬁguration space (without obstacles) by RD (the D-dimensional conﬁguration space), an obstacle by O, and S the equivalent of the obstacle with which we replace O for computational simplicity.
69

ω

O

ω

ω

S1 S2
(a) Both S1 and S2 are subsets of the solid torus, O. Moreover, each has the homotopy type of the solid torus. ω is a non-trivial cycle in (R3 − O).

S1
(b) (R3 − S1) has homology groups isomorphic to those of (R3 − O). However, the cycle ω becomes trivial in (R3 − S1). Thus S1 is not a valid replacement of O.

S2
(c) (R3 − S2) also has homology groups isomorphic to those of (R3 − O). Moreover, the cycle ω remain non-trivial in (R3 − S2). S2 is a valid replacement of O.

Figure 4.2: A solid torus, and its valid/invalid replacements. This is an example with D = 3, N = 2 – the 3-dimensional case discussed in Chapter 3. The obstacle, O, need to be replaced by appropriate (D − N ) = 1-dimensional equivalents, that we called skeletons. The replacement needs to be such that the inclusion map i : (RD − O) → (RD − S) induces the isomorphism.

Proposition 4.2.1. Let O be a compact, locally contractible and orientable sub-manifolds of RD. Let S be a (D − N )-dimensional compact, locally contractible and orientable sub-manifolds of O contained in the interior of O such that HD−N (S) HD−N (O) and HD−N (O, S) 0. Then the inclusion map i : (RD − O) → (RD − S) induces an isomorphism i∗:N−1 : HN−1(RD − O) → HN−1(RD − S).
Proof. Detailed proof can be found in Appendix B.1.

In light of robot path planning, O in the above proposition are the solid obstacles in the environment, and S are their equivalents/replacements (in terminology of Chapter 3 they are representative points of obstacles on a 2-dimensional plane, and skeletons of obstacles in a 3-dimensional Euclidean space). The aim of the above proposition is to establish a relationship between the homology groups of the complement (or free) spaces, (RD − O) and (RD − S), from some known relationship between the spaces O and S. In fact, it is not just the homology groups that we are trying to establish relationship for, but homology classes of (N − 1)-dimensional manifolds (the closed trajectories in robot planning problem) in the complement space.
For example, in Figure 4.2, the solid torus, which represents an obstacle in R3, was previously (in Chapter 3) replaced by its ‘skeleton’, S2, for computations of homology class of closed loops like ω (formed by pair of trajectories). Under such a replacement, the claim was that, the homology class of ω in the complement space remain unchanged. This replacement, according to Proposition 4.2.1, is justiﬁed by the facts that H1(S2) H1(O) and H1(O, S2) 0 (due to the fact that S2 is a deformation retract of O). Corollary 4.2.2 simply asserts that a deformation retract (which S2 indeed is of O) in fact satisﬁes the required conditions of the proposition. On the other hand, although S1 satisﬁes H1(S1) H1(O) it does not satisfy H1(O, S1) 0. Thus S1 is not a valid replacement of O.
Corollary 4.2.2. If S and O are compact, locally contractible and orientable submanifolds of RD such that S is a deformation retract of O, then the inclusion map i : (RD − O) → (RD − S) induces
70

S

O

O

S

(a) The hollow torus can be replaced by the im-
age of its generating 1-cycles, S. This replacement does not alter the (N − 1)th homology
groups of the complement space, neither does it
alter the class of a (N − 1)-cycle in the complement space, (RD − O). O and S satisfy the conditions of Proposition 4.2.1.

(b) In this ﬁgure we choose a S ⊂ O such that
HD−N (S) HD−N (O). The replacement of O by S, as in (a), does not alter the (N − 1)th homology groups of the complement space, (RD − O). However, the replacement does not preserve
the class of a (N − 1)-cycle in the complement
space. This is because HD−N (O, S) / 0 in this case. Thus this is not a valid replacement of O.

Figure 4.3: A hollow (or thickened) torus as an obstacle in a D = 3 dimensional space, with N = 2 for our problem (i.e. we are interested in homology classes of (N − 1) = 1-dimensional manifolds, which are closed trajectories). It does not have a (D − N ) = 1-dimensional deformation retract or homotopy equivalent. However, we can replace it by its generating 1-cycles. This is the consequence of Corollary 4.2.3.

isomorphisms i∗ : H∗(RD − O) → H∗(RD − S)
Proof. Deformation retract implies homotopy equivalence, and that the inclusion induces isomorphisms i∗ : HD−N (S) −→ HD−N (O) for all N . Using this in the long exact sequence of homology groups for pair (O, S) we further have HD−N (O, S) 0 for all N (This can be concluded by observing that i∗ being an isomorphism requires that for exactness of the sequence, ∂∗ be a zero map, and j∗ be a surjection and a zero map at the same time. Thus HD−N (O, S) requires to be zero for all N .). The result can then be concluded using Proposition 4.2.1.

Corollary 4.2.3. Given a compact, locally contractible and orientable submanifold O ⊂ RD, let {Sk}k=1,2,··· ,m be the images of generating cycles of HD−N (O) (i.e. if {Sk} are (D − N )-cycles in O such that the homology classes of {Sk} generate the group HD−N (O) freely, then {Sk} are the images of {Sk}), and let S = k=1,2,··· ,m Sk. Then the inclusion map i : (RD − O) → (RD − S) induces an isomorphism i∗:N−1 : HN−1(RD − O) → HN−1(RD − S).
Proof. The proof follows from the observation that the inclusion i : S → O induces an isomorphism in the (D − N )th homology groups of the spaces.
Clearly the (D − N )th homology groups of O and S are isomorphic. The fact that the generating cycles of S are generating cycles of O under inclusion, implies any cycle σ ∈ CD−N (O) can be written as σ = i ◦ ω + ∂D−N+1 ◦ α for some ω ∈ CD−N (S) and α ∈ CD−N+1(O). This implies that any cycle in the relative chain CD−N (O)/CD−N (S) are trivial. Thus HD−N (O, S) is trivial.
71

The result hence follows from Proposition 4.2.1. Note that being images of cycles, each of Sk are (D − N )-dimensional closed (boundaryless), compact, locally contactable and orientable manifolds.
The consequence of the last two corollaries is that instead of computing homology in the original punctured space (X − O), we can conveniently replace the obstacles with their equivalents, S, and compute homology in (X − S), and yet, the results we obtain will be identical. That is exactly what we did by taking the representative points (Deﬁnition 3.3.1) of obstacles on a 2-dimensional plane, and skeletons (Deﬁnition 3.4.2) of obstacles in a 3-dimensional Euclidean space. Corollary 4.2.2 says that we can replace obstacles with such (D −N )-dimensional deformation retracts (Figure 4.1). However, often obstacles may not have (D − N )-dimensional deformation retracts (for example, a hollow torus does not have a 1 dimensional deformation retract, as illustrated in Figure 4.3). In such cases we can use Corollary 4.2.3 to replace obstacles by certain (D − N )-dimensional equivalents (generating cycles of (D − N )th homology group).
4.2.1 Reduced Problem Deﬁnition
Thus we have established that given any subset O of RD (which represent obstacles in robot planning problem), instead of looking at the homology classes of (RD − O), we can simply consider the homology classes of a space (RD − S) for some equivalents S of O (as prescribed by Corollaries 4.2.2 and 4.2.3). Of course we can decompose S into a collection of manifolds since the types of spaces we are interested in are in fact manifolds, hence deformation retracts and images of generating cycles are manifolds as well. Thus, in the rest of the chapter, we will only consider the presence of (D−N )dimensional compact, closed (boundary-less), locally contractible and orientable equivalents of the obstacles. Hence is the following reduced problem deﬁnition:
We are given (D − N )-dimensional (N > 1) compact, closed (boundaryless), locally contactable and orientable manifolds (which we call singularity manifolds), S1, S2, · · · , Sm, embedded in the D-dimensional Euclidean space RD. Each of Si is path-connected (i.e. has single component). We deﬁne the set S = S1 ∪ S2 ∪ · · · ∪ Sm to be the set of all singularity manifolds.
We are interested in identifying homology classes of (N −1)-dimensional compact, closed (boundaryless), locally contactable and orientable manifolds in (RD − S) (which we call candidate manifolds). In order to compute that we use (N − 1)-cycles on the candidate manifolds (i.e. topdimensional cycles). Those, by inclusion, are (N − 1)-cycles in (RD − S). Thus, given a candidate manifold ω, we can conveniently use a simplicial cover (or, equivalently, singular, cellular or cubical cover) of the manifold, ω, which is a (N − 1)-cycle in (RD − S). However, given two cycles ω1, ω2 ∈ ZN−1(RD − S), instead of checking if or not ω1 − ω2 is boundary in HN−1(RD − S), we would like to be able to use the action of some co-cycles in HN−1(RD − S) on the cycles (specifically, integrations of diﬀerential forms over the cycles) to be able to say which homology classes they belong to.
72

Y

X

R3, N = 2

A

ζ

A

X-A

X
Relative cycle ζ of class

B
Relative cycle of class

Figure 4.4: Illustration of intersection number in R3 with N = 2 in light of Deﬁnition 4.3.1.

4.3 Preliminaries on Linking Numbers
Equipped with the notion of the (D − N )-dimensional replacements of the obstacles/punctures, Si, we proceed towards computing the homology classes of (N − 1)-cycles (in light of robot planning problem those are the closed trajectories) of (RD − S).
In this section we start by deﬁning intersection number, and the related concept of linking number, from an algebraic topology view-point. The main purpose of this section is two fold:
i. To establish the fact that the linking numbers between the (N − 1)-cycles in (RD − Si), and the manifolds Si indeed tells us about the homology class of the (N − 1)-cycles in (RD − Si) (Proposition 4.3.4),
ii. Propose a formula for computing the linking number using an integration over the (N − 1)cycle and a top-dimensional cycle of Si (Proposition 4.3.5).
However, we will try to keep our initial treatment of linking/intersection numbers and related propositions fairly general from an algebraic topology consideration. We will however try to illustrate the ideas using corresponding examples from the familiar robot planning problem of Chapter 3.

4.3.1 Deﬁnitions
We ﬁrst give the technical deﬁnitions of intersection number and linking number, following which we try to illustrate those using simple examples.

Technical Deﬁnitions Recall the deﬁnition of intersection number [27], Deﬁnition 4.3.1 (Intersection Number – Ch. VII, Def. 4.1 of [27]).
73

If X and Y are sub-manifolds of RD, and A ⊂ X ⊂ RD, B ⊂ Y ⊂ RD be such that A ∩ Y = ∅, X ∩ B = ∅ (Figure 4.4), and consider the map p : (X × Y, A × Y ∪ X × B) → (RD, RD − {0}) given by p(x, y) = x − y (where we used the natural vector structure of RD). The composition
HN (X, A) × HD−N (Y, B) −−−×−−→ HD(X × Y, A × Y ∪ X × B) −(−−−1)−D−−−N−p→∗ HD(RD, RD − {0})
is called the intersection pairing (Note that the product ‘×’ for homology groups is the homology cross product, which is more closely related to the tensor product of the homology groups rather than the cartesian product – see p. 268 of [40]).
We write
I (ζ, µ) = (−1)D−N p∗(ζ × µ), for ζ ∈ HN (X, A), µ ∈ HD−N (Y, B)
and call this element of HD(RD, RD − {0}) R the intersection number of ζ and µ.
Note that the intersection number is deﬁned for homology classes of the pairs (X, A) and (Y, B). However it can be easily extended to relative cycles ζ ∈ ZN (X, A), µ ∈ ZD−N (Y, B) as I (ζ, µ) = (−1)D−N p(ζ × µ) = I ([ζ], [µ]), where [·] represents the homology class of a cycle. This follows from functoriality of homology (See p. 162 of [40]).
Also, once again note that the product ‘×’ between chains is more closely related to group tensor products. This can just be the group tensor product for cellular or cubical chains. But for singular or simplicial chains the product involves further operations and is called the simplicial cross product (See p. 277 of [40]).
Moreover, more generally, p : X × Y → RD can be an arbitrary continuous surjective map which maps only the points {(x, y) ∈ X × Y x = y} to {0} ∈ RD.
Deﬁnition 4.3.2 (Linking Number – Adapted from Ch. 10, Art. 77 of [78]). We borrow deﬁnitions of X, A, Y and B from Deﬁnition 4.3.1. Recall that from the long exact
sequence of the pair (X, A) we have a map ∂∗ : HN (X, A) → HN−1(A). Now, if ς ∈ HN−1(A) is such that it can be written as ς = ∂∗ζ for some ζ ∈ HN (X, A), and if
µ ∈ HD−N (Y, B), then the linking number between ς and µ is deﬁned as L (ς, µ) = I (ζ, µ).
Note that similar to the intersection number, by the functoriality of homology, linking number can be deﬁned between a cycle, ς, in A and a relative cycle, µ, in (Y, B).
Simpliﬁed Description of the Deﬁnitions
Let us consider the simple case when X = R3, A = R3 − S, Y = S and B = ∅, and with D = 3, N = 2, which arises in robot path planning in R3 (Figure 4.5). Let µ be a top-dimensional cycle on the (D − N )-dimensional manifold, S (to be consistent with the notations used in the deﬁnition). Intersection number, as the name suggests, informally speaking, counts the number of intersections between a N -chain ξ (in light of Deﬁnition 4.3.1, it is represented by the relative cycle ζ), and a (D − N )-cycle µ. Thus, in Figure 4.5, informally, the intersection number between ξ and µ is ±1 (the sign depends on orientation).
74

ς

u

0

μ
ξ
R3 x S (a)

p(x, y) = x - y

R3 (b)

Figure 4.5: A simpliﬁed illustration (following from Figure 4.2(c)) of intersection number and linking number in R3 with N = 2. This is a special case of Deﬁnition 4.3.1 when X = R3, A = R3 −S, Y = S and B = ∅. Figure (a) on the left: The intersection number is computed between a N -chain, ξ (more precisely it is a relative cycle in (X, A) that we consider – the boundary of ξ trivialized), and the (D − N )-cycle, µ, that is a top-dimensional cycle on S. In this ﬁgure the said intersection number is ±1 due to the single intersection marked by the blue ‘cross’ at u. Then, by deﬁnition, that is equal to the linking number between ς = ∂ξ and µ. Figure (b) on the right: The precise deﬁnition requires a mapping, p, from pair of points in the original space (one point from the 2-chain, ξ, embedded in the ambient space, R3, and another from S) to (a diﬀerent copy of) R3. The intersection/linking number is then, informally, the number of times intersection points in the pre-image of p (points like u) maps to the origin, 0 (with proper sign), in the image, or equivalently, the number of times the image of ς × µ, under the action of p, wraps around the origin. Thus, it is the homology class of the cycle p(ς × µ) in the punctured Euclidean space (RD − 0).

Now, if ξ has a boundary, say ς = ∂ξ, the linking number between ς and µ is, by deﬁnition, the intersection number between ξ and µ.
In deﬁning the intersection number, however, one does not talk about the N -chain ξ. Instead, one talks about the corresponding relative cycle in (R3, R3 − S) under the action of the quotient map j : CN (R3) → CN (R3, R3 − S) – that is, the part of ξ that does not intersect with S, is trivialized (which is ζ (= j(ξ)) in notation of Deﬁnition 4.3.1). This is because homology classes are not deﬁned for chains, rather can be deﬁned for cycles or relative cycles only. By trivializing the part of the chain that contains the boundary (i.e. the one lying in (R3 − S)), we convert it into a relative cycle, thus enabling us to talk about its homology class (ζ in Deﬁnition 4.3.1).
For constructing a precise algebraic deﬁnition of linking/intersection number, the relative cycles ζ and µ are then mapped to R3 via the map p(x, y) = x − y. The intersection number is then, informally, the number of times the intersection points (like u in Figure 4.5) map to (with proper sign) the origin in the co-domain of p. Linking number is then essentially the number of times the image of ς × µ, under the action of p, wraps around the origin in the co-domain of p. In other words, it is the homology class of the cycle p(ς × µ) in the punctured Euclidean space (RD − 0).

75

R2
ξ ς
μ

ξ2 ξ1
ς

ξ1

ξ2

μ
ς

μ

(a) On R2 the linking number between a point µ (a 0-cycle) and a 1cycle ς is uniquely determined, and is equal to the intersection number between µ and a 2-chain ξ such that ς = ∂ξ. It can be shown that the choice of ξ does not matter.

(b) Similarly, in R3 the linking number between a 1-cycle, µ, and a closed cycle ς is uniquely determined, and is equal to the intersection number between µ and a 2-chain ξ such that ς = ∂ξ. It can be shown that the choice of ξ does not matter – that is, we could choose ξ1 or ξ2 for computation of the intersection number, and the value that we would obtain will be the same.

(c) However, if the ambient space, X,
is not contractible (in this ﬁgure it is the 2-sphere, S2), then the linking number between µ and ς is not un-
ambiguously deﬁned. This is because
the choices of ξ such that ς = ∂ξ can
be made in ways such that its inter-
section number with µ is diﬀerent for
the diﬀerent choices. In the ﬁgure, on S2, the boundary of both ξ1 and ξ2 are ς. However the intersection num-
ber between ξ1 and µ is zero, while that between ξ2 and µ is ±1.

Figure 4.6: Examples and counter-examples of uniqueness of linking number – a consequence of Proposition 4.3.3.

4.3.2 Propositions on Linking Number
In this sub-section we will state and prove two propositions, each followed by simpliﬁed explanation of the result of the propositions.
The fact that we have assumed X and Y to be embedded in RD guarantees that the linking number is uniquely deﬁned. However, one can consider a more general case where they are embedded in an arbitrary D-dimensional manifold, M . Also, the map p is replaced by a more general continuous surjective map p : (X × Y, A × Y ∪ X × B) → (M, M − 0) for some base-point 0 in M . In such case the uniqueness of the linking number is non-trivial (see Figure 4.6).
Proposition 4.3.3 (Uniqueness of linking number). If HN (X) = HN−1(X) = 0 holds, then L (ς, µ) is independent of the exact choice of ζ [78]. More precisely, under the said conditions, ∂∗−1 exists, and thus L (ς, µ) = I (∂∗−1ς, µ) = (−1)D−N p∗(∂∗−1ς × µ).
Proof. From the long exact sequence for the pair (X, A), using the condition HN (X) = HN−1(X) = 0, it follows that ∂∗ : HN (X, A) → HN−1(A) is an isomorphism (See p. 114 of [40]). Hence the result follows. [Note that the contractibility of X is suﬃcient for the said condition to hold.]

The the statement of the above proposition is about the uniqueness in the value of linking number. Intersection number, according to deﬁnition, is between a N -chain (like ξ in the example of ﬁgure 4.5 or 4.6) and a (D − N )-cycle (like µ in the example of Figure 4.5). That is then, by deﬁnition, the linking number between the boundary of the N -chain, which is a (N − 1)-cycle (like
76

ς in the example of Figure 4.5) and the (D − N )-cycle (µ). However, it may be possible that there exists another N -chain, ξ , such that ς is the boundary of that N -chain as well (i.e. ς is a common boundary between ξ and ξ – as illustrated in Figure 4.6(b)). Then, if the intersection number between ξ and µ is not same as that between ξ and µ, the deﬁnition of the linking number between ς and µ becomes ambiguous. This is exempliﬁed in Figure 4.6(c). Proposition 4.3.3 precisely gives the condition under which such ambiguity is not present.
Proposition 4.3.4 (Connection to homology of A). Consider a ﬁxed non-zero µ ∈ HD−N (Y, B). If, in addition to the condition of Proposition 4.3.3, we have HN (X, A) HN−1(A) R, and if there exists at least one (N − 1)-cycle in A such that its linking number with µ is non-zero, then the value of L (ς, µ) tells us which element of HN−1(A) is the chosen ς. In other words, the map H ≡ L (·, µ) : HN−1(A) → HD−1(RD, RD − {0}) R is an injective homomorphism.
Proof. The map H is given by H(ς) = (−1)D−N p∗(∂∗−1ς ×µ). This clearly is a group homomorphism between HN−1(A) and HD−1(RD, RD − {0}). Since by hypothesis, both the domain and the codomain of H are isomorphic to R, H can either be a trivial homomorphism (i.e. maps everything in its domain to 0 in its co-domain), or it can be an injection. The former possibility is ruled out by the hypothesis of existence of at least one (N − 1)-cycle in A with non-zero linking number with µ. Thus the result follows. The result implies that the linking number with µ is a complete invariant for the homology class ς.

So far we have been talking about intersection number and linking number. However what we are really interested in is the homology class of ς in A (in light of robot planning problems, that is the homology class of the closed trajectories in (RD − S), as illustrated in ﬁgures 4.5 ans 4.6). The result of the above proposition establishes a relationship between the linking number between µ and ς (see ﬁgure 4.5 or 4.6), and the homology class of ς. It says that under certain conditions, the linking number will precisely tell us about the homology class of ς (i.e. a complete invariant).

4.3.3 Computation of Intersection/Linking Number for Given Cycles

In this sub-section we will actually try to compute the linking number between the cycles ς and µ.

As described in the beginning of this chapter, we would like to be able to compute the homology

class of (N − 1)-cycles (top-dimensional cycles on (N − 1)-dimensional manifolds) as an explicit

number (or a set of numbers). Equipped with Proposition 4.3.4, that problem can be converted to

the problem of computation of the linking numbers.

There can be a large variety of diﬀerential forms on a manifold. A n-form can always be

integrated on a n-cycle. However, the value of the integration may not tell us anything about the

homology class of the cycle. For example, in (R2 − 0), i.e. the plane with the origin removed, dx

is a diﬀerential 1-form. However it is exact and evaluates to 0 on every closed curve. On the other

hand, as we saw in Chapter 3,

dθ

=

x

dy+y dx x2 +y 2

(=

Im(

dz z

))),

which

is

closed

but

not

exact

[8]

in

(R2 − 0), in fact tell us about the homology class of closed loops.

The purpose of the proposition below is to design a diﬀerential from, integration of which,

along with the conditions of Proposition 4.3.4, captures the homology class of (N − 1)-cycles in

77

A (which, in light of robot planning problem, are the punctured spaces (RD − S), S being pathconnected). In order to achieve this for arbitrary A (in robot planning, for example, we can arbitrary representatives, S, for the obstacles), we exploit the transformation, p, in the deﬁnition of linking numbers. Thus, the closed, non-exact diﬀerential form that we have to choose is one from the codomain of p, namely (RD − 0) (a space which is much simpler and well-known than, say, (RD − S)), and then pull it back to the original space by p. Thus we have the following proposition.
Let η0 ∈ ΩDdR−1(R − {0}) be a closed but non-exact diﬀerential form in (R − {0}) such that [η0] ∈ HdDR−1(R − {0}) R is a generator of HdDR−1(R − {0}).
Proposition 4.3.5. In addition to the condition of Proposition 4.3.3, if HD−N (B) = HD−N−1(B) = 0, then the linking number between cycles ς ∈ ZN−1(A) and µ ∈ ZD−N (Y, B) is uniquely identiﬁed by the value of (i.e. a complete invariant for the linking number is)

(−1)D−N

p∗(η0)

ς ×u

where u ∈ ZD−N (Y ) is such that j (u) = µ, where j is the quotient map Y → Y /B (See Thm. 2.13 of [40] – note that for a given µ, in general, there can be many possible choices for u).

Proof. Detailed proof can be found in Appendix B.2.

4.4 Computation in Our Speciﬁc Problem
In this section we specialize the results of the previous section to match the description of the reduced problem deﬁnition in Section 4.2.1. We consider the case where there is a single path-connected component of S, namely S.
For our problem, in connection to the deﬁnitions stated in Section 4.3 (see Figure 4.5), we set
X = RD, A = RD − S, Y = S and B = ∅
Moreover, since Y ≡ S is a (D − N )-dimensional compact, connected and orientable manifold, we have HD−N (S) R. We thus choose µ = S to be a non-zero top dimensional cover of S such that [S] = 1 ∈ HD−N (S) is a generator of HD−N (S) (which is isomorphic to R since S is a closed, path-connected and orientable (D − N )-dimensional manifold).
Also, note that since B = ∅, the maps j : Y → Y /B is the identity map. So in this case [S] ∈ HD−N (S, B) ≡ HD−N (S).
For this choice it is easy to verify that the conditions of Propositions 4.3.3, 4.3.4 and 4.3.5 hold.
i. Condition for Proposition 4.3.3: HN (RD) = HN−1(RD) = 0 follows from contractibility of RD .
ii. Conditions for Proposition 4.3.4:
a. By Proposition 3.46 of [40], HN (RD, RD −S) HD−N (S). Again, using Poincar Duality for S (which is a (D−N )-dimensional closed, orientable manifold), HD−N (S) H0(S) 78

R3, N = 2
ς v

S

Figure 4.7: The speciﬁc problem under consideration, illustrated for D = 3, N = 2.

R (since S has a single connected component). Finally, from the long exact sequence for the pair (RD, RD − S), using the contractibility of RD, we have, HN (RD, RD − S) HN−1(RD − S). Combining these three isomorphisms we have,

HN (RD, RD − S) HN−1(RD − S) R

(4.4.1)

.
b. Consider a point v ∈ S. Since S covers S, this point is also in (the image of) S. Since S is (D − N )-dimensional, we can choose a small N -ball, B, centered at v such that it intersects S transversely only at v. Let B ∈ CN (RD) be a top-dimensional nonzero chain that covers B. Clearly the intersection number between S and j(B) (where j : RD → RD/(RD − S) is the quotient map) is non-zero. Thus the linking number between ∂B (RD−S) (which, by our construction, is a (N − 1)-cycle in (RD − S)) and S is non-zero. Thus there exists at least one (N − 1)-cycle in (RD − S) that has non-zero linking number with S (see Figure 4.7).
iii. Condition for Proposition 4.3.5: Follows from the fact that B = ∅.
Thus, we are concerned with ﬁnding a complete invariant for homology classes of (N − 1)-cycles, ω ∈ ZN−1(RD − S). Which, by Proposition 4.3.4, is the linking number between ω and S. And, ﬁnally, using Proposition 4.3.5, the complete invariant for the homology classes of such chains is given by the value of the integration

φS(ω) = (−1)D−N

p∗(η0)

ω×S

= (−1)D−N

p∗(η0)

ωS

[by Fubinis theorem]

79

(4.4.2)

4.4.1 Computation of the integral in φS
Let x ∈ (RD−S) ⊂ RD be the coordinate variable describing points in (RD−S), and let x ∈ S ⊂ RD be the one describing points in S. Thus we have p(x, x ) = x − x .
Again, we let s ∈ (RD − {0}) ⊂ RD be the natural coordinate variable describing points in the space (RD −{0}). A well-known result [3, 30] is that a diﬀerential closed but non-exact (D −1)-form in (RD − {0}) (i.e., a nontrivial element of ZdDR−1(RD − {0})) is,

D
η0(s) = Gk(s) (−1)k+1 ds1 ∧ ds2 ∧ · · · ∧ dsk−1 ∧ dsk+1 ∧ · · · ∧ dsD
k=1

(4.4.3)

where

1 Gk(s) = AD−1

sk (s21 + s22 + · · · + s2D)D/2

(4.4.4)

D

where,

s

=

[s1, s2, · · ·

, sD]T

∈

(RD −{0}),

and

AD−1

=

Dπ 2

Γ(

D 2

+1)

is

the surface area

of the

(D−1)-unit

sphere (which acts as a normalizing factor, and can be set to any non-zero value).

Thus the pullback of η0 under p is given by the following formula,

η(x, x ) = p∗(η0) = η0 s=x−x

D

=

Gk(x − x ) (−1)k+1 d(x1 − x1) ∧ d(x2 − x2) ∧ · · ·

k=1

∧ d(xk−1 − xk−1) ∧ d(xk+1 − xk+1) ∧ · · · ∧ d(xD − xD) (4.4.5)

Now consider the quantity of our interest, φ(ω) = x∈ω x ∈S η(x, x ). On ω × S, at most (N − 1) unprimed diﬀerentials can be independent, and at most (D − N ) primed diﬀerentials can be independent (since x represents a point on the image of the (N −1) chain ω and x represents a point on the image of the (D −N ) chain S). Thus we can conveniently drop all the terms in the expansion of η (which is a (D − 1)-diﬀerential form on (RD − S) × S) that do not satisfy these conditions on maximum number of primed/unprimed diﬀerentials. Thus we obtain a simpler diﬀerential form η˜,

D

η˜(x, x ) =

Gk(x − x ) (−1)k+1+D−N ·

k=1

dx1(τ1) ∧ dx2(τ2) ∧ · · · ∧ dx(kτ−k1−1) ∧ dx(kτ+k1+1) ∧ · · · ∧ dxD(τD)
τi ∈{0,1} τ1+···+τD =D−N
(4.4.6)

[where, x(iτ) represents xi if τ = 1, otherwise represents xi if τ = 0.] This diﬀerential form, though simpler, has the property

φS(ω) = (−1)D−N

η(x, x ) = (−1)D−N

η˜(x, x )

x∈ω x ∈S

x∈ω x ∈S

(4.4.7)

80

Finally, we re-write the formula for η˜ using a new notation as follows,

D

η˜(x, x ) = (−1)D−N

Gk(x − x ) (−1)k+1 ·

k=1

sgn(ρ)
ρ∈partD−N (N−Dk)

dxρl(1) ∧ · · · ∧ dxρl(D−N) ∧ dxρr(1) ∧ · · · ∧ dxρr(N−1) (4.4.8)

where, ◦ N−Dk = [1, 2, · · · , k − 1, k + 1, · · · , D] is an ordered set, ◦ partw(A) is the set of all 2 partitions of the ordered set A, such that the ﬁrst partition contains w elements, and each of the partitions contain elements in order. 1
Thus, the ﬁnal formula for the complete invariant for homology class of ω ∈ ZN−1(RD − S) is,

φS(ω) = (−1)D−N

η˜(x, x )

x∈ω x ∈S

D

=

x∈ω k=1 ρ∈partD−N (N−Dk)

(−1)k+1

Gk(x − x ) sgn(ρ) dxρl(1) ∧ · · · ∧ dxρl(D−N)

x ∈S

∧ dxρr(1) ∧ · · · ∧ dxρr(N−1)

D

=

Uρk(x; S) ∧ dxρr(1) ∧ · · · ∧ dxρr(N−1)

x∈ω k=1 ρ∈partD−N (N−Dk)

(4.4.9)

where,

Uρk(x; S) = (−1)k+1 sgn(ρ)

Gk(x − x ) dxρl(1) ∧ · · · ∧ dxρl(D−N)

x ∈S

(4.4.10)

and by convention, S is a top-dimensional cycle covering S such that [S] = 1 ∈ HD−N (S). Also, note that the quantity inside the integral in the formula for φS is a diﬀerential (N −1)-form
in (RD − S). Thus we can integrate it over ω. We represent the diﬀerential (N − 1)-form by ψS

ψS =

Uρk(x; S) ∧ dxρr(1) ∧ · · · ∧ dxρr(N−1)
ρ∈partD−N (N−Dk)

(4.4.11)

1Let us consider an ordered set A = [a1, a2, · · · , aq] with a1 ≤ a2 ≤ · · · ≤ aq (where the inequality sign signiﬁes

order of arrangement and not necessarily the order of magnitude). We represent the set of all ordered 2-partitions

of the set A into w and q − w elements as partw(A), such that for a ρ = [ρl, ρr] ∈ partw(A), ρl and ρr are ordered

sets of w and q − w elements respectively, with the properties that ρl ∩ ρr = ∅, ρl(1) ≤ ρl(2) ≤ · · · ≤ ρl(w) and

ρr(1) ≤ ρr(2) ≤ · · · ≤ ρr(q − w). Then the sign of the partition, sgn(ρ), is deﬁned as the permutation sign of the

ordered set ρl ρr. For example,

part3([1, 3, 6, 9, 5]) =

[[1, 3, 6], [9, 5]] , [[1, 3, 9], [6, 5]] , [[1, 3, 5], [6, 9]] , [[1, 6, 9], [3, 5]] ,

[[1, 6, 5], [3, 9]] , [[1, 9, 5], [3, 6]] , [[3, 6, 9], [1, 5]] , [[3, 6, 5], [1, 9]] , [[3, 9, 5], [1, 6]] , [[6, 9, 5], [1, 3]] .
Then if ρ = [[1, 6, 5], [3, 9]] ∈ part3([1, 3, 6, 9, 5]), we write ρl = [1, 6, 5] and ρr = [3, 9]. Also, the jth element of ρb, b ∈ {l, r} is written as ρb(j). Thus, in the example, ρl(2) = 6.

81

R2

ω

S2

S1

S3 Ω
S4

(a) D = 2, N = 2

R3

S1

S2
Ω

ω
S3 (b) D = 3, N = 2

R3

ω

S3

S1

S4

S2
Ω

(c) D = 3, N = 3

Figure 4.8: Schematic illustration of some lower dimensional cases of the problem. The Cauchy Residue theorem can be applied to (a), Ampere’s law to (b), and Gauss Divergence theorem to (c).

4.4.2 Incorporating Multiple Connected Components of S

So far we have worked with a single connected component of the puncture, namely, S. However,

recall that the original space under consideration was (RD − S), with S =

m i=1

Si,

such

that

each

Si is path connected, compact, closed, locally contractible and orientable. Moreover, by hypothesis,

Si ∩ Sj = ∅, ∀i = j. We have the following proposition in order to compute the homology of the

smaller space, (RD − S), in terms of the larger spaces, (RD − Sk).

Proposition 4.4.1. HN−1(RD − S)

m k=1

HN −1 (RD

−

Sk )

Rm. Where, the ﬁrst isomor-

phism is induced by the direct sum of the inclusion maps ˜ik : (ED − S) → (ED − Sk).

Proof. Detailed proof can be found in Appendix B.3.

Thus, for any ω ∈ ZN−1(ED − S), a complete invariant for the homology class of ω is given by,

 φS1 (ω) 

φS (ω)

= def.

 

φS2 (ω)

 

  

...

  

φSm (ω)

(4.4.12)

where, φSi is given by the formula in Equation (4.4.9). [Note that we have implicitly assumed a inclusion map ˜ik : (ED − S) → (ED − Sk) being applied on ω for computation of the kth component. For simplicity we don’t write it explicitly, since the map is identity as far as computation
is concerned.] Thus, [ω1] = [ω2] if and only if φS (ω1) = φS (ω2), for any ω1, ω2 ∈ ZN−1(ED − S).

4.5 Validations in Low Dimensions
In this section we illustrate the forms that equations (4.4.10) and (4.4.11) take under certain special cases. We compare those with the well-known formulae from complex analysis, electromagnetism and electrostatics that are known to give homology class invariants. Once again, we demonstrate all the computations using a single connected component of S.
82

4.5.1 D = 2, N = 2 :

This particular case has parallels with the Cauchy integral theorem and the Residue theorem from Complex analysis. This formula was used in Section 3.3 for designing a H-signature in the 2dimensional case. Here a singularity manifold, S, is a D − N = 0-dimensional manifold, i.e. a point, the coordinate of which we represent by S = [s1, s2]T (the representative points according to terminology of Chapter 3 - Figure 4.8(a)). Thus, the partitions in (4.4.11) for the diﬀerent values of k are as follows, For k = 1, part0({2}) = {{}, {2}} ,

For k = 2, Thus,

part0({1}) = {{}, {1}}

U11(x)

=

1 2π

(−1)2−2+1+1(1)

x1 |x

− S1 − S|2

1 =
2π

x1 − s1 |x − S|2

U12(x)

=

1 2π

(−1)2−2+2+1(1)

x2 |x

− S2 − S|2

1 =−
2π

x2 − s2 |x − S|2

where the subscripts of U indicate the index of the partition used (in the lists above). Also, note that integration of a 0-form on a 0-dimensional manifold is equivalent to evaluation of the 0-form at the point. Thus,

ψS = U11(x) dx2 + U12(x) dx1

=

1 (x1 − s1) dx2 − (x2 − s2) dx1

2π

|x − S|2

1

1

=

Im

dz

2π

z − Sc

where in the last expression we used the complex variables, z = x1 + ix2 and Sc = s1 + is2. In fact,

from complex analysis (Residue theorem and Cauchy integral theorem) we know that

1 γ z−Sc

dz

(where γ is a closed curve in C) is 2πi if γ encloses Sc, but zero otherwise. This is just the fact that

±1, if Ins(γ) contains S

ψS =

dψS =

γ

Ins(γ)

0, otherwise

where Ins(γ) represents the inside region of the curve γ, i.e. the area enclosed by it.

4.5.2 D = 3, N = 2 :
This particular case has parallels with the Ampere’s Law and the Biot-Savart Law from Electromagnetism. This formula was used in Section 3.4 for designing a H-signature in the 3-dimensional case. Here a singularity manifold, S, is a D − N = 1-dimensional manifold, which, in light of Electromagnetism is a current-carrying line/wire (the skeletons according to terminology of Chapter 3 - Figure 4.8(b)). The partitions in (4.4.11) for the diﬀerent values of k are as follows, For k = 1, part1({2, 3}) = {{2}, {3}} , {{3}, {2}} ,
83

For k = 2, part1({1, 3}) = {{1}, {3}} , {{3}, {1}} , For k = 3, part1({1, 2}) = {{1}, {2}} , {{2}, {1}} ,

Thus,

U11(x) =

1 4π

(−1)3−2+1+1(1)

S

x1 − x1 |x − x |3

dx2

1 =−
4π

U21(x) =

1 4π

(−1)3−2+1+1(−1)

S

x1 − x1 |x − x |3

dx3

=

1 4π

S

x1 − x1 |x − x |3

dx2

S

x1 − x1 |x − x |3

dx3

U12(x) =

1 4π

(−1)3−2+2+1(1)

S

x2 − x2 |x − x |3

dx1

=

1 4π

S

x2 − x2 |x − x |3

dx1

U22(x) =

1 4π

(−1)3−2+2+1(−1)

S

x2 − x2 |x − x |3

dx3

=− 1 4π

S

x2 − x2 |x − x |3

dx3

U13(x) =

1 4π

(−1)3−2+3+1(1)

S

x3 − x3 |x − x |3

dx1

1 =−
4π

S

x3 − x3 |x − x |3

dx1

U23(x) =

1 4π

(−1)3−2+3+1(−1)

S

x3 − x3 |x − x |3

dx2

=

1 4π

S

x3 − x3 |x − x |3

dx2

where, as before, the subscripts of U indicate the index of the partition used (in the lists above).

Thus,

ψS = U11(x) dx3 + U21(x) dx2 + U12(x) dx3 + U22(x) dx1 + U13(x) dx2 + U23(x) dx1

= (U22(x) + U23(x)) dx1 + (U21(x) + U13(x)) dx2 + (U11(x) + U12(x)) dx3

 U22(x) + U23(x)   dx1 

=

 

U21(x) + U13(x)

·∧ 

dx2

 

U11(x) + U12(x)

dx3

=

1 4π



−

x2 −x2 |x−x |3

dx3

+

x3 −x3 |x−x |3

dx2





 

x1 −x1 |x−x |3

dx3

−

x3 −x3 |x−x |3

dx1

 

·

∧





S

−

x1 −x1 |x−x |3

dx2

+

x2 −x2 |x−x |3

dx1



dx1 

dx2

 

dx3

1

dl × (x − x )  dx1 

= 4π S

|x − x |3

·∧ 

dx2

 

dx3

where, bold face indicates column 3-vectors and the cross product “×”: R3 × R3 → R3 is the

elementary cross product operation of column 3-vectors. The operation “·∧” between column vectors

implies element-wise wedge product followed by summation. Also, dl = [ dx1 dx2 dx3]T . It is

not

diﬃcult

to

identify

the

integral

in

the

last

expression,

B

=

1 4π

S

dl ×(x−x ) |x−x |3

with

the

Magnetic

Field vector created by unit current ﬂowing through S, computed using the BiotSavart law. Thus,

if γ is a closed loop, the statement of the Ampre’s circuital law gives, γ B · dl = γ ψS = Iencl , the current enclodes by the loop.

84

4.5.3 D = 3, N = 3 :
This particular case has parallels with the Gauss’s law in Electrostatics, and in general the Gauss Divergence theorem. Here a singularity manifold, S, is a D − N = 0-dimensional manifold, i.e. a point, the coordinate of which is represented by S = [S1, S2, S3]T , which in the light of Electrostatics, is a point charge. The candidate manifolds are 2-dimensional surfaces (Figure 4.8(c)). The partitions in (4.4.11) for the diﬀerent values of k are as follows, For k = 1, part0({2, 3}) = {{}, {2, 3}} , For k = 2, part0({1, 3}) = {{}, {1, 3}} , For k = 3, part0({1, 2}) = {{}, {1, 2}} ,

Here, D − N = 0 implies the integration of (4.4.10) once again becomes evaluation of 0-forms at S.

Thus,

U11(x)

=

1 4π

(−1)3−3+1+1(1)

x1 |x

− S1 − S|3

=1 4π

x1 − S1 |x − S|3

U12(x)

=

1 4π

(−1)3−3+2+1(1) x2 − S2 |x − S|3

1 =−
4π

x2 − S2 |x − S|3

U13(x)

=

1 4π

(−1)3−3+3+1(1) x3 − S3 |x − S|3

=1 4π

x3 − S3 |x − S|3

Thus,

ψS = U11(x) dx2 ∧ dx3 + U12(x) dx1 ∧ dx3 + U13(x) dx1 ∧ dx2

=

1 4π

x1 − S1 |x − S|3

dx2 ∧ dx3

+

x2 − S2 |x − S|3

dx3 ∧ dx1

+

x3 − S3 |x − S|3

dx1 ∧ dx2

+

=

1 x−S 4π |x − S|3

· ∧ [ dx2 ∧ dx3 , dx3 ∧ dx1 , dx1 ∧ dx2]T

(4.5.1)

The quantity E =

1 x−S 4π |x−S|3

can be readily

identiﬁed with the electric

ﬁeld created by an unit

point

charge at S. If A is a closed surface, then A E · dA = A ψS = Qencl , the charge enclosed by A.

4.6 Examples and Applications
We implemented the general formula for computing ψS (ω) in C++ programming language for arbitrary D and N . Singularity manifolds, S, and candidate manifold, ω, are discretized to create simplicial complexes S and ω respectively, thus enabling us to compute the integral in equations (4.4.9) and (4.4.10) as a sum of integrals over pair of simplices. In the following section, for simplicity, we use the same notation of the manifolds to refer to their equivalent simplicial complex. We extensively used the Armadillo linear programming library [74] for all vector and matrix operations, and the GNU Scientiﬁc Library [32] for all the numerical integrations.

4.6.1 An Example for D = 5, N = 3
In Section 4.5 we have shown that the general formulation we proposed in Section 4.4 indeed reduces to known formulae that gives us the homology class invariants for certain low dimensional cases.
85

In this section we present numerical validation for a higher dimensional case. While we want the example to be non-trivial, we would also like it to be such that the results obtained numerically can be interpreted and veriﬁed without much diﬃculty. Hence we consider the following example.
Consider D = 5 and N = 3. The candidate manifold hence needs to be N − 1 = 2-dimensional. We consider a 2-sphere centered at the origin in R5 as the candidate manifold. In particular, we consider a family of candidate manifolds that is described by

ω(RC ) = {x | x21 + x22 + x23 = RC2 , x4 = 0, x5 = 0}

(4.6.1)

Correspondingly, a possible ball Ω(RC ), such that ω(RC ) = ∂Ω(RC ), is hence given by, Ω(RC ) = {x | x21 + x22 + x23 ≤ RC2 , x4 = 0, x5 = 0}

(4.6.2)

A candidate manifold, ω(RC), can be parametrized, which in turn can be conveniently used for

triangulation

(see

Figure

4.9(b)),

using

two

parameters,

θ

∈

[−

π 2

,

π 2

]

and

φ

∈

[0,

2π],

as

follows,

x1 = RC cos(θ) cos(φ) x2 = RC cos(θ) sin(φ) x3 = RC sin(θ) x4 = 0 x5 = 0

(4.6.3)

We consider a single connected component as the singularity manifold, S, that is described by a 2-torus (Figure 4.9(a)) as follows,

x1 = 0 x2 = 0 x3 = (RT + r cos(φ )) cos(θ ) − (RT + r) x4 = (RT + r cos(φ )) sin(θ ) x5 = r sin(φ)

(4.6.4)

with RT > r and the parameters θ ∈ [0, 2π] and φ ∈ [0, 2π]. For all examples that follow, we choose r = 0.8, RT = 1.6.
Now consider the particular candidate manifold ω(1.0) (i.e. RC = 1.0). By numerical computation of integrals in (4.4.9) and (4.4.10), the value of φS(ω(1.0)) that we obtain for the above example is −1. In order to interpret this result we ﬁrst observe that ω(1.0) does not intersect S (i.e. there is no common solution for (4.6.3) and (4.6.4) with RC = 1.0, r = 0.8, RT = 1.6). However on S (Equations (4.6.4)), when x1 = x2 = x4 = x5 = 0, x3 can assume the values 0, −2r, −2RT and −2(RT + r). Thus, if 2r > RC , S intersects Ω(RC ) (the ball whose boundary is ω(RC )) only at one point, i.e. the origin. A simple computation of the tangents revel that the intersection is transverse. Since that is a single transverse intersection with Ω(RC), clearly the linking number between ω(RC) and S (i.e. intersection number between Ω(RC) and S according to Deﬁnition 4.3.2) is ±1 for all RC < 2r, just as indicated by the numerical analysis (i.e. the value of φS(ω(1.0))). The sign is not of importance since that is determined by our choice of orienting the manifold during triangulation.
86

