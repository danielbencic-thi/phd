IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Loading [MathJax]/jax/output/HTML-CSS/fonts/TeX/Math/BoldItalic/Main.js

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Journals & Magazines > IEEE Transactions on Robotics > Volume: 38 Issue: 2
FASTER: Fast and Safe Trajectory Planner for Navigation in Unknown Environments
Publisher: IEEE
Cite This
PDF
  << Results   
Jesus Tordesillas ; Brett T. Lopez ; Michael Everett ; Jonathan P. How
All Authors
View Document
1
Paper
Citation
905
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Related Work
    III.
    Faster
    IV.
    Simulation Results
    V.
    Hardware Results

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
Media
More Like This
Footnotes

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: Planning high-speed trajectories for UAVs in unknown environments requires algorithmic techniques that enable fast reaction times to guarantee safety as more information ... View more
Metadata
Abstract:
Planning high-speed trajectories for UAVs in unknown environments requires algorithmic techniques that enable fast reaction times to guarantee safety as more information about the environment becomes available. The standard approaches that ensure safety by enforcing a “stop” condition in the free-known space can severely limit the speed of the vehicle, especially in situations where much of the world is unknown. Moreover, the ad-hoc time and interval allocation scheme usually imposed on the trajectory also leads to conservative and slower trajectories. This work proposes FASTER (Fast and Safe Trajectory Planner) to ensure safety without sacrificing speed. FASTER obtains high-speed trajectories by enabling the local planner to optimize in both the free-known and unknown spaces. Safety is ensured by always having a safe back-up trajectory in the free-known space. The MIQP formulation proposed also allows the solver to choose the trajectory interval allocation. FASTER is tested extensively in simulation and in real hardware, showing flights in unknown cluttered environments with velocities up to 7.8 m/s, and experiments at the maximum speed of a skid-steer ground robot (2 m/s).
Published in: IEEE Transactions on Robotics ( Volume: 38 , Issue: 2 , April 2022 )
Page(s): 922 - 938
Date of Publication: 28 October 2021
ISSN Information:
INSPEC Accession Number: 21670048
DOI: 10.1109/TRO.2021.3100142
Publisher: IEEE
Funding Agency:
Contents

Acronyms : UAV (Unmanned Aerial Vehicle), MIQP (Mixed-Integer Quadratic Program), RRT (Rapidly-Exploring Random Tree), VIO (Visual-Inertial Odometry), FOV (Field of view).

Code :

    FASTER: https://github.com/mit-acl/faster

    Simulation worlds: https://github.com/jtorde/planning_worlds_gazebo

Video : https://youtu.be/fkkkgomkX10
SECTION I.
Introduction

Despite its numerous applications, high-speed UAV navigation through unknown environments is still an open problem. The desired high speeds together with partial observability of the environment and limits on payload weight make this task especially challenging for aerial robots. Safe operation, in addition to flying fast, is also critical but difficult to guarantee since the vehicle must repeatedly generate collision-free, dynamically feasible trajectories in real-time with limited sensing. Similar to the model predictive control literature, safety is guaranteed by ensuring a feasible solution exists indefinitely.

If we consider R 3 = F ∪ O ∪ U where F , O , U are disjoint sets denoting free-known, occupied-known, and unknown space, respectively, the following hierarchical planning architecture is commonly used: a global planner first finds the shortest piece-wise linear path from the UAV to the goal, avoiding the known obstacles O . Then, a local planner finds a dynamically feasible trajectory in the direction given by this global plan. This local planner should find a fast and safe trajectory that leads the UAV to the goal. These two requirements of safety and speed represent the following tradeoff: on the one hand, safety argues for short trajectories completely contained in F and end points not necessarily near the global plan. As a final stop condition is needed to guarantee safety, short trajectories are generally much slower than long trajectories because the braking maneuver propagates backwards from the end to the initial state of the trajectory. On the other hand, speed argues for longer planned trajectories (usually extending farther than F ) and end points near the global plan.

The typical way to solve the speed versus safety tradeoff is to ensure safety by planning only in F , and then impose a final stop condition near the global plan. This can be achieved by either generating motion primitives that do not intersect O ∪ U [1] – [4] , or by constructing a convex representation of F to be used in an optimization [5] – [7] . The main limitation of these works is that safety is guaranteed at the expense of higher speeds, especially in scenarios where F is small compared to O ∪ U . This article presents an optimization-based approach that solves this limitation by solving for two optimal trajectories at every planning step (see Fig. 1 ). The first trajectory is in U ∪ F and ensures a long planning horizon with an end point on the global plan. The second trajectory is in F , starts from a point along the first trajectory, and it may deviate from the global plan. Only a portion of the first trajectory is actually implemented by the UAV (therefore satisfying the speed requirement), while the second trajectory guarantees safety , since it is contained in F and available at the start of every replanning step. This second trajectory is only implemented if the optimization problem becomes infeasible in the next replanning steps.
Fig. 1.

Safety and Speed tradeoff. O is the occupied-known space ( ), and U is the unknown space ( ). A and E are, respectively, the start and goal locations of the local plan.

Show All

A second limitation, specially for the optimization-based approaches that use convex decomposition, is the choice of the interval and time allocation method. The interval allocation decides in which polyhedron each interval of the trajectory will be located, whereas the time allocation deals with the time spent on each interval (see Fig. 2 ). In order to simplify the interval allocation, a common choice is to set the number of intervals to be the same as the number of polyhedra found, forcing each interval to be in one specific polyhedron. This forces the optimizer to select the end points of each trajectory segment within the overlapping area of two consecutive polyhedra and, therefore, possibly leading to more conservative or longer trajectories. Moreover, since a different time for each interval has to be found, the time allocation calculation is harder, leading to higher replanning times when using optimization techniques to allocate this time, and to nonsmooth or infeasible trajectories when imposing an ad-hoc time allocation. To overcome this limitation, FASTER allows the solver to decide the interval allocation by using a number of intervals greater than the number of polyhedra found [8] and by allocating the same time for all the intervals. This time allocation method is efficiently found through a line search algorithm initialized with the solution at the previous replanning iteration.
Fig. 2.

Interval and time allocation when using a convex decomposition ( ). A and E are, respectively, the start and goal locations of the local plan.

Show All

The planning framework proposed is called FASTER − FA st and S afe T rajectory Plann ER , and is an extension of our two published conference papers [4] , [9] . In summary, this work has the following contributions:

    A framework that ensures feasibility of the entire collision avoidance algorithm and guarantees safety without reducing the nominal flight speed by allowing the local planner to plan in F ∪ U while always having a Safe Trajectory in F .

    Reduced conservatism of the time and interval allocation compared to prior ad-hoc approaches by efficiently finding the time allocated from the result of the previous replanning iteration and then allowing the optimizer to choose the interval allocation.

    Extension of our previous work [4] by proposing a way to compute very cheaply a heuristic of the cost-to-go needed by the local planner to decide which direction is the best one to optimize toward.

    Simulation and hardware experiments showing agile flights in completely unknown cluttered environments, with velocities up to 7.8 m/s, two times faster than previous state-of-the-art methods [4] , [9] . FASTER is also tested on a skid-steer robot, showing hardware experiments at the top speed of the robot (2 m/s).

In particular, the new contributions of this version with respect to the conference papers [4] , [9] are as follows:

    Theoretical analysis: Feasibility theorem that guarantees safety for FASTER.

    Simulation: Cluttered office simulation, which presents a major challenge in terms of both clutterness for obstacle avoidance and limited visibility.

    Hardware: Duplication of the flight volume, achieving velocities up to 7.8 m/s.

    Extension: Skid-steer robot.

Moreover, we also perform a deeper analysis of the role of the Safe Trajectory in terms of safety and speed, a comparison of the performance of the interval allocation versus the time allocation, and a comparison between the flight corridors associated with the safe and whole trajectories.
SECTION II.
Related Work

Different methods have been proposed in the literature for planning, mapping, and the integration of these two (see Fig. 3 ).
Fig. 3.

Classification of the state-of-the-art techniques for planning, mapping, and the integration between these two.

Show All

Planning for UAVs can be classified according to the specific formulation of the optimization problem and the operating space of the local planner.

As far as the optimization problem itself is concerned, most of the current state-of-the-art methods exploit the differential flatness of the quadrotors, and, using an integrator model, minimize the squared norm of a derivative of the position to find a dynamically feasible smooth trajectory [10] – [12] . When there are obstacles present, some methods include them as constraints in an optimization problem, while others take these obstacles into account either after the optimization or during a search-based algorithm.

There are approaches where the obstacle constraints (and sometimes also the input constraints) are either checked after solving the optimization problem, or imposed during a search-based algorithm: some of them use stitched polynomial trajectories that pass through several waypoints obtained running RRT-based methods [10] , [12] , [13] , while others use closed-form solutions or motion-primitive libraries [1] – [3] , [14] – [17] . These methods are usually limited to short trajectories unable to perform complex maneuvers around obstacles. Sometimes these primitives are also used to search over the state space [18] – [20] , often benefiting from ESDF representations to guide the search. However, the search-based methods are usually computationally expensive, especially in cluttered environments.

The other approach is to include the obstacles directly as constraints in an optimization problem. This can be done in the cost function by penalizing the distance to the obstacles [21] , [22] , but this usually leads to computationally expensive distance fields representations and/or nonconvex optimization problems. Another option is to encode the shape of the obstacles in the constraints using successive convexification [23] – [25] or a convex decomposition of the environment [6] , [26] – [30] . The convergence of successive convexification typically depends on the initial guess, and is usually not suitable for real-time planning in unknown cluttered environments. The convex decomposition approach is usually done by decomposing the free-known space as a series of P overlapping polyhedra [5] – [7] . As the trajectory is usually decomposed of N third (or higher)-degree polynomials, to guarantee that the Whole Trajectory is inside the polyhedra, Bézier Curves [7] , [31] , or the sum-of-squares condition [5] , [8] are often used. Moreover, for a trajectory there is both an interval (in which polyhedron each interval is) and a time allocation (how much time is assigned to each interval) problem. For the interval allocation , a usual decision is to use N = P intervals, and force each interval to be inside its corresponding polyhedron [7] . However, this sometimes can be very conservative, since the solver can only choose to place the two extreme points of each interval in the overlapping area of two consecutive polyhedra. Another option, but sometimes with higher computation times, is to use binary variables [5] , [8] to allow the solver to choose the specific interval allocation. For the time allocation , different techniques have been proposed. One way is to impose a fixed time allocation using a specific velocity profile [6] , which can be conservative, or cause infeasibility in the optimization problem if the overlapping area of the polyhedra is not large enough. Other options are to use line search or gradient descent to iteratively obtain these times [10] , [12] , [32] , to use alternating minimization between the spatial and temporal trajectory [33] , or to implement a neural network trained offline [34] . Another option is to decouple the spatial and the temporal trajectory [35] , but, as noted in this work, this may cause infeasibility if the initial and final states are not static.

With regard to the planning space of the local planner, several approaches have been developed. One approach is to use only the most recent perception data [2] , [3] , which requires the desired trajectory to remain within the perception sensor field of view. An alternative strategy is to create and plan trajectories in a map of the environment built using a history of perception data. Within this second category, in some works [4] , [22] , [36] , the local planner only optimizes inside F , which guarantees safety if the local planner has a final stop condition. However, limiting the planner to operating in F and enforcing a terminal stopping condition can lead to conservative, slow trajectories (especially when much of the world is unknown). Higher speeds can be obtained by allowing the local planner to optimize in both the free-known and unknown space ( F ∪ U ), but with no guarantees that the trajectory is safe or will remain feasible.

Moreover, two main categories can be highlighted in the mapping methods proposed in the literature: memory-less and fused-based methods. The first category includes the approaches that rely only on instantaneous sensing data, using only the last measurement, or weighting the data [14] , [28] , [37] , [38] . These approaches are in general unable to reason about obstacles observed in the past [2] , [3] , and are specially limited when a sensor with small FOV is used. The second category is the fusion-based approach, in which the sensing data are fused into a map, usually in the form of an occupancy grid or distance fields [39] , [40] . Two drawbacks of these approaches are the influence of the estimation error, and the fusion time.

Finally, several approaches have been proposed for the integration between the planner and the mapper: reactive and map-based planners. Reactive planners often use a memory-less representation of the environment, and closed-form primitives are usually chosen for planning [2] , [3] . These approaches often fail in complex cluttered scenarios. On the other hand, map-based planners usually use occupancy grids or distance fields to represent the environment. These planners either plan all the trajectory at once or implement a receding horizon planning framework, optimizing trajectories locally and based on a global planner. Moreover, when unknown space is also taken into consideration, several approaches are possible: some use optimistic planners that consider unknown space as free [41] , [42] , while in other works an optimistic global planner is used combined with a conservative local planner [21] , [22] .
SECTION III.
Faster

The notation used throughout this article is shown in Fig. 4 : M is a sliding map centered on L , the current position of the UAV. F and O will denote the free-known and occupied-known spaces, respectively. Similarly, F Unknown and O Unknown will denote the free-unknown and occupied-unknown spaces, respectively. The total unknown space, denoted as U , is, therefore, U = F Unknown ∪ O Unknown , and F and O are completely contained inside the map ( F ∪ O ⊆ M ), and all the space outside the map is inside U ( R 3 ∖ M ⊆ U ). Note also that FASTER is completely in 3-D, but some illustrations are in 2-D for visualization purposes.
Fig. 4.

Notation used for the different spaces. L is the current position of the UAV, and \mathcal {M} is the sliding map around the vehicle.

Show All
A. Mapping

A body-centered sliding map \mathcal {M} (in the form of an occupancy grid map) is used in this work. A rolling map is desirable since it reduces the influence of the drift in the estimation error. We fuse a depth map into the occupancy grid using the 3-D Bresenham’s line algorithm for ray-tracing [43] . Both \mathcal {O} and \mathcal {U} are inflated by the radius of the UAV to ensure safety.
B. Global Planner

In the proposed framework, Jump Point Search (JPS) is used as a global planner to find the shortest piece-wise linear path from the current position to the goal. JPS was chosen instead of A* because it runs an order of magnitude faster, while still guaranteeing completeness and optimality [6] , [44] . The only assumption of JPS is a uniform grid, which holds in our case.
C. Convex Decomposition

A convex decomposition is done around part of the piece-wise linear path obtained by JPS. To do this convex decomposition, we rely on the approach proposed by [6] : A polyhedron is found around each segment of the piece-wise linear path by first inflating an ellipsoid aligned with the segment, and then computing the tangent planes at the points of the ellipsoid that are in contact with the obstacles. The reader is referred to [6] for a detailed explanation. Given a piece-wise linear path with P segments, we will denote the sequence of P overlapping polyhedra as \lbrace (\boldsymbol{{A}}_p, \boldsymbol{{c}}_p)\rbrace,\;p=0:P-1 .
D. Local Planner

For the local planner, we distinguish these three different jerk-controlled trajectories (see Fig. 5 ).

    \color{red}{\textbf{Whole\; Trajectory}:} This trajectory goes from A to E , and it is contained in \mathcal {F}\cup \mathcal {U} . It has a final stop condition.

    \color{blue}\textbf{{Safe\; Trajectory}:} It goes from R to F , where R is a point in the Whole Trajectory, and F is any point inside the polyhedra obtained by doing a convex decomposition of \mathcal {F} . It is completely contained in \mathcal {F} , and it also has a final stop condition to guarantee safety.

    \color{green}\bf{{Committed Trajectory}:} This trajectory consists of the following two pieces: The first part is the interval A \rightarrow R of the Whole Trajectory. The second part is the Safe Trajectory. It will be shown later that this trajectory is also guaranteed to be inside \mathcal {F} . This trajectory is the one that the UAV will keep executing in case no feasible solutions are found in the next replanning steps.

Fig. 5.

Trajectories used by FASTER: The Committed and Safe Trajectories are inside \mathcal {F} , while the Whole Trajectory is inside \mathcal {F}\cup \mathcal {U} .

Show All

The quadrotor is modeled using triple integrator dynamics with state vector \mathbf {x}^T = [ \boldsymbol{{x}}^T \; \boldsymbol{{\dot{x}}}^T \; \boldsymbol{{\ddot{x}}}^T \; ] = [\boldsymbol{{x}}^T \; \boldsymbol{{v}}^T \; \boldsymbol{{a}}^T] and control input \mathbf {u} = \boldsymbol{{\dddot{x}}} = \boldsymbol{{j}} (where \boldsymbol{{x}} , \boldsymbol{{v}} , \boldsymbol{{a}} , and \boldsymbol{{j}} are the vehicle’s position, velocity, acceleration, and jerk, respectively).

In the optimization problem solved by the local planner, the trajectory is divided in N intervals (see Fig. 6 ). Let n=0:N-1 denote the specific interval of the trajectory, p=0:P-1 the specific polyhedron and dt the time allocated per interval (same for every interval n ). If \boldsymbol{{j}}(t) is constrained to be constant in each interval n=0:N-1 , then the Whole Trajectory will be a spline consisting of third-degree polynomials. Matching the cubic form of the position for each interval \begin{equation*} \boldsymbol{x}_{n}(\tau)=\mathbf {a}_{n}\tau ^{3}+\mathbf {b}_{n}\tau ^{2}+\mathbf {c}_{n}\tau +\mathbf {d}_{n},\; \; \tau \in [0,dt] \end{equation*}
View Source \begin{equation*} \boldsymbol{x}_{n}(\tau)=\mathbf {a}_{n}\tau ^{3}+\mathbf {b}_{n}\tau ^{2}+\mathbf {c}_{n}\tau +\mathbf {d}_{n},\; \; \tau \in [0,dt] \end{equation*} with the expression of a cubic Bézier curve \begin{equation*} \boldsymbol{x}_{n}(\tau)=\sum _{j=0}^{3}\left(\begin{array}{c}3\\ j \end{array}\right)\left(1-\frac{\tau }{dt}\right)^{3-j}\left(\frac{\tau }{dt}\right)^{j}\boldsymbol{r}_{nj},\;\; \tau \in [0,dt] \end{equation*}
View Source \begin{equation*} \boldsymbol{x}_{n}(\tau)=\sum _{j=0}^{3}\left(\begin{array}{c}3\\ j \end{array}\right)\left(1-\frac{\tau }{dt}\right)^{3-j}\left(\frac{\tau }{dt}\right)^{j}\boldsymbol{r}_{nj},\;\; \tau \in [0,dt] \end{equation*} we can solve for the four control points \boldsymbol{{r}}_{nj} (j=0:3) associated with each interval n : \begin{align*} & \boldsymbol{r}_{n0}=\mathbf {d}_{n}, \qquad \boldsymbol{r}_{n1}=\frac{\mathbf {c}_{n}dt+3\mathbf {d}_{n}}{3} & \\ & \boldsymbol{r}_{n2}=\frac{\mathbf {b}_{n}dt^{2}+2\mathbf {c}_{n}dt+3\mathbf {d}_{n}}{3} & \\ & \boldsymbol{r}_{n3}=\mathbf {a}_{n}dt^{3}+\mathbf {b}_{n}dt^{2}+\mathbf {c}_{n}dt+\mathbf {d}_{n}. & \end{align*}
View Source \begin{align*} & \boldsymbol{r}_{n0}=\mathbf {d}_{n}, \qquad \boldsymbol{r}_{n1}=\frac{\mathbf {c}_{n}dt+3\mathbf {d}_{n}}{3} & \\ & \boldsymbol{r}_{n2}=\frac{\mathbf {b}_{n}dt^{2}+2\mathbf {c}_{n}dt+3\mathbf {d}_{n}}{3} & \\ & \boldsymbol{r}_{n3}=\mathbf {a}_{n}dt^{3}+\mathbf {b}_{n}dt^{2}+\mathbf {c}_{n}dt+\mathbf {d}_{n}. & \end{align*}

Fig. 6.

Each interval n=0:N-1 of the trajectory is a third-degree polynomial, with a total time of dt per interval. \tau \in [0,dt] denotes a local reference of the time inside an interval, and p=0:P-1 denotes the polyhedron.

Show All

Let us introduce the binary variables b_{np} , with p=0:P-1 and n=0:N-1 ( P variables for each interval n=0:N-1 ). As a Bézier curve is contained in the convex hull of its control points, we can ensure that the trajectory will be completely contained in this convex corridor by forcing that all the control points of an interval n are in the same polyhedron [7] , [31] with the constraint [b_{np}=1\Rightarrow \boldsymbol{r}_{nj} \in \text{polyhedron } p \;\; \forall j] , and at least in one polyhedron with the constraint \sum _{p=0}^{P-1}b_{np}\geq 1 . With this formulation, the optimizer is free to choose the specific interval allocation (i.e., which interval is inside which polyhedron). The complete MIQP solved in each replanning step for both the Safe and the Whole Trajectories is as follows: \begin{align*} \min _{\boldsymbol{j}_{n}, b_{np}} & \sum _{n=0}^{N-1}\left\Vert \mathbf {j}_{n}\right\Vert ^{2}dt\\ \text {s.t. } & \mathbf {x}_{0}(0)=\mathbf {x}_{\text{init}} \\ & \mathbf {x}_{N-1}(dt)=\mathbf {x}_{\text{final}} \\ & \boldsymbol{x}_{n}(\tau)=\mathbf {a}_{n}\tau ^{3}+\mathbf {b}_{n}\tau ^{2}+\mathbf {c}_{n}\tau +\mathbf {d}_{n}\quad \;\forall n\quad \forall \tau \in [0,dt] & \\ & \boldsymbol{v}_{n}(\tau)=\dot{\boldsymbol{x}}_{n}(\tau)\;\qquad \qquad \qquad \qquad \;\forall n\quad \forall \tau \in [0,dt] \\ & \boldsymbol{a}_{n}(\tau)=\dot{\boldsymbol{v}}_{n}(\tau)\;\qquad \qquad \qquad \qquad \;\forall n\quad \forall \tau \in [0,dt] \\ & \mathbf {j}_{n}=6\mathbf {a}_{n}\qquad\qquad\qquad\qquad\qquad\qquad \forall n & \\ & b_{np}=1\Rightarrow \left\lbrace \begin{array}{c}\boldsymbol{A}_{p}\boldsymbol{r}_{n0}\leq \boldsymbol{c}_{p}\\ \boldsymbol{A}_{p}\boldsymbol{r}_{n1}\leq \boldsymbol{c}_{p}\\ \boldsymbol{A}_{p}\boldsymbol{r}_{n2}\leq \boldsymbol{c}_{p}\\ \boldsymbol{A}_{p}\boldsymbol{r}_{n3}\leq \boldsymbol{c}_{p} \end{array}\right.\quad \forall n\quad \forall p & \\ & \sum _{p=0}^{P-1}b_{np}\geq 1\qquad \qquad \quad \;\;\; \forall n & \\ & b_{np}\in \lbrace 0,1\rbrace \qquad \qquad \qquad\;\; \forall n\quad \forall p & \\ & \mathbf {x}_{n+1}(0)=\mathbf {x}_{n}(dt)\quad \qquad \;\; n=0:N-2 & \\ & \left\Vert \boldsymbol{v}_{n}(0)\right\Vert _{\infty }\leq v_{\text{max}} \qquad \quad \;\forall n & \\ & \left\Vert \boldsymbol{a}_{n}(0)\right\Vert _{\infty }\leq a_{\text{max}}\qquad \quad \;\forall n & \\ & \left\Vert \boldsymbol{j}_{n}\right\Vert _{\infty }\leq j_{\text{max}}\qquad \quad \quad \;\;\;\forall n. & \tag{1} \end{align*}
View Source \begin{align*} \min _{\boldsymbol{j}_{n}, b_{np}} & \sum _{n=0}^{N-1}\left\Vert \mathbf {j}_{n}\right\Vert ^{2}dt\\ \text {s.t. } & \mathbf {x}_{0}(0)=\mathbf {x}_{\text{init}} \\ & \mathbf {x}_{N-1}(dt)=\mathbf {x}_{\text{final}} \\ & \boldsymbol{x}_{n}(\tau)=\mathbf {a}_{n}\tau ^{3}+\mathbf {b}_{n}\tau ^{2}+\mathbf {c}_{n}\tau +\mathbf {d}_{n}\quad \;\forall n\quad \forall \tau \in [0,dt] & \\ & \boldsymbol{v}_{n}(\tau)=\dot{\boldsymbol{x}}_{n}(\tau)\;\qquad \qquad \qquad \qquad \;\forall n\quad \forall \tau \in [0,dt] \\ & \boldsymbol{a}_{n}(\tau)=\dot{\boldsymbol{v}}_{n}(\tau)\;\qquad \qquad \qquad \qquad \;\forall n\quad \forall \tau \in [0,dt] \\ & \mathbf {j}_{n}=6\mathbf {a}_{n}\qquad\qquad\qquad\qquad\qquad\qquad \forall n & \\ & b_{np}=1\Rightarrow \left\lbrace \begin{array}{c}\boldsymbol{A}_{p}\boldsymbol{r}_{n0}\leq \boldsymbol{c}_{p}\\ \boldsymbol{A}_{p}\boldsymbol{r}_{n1}\leq \boldsymbol{c}_{p}\\ \boldsymbol{A}_{p}\boldsymbol{r}_{n2}\leq \boldsymbol{c}_{p}\\ \boldsymbol{A}_{p}\boldsymbol{r}_{n3}\leq \boldsymbol{c}_{p} \end{array}\right.\quad \forall n\quad \forall p & \\ & \sum _{p=0}^{P-1}b_{np}\geq 1\qquad \qquad \quad \;\;\; \forall n & \\ & b_{np}\in \lbrace 0,1\rbrace \qquad \qquad \qquad\;\; \forall n\quad \forall p & \\ & \mathbf {x}_{n+1}(0)=\mathbf {x}_{n}(dt)\quad \qquad \;\; n=0:N-2 & \\ & \left\Vert \boldsymbol{v}_{n}(0)\right\Vert _{\infty }\leq v_{\text{max}} \qquad \quad \;\forall n & \\ & \left\Vert \boldsymbol{a}_{n}(0)\right\Vert _{\infty }\leq a_{\text{max}}\qquad \quad \;\forall n & \\ & \left\Vert \boldsymbol{j}_{n}\right\Vert _{\infty }\leq j_{\text{max}}\qquad \quad \quad \;\;\;\forall n. & \tag{1} \end{align*}

This problem is solved using Gurobi [45] . The decision variables of this optimization problem are the binary variables b_{np} and the jerk along the trajectory \boldsymbol{j}_{n} . \mathbf {x}_{\text{init}} and \mathbf {x}_{\text{final}} denote the initial and final states of the trajectory, respectively. The time dt allocated per interval is computed as \begin{equation*} { dt=f\cdot \max \lbrace T_{v_x},T_{v_y}, T_{v_z}, T_{a_x},T_{a_y},T_{a_z},T_{j_x},T_{j_y},T_{j_z}\rbrace /N } \tag{2} \end{equation*}
View Source \begin{equation*} { dt=f\cdot \max \lbrace T_{v_x},T_{v_y}, T_{v_z}, T_{a_x},T_{a_y},T_{a_z},T_{j_x},T_{j_y},T_{j_z}\rbrace /N } \tag{2} \end{equation*} where T_{v_i} , T_{a_i} , T_{j_i} are solution of the constant-input motions in each axis i=\lbrace x,y,z\rbrace by applying v_{\text{max}} , a_{\text{max}} , and j_{\text{max}} , respectively. f \geq 1 is a factor that is obtained according to the solution of the previous replanning step (see Fig. 7 ): Denoting f_{\text{worked},k-1} as the factor that made the optimization feasible in the replanning step k-1 , in the replanning step k the optimizer will try values of f (in increasing order) in the interval [f_{\text{worked},k-1}-\gamma,f_{\text{worked},k-1}+\gamma ^{\prime }] until the problem converges. Here, \gamma and \gamma ^{\prime } are constant values chosen by the user. Note that, if f=1 , then dt is a lower bound on the minimum time per interval required for the problem to be feasible. Therefore, only factors f\geq 1 are tried. This approach is essentially a line search for the time allocation, with the goal of trying to obtain the smallest dt that makes the optimization feasible (leading therefore to faster trajectories), but at the same time trying to minimize the number of trials with different dt needed until convergence.

Fig. 7.

Dynamic adaptation of the factor used to compute the heuristic of the time allocated per interval ( dt ): For iteration k , the range of factors used is taken around the factor that worked in the iteration k-1 . As f=1 is the lower bound that makes the problem feasible, only factors f\geq 1 are tried.

Show All

E. Complete

Algorithm 1 gives the full approach (see also Figs. 8 and 9 ). Let L be the current position of the UAV. The point A is chosen in the Committed Trajectory of the previous replanning step with an offset \delta t from L . This offset \delta t is computed by multiplying the total time of the previous replanning step by \alpha \geq 1 (typically \alpha \approx 1.25 ). The idea here is to dynamically change this offset to ensure that most of the time the solver can find the next solution in less than \delta t . Then, the final goal G_{\text{term}} is projected into the sliding map \mathcal {M} (centered on the UAV) in the direction \overrightarrow{G_{\text{term}}A} to obtain the point G (line 4). Next, we run JPS from A to G (line 5) to obtain \color{green}{\text{JPS}_a} .
Fig. 8.

Illustration for Alg. 1 . One unknown obstacle is shown with dotted line.

Show All
Fig. 9.

Illustration of all the trajectories involved in Alg. 1 and their associated velocity profiles. \mathcal {U} is the unknown space ( ), and k is the replanning step.

Show All

The local planner then has to decide which direction is the best one to optimize toward (lines 7–17). Instead of blindly trusting the last JPS solution ( \color{PineGreen}{\text{JPS}_a} ) as the best direction for the local planner to optimize (note that JPS is a zero-order model, without dynamics encoded), we take into account the dynamics of the UAV in the following way: First of all, we modify the \color{Peach}{\text{JPS}_{k-1}} so that it does not collide with the new obstacles seen (see Fig. 10 ): we find the points I_1 and I_2 (first and last intersections of \color{Peach}{\text{JPS}_{k-1}} with \mathcal {O} ) and run JPS three times, so A \rightarrow I_1 , I_1 \rightarrow I_2 , and I_2 \rightarrow G . Hence, the modified version, denoted by \color{Magenta}{\text{JPS}_{b}} , will be the concatenation of these three paths. Note that by using A \rightarrow I_1 , I_1 \rightarrow I_2 , and I_2 \rightarrow G , we are forcing the combined path to pass through the points A , I_1 , I_2 , and G (all of which belonged to \color{Peach}{\text{JPS}_{k-1}} ), and therefore, this gives a close approximation to \color{Peach}{\text{JPS}_{k-1}} , while avoiding \mathcal {O} .
Fig. 10.

Choice of the direction to optimize. At t=t_{k-1} , the JPS solution chosen was \color{Peach}{\text{JPS}_{k-1}} . At t=t_{k} , JPS is run again to obtain \color{PineGreen}{\text{JPS}_a} , and \color{Peach}{\text{JPS}_{k-1}} is modified so that it does not collide with \mathcal {O} , obtaining \color{Magenta}{\text{JPS}_{b}} . A heuristic of the cost-to-go in each direction is computed, and the direction with the lowest cost is chosen as the one toward which the local planner will optimize. By using A \rightarrow I_1 , I_1 \rightarrow I_2 , and I_2 \rightarrow G , \color{Magenta}{\text{JPS}_{b}} will pass through the points A , I_1 , I_2 , and G (all of which belonged to \color{Peach}{\text{JPS}_{k-1}} ), and therefore, this gives a close approximation to \color{Peach}{\text{JPS}_{k-1}} , while avoiding \mathcal {O} .

Show All

Then, we compute a lower bound on dt using Eq. (2) for both A \rightarrow C and A \rightarrow D , where C and D are the intersections of the previous JPS paths with a sphere \mathcal {S} of radius r centered on A , where r is specified by the user. Next, we find the cost-to-go associated with each direction by adding this dt_a (or dt_b ) and the time it would take the UAV to go from C (or D ) to G following the JPS solution flying at v_{\text{max}} . Finally, the one with lowest cost is chosen, so \text{JPS}_k\leftarrow \underset{\{\color{PineGreen}{\text{JPS}_{a}},\color{Magenta}{\text{JPS}_{b}}\}}{\rm argmin}\{J_{a},J_{b}\} , which is then the direction toward which the local planner optimizes. To save computation time, this decision between \color{PineGreen}{\text{JPS}_a} and \color{Magenta}{\text{JPS}_{b}} is made only if the angle \angle CAD exceeds a certain threshold \alpha _{0} (typically 15^{\circ } ). Note that \angle CAD gives a measure of how much the JPS solution has changed with respect to the iteration k-1 . A small angle indicates that \color{PineGreen}{\text{JPS}_a} and \color{Peach}{\text{JPS}_{k-1}} are very similar (at least within the sphere \mathcal {S} ), and that therefore the direction of the local plan will not differ much from the iteration k-1 .

The \color{red}{\text{Whole Trajectory}} (lines 18–21) is obtained as follows. We do the convex decomposition [6] of \mathcal {U} \cup \mathcal {F} around the part of \text{JPS}_{k} that is inside the sphere \mathcal {S} , which we denote as \text{JPS}_{\text{in}} . This gives a series of overlapping polyhedra that we denote as \text{Poly}_{\text{Whole}} . Then, the MIQP in (1) is solved using these polyhedral constraints to obtain the Whole Trajectory.

The \color{blue}{\text{Safe Trajectory}} is computed as in lines 22–27. First, we compute the point H as the intersection between the Whole Trajectory and \mathcal {U} . Then, we have to choose the point R along the Whole Trajectory as the start of the Safe Trajectory. To do this, note that, on the one hand, R should be chosen as far as possible from A , so that \delta t can be chosen larger in the next replanning step, which helps to guarantee that A is not chosen on the Safe Trajectory (where the braking maneuver happens). On the other hand, however, a point R too close to H may lead to an infeasible problem for the Safe Trajectory optimizer. We propose two ways to compute R : The first one is to choose it with an offset \delta t^{\prime } from A , where \delta t^{\prime } is computed by multiplying the previous replanning time by \beta \geq 1 . The second (and better) way to solve this tradeoff is the following one: we can choose R as the nearest state to H (in the segment A\rightarrow H of the Whole Trajectory) that is not in inevitable collision with \mathcal {U} . To compute an approximation of this state in a very efficient way, we choose R as the last point (going from A to H along the Whole Trajectory) that satisfies \begin{equation*} \text{sign}\left[\boldsymbol{v}_{R,j}\left(\boldsymbol{x}_{H,j}-\boldsymbol{x}_{R,j}\right)\right]\cdot \frac{\boldsymbol{v}_{R,j}^{2}}{2\left|a_{\text{max}}\right|}< \left|\boldsymbol{x}_{H,j}-\boldsymbol{x}_{R,j}\right| \end{equation*}
View Source \begin{equation*} \text{sign}\left[\boldsymbol{v}_{R,j}\left(\boldsymbol{x}_{H,j}-\boldsymbol{x}_{R,j}\right)\right]\cdot \frac{\boldsymbol{v}_{R,j}^{2}}{2\left|a_{\text{max}}\right|}< \left|\boldsymbol{x}_{H,j}-\boldsymbol{x}_{R,j}\right| \end{equation*} where \boldsymbol{v}_{R,j} , \boldsymbol{x}_{R,j} , and \boldsymbol{x}_{H,j} are, respectively, the velocity of R , the position of R , and the position of H in the axes j=\lbrace x,y\rbrace . Here, we have approximated the system as a double integrator model in each axis and, hence, \frac{\boldsymbol{v}_{R,j}^{2}}{2|a_{\text{max}}|} is the minimum stopping distance. Due to these two approximations (double integrator and decoupling in axes x and y ), this heuristic may be conservative. We ignore the axis z in this computation to reduce the conservativeness of this heuristic.

Note that even if this heuristic leads to a choice of R for which no feasible collision-free (with \mathcal {U}\cup \mathcal {O} ) trajectory exists, the optimizer will not find a solution in that replanning step and, therefore, will continue executing the solution of the previous replanning step.

After choosing the point R , we do the convex decomposition of \mathcal {F} using the part of \text{JPS}_{\text{in}} that is in \mathcal {F} , obtaining the polyhedra \text{Poly}_{\text{Safe}} . Then, we solve the MIQP from R to any point F inside \text{Poly}_{\text{Safe}} (this point F is chosen by the optimizer).

In both of the convex decompositions presented earlier, one polyhedron is created for each segment of the piecewise linear paths. To obtain a less conservative solution (i.e., larger polyhedra), we first check the length of segments of the JPS path, creating more vertexes if this length exceeds a certain threshold l_{\text{max}} . Moreover, we truncate the number of segments in the path to ensure that the number of polyhedra found does not exceed a threshold P_{\text{max}} . This helps reduce the computation times (see Section IV ).

Finally (line 28), we compute the \color{ForestGreen}{\text{Committed Trajectory}} by concatenating the piece A \rightarrow R of the Whole Trajectory, and the Safe Trajectory. Note that in this algorithm we have run two decoupled optimization problems per replanning step: 1) one for the Whole Trajectory, and 2) one for the Safe Trajectory. This ensures that the piece A \rightarrow R is not influenced by the braking maneuver R \rightarrow F , and therefore, it guarantees a higher nominal speed on this first piece. The intervals L \rightarrow A and A \rightarrow R have been designed so that at least one replanning step can be solved within that interval.

The UAV will continue executing the trajectory of the previous replanning step ( \text{Committed}_{k-1} ) if one of these three scenarios happens.

    Scenario 1 : Either of the two optimizations is infeasible.

    Scenario 2 : The piece A-R intersects \mathcal {U} .

    Scenario 3 : The replanning takes longer than \delta t .

In Alg. 1 , it is required to compute the intersection between a piece-wise linear path (the solution of JPS) and a voxel grid ( \mathcal {U} or \mathcal {O} ) to obtain the points I_1 , I_2 , or M . To do this in an efficient way, we use Alg. 2 , depicted in Fig. 11 . We first find the nearest neighbor N from the beginning of the piece-wise linear path A (line 4), and compute the intersection M between the path and a sphere \mathcal {S} centered on A with radius equal to the distance between A and N (line 9). As it is guaranteed that all the points of the path that are inside \mathcal {S} do not intersect with the voxel grid, we can repeat the same procedure again, but this time starting from M . This process continues until the distance to the nearest neighbor is below some threshold \epsilon >0 (lines 6–7). Note that, instead of Alg. 2 , another option would be to represent \mathcal {F} as a voxel grid, and then use standard ray-tracing (such as the 3-D Bresenham’s line Algorithm [43] ) for each of the segments of the piece-wise linear path. However, this might be very computationally expensive for grids \mathcal {F} with small voxel sizes.
Fig. 11.

Illustration of Alg. 2 to efficiently find (an approximation of) the intersection between a piece-wise linear path and a voxel grid. \mathcal {U} and \text{JPS}_k are used in this figure, but in FASTER this algorithm is also used with \mathcal {O} and \text{JPS}_{k-1}

Show All
F. Feasibility Theorem

We can now state the following feasibility theorem for FASTER, which guarantees that all the Committed Trajectories are completely contained inside free space (known or unknown), and that, therefore, safety is guaranteed. Here, k denotes the replanning step.
Assumption 1:

The map \mathcal {M} is noise-free and the world is static: \mathcal {F}_k \cup \mathcal {F}_{{\text {Unknown}},k}=\mathcal {F}_{k+1} \cup \mathcal {F}_{{\text {Unknown}},k+1},\;\;\forall k .
Theorem 1:

Under the assumption 1 , Alg. 1 achieves \begin{equation*} {\text {Committed}}_k \subseteq \mathcal {F}_k \cup \mathcal {F}_{{\text {Unknown}},k}\quad \;\; \forall k. \end{equation*}
View Source \begin{equation*} {\text {Committed}}_k \subseteq \mathcal {F}_k \cup \mathcal {F}_{{\text {Unknown}},k}\quad \;\; \forall k. \end{equation*}

Proof:

This theorem can be proven by induction:

    Base case : \text{Committed}_1 is the union of A_1\rightarrow R_1 and the Safe Trajectory. The interval A_1\rightarrow R_1 is in \mathcal {F}_1 because it has been checked against collision with \mathcal {U}_1 and is contained in a convex corridor that does not intersect \mathcal {O}_1 . The Safe Trajectory is inside \mathcal {F}_1 by construction. Therefore, \text{Committed}_1\subseteq \mathcal {F}_1 \cup \mathcal {F}_{\text{Unknown},1} .

    Recursion : If \text{Committed}_k \subseteq \mathcal {F}_k \cup \mathcal {F}_{\text{Unknown},k} , two different situations can happen in iteration k+1 :

        One of the scenarios 1, 2, or 3 happens. The algorithm will choose \text{Committed}_{k+1}=\text{Committed}_{k} , and by the assumption 1 we have that \text{Committed}_{k+1} \subseteq \mathcal {F}_{k+1} \cup \mathcal {F}_{\text{Unknown},k+1} .

        In any other case, the trajectory obtained ( \text{Committed}_{k+1} ) will be inside \mathcal {F}_{k+1} by construction of the algorithm.

    Hence, we conclude that \begin{eqnarray*} && \text{Committed}_k \subseteq \mathcal {F}_k \cup \mathcal {F}_{\text{Unknown},k}\\ && \Rightarrow \text{Committed}_{k+1} \subseteq \mathcal {F}_{k+1} \cup \mathcal {F}_{\text{Unknown},k+1}. \end{eqnarray*}
    View Source \begin{eqnarray*} && \text{Committed}_k \subseteq \mathcal {F}_k \cup \mathcal {F}_{\text{Unknown},k}\\ && \Rightarrow \text{Committed}_{k+1} \subseteq \mathcal {F}_{k+1} \cup \mathcal {F}_{\text{Unknown},k+1}. \end{eqnarray*}

\blacksquare
Remark 1:

The theorem does not assume that \mathcal {F}_k \subseteq \mathcal {F}_{k+1} . In other words, it does not assume that the size of the free-known space always increases: \mathcal {F}_k \subseteq \mathcal {F}_{k+1} is not necessarily true due to the sliding map. Note, however, that the proof does not depend on the shape of the map nor on the length of the history kept in this map. Hence, the theorem is also valid for the following two cases:

    a nonsliding global map \mathcal {M}\equiv \mathbb {R}^3 .

    a map \mathcal {M}\equiv {\text{FOV}} , obtained uniquely by considering the instantaneous sensing data and, therefore, not keeping history in the map.

Remark 2:

By allowing the algorithm to choose {\text {Committed}}_{k+1}={\text {Committed}}_{k} (which occurs when one of the scenarios 1, 2, or 3 happen), in iteration k+1 the UAV may commit to a trajectory that has some parts outside the map \mathcal {M}_{k+1} . As proven above, it is still guaranteed that {\text {Committed}}_{k+1} \subseteq \mathcal {F}_{k+1} \cup \mathcal {F}_{{\text {Unknown}},k+1} . This constitutes a form of data compression, where the information of a part of the world being free (which was obtained in iteration {k} or before) is embedded in the trajectory itself and not directly in the map \mathcal {M}_{k+1} .
G. Controller

To track the trajectory obtained by FASTER, we used the cascade controller presented in [46] . The yaw of the UAV is chosen such that the camera of the UAV points to M (intersection between \text{JPS}_k and \mathcal {U} , see Fig. 8 ). This controller is used in all the UAV simulation and hardware experiments of this article. In the real hardware experiments, position, velocity, attitude, and IMU biases are estimated by fusing propagated IMU measurements with an external motion capture system.
SECTION IV.
Simulation Results
A. Forest, Bugtrap, and Office Simulations

We evaluate the performance of the proposed algorithm in different simulated scenarios. The simulator uses C++ custom code for the dynamics engine, integrating the nonlinear differential equations of the UAV using the Runge–Kutta method. Gazebo [47] is used to simulate perception data in the form of a depth map. In all these simulations, the depth camera has a horizontal FOV of 90^{\circ } . The sensing range is 5 m for the first simulation (corner environment), and 10 m for the rest.

We now test FASTER in ten random forest environments with an obstacle density of 0.1 obstacles/m ^2 (see Fig. 12 ), and compare the flight distances achieved against the following seven approaches.

    Incremental approach (no goal selection).

    Random goal selection.

    Optimistic RRT ^\star (unknown space = free).

    Conservative RRT ^\star (unknown space = occupied).

    “Next-best-view” planner (NBVP) [48] .

    Safe local exploration [22] .

    Multifidelity [4] .

Fig. 12.

Forest (left) and bugtrap (right) environments used in the simulation. The forest is 50 m × 50 m, and the grid in the bugtrap environment is 1 m × 1 m.

Show All

The first six methods are described in [22] , and [4] is our previous algorithm. The results in Table I highlight that FASTER achieves a 8-51\% improvement in the total distance flown. Completion times are compared in Table II to [4] (time values are not available for all other algorithms in Table I ). FASTER achieves an improvement of 52% in the completion time. The dynamic constraints imposed for the results of this table are (per axis) v_{\text{max}}=5 m/s, a_{\text{max}}= 5 m/s ^2 , and j_{\text{max}}= 8 m/s ^3 . The velocity profiles obtained for one random forest simulation are shown in Fig. 13 .
TABLE I Distances Obtained in 10 Random Forest Simulations
TABLE II Comparison Between [4] and FASTER of Flight Times in the Forest Simulation
TABLE III Comparison Between [4] and FASTER of Flight Distances and Times in a Bugtrap Simulation
Fig. 13.

Velocity profile in a random forest simulation. On the left the results of our previous work [4] and on the right FASTER.

Show All

We also test FASTER using the bugtrap environment shown in Fig. 12 , and obtain the results that appear on Table III . Both algorithms have a similar total distance, but FASTER achieves an improvement of 63% on the total flight time. For both cases, the dynamic constraints imposed are v_{\text{max}}=10 m/s, a_{\text{max}}= 10 m/s ^2 , and j_{\text{max}}= 40 m/s ^3 . The velocity profile achieved along the trajectory can be seen in Fig. 14 .
Fig. 14.

Velocity profile in the bugtrap simulation. On the left the results of our previous work [4] and on the right FASTER.

Show All

Finally, we test FASTER in an office environment, obtaining the velocity profile shown in Fig. 15 and the distances and flight times shown in Table IV . In this case, the distance flown by FASTER was slightly longer than the one by [4] (note that FASTER entered one of the last rooms, and then turned back), but even with this extra distance, it achieved a 29.6% improvement on the flight time. The dynamic constraints used for the office simulation are v_{\text{max}}=3 m/s, a_{\text{max}}= 6 m/s ^2 , and j_{\text{max}}= 35 m/s ^3 .
TABLE IV Comparison Between [4] and FASTER of Flight Distances and Times in an Office Simulation
Fig. 15.

Velocity profile in the office simulation. On the left the results of [4] and on the right FASTER.

Show All

The timing breakdown of Alg. 1 as a function of the maximum number of polyhedra P_{\text{max}} is shown in Fig. 16 . The number of intervals N was 10 for the Whole Trajectory and 7 for the Safe Trajectory. Note that the runtime for the MIQP of the Safe Trajectory is approximately constant as a function of P_{\text{max}} because the Safe Trajectory is planned only in \mathcal {F} , and therefore, most of the time, P < P_{\text{max}} . For the simulation and hardware experiments presented here, P_{\text{max}} = 2-4 was used. Fig. 17 shows the runtimes for JPS as a function of the voxel size of the map, which are always < 10 ms for voxel sizes \geq 14 cm. All these timing breakdowns were measured using an Intel Core i7-7700HQ 2.8GHz Processor.
Fig. 16.

Timing breakdown for the MIQP and convex decomposition of the Whole Trajectory and the Safe Trajectory as a function of the maximum number of polyhedra P_{\text{max}} for the forest simulation. Note that the times for the MIQPs include all the trials until convergence (with different factors f ) in each replanning step. The shaded area is the 1- \sigma interval ( \sigma is the standard deviation).

Show All
Fig. 17.

Runtimes of JPS as a function of the voxel size. The shaded area is the 1- \sigma interval ( \sigma is the standard deviation). These results are for the forest simulation using a sliding map of size 20 m × 20 m.

Show All
B. Time Versus Interval Allocation

As explained in Section III , FASTER optimizes the interval allocation using binary variables, while fixing in each optimization the time allocated per interval. Another possible option would be to optimize the time allocation, while fixing the interval allocation. To see the advantages and disadvantages of each option, we compare the following two approaches.

    \textbf{TA}: \textbf{T}\text{ime}\; \textbf{A} llocation is optimized and there are N/P intervals per polyhedron. We test both the case when the total time of the trajectory T is free and when it is fixed at 12.5 s.

    \textbf{IA} \textbf{ (ours)}: \textbf{I}\text{nterval}\; \textbf{A} llocation is optimized and all the intervals have the same fixed allocated time. IA uses binary variables to optimize the allocation of the N intervals. T is fixed at 12.5 s and the time allocated per interval is 12.5/N .

We use an environment whose free space is defined by four overlapping polyhedra (i.e., P=4 , see Fig. 18
Fig. 18.

Time ( TA ) versus Interval ( IA ) allocation for different number intervals N and different constraints on the total time of the trajectory T (free versus fixed). In all the TA methods, there are N/4 intervals per polyhedron, where N is the total number of intervals. IA has a fixed time allocation, and uses binary variables to optimize the allocation of the N intervals. The plot on the left shows the 2-D projection of the 3-D flight corridor used in the experiments. The initial position is chosen randomly in the first polyhedron, and the end position is fixed inside the fourth polyhedron. The total cost in these experiments is computed as \sum _{n=0}^{N-1}\Vert \mathbf {j}_{n}\Vert ^{2}dt + \rho T , where \rho =0.2 m ^2 /s ^6 . For every method, a total of 50 runs are performed, and only the successful runs were taken into account for the costs and solve times.

Show All
). The final state is a stop condition in the centroid of the last polyhedron, while the initial state is a stop condition in a random position of the first polyhedron, for a total of 50 runs. Both IA and TA methods use a weighted sum of the control effort and the total time as the total cost: \sum _{n=0}^{N-1}\Vert \mathbf {j}_{n}\Vert ^{2}dt + \rho T , where \rho =0.2 m ^2 /s ^6 . Note that the second term of this cost is constant for the methods in which T is not a decision variable. The dynamic constraints imposed are v_{\text{max}}=2 m/s, a_{\text{max}}= 20 m/s ^2 , and j_{\text{max}}= 50 m/s ^3 . The solver used for the (nonconvex) problems of TA is fmincon [49] , while Gurobi [45] is used for the MIQP of IA (both interfaced through YALMIP [50] , [51] ). The results in Fig. 18 show that IA is able to succeed in all of the runs, and it obtains smaller total costs and computation times. The TA methods achieve lower success rates, though these tend to increase when T is not fixed and N>P . All these results support the choice of optimizing the interval allocation (instead of the time allocation) that FASTER makes. Note also that, as explained in Section III-D , FASTER runs on top of this a line search to choose the time allocated per interval, see Fig. 7 .

C. Role of the Safe Trajectory
1) Speed Achieved

We first test FASTER in a simple environment and, for the same replanning step, we compare the velocities of the trajectory found by FASTER (that plans in \mathcal {U}\cup \mathcal {F} ) with the ones of the trajectory found by a planner that plans only in \mathcal {F} . The environment is shown in Fig. 19 , and consists of a corner, with the goal on the other side of the wall, so that the UAV has to turn the corner. The initial velocity at A is 4.8 m/s, and the dynamic constraints imposed are v_{\text{max}}=6.5 m/s, a_{\text{max}}= 6 m/s ^2 , and j_{\text{max}}= 20 m/s ^3 . FASTER achieves a velocity of 6.02 m/s in the segment A\rightarrow R (segment that will actually be flown by the UAV), while planning only in \mathcal {F} achieves a velocity of 5.06 m/s. R\rightarrow F is the Safe Trajectory, and A\rightarrow R \rightarrow F is the Committed Trajectory. Safety is guaranteed by both planners.
Fig. 19.

Trajectories obtained when planning only in \mathcal {F} (left) and when planning in \mathcal {F} \cup \mathcal {U} (FASTER, right). The velocity at A is 4.8 m/s. FASTER achieves a velocity of 6.02 m/s in the segment A\rightarrow R (segment that will actually be flown by the UAV), while the other planner achieves a velocity of 5.06 m/s. The ground grid is 1 m × 1 m.

Show All
2) Safety

We now evaluate what happens if the UAV does not compute the Safe Trajectory, but instead commits directly to the Whole Trajectory. We test this in the environment shown in Fig. 20 , which consists of a corner with one obstacle behind it. This environment is especially challenging due to the presence of obstacles just behind the corner, which are not fully visible to the UAV until it turns the corner. The results in Table V show that the Safe Trajectory is not strictly necessary when flying at low speeds ( \leq 4 m/s), but it is crucial to guarantee safety when flying at high speeds ( \geq 6 m/s). For high speeds, the planner without the Safe Trajectory collides due to the lack of time to replan when suddenly discovering an obstacle that was in the unknown space.
TABLE V Safety With and Without the Safe Trajectory
Fig. 20.

Environment with an obstacle behind the corner.

Show All
D. Comparison Between {\text {Poly}}_{{\text {Whole}}} and {\text {Poly}}_{{\text {Safe}}}

For the corner environment explained in Section IV-C (which uses four polyhedra), the top view and the quantitative comparison of the volumes covered are shown in Fig. 21 . \text{Poly}_{\text{Whole}} covers 145.1\cdot V_{\text{UAV}} of unknown space that extends beyond \text{Poly}_{\text{Safe}} . Here, V_{\text{UAV}} is the volume of the drone (a sphere of radius 0.3 m).
Fig. 21.

Comparison of the unknown volume covered by \text{Poly}_{\text{Safe}} and \text{Poly}_{\text{Whole}} in the corner environment. As \text{Poly}_{\text{Safe}}\subset \mathcal {F} , it does not cover any unknown volume. However, \text{Poly}_{\text{Whole}}\subset \mathcal {U}\cup \mathcal {F} , and the total unknown volume covered is 145.1\cdot V_{\text{UAV}} , where V_{\text{UAV}} is the volume of a sphere with radius r=0.3 m that models the UAV. This makes optimization 1 operate in a completely different space when using \text{Poly}_{\text{Safe}} than when using \text{Poly}_{\text{Whole}} .

Show All

For the forest and office simulations (which use 2 polyhedra), the comparison of the volumes is shown in Fig. 22 and Table VI . Letting V_{\text{UAV}} denote the volume of the sphere that models the UAV, these results show that, on average, \text{Poly}_{\text{Whole}} is, respectively, 250.8\cdot V_{\text{UAV}} and 21.9\cdot V_{\text{UAV}} larger than \text{Poly}_{\text{Safe}} in the office and forest simulations. Moreover, \text{Poly}_{\text{Safe}} does not cover unknown space, while \text{Poly}_{\text{Whole}} is able to cover, respectively, an unknown volume of 122.8\cdot V_{\text{UAV}} and 5.5\cdot V_{\text{UAV}} in the office and forest simulations. Note also that in the office simulation (which is more cluttered than the forest simulation), \text{Poly}_{\text{Whole}} covers more unknown volume than in the forest simulation.
TABLE VI Quantitative Comparison of the Volumes Covered by \text{Poly}_{\text{Whole}} and \text{Poly}_{\text{Safe}} in the Forest and Office Simulations
Fig. 22.

Qualitative comparison of the volumes covered by \text{Poly}_{\text{Whole}} and \text{Poly}_{\text{Safe}} in the office and forest simulations.

Show All

The key conclusion of these results is that, even with a relatively small number of polyhedra (2–4), the volume of unknown space covered by \text{Poly}_{\text{Whole}} can be hundreds of times the volume of the UAV, especially in cluttered environments. This makes \text{Poly}_{\text{Whole}} extend much farther than \text{Poly}_{\text{Safe}} , which is restricted to stay in \mathcal {F} . Hence, the Whole Trajectory will benefit from a longer planning horizon, leading to a higher nominal speed in the segment A\rightarrow R of the Whole Trajectory used in the Committed Trajectory.
SECTION V.
Hardware Results

The UAVs used in the hardware experiments are shown in Fig. 23 . A quadrotor was used in the experiments 1–4, and a hexarotor was used in the experiments 5 and 6. In both UAVs, the perception runs on the Intel RealSense, the mapper and planner run on the Intel NUC, and the control runs on the Qualcomm SnapDragon Flight.
Fig. 23.

Quadrotor (top) used in the experiments 1–4 and hexarotor (bottom) used in the experiments 5 and 6. Both are equipped with a Qualcomm SnapDragon Flight, an Intel NUC i7DNK, and an Intel RealSense Depth Camera D435.

Show All

The six hardware experiments done are shown in Figs. 24 – 29 . The corresponding velocity profiles are shown in Fig. 30 . The maximum speed achieved was 7.8 m/s, in Experiment 5 (see Fig. 28 ). The first and second experiments ( Figs. 24 and 25 ) were done in similar obstacle environments with the same starting point but with different goal locations. In the first experiment (see Fig. 24 ), the UAV performs a 3-D agile maneuver to avoid the obstacles on the table. In the second experiment (see Fig. 25 ), the UAV flies through the narrow gap of the cardboard boxes structure, and then flies below the triangle-shaped obstacle. In these two experiments, the maximum speed was 2.1 m/s.
Fig. 24.

Composite images of Experiment 1. The UAV must fly from start ( ) to goal ( ). Snapshots shown every 670 ms.

Show All
Fig. 25.

Composite image of Experiment 2. The UAV must fly from start ( ) to goal ( ). Snapshots shown every 330 ms.

Show All
Fig. 26.

Composite image of Experiment 3. The UAV must fly from start ( ) to goal ( ). Snapshots shown every 670 ms.

Show All
Fig. 27.

Composite image of Experiment 4. The UAV must fly from start ( ) to goal ( ). Snapshots shown every 670 ms.

Show All
Fig. 28.

Composite image of Experiment 5. The UAV must fly from start ( ) to goal ( ). Snapshots shown every 330 ms.

Show All
Fig. 29.

Composite image of Experiment 6. The UAV must fly from start ( ) to goal 1 ( ) and then back to goal 2 ( ). Snapshots shown every 330 ms.

Show All
Fig. 30.

Velocity plots of all the UAV hardware experiments. This velocity is the estimated velocity of the UAV, obtained by applying finite differences to the ground truth position measurements of an external motion capture system. This leads to some noisy estimates, especially for the high velocities of experiments 5 and 6. Moreover, these positions measurements are not available when the UAV is passing below an obstacle, which produces also noisy velocity estimates at those points. This happens in experiment 2 at t=4.0 s and t=5.9 s and in experiment 4 at t=5.0 s.

Show All

In the third and fourth experiments ( Figs. 26 and 27 ), the UAV must fly through a space with poles of different heights, and finally below the cardboard boxes structure to reach the goal, achieving a maximum speed of 3.6 m/s. Finally, in the fifth and sixth experiments ( Figs. 28 and 29 ), the UAV is allowed to fly in a much bigger space, and has to avoid some poles and several cardboard boxes structures. In the fifth experiment (see Fig. 28 ), the UAV achieved a top speed of 7.8 m/s. In the sixth experiment (see Fig. 29 ), the UAV was first commanded to go to a goal at the other side of the flight space, and then to come back to the starting position, achieving a top velocity of 4.6 m/s.

Fig. 30 shows the estimated velocity of the UAV, obtained by applying finite differences to the ground truth position measurements of an external motion capture system. This leads to some noisy estimates, in particular for the high velocities of experiments 5 and 6. Moreover, these positions measurements are not available when the UAV is passing below an obstacle, which produces also noisy velocity estimates at those points. This happens in experiment 2 at t=4.0 s and t=5.9 s and in experiment 4 at t=5.0 s.

For P_{\text{max}}=2 , the boxplots of the runtimes achieved on the forest simulation (measured on an Intel Core i7-7700HQ) and on the hardware experiments (measured on the onboard Intel NUC i7DNK with the mapper and the RealSense also running on it) are shown in Fig. 31 . For the runtimes of the MIQP of the Whole and the Safe Trajectories, the 75th percentile is always below 32 ms.
Fig. 31.

Timing breakdown for the forest simulation and for the real hardware experiments. The parameters used are P_{\text{max}}=2 , N=10 for the Whole Trajectory, and N=7 for the Safe Trajectory.

Show All
SECTION VI.
Extension to a Ground Robot

We now show how, by generating 2-D trajectories instead of 3-D, and changing the controller, FASTER can also be extended for skid-steer robots. To track the trajectory obtained by MADER, we generate the linear and angular velocities using a PD controller based on the derivative of the tangential angle of the trajectory [52] and the desired position and velocity. The commanded angular velocities of the wheels are then obtained from the desired angular velocities of the wheels using a PID.

Three different experiments were done with the ground robot (see Figs. 32 , 33 , and 34 ). An external motion capture system was used to estimate the position and orientation of the robot. Experiments 7 and 8 were done in obstacle environments similar to the random forest. The maximum speeds achieved for the experiments 7 and 8 were 1.95 m/s and 2.22 m/s, respectively. Note that the maximum speed specified for this ground robot is \approx 2 m/s [53] .
Fig. 32.

Composite images of Experiments 7–9. The ground robot must go from start ( ) to goal ( ). Snapshots shown every 670 ms. To show the ability of FASTER to get out from bugtraps, only points in the depth image closer than 3 m were used to build the map in experiment 9.

Show All
Fig. 33.

Velocity plots of the experiments 7–9.

Show All
Fig. 34.

Ground robot used in the experiments. It is equipped with an Intel RealSense Depth Camera D435, and an i7-7700HQ laptop.

Show All

To test the ability of FASTER to reuse the map built, the setup for experiment 9 was a bugtrap environment, and only points in the depth image closer than 3 m were used to build the map. The robot first enters the bugtrap because it does not see the end of it. Once the robot detects that there is no exit at the end of the bugtrap, it turns back, exits the bugtrap, passes through its left and avoids some new obstacles to finally reach the goal. The maximum speed achieved in this experiment was 1.70 m/s
SECTION VII.
Conclusion

This work presented FASTER, a fast and safe planner for agile flights in unknown environments. The key properties of this planner is that it leads to a higher nominal speed than other works by planning both in \mathcal {U} and \mathcal {F} using a convex decomposition, and ensures safety by having always a Safe Trajectory planned in \mathcal {F} at the beginning of every replanning step. FASTER was tested successfully both in simulated and in hardware flights, achieving velocities up to 7.8 m/s. Finally, we showed how FASTER is also applicable to skid-steer robots, achieving hardware experiments at 2 m/s.

Our algorithm has also some limitations: In environments where the planning horizon is not very large (as in all the experiments shown in this article), 2-4 polyhedra usually suffice, and our algorithm maintains computational tractability. However, for large known worlds (for example, if a map of the environment already exists beforehand), a long planning horizon may require more than four polyhedra, which, as shown in Fig. 16 , will increase the computation time. One possible way to address this is to solve the interval allocation only in the polyhedra that are close to the current position of the UAV, and force a predefined interval and time allocation for the polyhedra that are farther in the planning horizon. Moreover, we also noticed how important the choice of the point R is: As discussed in Section III-E , if the point R is chosen very close to the unknown space, it may lead to infeasibility of the optimization problem associated with the Safe Trajectory. However, if R is chosen very close to A , then the UAV may not have enough time to replan in the next iteration, which will lead to keep executing the previous trajectory, and may eventually decrease the nominal speed of the flight. Nonheuristic ways to solve this tradeoff seems like a promising direction for future work. Further future work includes the relaxation of the assumption 1: we plan to include the uncertainty associated with the map (due to estimation error and/or sensor noise) in the replanning function, and to extend this planner to dynamic environments. We also plan to use onboard estimation algorithms like VIO instead of an external motion capture system for the real hardware experiments.

Finally, another promising future work is the reduction of the computation times of the time allocation approaches. Experiments in Section IV-B use a generic nonconvex solver to optimize the time allocation, which may be inefficient in some situations. Exploitation of the structure of the time allocation problem and/or the use of hierarchical optimization could help to reduce the associated computation times [54] , [55] . This could potentially avoid the use of binary variables needed for the interval allocation, or allow the optimization of both the interval and the time allocation in the trajectory planning problem.
ACKNOWLEDGMENT

The authors would like to thank P. Tordesillas (ETSAM-UPM) for his help with some figures, P. Lusk and A. Paris (ACL-MIT) for their help with the hardware, and H. Oleynikova (ASL-ETH) for the data of the forest simulation. The authors would also like to thank J. Carter and J. Ware (CSAIL-MIT) for their help with the mapper used. Views expressed here are those of the authors, and do not reflect the official views or policies of the Department of Defense or the U.S. Government.

Authors
Figures
References
Citations
Keywords
Metrics
Media
Footnotes
   Back to Results   
More Like This
Metaheuristic optimization approach to mobile robot path planning

2012 International Conference on Engineering and Technology (ICET)

Published: 2012
Multiple Waypoints Path Planning for a Home Mobile Robot

2018 Ninth International Conference on Intelligent Control and Information Processing (ICICIP)

Published: 2018
Show More
References
References is not available for this document.
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
