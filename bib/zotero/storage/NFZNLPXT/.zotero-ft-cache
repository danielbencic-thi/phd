IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Typesetting math: 100%

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Conferences > 2021 IEEE International Confe...
High-Speed Planning in Unknown Environments for Multirotors Considering Drag
Publisher: IEEE
Cite This
PDF
  << Results   
Charbel Toumieh ; Alain Lambert
All Authors
View Document
52
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    MAV MODEL
    III.
    The method
    IV.
    Simulation Results
    V.
    Conclusions and Future Works

Authors
Figures
References
Keywords
Metrics
More Like This

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: In this paper, we propose a new planning scheme for high-speed flight in an unknown environment while taking into account drag forces. Drag forces become non-negligible a... View more
Metadata
Abstract:
In this paper, we propose a new planning scheme for high-speed flight in an unknown environment while taking into account drag forces. Drag forces become non-negligible at high speeds and may lead to unfeasible trajectories. The method leverages a new Mixed-Integer Quadratic Program/Model Predictive Control formulation that allows to easily account for drag forces. This formulation makes use of a state-of-the-art Safe Corridors generator to guarantee safety. It uses state-of-the-art mapping algorithms and solvers to achieve a higher computational efficiency than similar state-of-the-art methods. To the best of our knowledge, our method is the first high-speed planner that generates safe trajectories while accounting for drag. The proposed method is tested in simulation and compared to similar state-of-the-art methods for planning in unknown environments in terms of quality and computation time.
Published in: 2021 IEEE International Conference on Robotics and Automation (ICRA)
Date of Conference: 30 May-5 June 2021
Date Added to IEEE Xplore : 18 October 2021
ISBN Information:
ISSN Information:
INSPEC Accession Number: 21257366
DOI: 10.1109/ICRA48506.2021.9560773
Publisher: IEEE
Conference Location: Xi'an, China
Contents
SECTION I.
Introduction

High-speed navigation in complex environments has numerous applications [1] such as infrastructure inspection [2] , exploration [3] , search and rescue [4] and cinematography [5] . In these applications, high-speed planning is favorable as it prolongs the covered distance on a single battery charge.

The motivation behind this work is to create a planner for high-speed flight (mean: 3.5 m/s , max: 6 m/s ) in unknown environments while taking into account drag forces and the limitations of embedded computing.

The paper is organized as follows: we will first present briefly the current state-of-the-art methods for multirotor planning and state the main contributions of our paper. We will then describe the multirotor model used for planning and how it accounts for drag forces. The planning method is then presented with each step explained in a separate subsection. Finally, the simulation results are shown and comparisons with the state-of-the-art are done.
A. Related Work

Most of the current state-of-the-art planning methods rely on the differential flatness property of quadrotors [6] . Differential flatness allows expressing all states and inputs of the quadrotor in terms of its position and yaw angle (flat outputs), and their derivatives. This allows them to simplify the planning problem by transforming the quadrotor dynamics to an integrator model. To generate smooth trajectory, they minimize the squared euclidean norm of a derivative of the position [6] , [7] , [8] . Some of these methods take into account static obstacles when solving the optimization problem, while others account for them after solving it. None of these methods can take into account drag or the unknown aspect of environments.
Fig. 1. - Schematics of the multirotor model with the used coordinate systems.
Fig. 1.

Schematics of the multirotor model with the used coordinate systems.

Show All

Other planning methods use motion primitives or closed-form solutions to transform the planning problem into a graph search in the state space [9] , [10] , [11] , [12] . These methods usually require a computationally expensive search in order to be able to generate complex maneuvers around obstacles.

There are methods that take into account obstacles when solving for the optimal trajectory by using Euclidean Signed Distance Fields (ESDF) that transform the 3D space into voxels encoding the distance to the nearest obstacle [13] , [14] , [15] , [16] . These methods generate problems that are non convex, and lead to local minima problems. Others use successive convexification to solve the non-convex problem that results from including obstacles in the problem formulation [17] . These methods rely heavily on a good initialization and may have some convergence difficulties while handling complex environments.

In [18] , obstacles must be decomposed into overlapping convex shapes which is non trivial when dealing with cluttered environments. Another set of methods rely on a convex decomposition of the free space: in [19] , [20] , [21] , [22] , [23] , [24] , polynomials or Bézier curves were used, and drag forces are not accounted for.
B. Contribution

None of the aforementioned works include drag forces in the planning framework. Our work takes inspiration from previous planners that use Safe Corridors, notably [19] and [24] . The main contributions of our paper are:

    The integration of a state-of-the-art method for Safe Corridor generation in a new planning framework.

    A novel planning algorithm that takes into account drag forces, and is significantly more computationally efficient than similar state-of-the-art methods.

We validate the feasibility of our generated trajectories by testing them in the simulation engine Airsim [25] . The physics engine is state-of-the-art and takes into account drag forces.
SECTION II.
MAV MODEL
TABLE I. Nomenclature
Table I.- Nomenclature

We assume a low-level controller that allows for controlling the attitude and thrust. We use the nomenclature defined in Table I . The equations of motion are:
p ˙ = v v ˙ = − g z W + c c m d m z B − R D R ′ v ∥ v ∥ 2 ϕ ˙ = ϕ ˙ c m d θ ˙ = θ ˙ c m d ψ ˙ = ψ ˙ c m d (1) (2) (3) (4) (5)
View Source Right-click on figure for MathML and additional features. \begin{align*} & \dot p = v\tag{1} \\ & \dot v = - g{z_W} + \frac{{{c_{cmd}}}}{m}{z_B} - RD{R^\prime }v{\left\| v \right\|_2}\tag{2} \\ & \dot \phi = {\dot \phi _{cmd}}\tag{3} \\ & \dot \theta = {\dot \theta _{cmd}}\tag{4} \\ & \dot \psi = {\dot \psi _{cmd}}\tag{5}\end{align*}

We reformulate the five equations of motion to get the following:
p ˙ = v v ˙ = a − D l i n _ m a x v a ˙ = j (6)
View Source Right-click on figure for MathML and additional features. \begin{gather*} {\mathbf{\dot p = v}} \\ {\mathbf{\dot v = a}} - {{\mathbf{D}}_{{\mathbf{lin\_max}}}}{\mathbf{v}} \\ {\mathbf{\dot a = j}} \tag{6}\end{gather*}

D lin_max a diagonal matrix representing the maximum possible linear drag coefficient in all directions (identified offline). We replace the quadratic drag force model with a linear worst-case scenario model at any given direction, because this will allow us to account for drag while maintaining the linearity of the dynamics. The linearity of the model allows us to solve the MPC problem using solvers that are very efficient for linear constraints. External forces (such as disturbances identified online) can also be added to the model to further guarantee feasibility, without affecting its linearity (and thus computation time). The online estimation of such forces can be done using [26] .

Drag coefficients offline identification: We first identify the z component of the quadratic drag matrix ( D 3,3 ) by moving at full thrust c cmd,max in the z W direction ( v x = v y = 0). The velocity approaches a maximum constant value v max,z asymptotically. D 3,3 is then calculated using equation (2) at the steady state ( v ˙ z = 0 ) : D 3 , 3 = ( − g + c c m d , max m ) / v 2 max , z . Note that in this experiment the rotation matrix R is the identity matrix and z W = z B . Then we identify D 2,2 by moving at full thrust in the y direction ( v z = v x = 0). In this case we need to tilt only around the x axis of the body frame such that a fraction of c cmd,max compensates the gravity ( v ˙ z = 0 ) , and the remaining force of c cmd,max is in the y direction. The velocity approaches a maximum constant value v max,y asymptotically. By using equation (2) , we get 1 equation ( v ˙ y = 0 ) with the only unknown D 2,2 . We identify D 1,1 similarly to D 2,2 . Finally, the elements on the diagonal of D lin_max are all chosen equal to: max ( D 1 , 1 , D 2 , 2 , D 3 , 3 ) min ( v max , x , v max , y , v max , z ) .
SECTION III.
The method

The planner takes in the position of the multirotor, a voxel grid partitioning space into free, occupied, and unknown voxels (centered at the robot position), and a goal in 3D space. It then proceeds to plan/explore until it reaches the goal.

The method is divided into 4 steps:

    Generating a global path.

    Creating a Safe Corridor around the global path.

    Generating a safe local reference trajectory.

    Solving the Mixed-Integer Quadratic Program (MIQP)/Model Predictive Control (MPC) problem.

All these steps are run at constant rates in a loop ( Fig. 2 ). In the first step, we generate a global path to the goal. At every iteration, this step takes as input the current position of the robot and the goal. The second step generates a Safe Corridor using the last generated global path ( last in Fig. 2 ), and the Safe Corridor and MIQP/MPC solution generated in the previous iteration ( k − 1). The third step generates a local reference trajectory using the last generated global path, the Safe Corridor of the current iteration ( k ), and the MIQP/MPC solution and local reference solution generated in the previous iteration ( k − 1). The fourth step generates the optimal and safe trajectory using the Safe Corridor and local reference trajectory of the current iteration ( k ). The final trajectory is finally fed to the controller for execution.

Steps 2-4 are run at the same frequency (10Hz) whereas step 1 can be run at an equal or lower frequency than 10Hz. The controller can be run at an equal or greater frequency than 10Hz. Our method has the following properties:

    Resolution Completeness: we guarantee that we will find a path from point A to point B as long as there exists a path and the local grid map is big enough and fine enough. This property is inherited from Jumping Point Search (JPS) [27] (used to find a global path).

    Feasibility: we guarantee feasibility by accounting for drag and limiting input constraints to the quadrotor’s dynamical limits.

    Smoothness and Local Optimality: we get optimality in the sense of minimizing the jerk on a given time horizon.

    Safety: we guarantee the trajectory is collision-free through Safe Corridors and by using the Distance Map Planner (DMP) [28] on top of JPS, which pushes the trajectory away from obstacles.

Fig. 2. - We show the global pipeline of our planning framework at iteration k. The last generated global path is always used at every iteration, and some steps use results generated at step k − 1.
Fig. 2.

We show the global pipeline of our planning framework at iteration k. The last generated global path is always used at every iteration, and some steps use results generated at step k − 1.

Show All
Fig. 3. - Choosing the intermediate goal when the final goal is outside the local voxel grid.
Fig. 3.

Choosing the intermediate goal when the final goal is outside the local voxel grid.

Show All
A. Generating a global path

In this step, we will generate a global path from the robot position to the goal using a local voxel gird generated by [29] using a point cloud.

The local voxel grid spans a given volume. If the goal is outside this volume, we find the intersection between the borders of the grid and the line from the center of the multirotor to the goal ( Fig. 3 ). This will determine the intermediate goal to which we plan. We free the intermediate goal voxel as well as all voxels on the border of the voxel grid to guarantee that we will find a path to the intermediate goal (if there exists a path).

We use Jumping Point Search (JPS) [27] to find a feasible path between the position of the multirotor and the goal (or intermediate goal). JPS is a shortest path algorithm that preserves A*’s optimality, while potentially lowering the computation time by an order of magnitude. We then use the Distance Map Planner (DMP) [28] , to generate a safer path. It uses the artificial potential field to push away the path from the obstacles ( Fig. 4 ). Pushing away the trajectory from obstacles not only provides a safety margin for disturbances, but also allows for better vision/coverage when turning corners i.e. to see/cover more space behind a corner before turning it. This increases the overall trajectory speed.

The DMP adds time to the computation but as long as the map size is small enough or the voxel size is big enough i.e. the total number of voxels in the grid is small enough, the combined computation time of both JPS and DMP is lower than the MIQP/MPC solving time.
B. Creating a Safe Corridor around the global path

After finding a path, we decompose the space around the path into overlapping convex polyhedra (Safe Corridor). Many methods exist in the literature to create Safe Corridors [19] [30] . We use the algorithm described in [30] as it provides better safety guarantees and a lower solving time for the MIQP/MPC. It takes a voxel grid with occupied, free, and unknown voxels, and a path around which we would like to find a Safe Corridor. It returns a series of overlapping polyhedra covering only the free space ( Fig. 4 ).

At the first planning iteration, we find the convex polyhedron around the voxel containing the starting position of the global path (seed voxel). Then we find the intersection between the global path and the convex polyhedron, and find an additional polyhedron with the voxel containing the intersection as its seed. Sometimes, the voxel containing the intersection is the same seed voxel as the one used for the last polyhedron (which would result in a duplication of the same polyhedron). In this case, we move further along the global path to find the next closest voxel outside the last polyhedron. We then use this voxel as a seed for the next polyhedron. This algorithm is repeated until we reach the maximum number of polyhedra P hor (polyhedra horizon).

At the next planning iterations, we first determine the minimum number of the polyhedra generated at the previous iteration ( P min ) that contain the trajectory generated by the MIQP/MPC at the previous iteration, with preference given to the newest generated polyhedra. We then generate P rem = P hor − P min polyhedra using the aforementioned algorithm and add them to the P min polyhedra. These polyhedra will be used by the MIQP/MPC to generate a safe trajectory at the current iteration.
C. Generating a safe local reference trajectory

In this step, we use the global path and the Safe Corridor to generate a reference trajectory for the MIQP/MPC. We denote N the number of discretization steps and h the time step used in the MIQP/MPC.
Fig. 4. - We show the first planning iteration of our algorithm. The global path is generated using JPS and DMP. DMP uses the artificial potential field (pink) to push the path away from the obstacles. The convex polyhedra (blue) span only the free space. A local reference trajectory is sampled from the global path (green circles). It is then given with the overlapping convex polyhedra to the MIQP solver to generate a feasible trajectory (yellow circles).
Fig. 4.

We show the first planning iteration of our algorithm. The global path is generated using JPS and DMP. DMP uses the artificial potential field (pink) to push the path away from the obstacles. The convex polyhedra (blue) span only the free space. A local reference trajectory is sampled from the global path (green circles). It is then given with the overlapping convex polyhedra to the MIQP solver to generate a feasible trajectory (yellow circles).

Show All

We first determine the initial direction of the global path (first two nodes of the DMP), then we project the velocity vector of the robot along this direction (dot product). This will determine the initial sampling velocity: if the projection is negative, we set the sampling velocity to 0, otherwise it is kept as is. We then move along the global path for a time h (time step) with the initial velocity, and the found point is set as the first local reference point. The sampling velocity is then updated such as v samp = min( v samp,max , v samp + h × a samp ) with a samp the acceleration of the sampling (chosen close to the maximum quadrotor acceleration), and v samp,max the maximum velocity of the sampling (chosen close to the maximum quadrotor velocity, which is limited by drag). The next point is sampled starting from the last reference point and with the updated sampling velocity. If a generated reference point is outside the Safe Corridor, the last reference point (which is inside the Safe Corridor) is duplicated and takes its place. We generate N reference points ( Fig. 4 ).

At each iteration, after solving the MIQP/MPC, we check if the final state is close enough from the previous final reference point (within thresh_dist ). If yes, we regenerate a new local reference trajectory using the aforementioned algorithm starting from x 1, ref . If no, wait another time step h to give the MPC enough time to reach the final reference point x N,ref .
D. Solving the MIQP/MPC problem

In this step, we generate a safe trajectory to be executed by the multirotor’s controller using the safe local reference trajectory generated in Sect. III-C and the Safe Corridor generated in Sect. III-B . We minimize the error to the reference trajectory as well as the jerk norm, which results in a smooth version of the local reference trajectory ( Fig. 4 ).

At every iteration, the initial state x 0 of the MPC is set to the first state x 1 of the last generated trajectory. The terminal velocity v N is set to 0 to make sure that the multirotor has a safe trajectory to execute in case subsequent MIQP optimizations fail to find a solution. We can also set a N to 0, but this results in slower trajectories.

In case the solver fails to find a solution at a given iteration or the computation time exceeds the time step h , we skip the iteration (the solution is discarded), and at the next iteration, we solve the MIQP/MPC with the initial state x 2 instead of x 1 . In case this also fails, we keep offsetting the initial position (which may reach x N in the worst case) until the solver converges to a solution within the time step h.
1) Dynamics:

With x = [ p v a ] T , u = j , f ( x ( t ), u ( t )) defined by Eq. 6 , the model is discretized using Euler or Runge-Kutta 4 th order to obtain the discrete dynamics x k +1 = f d ( x k , u k ). We choose the Euler method as it results in faster solving times without any noticeable difference in the generated trajectory.
2) State bounds:

The acceleration resulting from the thrust and gravity, and the jerk obey the following equations at every discrete point k :
a 2 x , k + a 2 y , k + ( a z , k + g ) 2 − − − − − − − − − − − − − − − − − − √ ≤ a max a z , k ≥ a z , min j 2 x , k + j 2 y , k + j 2 z , k − − − − − − − − − − − − √ ≤ j max (7) (8) (9)
View Source Right-click on figure for MathML and additional features. \begin{align*} & \sqrt {a_{x,k}^2 + a_{y,k}^2 + {{\left( {{a_{z,k}} + g} \right)}^2}} \leq {a_{\max }}\tag{7} \\ & {a_{z,k}} \geq {a_{z,\min }}\tag{8} \\ & \sqrt {j_{x,k}^2 + j_{y,k}^2 + j_{z,k}^2} \leq {j_{\max }}\tag{9}\end{align*}

The velocity is limited by the drag forces. The bounds a max , a z,min (= − g ) and j max are imposed by the dynamical constraints. These constraints are quadratic. However, since we want them to be linear (faster solving time), each direction is decoupled and they are transformed into the following conservative constraints:
| a x , k | ≤ a x , m a x , | a y , k | ≤ a y , m a x a z , k ≤ a z , max , a z , k ≥ a z , min | j x , k | ≤ j x , max , | j y , k | ≤ j y , min , | j z , k | ≤ j z , max (10) (11) (12)
View Source Right-click on figure for MathML and additional features. \begin{align*} & \left| {{a_{x,k}}} \right| \leq ax,max,\left| {ay,k} \right| \leq {a_{y,max}}\tag{10} \\ & {a_{z,k}} \leq {a_{z,\max }},\quad {a_{z,k}} \geq {a_{z,\min }}\tag{11} \\ & \left| {{j_{x,k}}} \right| \leq {j_{x,\max }},\quad \left| {{j_{y,k}}} \right| \leq {j_{y,\min }},\quad \left| {{j_{z,k}}} \right| \leq {j_{z,\max }}\tag{12}\end{align*}

We choose the bounds of each direction such that:
a 2 x , max + a 2 y , max + ( a z , max + g ) 2 − − − − − − − − − − − − − − − − − − − − − − − √ ≤ a max j 2 x , m a x + j 2 y , m a x + j 2 z , m a x − − − − − − − − − − − − − − − − − − √ ≤ j max (13) (14)
View Source Right-click on figure for MathML and additional features. \begin{align*} & \sqrt {a_{x,\max }^2 + a_{y,\max }^2 + {{\left( {{a_{z,\max }} + g} \right)}^2}} \leq {a_{\max }}\tag{13} \\ & \sqrt {j_{x,max}^2 + j_{y,max}^2 + j_{z,max}^2} \leq {j_{\max }}\tag{14}\end{align*}

3) Static obstacle avoidance:

This is achieved by forcing every two consecutive discrete points (and thus the segment formed by them) to be in one of the overlapping polyhedra. Let’s assume we have P overlapping polyhedra. They are described by { ( A p , c p ) } , p = 0: P – 1. The constraint that the discrete position p k is in a polyhedron p is described by A p . p k ≤ c p . We introduce binary variables b kp ( P variables for each x k , k = 0: N − 1) that indicate that p k and p k +1 are in the polyhedron p. We force all the segments to be in at least one of the polyhedra with the constraint ∑ P − 1 p = 0 b k p ≥ 1 .

Typically, the number of polyhedra considered for optimization P hor is 2 to avoid high solving times.
4) Formulation:

We formulate our MPC under the following Mixed-Integer Quadratic Program (MIQP) formulation. The reference trajectory x k,ref is generated as described in Sect. III-C . R x , R N and R u are the weight matrix for the discrete state errors without the final state, the weight matrix for the final discrete state error (terminal state), and the weight matrix for the input, respectively.
minimize x k , u k ∑ k = 0 N − 1 ( ∥ x k − x k , r e f ∥ 2 R x + ∥ u k ∥ 2 R u ) + ∥ x N − x N , r e f ∥ 2 R N subject to x k + 1 = f d ( x k , u k ) , k = 0 : N − 1 x 0 = X 0 v N = 0 | a x , k | ≤ a x , max | a y , k | ≤ a y , max , a z , k ≤ a z , max a z , k ≥ a z , min , | j x , k | ≤ j x , max | j y , k | ≤ j y , min , | j z , k | ≤ j z , max b k p = 1 ⇒ A p p k ≤ c p , A p p k + 1 ≤ c p ∑ p = 0 P h o r − 1 b k p ≥ 1 b k p ∈ { 0 , 1 } (15) (16) (17) (18) (19) (20) (21) (22) (23) (24) (25)
View Source Right-click on figure for MathML and additional features. \begin{align*} & \begin{array}{l} \mathop {\operatorname{minimize} }\limits_{{{\mathbf{x}}_k},{{\mathbf{u}}_k}} \sum\limits_{k = 0}^{N - 1} {\left( {\left\| {{{\mathbf{x}}_k} - {{\mathbf{x}}_{k,ref}}} \right\|_{{{\mathbf{R}}_x}}^2 + \left\| {{{\mathbf{u}}_k}} \right\|_{{{\mathbf{R}}_u}}^2} \right)} \\ + \left\| {{{\mathbf{x}}_N} - {{\mathbf{x}}_{N,ref}}} \right\|_{{{\mathbf{R}}_N}}^2 \end{array} \tag{15} \\ & {\text{subject to}}\quad {x_{k + 1}} = {f_d}\left( {{{\mathbf{x}}_k},{{\mathbf{u}}_k}} \right),\quad k = 0:N - 1\tag{16} \\ & {{\mathbf{x}}_0} = {{\mathbf{X}}_0}\tag{17} \\ & {{\mathbf{v}}_N} = {\mathbf{0}}\tag{18} \\ & \left| {{a_{x,k}}} \right| \leq {a_{x,\max }}\tag{19} \\ & \left| {{a_{y,k}}} \right| \leq {a_{y,\max }},\quad {a_{z,k}} \leq {a_{z,\max }}\tag{20} \\ & {a_{z,k}} \geq {a_{z,\min }},\quad \left| {{j_{x,k}}} \right| \leq {j_{x,\max }}\tag{21} \\ & \left| {{j_{y,k}}} \right| \leq {j_{y,\min }},\quad \left| {{j_{z,k}}} \right| \leq {j_{z,\max }}\tag{22} \\ & {b_{kp}} = 1 \Rightarrow {{\mathbf{A}}_p}{{\mathbf{p}}_k} \leq {{\mathbf{c}}_p},{{\mathbf{A}}_p}{{\mathbf{p}}_{k + 1}} \leq {{\mathbf{c}}_p}\tag{23} \\ & \sum\limits_{p = 0}^{{P_{hor}} - 1} {{b_{kp}} \geq 1} \tag{24} \\ & {b_{kp}} \in \{ 0,1\} \tag{25}\end{align*}

The MIQP is solved using the Gurobi solver [31] .
SECTION IV.
Simulation Results

The simulation is done using a quadrotor in Airsim [25] , a photo-realistic state-of-the-art simulator. The state of the quadrotor is known. The obstacles are cylinders with a radius of 0.35 m and span a 50 m × 50 m area with a density of 0.1 obs/m 2 . They are generated randomly, following a uniform distribution. The Gurobi solver is set to use one thread only as this resulted in faster computation times during our simulations. All testing is done on the Intel Core i7-9750H up to 4.50 GHz CPU, and for the GPU we use NVIDIA’s GeForce RTX 2060 up to 1.62 GHz.
A. Controller design

We control our quadrotor using a nonlinear MPC [32] , with the acados toolkit [33] . The MPC minimizes the cost function:
J = ∫ T t = 0 ∥ x ( t ) − x r e f ( t ) ∥ 2 Q x + ∥ u ( t ) − u r e f ( t ) ∥ 2 R u d t + ∥ x ( T ) − x r e f ( T ) ∥ 2 P (26)
View Source Right-click on figure for MathML and additional features. \begin{gather*} J = \int_{t = 0}^T {\left\| {{\mathbf{x}}(t) - {{\mathbf{x}}_{ref}}(t)} \right\|_{{{\mathbf{Q}}_x}}^2 + \left\| {{\mathbf{u}}(t) - {{\mathbf{u}}_{ref}}(t)} \right\|_{{{\mathbf{R}}_u}}^2dt} \\ + \left\| {{\mathbf{x}}(T) - {{\mathbf{x}}_{ref}}(T)} \right\|_{\mathbf{P}}^2 \tag{26}\end{gather*}

We use the model described in section II with u = [ c c m d ϕ ˙ c m d θ ˙ c m d ψ ˙ c m d ] T and x = [ p v φ θ ψ ] T . The sampling time is h = 0.05 s and the horizon N h = 15 which gives a time horizon T = 0.75 s. The weights are:
P = Q x = d i a g ( 15 , 15 , 15 , 0.01 , 0.01 , 0.01 , 0 , 0 , 1 ) R u = d i a g ( 0.05 , 0.1 , 0.1 , 0.1 ) (27) (28)
View Source Right-click on figure for MathML and additional features. \begin{align*} & {\mathbf{P}} = {{\mathbf{Q}}_{\mathbf{x}}} = diag(15,15,15,0.01,0.01,0.01,0,0,1)\tag{27} \\ & {{\mathbf{R}}_{\mathbf{u}}} = diag(0.05,0.1,0.1,0.1)\tag{28}\end{align*}

All parameters are set by approximation/experimentation and may not be optimal. They provide however some measurement to the feasibility of the generated trajectory. We limit |ϕ| ≤ 85 deg , θ ≤ 85 deg , ∣ ∣ ϕ ˙ c m d ∣ ∣ ≤ 120 deg / s , ∣ ∣ θ ˙ c m d ∣ ∣ ≤ 120 deg / s and ∣ ∣ ψ ˙ c m d ∣ ∣ ≤ 60 deg / s .

Since the planning frequency is 10Hz and the control frequency is 20Hz, we interpolate linearly the reference trajectory generated by the planner (which has a time step of 100 ms ) to get the reference trajectory of the controller (which has a time step of 50 ms ). This means that a reference point will be added in the middle of every 2 consecutive reference points generated by the MIQP solver.
B. Voxel grid generation

We use a lidar to have omnidirectional coverage, which also can be provided by omnidirectional stereo cameras (with stereo matching). The point cloud is transformed into a voxel grid with occupied, free and unknown voxels using the state-of-the-art GPU accelerated voxelization algorithm [29] . We choose a voxel size (side length) of 0.3 m and a grid size of ( size x = 16, size y = 16, size z = 3). We inflate the obstacles by one voxel for the convex decomposition and 2 voxels for the JPS global pathfinding. The inflation is done on the GPU using [29] .
C. Planner parameters

We choose the following parameters: N = 9, h = 100 ms , a x,max = a y,max = 0.7 g , a z,max = 0.4 g , a z,min = – g , j x,max = j y,max = j z,max = 15 m/s 2 , v max,samp = 6 m/s , a samp = 7 m/s 2 D lin_max = diag (1, 1, 1), thresh_dist = 0.35 m , P hor = 2. The weight matrices are diagonal: R x = R N = diag (100, 100, 100, 0, 0, 0, 0, 0, 0) and R u = diag (0.01, 0.01, 0.01). Some of these parameters are identified from the quadrotor’s model in Airsim.

The DMP planner pushes the JPS path 0.6 m away from obstacles (when possible). The planning frequency for the global path planning is 5Hz and that of the safe local trajectory generation, Safe Corridor generation, and MIQP/MPC optimization is 10Hz. However, due to the low computation time, it can be increased.
D. Comparison with the state of the art

We compare our planner with the state-of-the-art FASTER planner [24] . It was fine-tuned to get a very good performance in terms of controller tracking and computation time.

The comparison is done using 10 randomly generated maps of obstacles which span a 50 m × 50 m area with a density of 0.1 obs/m 2 . We show the trajectories generated by both methods on one of the maps in Fig. 5 and the overall results over all 10 maps in Table II . Both methods are similar in terms of flight distance and flight velocity with a slight advantage to FASTER, which outperforms our method by 2.5% in mean flight distance and 3% in mean flight velocity. However, in terms of computation time, our method far outperforms FASTER, with an advantage of 336% for the mean computation time and 516% for the maximum computation time.

In Fig. 6 we show the breakdown of the computation time of our planner. The generation of overlapping convex polyhedra i.e. Safe Corridor takes on average 0.15 ms , has a median of 0.178 ms and a max of 0.607 ms. The generation of a global path through JPS and DMP takes on average 2.07 ms , has a median of 1.948 ms and a max of 7 ms. The MIQP/MPC solver takes on average 3.86 ms , has a median of 3.68 ms and a max of 18.2 ms. The total planner takes on average 6 ms , has a median of 5.6 ms and a max of 19.8 ms. Since the global path planning is run at 5Hz, its mean contribution to the total planning time (run at 10Hz) is halved. Setting up the Gurobi MIQP/MPC solver at every planning iteration takes on average 1 ms. The generation of a safe local trajectory (step 3) takes negligible time.
Fig. 5. - The trajectories and velocity of the quadrotor generated by FASTER [24] and our planner on the same map.
Fig. 5.

The trajectories and velocity of the quadrotor generated by FASTER [24] and our planner on the same map.

Show All
TABLE II. Comparison between FASTER [24] and our planner on 10 randomly generated maps of size 50 m 50 m and with obstacle density 0.1 obst/m2. The better performer is shown in bold.
Table II.- Comparison between FASTER [24] and our planner on 10 randomly generated maps of size 50 m 50 m and with obstacle density 0.1 obst/m2. The better performer is shown in bold.
Fig. 6. - Boxplot of the computation times of the different functional blocks of the planner as well as the total computation time of the planner. The red segment represents the median. The lower and upper bounds of the box represent the 25th and 75th percentile respectively, and the lower and upper whiskers represent the minimum and maximum respectively.
Fig. 6.

Boxplot of the computation times of the different functional blocks of the planner as well as the total computation time of the planner. The red segment represents the median. The lower and upper bounds of the box represent the 25 th and 75 th percentile respectively, and the lower and upper whiskers represent the minimum and maximum respectively.

Show All

During our 10 simulated flights, the worst-case computation time for the Safe Corridor generation, global pathfinding, and MIQP/MPC solver don’t happen at the same time, otherwise, the maximum total planning time would be the sum of the 3 maximum computation times + solver setup time. If we assume the worst-case scenario i.e. worst-case computation time in each step simultaneously, the maximum total planning time would become 26.8 ms. This means that we can run our planner at 30Hz in the worst-case scenario.

If we take an embedded system like the NVIDIA Jetson Nano [34] whose CPU runs at 1.43GHz i.e. 3.14× slower then the turbo-boosted clock of our CPU (4.5G × Hz), the theoretical worst case computation time would be 3.14× 26.8 = 82.4 ms. This means that the results produced in this paper can be reproduced on a low-cost embedded system since the worst-case computation time is lower than the planning period which is 100 ms (since the planner runs at 10Hz).
SECTION V.
Conclusions and Future Works

In this paper, we presented a novel method for high-speed planning in unknown environments that leverages the state-of-the-art in mapping (voxelization) and convex decomposition of free space to produce similar results to the state-of-the-art at a fraction of the computation cost. This makes it suitable for low-powered/low-cost embedded systems. The proposed planning method is, to the best of our knowledge, the first in its class to account for drag forces which adds guarantees to the feasibility of the trajectory and allows for better exploitation of the full dynamics of the multirotor. We also tested our planner in a state-of-the-art simulation environment (Airsim) and compared it with a similar state-of-the-art method. Our method showed similar results while being significantly more computationally efficient. In the future, we plan to integrate our method in a full-fledged autonomous system with SLAM capabilities.

Authors
Figures
References
Keywords
Metrics
   Back to Results   
More Like This
Path Planning and Tracking for Vehicle Collision Avoidance Based on Model Predictive Control With Multiconstraints

IEEE Transactions on Vehicular Technology

Published: 2017
Integrated Path Planning and Tracking Control of Autonomous Vehicle for Collision Avoidance based on Model Predictive Control and Potential Field

2020 20th International Conference on Control, Automation and Systems (ICCAS)

Published: 2020
Show More
References
1. S. Chung, A. A. Paranjape, P. Dames, S. Shen and V. Kumar, "A survey on aerial swarm robotics", IEEE Transactions on Robotics , vol. 34, no. 4, pp. 837-855, 2018.
Show in Context View Article Full Text: PDF (920) Google Scholar
2. A. Bircher, M. Kamel, K. Alexis, H. Oleynikova and R. Siegwart, "Receding horizon path planning for 3d exploration and surface inspection", Autonomous Robots , pp. 1-16, 2016.
Show in Context Google Scholar
3. A. Bircher, M. Kamel, K. Alexis, H. Oleynikova and R. Siegwart, "Receding horizon “next-best-view” planner for 3d exploration", IEEE International Conference on Robotics and Automation (ICRA) , 2016.
Show in Context View Article Full Text: PDF (5054) Google Scholar
4. P. Oettershagen, T. Stastny, T. Mantel, A. Melzer, K. Rudin, P. Gohl, et al., "Long-endurance sensing and mapping using a hand-launchable solar-powered uav", Field and Service Robotics , pp. 441-454, 2016.
Show in Context CrossRef Google Scholar
5. R. Bonatti, Y. Zhang, S. Choudhury, W. Wang and S. Scherer, "Autonomous drone cinematographer: Using artistic principles to create smooth safe occlusion-free trajectories for aerial filming", 2018.
Show in Context Google Scholar
6. D. Mellinger and V. Kumar, "Minimum snap trajectory generation and control for quadrotors", 2011 IEEE International Conference on Robotics and Automation , pp. 2520-2525, 2011.
Show in Context View Article Full Text: PDF (1980) Google Scholar
7. M. Burri, H. Oleynikova, M. W. Achtelik and R. Siegwart, "Real-time visual-inertial mapping re-localization and planning onboard mavs in unknown environments", 2015 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) , pp. 1872-1878, 2015.
Show in Context View Article Full Text: PDF (1445) Google Scholar
8. C. Richter, A. Bry and N. Roy, "Polynomial trajectory planning for aggressive quadrotor flight in dense indoor environments" in Robotics Research, Springer, pp. 649-666, 2016.
Show in Context Google Scholar
9. S. Liu, N. Atanasov, K. Mohta and V. Kumar, "Search-based motion planning for quadrotors using linear quadratic minimum time control", 2017 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) , pp. 2872-2879, 2017.
Show in Context View Article Full Text: PDF (3361) Google Scholar
10. S. Liu, K. Mohta, N. Atanasov and V. Kumar, "Search-based motion planning for aggressive flight in se (3)", IEEE Robotics and Automation Letters , vol. 3, no. 3, pp. 2439-2446, 2018.
Show in Context View Article Full Text: PDF (842) Google Scholar
11. S. Liu, K. Mohta, N. Atanasov and V. Kumar, "Towards search-based motion planning for micro aerial vehicles", 2018.
Show in Context Google Scholar
12. B. Zhou, F. Gao, L. Wang, C. Liu and S. Shen, "Robust and efficient quadrotor trajectory generation for fast autonomous flight", IEEE Robotics and Automation Letters , vol. 4, no. 4, pp. 3529-3536, 2019.
Show in Context View Article Full Text: PDF (3656) Google Scholar
13. H. Oleynikova, M. Burri, Z. Taylor, J. Nieto, R. Siegwart and E. Galceran, "Continuous-time trajectory optimization for online uav replanning", 2016 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) , pp. 5332-5339, 2016.
Show in Context View Article Full Text: PDF (2218) Google Scholar
14. H. Oleynikova, Z. Taylor, M. Fehr, R. Siegwart and J. Nieto, "Voxblox: Incremental 3d euclidean signed distance fields for on-board mav planning", 2017 IEEE/rsj International Conference on Intelligent Robots and Systems (iros) , pp. 1366-1373, 2017.
Show in Context View Article Full Text: PDF (1000) Google Scholar
15. L. Han, F. Gao, B. Zhou and S. Shen, "Fiesta: Fast incremental euclidean distance fields for online motion planning of aerial robots", 2019.
Show in Context Google Scholar
16. F. Gao, W. Wu, Y. Lin and S. Shen, "Online safe trajectory generation for quadrotors using fast marching method and bernstein basis polynomial", 2018 IEEE International Conference on Robotics and Automation (ICRA) , pp. 344-351, 2018.
Show in Context View Article Full Text: PDF (1955) Google Scholar
17. Y. Mao, M. Szmuk, X. Xu and B. Acikmese, "Successive convexification: A superlinearly convergent algorithm for non-convex optimal control problems", 2018.
Show in Context Google Scholar
18. C. Liu, C.-Y. Lin and M. Tomizuka, "The convex feasible set algorithm for real time optimization in motion planning", SIAM Journal on Control and optimization , vol. 56, no. 4, pp. 2712-2733, 2018.
Show in Context CrossRef Google Scholar
19. S. Liu, M. Watterson, K. Mohta, K. Sun, S. Bhattacharya, C. J. Taylor, et al., "Planning dynamically feasible trajectories for quadrotors using safe flight corridors in 3-d complex environments", IEEE Robotics and Automation Letters , vol. 2, no. 3, pp. 1688-1695, 2017.
Show in Context View Article Full Text: PDF (1559) Google Scholar
20. M. Watterson, S. Liu, K. Sun, T. Smith and V. Kumar, "Trajectory optimization on manifolds with applications to so (3) and r3xs2", Robotics: Science and Systems , 2018.
Show in Context CrossRef Google Scholar
21. F. Gao, W. Wu, W. Gao and S. Shen, "Flying on point clouds: Online trajectory generation and autonomous navigation for quadrotors in cluttered environments", Journal of Field Robotics , vol. 36, no. 4, pp. 710-733, 2019.
Show in Context CrossRef Google Scholar
22. S.-p. Lai, M.-l. Lan, Y.-x. Li and B. M. Chen, "Safe navigation of quadrotors with jerk limited trajectory", Frontiers of Information Technology & Electronic Engineering , vol. 20, no. 1, pp. 107-119, 2019.
Show in Context CrossRef Google Scholar
23. G. Rousseau, C. S. Maniu, S. Tebbani, M. Babel and N. Martin, "Minimum-time b-spline trajectories with corridor constraints. application to cinematographic quadrotor flight plans", Control Engineering Practice , vol. 89, pp. 190-203, 2019.
Show in Context CrossRef Google Scholar
24. J. Tordesillas, B. T. Lopez, M. Everett and J. P. How, "Faster: Fast and safe trajectory planner for flights in unknown environments", 2020.
Show in Context Google Scholar
25. S. Shah, D. Dey, C. Lovett and A. Kapoor, "Airsim: High-fidelity visual and physical simulation for autonomous vehicles", Field and Service Robotics , 2017, [online] Available: https://arxiv.org/abs/1705.05065.
Show in Context Google Scholar
26. B. Nisar, P. Foehn, D. Falanga and D. Scaramuzza, "Vimo: Simultaneous visual inertial model-based odometry and force estimation", IEEE Robotics and Automation Letters , vol. 4, no. 3, pp. 2785-2792, 2019.
Show in Context View Article Full Text: PDF (1788) Google Scholar
27. D. D. Harabor and A. Grastien, "Online graph pruning for pathfinding on grid maps", Twenty-Fifth AAAI Conference on Artificial Intelligence , 2011.
Show in Context Google Scholar
28. K. Robotics, "Mrsl jump point search planning library v1.1", [online] Available: https://github.com/KumarRobotics/jps3d.
Show in Context Google Scholar
29. C. Toumieh and A. Lambert, "Gpu accelerated voxel grid generation for fast mav exploration", 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) , 2021.
Show in Context Google Scholar
30. C. Toumieh and A. Lambert, "Voxel-grid based convex decomposition of 3d space for robot planning", 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS) , 2021.
Show in Context Google Scholar
31. L. Gurobi Optimization, "Gurobi optimizer reference manual", 2020, [online] Available: http://www.gurobi.com.
Show in Context Google Scholar
32. M. Kamel, M. Burri and R. Siegwart, "Linear vs nonlinear mpc for trajectory tracking applied to rotary wing micro aerial vehicles", IFAC-PapersOnLine , vol. 50, no. 1, pp. 3463-3469, 2017.
Show in Context CrossRef Google Scholar
33. R. Verschueren, G. Frison, D. Kouzoupis, N. van Duijkeren, A. Zanelli, R. Quirynen, et al., "Towards a modular software package for embedded optimization", Proceedings of the IFAC Conference on Nonlinear Model Predictive Control (NMPC) , 2018.
Show in Context CrossRef Google Scholar
34. "Nvidia jetson nano", [online] Available: https://developer.nvidia.com/embedded/jetson-nano-developer-kit.
Show in Context Google Scholar
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
