Springer Tracts in Advanced Robotics
Volume 58
Editors: Bruno Siciliano · Oussama Khatib · Frans Groen

Torsten Kröger
On-Line Trajectory Generation in Robotic Systems
Basic Concepts for Instantaneous Reactions to Unforeseen (Sensor) Events
ABC

Professor Bruno Siciliano, Dipartimento di Informatica e Sistemistica, Università di Napoli Federico II, Via Claudio 21, 80125 Napoli, Italy, E-mail: siciliano@unina.it Professor Oussama Khatib, Artiﬁcial Intelligence Laboratory, Department of Computer Science, Stanford University, Stanford, CA 94305-9010, USA, E-mail: khatib@cs.stanford.edu Professor Frans Groen, Department of Computer Science, Universiteit van Amsterdam, Kruislaan 403, 1098 SJ Amsterdam, The Netherlands, E-mail: groen@science.uva.nl
Author
Torsten Kröger Technische Universität Carolo-Wilhelmina zu Braunschweig Institut für Robotik und Prozessinformatik Mühlenpfordtstraße 23 D-38106 Braunschweig Germany E-mail: t.kroeger@tu-bs.de

ISBN 978-3-642-05174-6 DOI 10.1007/978-3-642-05175-3 Springer Tracts in Advanced Robotics

e-ISBN 978-3-642-05175-3 ISSN 1610-7438

Library of Congress Control Number: 2009941046
c 2010 Springer-Verlag Berlin Heidelberg
This work is subject to copyright. All rights are reserved, whether the whole or part of the material is concerned, speciﬁcally the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microﬁlm or in any other way, and storage in data banks. Duplication of this publication or parts thereof is permitted only under the provisions of the German Copyright Law of September 9, 1965, in its current version, and permission for use must always be obtained from Springer. Violations are liable for prosecution under the German Copyright Law.
The use of general descriptive names, registered names, trademarks, etc. in this publication does not imply, even in the absence of a speciﬁc statement, that such names are exempt from the relevant protective laws and regulations and therefore free for general use.
Typeset & Cover Design: Scientiﬁc Publishing Services Pvt. Ltd., Chennai, India.
Printed in acid-free paper
543210
springer.com

Editorial Advisory Board
Oliver Brock, TU Berlin, Germany Herman Bruyninckx, KU Leuven, Belgium Raja Chatila, LAAS, France Henrik Christensen, Georgia Tech, USA Peter Corke, CSIRO, Australia Paolo Dario, Scuola S. Anna Pisa, Italy Rüdiger Dillmann, Univ. Karlsruhe, Germany Ken Goldberg, UC Berkeley, USA John Hollerbach, Univ. Utah, USA Makoto Kaneko, Osaka Univ., Japan Lydia Kavraki, Rice Univ., USA Vijay Kumar, Univ. Pennsylvania, USA Sukhan Lee, Sungkyunkwan Univ., Korea Frank Park, Seoul National Univ., Korea Tim Salcudean, Univ. British Columbia, Canada Roland Siegwart, ETH Zurich, Switzerland Guarav Sukhatme, Univ. Southern California, USA Sebastian Thrun, Stanford Univ., USA Yangsheng Xu, Chinese Univ. Hong Kong, PRC Shin’ichi Yuta, Tsukuba Univ., Japan

EUR ***ON

STAR (Springer Tracts

in

Advanced Robotics) has been promoted un-

***

European
ROBO*** TICS

***

der the auspices of EURON (European Robotics Research Network)

Research Network

There is always an easy solution to every human problem — neat, plausible, and wrong.
Henry Louis Mencken (1880–1956)

Foreword
By the dawn of the new millennium, robotics has undergone a major transformation in scope and dimensions. This expansion has been brought about by the maturity of the ﬁeld and the advances in its related technologies. From a largely dominant industrial focus, robotics has been rapidly expanding into the challenges of the human world. The new generation of robots is expected to safely and dependably co-habitat with humans in homes, workplaces, and communities, providing support in services, entertainment, education, healthcare, manufacturing, and assistance.
Beyond its impact on physical robots, the body of knowledge robotics has produced is revealing a much wider range of applications reaching across diverse research areas and scientiﬁc disciplines, such as: biomechanics, haptics, neurosciences, virtual simulation, animation, surgery, and sensor networks among others. In return, the challenges of the new emerging areas are proving an abundant source of stimulation and insights for the ﬁeld of robotics. It is indeed at the intersection of disciplines that the most striking advances happen.
The goal of the series of Springer Tracts in Advanced Robotics (STAR) is to bring, in a timely fashion, the latest advances and developments in robotics on the basis of their signiﬁcance and quality. It is our hope that the wider dissemination of research developments will stimulate more exchanges and collaborations among the research community and contribute to further advancement of this rapidly growing ﬁeld.
The monograph written by Torsten Kr¨oger is the outcome of six years of work by the author during his doctoral thesis. The book focuses on sensor integration in robotic manipulation control systems, and in particular on the instantaneous planning of motion trajectories in reaction to unforeseen sensor events, such as failures or more simply a change of reference frame or control space. The supporting theoretical tool is hybrid switched-system control enabling to switch from sensor-guided motion, e.g., under force/torque or visual servo control, to sensor-guarded motion and vice versa. The resulting online trajectory generation algorithm serves as an intermediate layer between

X

Foreword

low-level motion control and high-level sensor-based motion planning. Numerous examples illustrate the proposed concepts in practice.
This volume is a very ﬁne addition to our STAR series!

Naples, Italy September 2009

Bruno Siciliano STAR Editor

Preface
Research activities in the ﬁeld of engineering cannot be performed by individuals alone. One always has to intercommunicate, to discuss, to exchange knowledge and experiences — to work together. This monograph is the result of six years of research on robot motion control at the Institut fu¨r Robotik und Prozessinformatik at the Technische Universita¨t Braunschweig.
It contains nothing but the description of an algorithm for on-line trajectory generation in robotics. The original idea of this algorithm was born during my diploma thesis in 2001. At ﬁrst, I thought I could develop such an algorithm as a small subpart of my thesis, but after two weeks working on a concept, I decided to simplify the problem and developed an algorithm whose functionality was greatly reduced. During my time as a PhD student, I supervised a number of master students, who worked on a more advanced version of the algorithm, but the algorithms we developed at that time were erroneous and incomplete, as I know now. It took me some years to discover what the actual problem of this trivial and seemingly simple idea was — and the basic idea was extremely simple, not even worth publishing. Now, years later, the original idea has been realized, and the way from the idea to its realization shall be conclusively, compactly, and comprehensively presented in this book. During this project, I have interacted with many people. Each has had some inﬂuence on the ﬁnal version of this document, and I am absolutely grateful for all these contributions.
First of all, I would like to thank my supervisor, Professor Friedrich Wahl. He provided excellent technical equipment, an ideal environment, and the best imaginable atmosphere for a group of young, highly motivated researchers. All the discussions, all the encouragements, and the great latitude during all stages of this work gave me the possibility of working very eﬃciently and — in particular — of choosing my own area in the ﬁeld of robotics research. I sincerely appreciate this.
Professor Herman Bruyninckx from the Department of Mechanical Engineering at the Katholieke Universiteit Leuven not only reviewed this work as the second examiner, he has also been an important discussion partner over

XII

Preface

the years. After our ﬁrst meeting in 2003, we met sporadically, and we always had great dialogs that were always very fruitful for me.
I should like to give a special word of thanks to the whole staﬀ of the Institut fu¨r Robotik und Prozessinformatik. The friendly and cooperative environment is preeminent. In particular, I owe a debt to Daniel Kubus. He proofread the manuscript, and he has always been an excellent and competent discussion parter who supported me in manifold ways.
Furthermore, I would like to express my gratitude to my former diploma supervisor and later colleague, Bernd Finkemeyer. He belongs to the most reliable and respectable persons I have met in my whole life. The core of Chap. 7 of this book is based on his ideas, approaches, and experiments. Although he left the university, we still discuss and meet regularly, which very often leads to valuable new ideas.
During the development of the on-line trajectory generation algorithms, a number of mathematical problems occurred, and I am very grateful to Professor Sa´ndor Fekete, Professor Harald Lo¨we, and Professor Rainer Lo¨wen, all of whom gave me immediate support in a very eﬃcient way.
Michael Marschollek gave me a short introduction to neurophysiology and very good references to this ﬁeld, such that I could write a subsection about the neurophysiological system of human beings in order to compare the reﬂexes of humans and robots.
All diploma and master students who worked under my supervision have earned great tribute. Especially, Michaela Hanisch, Christian Hurnaus, and Adam Tomiczek strongly supported me with their eﬀorts, discussions, and ideas. All three worked hard on the ﬁrst ideas and implementations of the concept of on-line trajectory generation.
Many thanks to all my friends in Braunschweig and in other places — we really had a great time during the past eleven years of study. I will never forget this lovely period of life. Finally, I thank my family for their outstanding aid during all my years of study.

Braunschweig, January 2009

Torsten Kro¨ger

Abstract
This monograph focuses on sensor integration in robotics, in particular in robotic manipulation control systems. We consider a mechanical system with multiple degrees of freedom equipped with one or more sensors delivering digital and/or analog sensor signals. There is no question that sensor integration and sensor-based control belong to the dominating domains for the future advancement of robotic systems. Although there has been much research on this objective, there is still one important question that has not been answered yet: If we consider a robot in an arbitrary state of motion, how can we calculate a trajectory, if we want the robot to react instantaneously to unforeseen sensor events?
The core part derives a class of algorithms that generate motion trajectories for robotics systems on-line, that is, within one control cycle (typically one millisecond or less). Such an algorithm is executed in parallel to low-level motion controllers, and systems using it are able to react instantaneously to unforeseen (sensor) events. In order to answer the above question, the algorithm enables switchings from sensor-guided robot motion control (e.g., force/torque or visual servo control) to trajectory-following motion control and vice versa, which is an important feature for the practical realization of sensor-based robot motion control systems. The proposed on-line trajectory generation algorithm acts as an open-loop pose controller at an intermediate control layer that functions as one element of the important bridge between low-level robot motion control and higher-level (sensor-based) motion planning. Furthermore, it enables robotic systems to perform a kind of robotic reﬂex.
As the ﬁrst derivation step, the algorithm is developed for systems with one actuator only, and subsequently it becomes extended to be applicable in robotic systems with multiple degrees of freedom. The generated trajectories are time-optimal and synchronized for all degrees of freedom, such that all degrees of freedom reach their target at the same time instant.
Using the proposed on-line trajectory generation algorithm as one control submodule in a hybrid switched-control system simpliﬁes the execution of

XIV

Abstract

sensor-guided and sensor-guarded motions. As the algorithm is able to take over control at any time instant and in any state of motion, safe and continuous motions can be guaranteed — even if sensors fail. An additional beneﬁt is that unforeseen (sensor-dependent) switchings of reference frames and/or control spaces become possible.
The proposed concept is of a very basic nature and, thus, addresses various ﬁelds of robotics, in which sensor integration plays a fundamental role, for example, in service robotics, manipulation control systems, mobile robotics and manipulation, and robotic surgery. Samples and use-cases accompany the book in order to provide a comprehensible insight into this interesting and relevant ﬁeld of robotics.

Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.1 Robot Motion Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 1.1.1 Path Planning and Trajectory-Following Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 1.1.2 Sensor-Guided Robot Motion Control . . . . . . . . . . . . . . 2 1.1.3 Verbal Problem Formulation and Motivation for This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 1.1.4 Deﬁnition: Sensor-Guarded Robot Motion Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5 1.2 Excursion: The Neurophysiological System of Human Beings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6 1.3 Outline of This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2 Literature Survey: Trajectory Generation in and Control of Robotic Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.1 Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11 2.2 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 2.3 State of the Art in Robot Technology . . . . . . . . . . . . . . . . . . . . 13 2.4 State of the Art in Robotics Research . . . . . . . . . . . . . . . . . . . . 15 2.4.1 Path Planning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15 2.4.2 Trajectory Planning Concepts . . . . . . . . . . . . . . . . . . . . . 17 2.4.3 Robot Motion Control . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 2.4.4 Human-Inspired Motion Analysis . . . . . . . . . . . . . . . . . . 27 2.4.5 Own Works . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28 2.5 Conclusions and Classiﬁcation of This Work . . . . . . . . . . . . . . 29
3 Mathematical Conventions and Problem Formulation . . . . 33 3.1 Notation and Nomenclature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33 3.2 Classiﬁcation of On-Line Trajectory Generators . . . . . . . . . . . 38 3.2.1 Type Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

XVI

Contents

3.2.2 Variant Classiﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 3.3 Formal Problem Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40 3.4 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
4 Solution for One Degree of Freedom . . . . . . . . . . . . . . . . . . . . . 45 4.1 Generic Algorithm for On-Line Trajectory Generation . . . . . . 45 4.1.1 Problem Formulation for One-DOF Systems . . . . . . . . 45 4.1.2 Generic Solution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47 4.2 Solution for Type IV . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49 4.2.1 Type IV, Variant A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50 4.2.2 Type IV, Variant B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 4.3 Summary and Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
5 Solution in Multi-dimensional Space . . . . . . . . . . . . . . . . . . . . . 69 5.1 General Variant A Algorithm for On-Line Trajectory Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69 5.1.1 Step 1: Calculating the Synchronization Time tisync . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 5.1.2 Step 2: Synchronization . . . . . . . . . . . . . . . . . . . . . . . . . . 75 5.1.3 Step 3: Calculation of Output Values . . . . . . . . . . . . . . 79 5.1.4 Final Remarks on the General OTG Algorithm . . . . . . 80 5.2 Extension for Variant B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80 5.3 Type IV On-Line Trajectory Generation . . . . . . . . . . . . . . . . . . 80 5.3.1 Type IV, Variant A . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81 5.3.2 Type IV, Variant B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95 5.4 Summary and Final Remarks . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
6 On-Line Generation of Homothetic Trajectories . . . . . . . . . 99 6.1 Problem Formulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 99 6.2 The Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
7 Hybrid Switched-System Control for Robotic Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105 7.1 Hybrid Switched-System Control . . . . . . . . . . . . . . . . . . . . . . . . 105 7.2 The Manipulation Primitive Framework . . . . . . . . . . . . . . . . . . 108 7.2.1 Manipulation Primitives as Interface to Hybrid Switched-Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109 7.2.2 Control Scheme for the Execution of Manipulation Primitives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117 7.2.3 Remarks on the Availability Flag Vector fic . . . . . . . . 123 7.2.4 Remarks on Task Frame Switchings . . . . . . . . . . . . . . . . 124 7.2.5 Remarks on the OTG Module . . . . . . . . . . . . . . . . . . . . . 126 7.3 On-Line Trajectory Generation for Open-Loop Velocity Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128 7.4 Stability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132 7.5 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134

Contents

XVII

8 Experimental Results and Applications . . . . . . . . . . . . . . . . . . 137 8.1 Handling Arbitrary States of Motion . . . . . . . . . . . . . . . . . . . . . 137 8.2 Instantaneous Reaction to Unforeseen (Sensor) Events . . . . . 139 8.3 Homothetic Trajectories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141 8.4 Unforeseen Switchings of Reference Coordinate Systems . . . . 145 8.5 Unforeseen Switchings of State Spaces . . . . . . . . . . . . . . . . . . . . 148 8.6 Hybrid Switched-System Control of a Six-DOF Industrial Manipulator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
9 Further Discussion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159 9.1 On-Line Trajectory Generation as an Interface to Non-Real-Time Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159 9.2 Visual Servo Control . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160 9.3 Relation to High-Level Motion Planning Systems . . . . . . . . . . 161 9.4 The Problem of Overshooting . . . . . . . . . . . . . . . . . . . . . . . . . . . 163 9.5 Embedding of Robot Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . 164 9.6 Further Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 9.7 Migration of Existing Architectures . . . . . . . . . . . . . . . . . . . . . . 169 9.8 Real-Time Veriﬁcation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170 9.9 Higher Control Rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 9.10 Aspects on the Development of Decision Trees . . . . . . . . . . . . 173 9.11 Completeness Analysis of Decision Trees . . . . . . . . . . . . . . . . . . 174 9.12 OTG Types V – IX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175 9.13 Further Variants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176 9.14 On the Elegance of Natural Laws . . . . . . . . . . . . . . . . . . . . . . . . 177
10 Summary, Future Work, and Conclusion . . . . . . . . . . . . . . . . . 179 10.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179 10.2 Limitations and Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . 182 10.3 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
A The Modiﬁed Anderson-Bj¨orck-King Method . . . . . . . . . . . . 185
B Details on the P osT riN egT ri Acceleration Proﬁle (Step 1) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 B.1 Position-Error Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189 B.2 Derivative of the Position-Error Function . . . . . . . . . . . . . . . . . 189 B.3 Setting up the Parameters of Mi . . . . . . . . . . . . . . . . . . . . . . . . 190
C Details on the P osT riZeroN egT ri Acceleration Proﬁle (Step 2) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195 C.1 Position-Error Function . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195 C.2 Setting up the Parameters of Mi . . . . . . . . . . . . . . . . . . . . . . . . 196

XVIII

Contents

D Type IV On-Line Trajectory Generation in Very Simple Terms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 D.1 The Rocket Car Example . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201 D.2 Type IV OTG for One-DOF Systems . . . . . . . . . . . . . . . . . . . . 202 D.3 Type IV OTG for Multi-DOF Systems . . . . . . . . . . . . . . . . . . . 203
Abbreviations and Symbols . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207
References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213

Chapter 1
Introduction

Sensor integration belongs — without any doubt — to one of the key technologies for the future advancement of robotic systems. This introductory chapter describes the subject of on-line trajectory generation (OTG) and its relation to (multi-)sensor integration and sensor-based control in the ﬁeld of robot technology. Furthermore, it contains a brief outline of this monograph.

1.1 Robot Motion Control
The ﬁeld of OTG is not dedicated to one particular kind or group of robotic systems. As will be ﬁgured out in the book, OTG is of very fundamental character and applicable to all kinds of robotic systems, in which sensor integration and sensor-based control plays a fundamental role. Hence, a robot is considered a very abstract kind of mechanical positioning system with multiple degrees of freedom (DOF).
We take the deﬁnition of the term “robot” speciﬁed by the International Organisation for Standardisation in ISO 8373 [117] as the basis:“An automatically controlled, reprogrammable, multipurpose manipulator programmable in three or more axes, which may be either ﬁxed in place or mobile for use in industrial automation applications.” This deﬁnition is also accepted by the International Federation of Robotics (IFR) [116] and by the European Robotics Research Network (EURON) [75]. Although this work originates from the ﬁeld of industrial manipulation control, the presented concept is not limited to the ﬁeld of industrial automation applications. OTG is also relevant in many other ﬁelds of robotics, such as service robotics, manipulation control systems, mobile robotics and manipulation, parallel kinematic machines, humanoid robotics, and robotic surgery. Besides, also the development of motion generation algorithms for computer numerical controlled (CNC) machine tools is addressed in this work.
Motion control of robotic systems belongs to the most classical areas of research in the ﬁeld of robotics. In the following two subsections, we brieﬂy

T. Kr¨oger: On-Line Trajectory Generation in Robotic Systems, STAR 58, pp. 1–9.

springerlink.com

c Springer-Verlag Berlin Heidelberg 2010

2

1 Introduction

Fig. 1.1 Basic outline of an example scheme for joint space control.
distinguish between trajectory-following control and sensor-guided robot control. Based on this distinction, we introduce a deﬁnition of sensor-guarded motion control.
1.1.1 Path Planning and Trajectory-Following Operations
One of the simplest methods of robot motion control is trajectory-following control, which is common in industrial manipulation control systems. As shown in Fig. 1.1, command variables containing joint positions qd(t), velocities q˙d(t), and accelerations q¨d(t) are sent to a joint controller, which is responsible for minimizing the error between the desired robot position qd(t) and the actual q(t) in order to achieve a good trajectory-following behavior. Depending on the joint type, rotatory or prismatic, the output of the joint controller f (t) contains forces and/or torques for the joints of the mechanical system. The command variables qd(t), q˙d(t), and q¨d(t) are functions of time and describe the trajectory of the robot. In contrast to this, a path is only a geometric representation of the desired robot motion without any consideration of time. Hence, we generally have to distinguish between trajectory generation and path planning. In the ﬁeld of path planning, we take geometric descriptions of the robot and its static or dynamic environment for granted. The aim is to ﬁnd a collision-free path from an initial pose to a target pose; this search is commonly done in the conﬁguration space. Fig. 1.2 shows a trivial example, in which the path from the initial position pstart to the target position ptrgt is represented by three vertexes, which are connected by splines. The aim of trajectory generation however, is to calculate command variables in order to reach the target position and orientation along the speciﬁed path under consideration of some criterion, for example, minimum-time or minimum-energy.
1.1.2 Sensor-Guided Robot Motion Control
In contrast to trajectory-following operations, which commonly do not allow a controlled reaction to sensor signals, sensor-guided robot motions only work on the basis of sensor signals, that is, the sensor is part of the control loop. Fig. 1.3 shows a control scheme on a very abstract level. We take the

1.1 Robot Motion Control

3

Fig. 1.2 Path planning: two-dimensional conﬁguration space example of a collisionfree path.
simple concept of Fig. 1.1 as the basis and assume that the robot is equipped with some sensor system (e.g., a force/torque sensor or a computer vision system) that delivers a signal s(t). Here, we consider a sensor as a generic device delivering a signal depending on the overall system state, that is, the robotic system with its entire environment. The robot motion of one single control cycle depends on the sensor signal(s) of the current control cycle. The respective controller for this signal acts in task space and uses its command variable sd(t) as well as the position feedback p(t) to generate new set-points pd(t), p˙d(t), and p¨d(t). These values are transformed back into joint space and act as command variables for the joint controller. It is obvious that this system can react to arbitrary situations, states, and events as long as they are detected by the sensor system. The reaction behavior only depends on the transfer function of the controller for the sensor signal s(t).
1.1.3 Verbal Problem Formulation and Motivation for This Book
Up to here we have deﬁned the two basic kinds of robot motions: trajectoryfollowing control (without sensors) and sensor-guided motion control. For
Fig. 1.3 Very abstract example of a scheme for sensor-guided robot motion control.

4

1 Introduction

Fig. 1.4 Very simple scheme to illustrate the subject of this book.
the realization of practically relevant systems, both kinds of control are required — of course. It is even necessary to combine both and use them at the same time; then some system DOFs are guided based on some sensor signal, and others are controlled with regard to a speciﬁed trajectory. A simple example of a system with three independent translational DOFs would be a motion command, for which force control in z-direction, distance control in y-direction, and trajectory-following control in x-direction is applied. The literature is full of approaches, descriptions, and research on sensor-based control. Force/torque control has had a dedicated community since the beginning of the 1980s as well as the ﬁeld of visual servo control has since the beginning of the 1990s. The same is of course true for the ﬁeld of trajectory generation for robotic systems; here the roots can be found in the 1960s. On the other hand, we have to wonder, why these proven concepts and technologies can hardly be found in commercially available robotic systems.
Major problems appear when all these ﬁelds are merged together: We must be able to switch abruptly at unforeseen time instants from one kind of robot control to another. If we arbitrarily switch one or more DOFs from trajectoryfollowing control to sensor-guided control, this problem is usually a solved. By using the transfer function of a desired controller, command variables for lower-level control can be generated at any time instant. But how can we switch one, some, or all DOFs of a robotic system from sensor-guided control to trajectory-following control? If we consider a robot in an arbitrary state of motion how can we calculate a trajectory if we want the robot to react instantaneously to unforeseen (sensor) events?
This is the central question of this work. Its answer allows us to change trajectory parameters for one or more DOFs at any time instant and in any arbitrary state of motion. Thus, we can not only close the signiﬁcant gap in the loop depicted in Fig. 1.4, but we can furthermore inﬂuence and change a currently executed trajectory in one or more DOFs at any arbitrary time instant.
In order to make a strong diﬀerentiation from similar ﬁelds: This work does not contain any path planning methodologies. As depicted in Fig. 1.5, OTG acts as an interface between high-level motion planning and low-level joint control.

1.1 Robot Motion Control

5

Fig. 1.5 Abstract three-layer model for robot motion control in accordance with [36].
1.1.4 Deﬁnition: Sensor-Guarded Robot Motion Control
We consider a robot equipped with one or more sensors delivering digital and/or analog sensor signals. The time instant, in which an analog sensor variable exceeds or under-runs a certain value, a digital sensor output switches, or a Boolean expression consisting of a number of conditions containing any available sensor signal becomes true, is considered a sensor event. A simple example of a sensor event is the transition from free space to contact (or vice versa). As soon as the measured contact force exceeds a certain threshold above the noise level, contact can be detected. Another example is the unforeseen detection of an object (e.g., a human being) by a computer vision system. All these are events that the robot has to instantaneously react to. Thus, we extend our classiﬁcation to
1. trajectory-following control (Section 1.1.1) 2. sensor-guided motion control (Section 1.1.2) 3. sensor-guarded motion control
and deﬁne the latter one as follows:
Deﬁnition 1.1 (Sensor-Guarded Motion). Sensor-guarded motions are considered as trajectory-following motions and/or sensor-guided motions, whose motion parameters for one, some, or all DOFs may change abruptly depending on sensor events. These parameter changes may include set-point switchings for closed-loop controllers (e.g., new force/torque control setpoints) as well as new desired target positions and/or new constraints for trajectory-following control.
In the moment of contact detection, for example, the control system may immediately and abruptly switch the respective controllers for all DOFs in contact from trajectory-following control to force/torque control. A second obvious example of the ﬁeld of visual servo control is the instantaneous reaction of a robotic system to any predictable or unpredictable event: The manipulator of [142] plays the parlor game Jenga [107] and has to interrupt any motion as soon as the game tower topples.
The fundamental achievement of sensor-guarded motions is that robotic systems become enabled to react instantaneously to unforeseen (sensor)

6

1 Introduction

events — similar to reﬂexes of living beings. Due to this absolutely new development, a new philosophy for robot control architecture may become possible. Since this development has rarely been considered in the robotics research literature on control systems technology, the next chapter brieﬂy investigates how the neurophysiological system of human beings performs a reﬂex motion.

1.2 Excursion: The Neurophysiological System of Human Beings
Sensor-guarded motions are comparable with many everyday human life scenarios: If a little child accidentally touches a stove with its hand, it kneejerkily reacts by pulling its hand away from the hot surface. Another higherlevel human scenario could be the ﬁght between two swordsmen: Depending on the motion of their opponent, the ﬁghters react immediately by adapting their own body motions and moves.
This section makes a short excursion from robotics to the human neurophysiological system and explains how a human reﬂex is performed. Except for the three blocks on the left, Fig. 1.6 was created in accordance with [262]. The author is clearly aware to the fact that the ﬁgure is wrong from a strictly neurophysiological or anatomical point of view. The only purpose of this

Fig. 1.6 Greatly simpliﬁed scheme of human neurophysiological control loops and general components of a reﬂex arc in accordance with [262].

1.3 Outline of This Book

7

ﬁgure is to transfer the principle of human motor skills (in particular reﬂexes) to the engineering area.
If we unknowingly touch a very spiky object and suddenly perceive pain, we immediately pull our hand away in a reactive manner (without thinking, that is, without global motion planning). The event of touching the spiky object activates a stimulus to the sensory receptors 1jin our skin, which respond by producing a graded generator potential. This potential is conducted to our spinal cord by sensory neurons 2j. In the simplest type of reﬂex, a monosynaptic reﬂex, the integrating center 3jin our spinal cord is a single synapse between a sensory neuron and a motor neuron. Speaking in the language of an engineer, a synapse is a kind of a switch, comparable to a transistor. More often, the integrating center consists of more than one synapse, which is then called polysynaptic reﬂex arc. Polysynaptic reﬂexes enable the involvement of more than one muscle to perform more complex motions, for example, pulling the whole arm, including the hand, away from something. The impulses triggered by the integrating center propagate from the central nervous system along a motor neuron 4jto the part of the body that will respond. This part, a muscle or a gland, is called an eﬀector 5j, which responds to the motor nerve impulse and performs the resulting movement — the reﬂex.
Such a synaptical reﬂex arc can be regarded as a low-level control loop for sensor-guarded motions. Above this loop, we can ﬁnd further anatomic systems for our motor skills, in particular the cerebrum and the cerebellum. These parts of our brain perceive the stimulus after the reﬂex motion has been initiated and are responsible for higher-level motion planning. To build a bridge from this neurophysiological excursion back to the ﬁeld of robotics, the human eyes were considered in Fig. 1.6 to have an analogousness to visual servo control.
The quintessence of this excursion is that we do not have a part in the ﬁeld of robot motion control that is comparable to the human reﬂex arc. It seems obvious that such a system would make advances in robotics. The whole wide ﬁeld of sensor-based robot motion control could be reorganized in order to open the gate to new and advanced robotic applications. The major requirement for such a technological advance is that motion control set-points can be generated from any arbitrary state of motion under consideration of dynamic and kinematic constraints. Developing, describing, and evaluating such a module, which is responsible for providing a kind of robot reﬂex, is the aim of this work.

1.3 Outline of This Book
As indicated in Fig. 1.7, this section brieﬂy outlines the rest of this work. To underline the statements of this introductory chapter, Chap. 2 gives a wide overview of the state of the art in technology and the state of the art in

8

1 Introduction

Fig. 1.7 Overview of the coherence of the chapters in this book.
research. Since the actual algorithm for OTG, which will be presented later, is rather large in scale, we describe it strictly mathematically in order to keep this monograph compact. For this purpose, it is necessary to introduce dedicated notations as well as some conventions, which is done in Chap. 3. Based on this, a formal problem formulation for this work as well as a classiﬁcation of diﬀerent types of OTG are given. In order to deduce the central algorithm step by step, Chap. 4 delivers the solution for the one-dimensional case, and Chap. 5 transfers this solution to systems with multiple DOFs. One special case, which is practically very important, is the on-line generation of straight-line trajectories; the following chapter extends the existing algorithm to enable the generation of homothetic trajectories.
The central novelty of this work is an open-loop control module, which is able to generate time-optimal and time-synchronized motion trajectories for any mechanical system with multiple DOFs during runtime, that is, on-line during every low-level control cycle. This enables new advances for multisensor integration in robotic systems, and hybrid switched-control systems become suitable for a wide range of robotic applications. How hybrid switchedsystems control can be used for the realization of multi-sensor-based control is addressed in Chap. 7.
Subsequently, simulation and real-world experimental results are discussed in Chap. 8. Besides the exemplary description of several switching events, we describe the OTG interface in relation to higher-level motion planning

1.3 Outline of This Book

9

systems. Furthermore, it is addressed how dynamic system models can be used for the optimization of the resulting trajectory. Before Chap. 10 concludes, Chap. 9 takes up some further marginal topics and deals with them in greater detail.
The Chicago Manual of Style [258] was used as guideline for the writing of this book.

Chapter 2
Literature Survey: Trajectory Generation in and Control of Robotic Systems

This work spans and combines a wide range of research topics. In order to classify this work within the robotics research landscape, this chapter provides a survey about all adjoining ﬁelds. Starting with a short section on terminology, the states of the art in technology as well as in robotics research are surveyed.

2.1 Terminology
Before going ahead with the literature survey, some terms and words are brieﬂy deﬁned for the context of this book in order to prevent misunderstandings and misusages as often happens in literature.
Pose/position/orientation A pose is considered position and orientation in Euclidian space. For all other spaces regarded in this book, for example, the joint space or any other multi-dimensional space, we only consider the term position for all DOFs. For example, position control in joint space takes all DOFs into account, while position control in Cartesian space only includes the three translational DOFs.
Path planning A path is a geometric representation of a plan to move from a start to a target pose. The task of planning is to ﬁnd a collision-free path among a collection of static and dynamic obstacles. Path planning can also include the consideration of dynamic constraints such as workspace boundaries, maximum velocities, maximum accelerations, and maximum jerks. We distinguish between on-line and oﬀ-line path planning algorithms. Oﬀ-line planned paths are static and calculated prior to execution. On-line methods enable the path (re-)calculation and/or adaptation during the robot motion in order to react to and interact with dynamic environments. This means that a robot moves along a path that has not necessarily been computed completely, and which may change during the movement. The

T. Kr¨oger: On-Line Trajectory Generation in Robotic Systems, STAR 58, pp. 11–31.

springerlink.com

c Springer-Verlag Berlin Heidelberg 2010

12

2 Literature Survey: Trajectory Generation

term real-time path planning is a synonym for on-line path planning. It would not make sense to use non-real-time planning algorithms for on-line purposes. Trajectory planning A trajectory is more than a path: It also includes velocities, accelerations, and jerks along the path. A common task is to ﬁnd trajectories for a priori speciﬁed paths, which fulﬁll a certain criterion (e.g., minimum execution time). We distinguish between on-line and oﬀ-line trajectory planning methods. An oﬀ-line calculated trajectory cannot be inﬂuenced during its execution, while on-line trajectory planning methods can (re-)calculate and/or adapt the robot’s motion behavior during the movement. The reasons for this (re-)calculation and/or adaptation can vary: improvement of accuracy, better utilization of currently available dynamics, reaction to and interaction with a dynamic environment, or reaction to (sensor) events. Analogous to real-time path planning, the term real-time trajectory planning is used in the same way as on-line trajectory planning. Motion planning Motion planning includes the task of path planning and the task of trajectory planning. On-line and oﬀ-line motion planning is deﬁned analogously to on-line path planning and on-line trajectory planning. Trajectory generation This term is used as a synonym for trajectory planning. Motion control A robotic system interacts with its environment only by moving its kinematic chain. The control of the robot’s kinematic chain is meant here. It includes trajectory-following control as well as sensor-guided motion control (e.g., force/torque control).
In particular the words path and trajectory are not consistently used in literature. The meaning of oﬀ-line is clear, but on-line and real-time are often used in diﬀerent contexts, as will be seen in the two following surveying sections.

2.2 Overview
As depicted in Fig. 1.5 (p. 5), the ﬁeld of on-line trajectory generation adjoins to (low-level) robot motion control and to (higher-level) robot motion planning, such that it exactly lies in-between these ﬁelds. Since these ﬁelds belong to the most classical ones in robotics research, we can ﬁnd plenty of technological and scientiﬁc contributions within the last four decades that will be surveyed here.
Fig. 2.1 shows an overview of the treated topics and how this work is related to them. After the reviews in Sec. 2.3 and Sec. 2.4, we will explain in Sec. 2.5 how the work is related to ﬁelds depicted in Fig. 2.1.

2.3 State of the Art in Robot Technology

13

Fig. 2.1 Overview and logical coherence of areas treated in this chapter. The terminology is based on Sec. 2.1.
2.3 State of the Art in Robot Technology
Robot manufacturing companies commonly do not publish detailed information about their control concepts, technologies, methodologies, or philosophies. Hence, this section is very brief, and we predominantly focus on the scientiﬁc literature in the next section. To give an overview of the state of the art in robot technology, product speciﬁcations of some of the world’s leading manufacturers of industrial manipulation robots are surveyed in the following. The text is meant to be neutral and free of bias; manufacturers are named in alphabetical order.
ABB Asea Brown Boveri Ltd. [3] applies a dynamic model in their robot controller called QuickMove TMand TrueMove TMconcept [1, 2], which enable fast and accurate positioning. Sensor integration is possible through digital and/or analog input and output ports or via ﬁeld bus systems, but these signals cannot be used for an on-line trajectory adaptation, but for search runs. Even when applying the force control options RobotWare Machining FC TMor RobotWare Assembly FC TM[2], the force sensor is not part of the control loop, and only intermediate path segments are adapted based on the sensor signal. Regarding pick and place tasks, ABB oﬀers the PickMaster TM[4], which uses a computer vision system in order to cope with undeﬁned part poses.
COMAU S.p.A. Robotics [60] oﬀers the C4G TMrobot control unit with two completely diﬀerent interfaces: 1) The standard C4G TM[57] interface with the robot programming language PDL2 TMdesigned for ﬁeld applications. 2) The open interface C4G OPEN TM[58, 59] designed for research and development institutions. The programming language PDL2 TMof the standard interface is a high-level Pascal-like language with typical motion planning instructions, but it does not allow for the addressing of a sensor

14

2 Literature Survey: Trajectory Generation

in the feedback control loop. Even the sensor tracking option only provides the possibility of modifying a pre-planned trajectory, but the robotic arm remains position controlled. Compared to this, the C4G OPEN TMinterface gives users access to the low-level servo control loops [58, 59]. An external PC communicates with the C4G OPEN TMcontroller in cycles of one millisecond and can even set torque set-points, such that the user can absolutely freely develop his own control schemes. This system is excellent for research and development purposes, and users can set up sensor-guided motion control schemes having sensors in the feedback control loop.
FANUC Ltd. [79] provides options for computer vision [77] and force/torque sensor [76] integration for the R-30iA Mate TMcontrollers [78]. Nevertheless, these sensors are not part of the feedback control loop; the signals are used for planning a trajectory prior to execution.
Kawasaki Heavy Industries Ltd. [123] oﬀers robot control units named DController TM[124], which are quite closed and only accessible via the individual and plain AS-Language TM[125]. Embedding sensors in feedback control loops is not possible in any way.
KUKA Roboter GmbH [153] also applies a dynamic model for the robot motion controller KR C2 TM[152] in order to achieve shorter cycle times and a lower trajectory-following control error. KUKA oﬀers the possibility to embed sensor systems via digital and/or analog input and output ports as well via ﬁeld bus systems [151]. One interesting system is the Occubot TMsystem [150], a robot system for car seat testing. Here, forces and torques are measured in six axes during one single test cycle, and these measured values are used to adapt the trajectory of the next test cycle, such that a desired force can be exerted after a certain number of test cycles.
The robotics division of Mitsubishi Heavy Industries Ltd. [186] provides robot painting systems [185], which are generally not open for any kind of sensor integration. Mitsubishi oﬀers a so-called open architecture, which enables customers to interface the robot control unit in time steps of seven milliseconds. Reseller companies such as Battenberg Robotic [18] use this interface for individual add-on controllers.
MOTOMAN Inc. [189] provides the MOTOMAN NX100 TM[190] controller for their industrial robots. Neither the previously mentioned manufacturers nor the NX100 TMof MOTOMAN Inc. provide the feature of embedding a sensor in the feedback control loop [191].
The Kantana TMmanipulator [192] of the Neuronics AG [194] is based on the ideas of using mechanical components of very light weight, of using lowpower drives, and of mounting foam around all feather-edged parts of the arm, so that the system can be used in human environments without any further protection mechanisms. The programming interface [193] is very open, such that users can develop their own control schemes, but the standard system does not oﬀer possibilities of integration in the feedback control loop.
St¨aubli Faverges SCA [250] oﬀers robot control units, for example, the CS8C TMcontroller [248], with digital and/or analog inputs and outputs,

2.4 State of the Art in Robotics Research

15

which can be used for the retrieval of sensor signals. But as also stated for
all other commercial robot manufacturers, it is not possible to put a sensor
into the feedback loop of the controller [249]. An interesting option oﬀered by St¨aubli is the Low Level Interface LLI TM[247], which is comparable to the solution C4G Open TMof Comau Robotics. Pertin et al. describe in [207] how the LLI TMcan be used as an interface for individual control schemes. The LLI TMaccepts position and velocity set-points as well as velocity and torque
values for feedforward control.

2.4 State of the Art in Robotics Research
Fig. 2.2 indicates a ﬁrst brief classiﬁcation of this work with regard to adjoining ﬁelds, which are surveyed in the following three subsections.
General overviews of all ﬁelds can be found in some robotic textbooks. The Springer Handbook of Robotics edited by Siciliano and Khatib [240] includes a chapter about oﬀ-line motion planning written by Kavraki and LaValle [122] and a chapter about on-line motion planning written by Brock, Kuﬀner, and Xiao [36]. A very recent and also very excellent textbook on on-line (but mostly oﬀ-line) trajectory generation concepts was written by Biagiotti and Melchiorri [24]; in particular the part [25] contains fundamental methods that are also applied in this work. Basic concepts of robot motion control were formulated by Chung, Fu, and Hsu [55]. Shorter summaries are given in the textbooks of Craig [62], of Fu, Gonzalez, and Lee [94], and of Spong, Hutchinson, and Vidyasager [246]. In general, it is of course a voluminous task to classify the whole scientiﬁc literature in this ﬁeld, because we can ﬁnd contributions from four decades ago and almost every work considers diﬀerent assumptions and basic conditions, but this classiﬁcation has to be done in order to place this work correctly within this wide ﬁeld of literature.

Fig. 2.2 Brief classiﬁcation of this survey based on the terminology of Sec. 2.1.
2.4.1 Path Planning
Oﬀ-Line Path Planning Methods
Oﬀ-line path planning methods are not directly related to this work, but as on-line path planning concepts are often based on oﬀ-line ones, we refer to a selection of surveys and books: Lozano-P´erez [169], Lindemann and LaValle [166], Gonz´alez-Ban˜os, Hsu, and Latombe [101], and LaValle [156].

16

2 Literature Survey: Trajectory Generation

On-Line Path Planning Methods
On-line path planning is generally only reasonable if paths and trajectories are considered. Hence, we talk about on-line motion planning or — to use a new eligible term for this ﬁeld — real-time adaptive motion planning (RAMP, [266]). This ﬁeld of research is very young and publications are rare. There are many works assuming dynamic but exactly known environments, which is not meant here. We assume robots that have to act in a dynamic and/or unknown environment, and which are equipped with sensor systems to react to and interact on-line with (unknown) static or dynamic obstacles, events, or (abrupt) changes of task parameters. As a result, RAMP takes place in the conﬁguration×time (CT) space.
The research groups of Brock and Xiao focus on real-time capable methods for (multi-)robot motion planning. The use of splines is one very common method to represent calculated trajectories; it is the task of a motion planning algorithm to calculate respective sets of spline knots and trajectory parameters during runtime. [266] proposes an on-line motion planning approach; paths and trajectories are calculated on-line in CT-space, such that the system can act in unknown dynamic environments. Yang and Brock [280] use collision-free vertices (“milestones”) and edges on a roadmap, which is another kind of representation, to represent currently planned trajectories. These knots or milestones are generated from an overall view onto the robotic system and its environment — it is in particular a kind of motion planning from a global point of view. The PhD thesis of Brock from 1999 [33] as well as follow-up works published together with Khatib and Kavraki [34, 35] introduced the elastic strip framework. The basic idea of this work is to locally deform a previously planned trajectory in order to avoid moving obstacles inside a collision-free “elastic tunnel”, such that the robot can move taskconsistently from the initial to the desired target pose in a three-dimensional workspace.
Jaillet and Sim´eon [118] on the contrary use rapidly exploring random trees (RRT) as a local planner to update a global roadmap, which was originally represented by a probabilistic road map (PRM). This way, arbitrarily moving obstacles can be also considered during runtime. Another method, which is based on a potential ﬁeld approach, avoids unknown and dynamic obstacles and was presented by O¨ gren, Egerstedt, and Hu [195]. In the work of Mbede et al. [177], a neuro-fuzzy controller is used to locally modify the base motion of a mobile manipulator in order to avoid a moving obstacle. Based on the contribution of Mbede et al., Merch´an-Cruz and Morris [180] published a work about motion planning for cooperating manipulators in 2006. Li and Latombe [161, 162] presented works on an on-line planner for the special purpose of planning the motions of two robot arms taking arbitrarily positioned parts from a conveyer belt.

2.4 State of the Art in Robotics Research

17

2.4.2 Trajectory Planning Concepts
Oﬀ-Line Trajectory Planning Methods
Even if oﬀ-line trajectory planning is not a subject in this work, many on-line trajectory planning concepts are rooted in ideas from oﬀ-line concepts. Roth and Kahn [120] belong to the pioneers in the ﬁeld of time-optimal trajectory planning. In 1971, they published methods of optimal, linear control theory and achieved a near-time-optimal solution for linearized manipulators. The resulting trajectories are jerk-limited and lead to smaller trajectory-following errors and to less excitation of structural natural frequencies in the system.
In 1982, the work of Brady [29] introduced several techniques of trajectory planning in joint space and Paul [203, 204] and Taylor [256] published works about the planning of trajectories in Cartesian space in parallel to Brady. Lin, Chang, and Luh [165] published another purely kinematic approach in 1983 as did Castain and Paul [43] in 1984 and Chand and Doty [44] in 1985.
In 1984, one of the early publications of Hollerbach [114] ﬁrst introduced the consideration of the nonlinear inverse robot dynamics for the generation of manipulator trajectories. The aim here is to exhaust the maximum actuator forces and/or torques as well as possible in order to achieve shorter execution times. The basic idea is to represent the path as well as the trajectory by a set of parametric functions, which are employed in the dynamic model of the manipulator. This way, the optimization problem can be described for an arbitrary number of DOFs. Later works of Hollerbach’s group are based on this idea [10, 11, 223].
During the middle of the 1980s, three groups developed techniques for time-optimal trajectory planning for arbitrarily speciﬁed paths: Bobrow, Dubowsky, and Gibson [27, 28], Shin and McKay [238, 239], and Pfeiﬀer and Johanni [208]. Based on the approach of Hollerbach, that is, describing the robot dynamics of dependence on a parametric path representation, a maximum acceleration can be calculated for each point of the trajectory. These maximum acceleration values correspond to maximum actuation forces and/or torques. Furthermore, maximum actuator velocities are taken into account, such that a characteristic curve for the maximum velocity can be calculated. This so-called maximum velocity curve describes the maximum velocity for each trajectory point and has to be regarded during the trajectory planning phase, that is, the time-optimal trajectory must avoid crossing the limit curve in order to minimize execution time. A time-optimal trajectory can be found by determining the switching points between positive and negative maximum acceleration values, which have been calculated beforehand. The algorithms of the groups around Bobrow, Pfeiﬀer, and Shin diﬀer in their way to ﬁnd these switching points.
Independently from these three groups, Rajan [218] presented a splinebased approach for minimum-time motion planning (cf. Fig. 2.2). Here an initial and a goal position are given in conﬁguration space; path and trajectory

18

2 Literature Survey: Trajectory Generation

are calculated and represented by cubic splines. Geering, Guzzella, Hepner, and Onder [99] discuss the same topic and extend it to diﬀerent types of robot kinematics.
Shiller and Dubowski [235] used B-splines as extension of the basic algorithm of Bobrow, Pfeiﬀer, and Shin as did Takayama and Kano [254] later. A B-spline curve is an extended version of B´ezier curves that consists of segments, each of which can be viewed as an individual B´ezier curve with some additions; a detailed introduction can be found in [212].
In 1988, Kyriakopoulos and Saridis [154] extended the basic trajectory planning approach of Bobrow/Pfeiﬀer/Shin by introducing a minimum-jerk criterion in order to achieve a better trajectory-following behavior. Tan and Potts [255] ﬁrst transferred the ideas of Bobrow, Pfeiﬀer, and Shin to a discretely working system that was based on a discrete dynamic model. One year later, in 1989, Slotine and Yang [244] proposed an alternative algorithm for the works of Bobrow, Pfeiﬀer, and Shin. To abandon the computationally expensive calculation of the maximum velocity curve, a method for the analytical calculation of a limit curve is proposed, and conditions for characteristic switching points on this curve are determined in order to achieve a time-optimal trajectory. In the same year, Olomski [196] presented detailed experimental results and used the oﬀ-line generated trajectories as input values for diﬀerent trajectory-following control schemes.
At the same time, Chen and Desrochers [49, 50, 51] proved that, as long as only dynamic constraints are considered, a time-optimal trajectory can only be achieved if at least one actuator permanently runs in saturation. McCarthy and Bobrow [178] present a similar proof but for the more general case of robots with arbitrary amounts of DOFs.
At the beginning of the 1990s, Shiller and Lu [236, 237] extended the algorithm of Bobrow, Pfeiﬀer, and Shin and considered dynamic singularities. A dynamic singularity is a part of the trajectory, at which at least one actuator does not contribute to the acceleration along the path.
Apart from the works mentioned above, Simon and Isik [243] presented a concept using trigonometric splines in 1993. The basic idea is to connect knots in joint space that have previously been calculated by the inverse kinematic model, with parameterized trigonometric functions. Some of the parameters can be chosen to minimize the jerk, which results in a very smooth and harmonic motion in joint space.
In 1994, Dahl [63] improved the basic algorithm of Shiller and Lu, such that it becomes more compact. Furthermore, Dahl presented more advanced experimental results. Two years later, Fiorini and Shiller [89] presented a further oﬀ-line algorithm for known dynamic environments. It is based on the assumption that the environment is completely known beforehand, that is, all static objects are known, and all moving objects are known with known trajectories.
Also in 1994, von Stryk and Schlemmer [252] evolved experimental results for minimum-time and minimum-energy trajectories for a Manutec r3

2.4 State of the Art in Robotics Research

19

industrial robot. The research group of von Stryk published further works on trajectory optimization methods, for example, [109]. In 1996, Zˇlajpah [270] slightly extended the basic approach of Bobrow, Pfeiﬀer, and Shin by embedding task constraints. The original algorithm becomes redeﬁned and diﬀerent areas below the maximum velocity curve are deﬁned and taken into account during the calculation of the switching points.
Based on Lie groups and Riemannian geometry, which were applied together in research on robotics dynamics by Park, Bobrow, and Ploen in 1995 [201], Zˇefran, Kumar, and Croke [269] suggested an oﬀ-line method for the generation of task space trajectories from an initial to a target pose (both with zero velocities); this is an approach that considers multiple DOFs. The key contribution of this work is a measure for the smoothness of a multidimensional trajectory that is supposed to be optimized by the proposed algorithm. Furthermore, dynamic system constraints such as boundary velocity and acceleration curves are considered.
A method for the generation of minimum-jerk trajectories, but without consideration of robot-dynamics, was contributed by Piazzi and Visioli [209, 210] in 1998 and 2000. In a follow-up work from 2002, Bianco and Piazzi embedded robot dynamics into this approach [26].
A general overview of basic oﬀ-line trajectory planning concepts is presented in the textbook of Khalil and Dombre [126]. A more recent approach of Lambrechts, Boerlage, and Steinbuch from 2004 suggests the generation of very smooth trajectories, whose jerk derivatives are limited as well [155], but there, only one DOF-systems are considered, and the method requires initial and goal velocities of zero.

On-Line Trajectory Planning Methods
An on-line modiﬁcation of a planned trajectory may have several reasons: 1) The trajectory becomes adapted in order to improve the accuracy with a path speciﬁed beforehand; 2) The robotic system reacts on sensor signals and/or events that cannot be predicted beforehand, because the robot acts in a (partly) unknown and dynamic environment. These two reasons are rooted in the ﬁeld of robotics, but there is another ﬁeld, in which on-line trajectory planning plays an important role: CNC machine tools. The following three paragraphs survey these ﬁelds.
Improving Path Accuracy
All previously described oﬀ-line trajectory planning methods assume a dynamic model that describes the behavior of the real robot exactly. In practice, this is often not the case, and some robot parameters are only estimated, some dynamic eﬀects remain unmodeled, and system parameters may change during operation. If this is the case, the resulting robot motion is not timeoptimal anymore and/or the maximum actuator forces and/or torques are

20

2 Literature Survey: Trajectory Generation

exceeded, which leads to an undesired diﬀerence between the speciﬁed and the executed path. In the following, we give a survey of methods that adapt the trajectory on-line in order to improve the path accuracy.
In 1989, Dahl and Nielsen [64] suggested an on-line trajectory adaptation method. The approach is based on the basic algorithm of Bobrow/Pfeiﬀer/ Shin, and adapts the acceleration along the path, and furthermore the parameters of the trajectory-following controller are adapted on-line, such that the underlying trajectory-following controller becomes adapted, depending on the current state of motion.
Independently from Dahl, van Aken and van Brussel [265] proposed a concept that uses one-dimensional parameterized acceleration proﬁles along the path in joint space instead of adapted splines. These proﬁles are computed on-line under consideration of the dynamic model of the manipulator.
Also independently from the two latter works, Bestaoui [23] proposed another algorithm for on-line trajectory generation at the same time. This method replans the trajectory based on state-dependent acceleration and velocity constraints if an intermediate trajectory knot is attained, or if the diﬀerence between the real and the desired trajectory is greater than a certain threshold.
The approaches of Cao, Dodds, and Irwin from 1994 [41] and 1998 [42] use cubic splines to generate smooth paths in joint space with time-optimal trajectories. A cost function is used to deﬁne an optimization problem that considers the execution time and the smoothness of the path. The cost-function can be minimized during the motion by applying the eﬃcient numerical quasiNewton method proposed by Davidon, Fletcher, and Powell [65, 92]. Thus, new intermediate knots are calculated. Robot dynamics are only considered by a set of parameters that must be determined empirically.
The works of Bazaz and Tondu [20, 21] (1997, 1999) extend the work of Bestaoui [23] and use segments of cubic splines to interconnect trajectory segments instead of fourth-order polynomials to describe the trajectory.
In 1998, Schlemmer and Gruebel [224] suggested an on-line method that embeds a static environmental model, such that the optimization problem becomes extended. Not only the minimum time criterion is applied but also a further function representing the distance between the robot and its environment is taken into account. Hence, the aim is to ﬁnd a compromise trajectory represented by cubic splines that minimizes the execution time and that maximizes the distance to the environment.
Constantinescu and Croft [61] suggest a further improvement to the approach of Shiller and Lu [234, 236, 237] in the year 2000. The additional limitation of the derivative of actuator forces/torques leads to a limitation of the jerk in joint space and thus to smoother trajectories with better following behavior.
The PhD thesis of Pietsch [214] from 2003 is based on the method of Dahl and Nielsen and improved the concept by combining adaptive control and time-optimal trajectory planning.

2.4 State of the Art in Robotics Research

21

In the same year, Macfarlane and Croft presented a jerk-bounded, neartime-optimal, one-dimensional trajectory planner in [174] that uses quintic splines that are computed on-line. Similar to the approach of Andersson [13, 14] from 1988, which will be described in the next paragraph, Macfarlane and Croft use quintic polynomials. As an extension to Andersson, they proposed an additional algorithm, which guarantees that these polynomials will perform a limited jerk along the path. Experimental results underline the usability of this approach, but robot dynamics are not considered.
Together with Owen and Benhabib, Croft publishes a further work on on-line trajectory planning [199, 200]. Here, a cooperating robot task is considered. An oﬀ-line planned trajectory becomes adapted on-line in order to respond to unmodeled disturbances and to maintain the desired path.
A work of Kim et al. from 2007 [130] implies improving the algorithm of Macfarlane and Croft [174] by taking robot dynamics into account, but only simulation results are shown.
Sensor-Based Trajectory Adaptation
The last paragraph presented an overview of on-line trajectory generation methods for improving the path accuracy, while this one focuses on the online consideration of sensor signals.
The works of Andersson [13, 14] from 1988 and 1989 present a Ping-Pongplaying PUMA 260 manipulator, whose trajectory is generated on the basis of a three-dimensional stereo-vision system. The position progression of a trajectory is represented by quintic polynomials that are parameterized by Andersson’s algorithm. One particular property is that the algorithm works with arbitrary initial and goal conditions, in particular target velocities unequal to zero.
In 1993, Lloyd and Hayward [168] proposed a technique to perform transitions between two diﬀerent path segments. On the one hand, the manipulator dynamics are considered based on the basic trajectory generation approach of Bobrow/Pfeiﬀer/Shin [27, 28, 208, 238, 239], and on the other hand the transition window technique ﬁrst proposed by Paul [205] and Taylor [256] is applied. The two path segments, which are to be blended together within the transition window, need not be known in advance. The trajectory-describing blend function for the transition window is calculated on-line and considers acceleration and velocity bounds.
Inspired by human arm movements and based on the works of Lloyd and Hayward, the research group of Flash [98, 222] published further works in the same ﬁeld in 1999 and 2001. Their superposition principle incorporates position, velocity, and acceleration constraints. As in the method of Lloyd and Hayward, the target position in joint space can change arbitrarily, and within a certain superposition window, the current trajectory “fades out” while the new one “fades in.”

22

2 Literature Survey: Trajectory Generation

In 2002, Liu [167] presented a one-dimensional approach that calculates linear acceleration progressions on-line by parameterizing the classic sevensegment acceleration proﬁle [43]. This way, the system can react to arbitrary target position switchings at any time. Liu’s approach is strongly related to a part of this work, but as will be described in Chap. 4, it is incomplete and erroneous.
Two years later, in 2004, Ahn, Chung, and Youm [5] proposed a work for the on-line calculation of one-dimensional trajectories for any given state of motion and with arbitrary target states of motion, that is, with target velocities and target accelerations unequal to zero. Sixth-order polynomials are used to represent the trajectory, which is called arbitrary states polynomiallike trajectory (ASPOT). The major drawback of this work is that neither kinematic nor dynamic constraints can be regarded for on-line trajectory generation, such that this method cannot be applied in practice.
In a work from 2005, Chwa, Kang, and Choi [56] presented an advanced visual servo control system, whose purpose is to intercept fast and arbitrarilymoving objects with a robot. The proposed on-line trajectory planner considers the system dynamics of a two-link planar robot and works in two DOFs. A drawback of this work is its missing generality, and only simulation results are shown.
The title of the work of Kang [121] implies the description of an on-line trajectory planning method, but only basic and well-known kinematic and dynamic principles of robotics are presented.
Broqu`ere, Sidobre, and Herrera-Aguilar [38] published a work in 2008 that uses an on-line trajectory generator for an arbitrary number of independently acting DOFs. The approach is very similar to the one of Liu [167] from 2002 and is based on the classic seven-segment acceleration proﬁle [43], but this approach is unfortunately also incomplete (cf. Chap. 4) and can only perform reactions if the current acceleration value of a DOF is zero. An additional very recent work of Haschke, Weitnauer, and Ritter [108] presents an on-line trajectory planner in the very same sense as this book does. The proposed algorithm generates jerk-limited trajectories from arbitrary states of motion, but it suﬀers from numerical stability problems and only allows target velocities of zero.
On-Line Trajectory Generation for CNC Machine Tools
Besides the ﬁeld of robotics research, we can also ﬁnd approaches for trajectory generation in the ﬁeld of CNC, that is, machines reading G-code instructions and driving machine tools. G-code is the numerical control programming language. We neither give an overview of CNC systems nor introduce this ﬁeld here. Therefore, please refer to basic textbooks, for example, the one of Suh, Kang, Shung, and Stroud [253]. Another brief survey of the ﬁeld of machine tools is given in [133]. In the following, only recent CNC-related works that address the ﬁeld of on-line trajectory generation are brieﬂy surveyed.

2.4 State of the Art in Robotics Research

23

Non-uniform, rational B-splines (NURBS) are commonly used as representation of free-form shapes in the ﬁeld of CAD/CAM systems (computer aided design/computer aided manufacturing). During the process of machining, these free-form shapes are comparable to arbitrarily speciﬁed paths in the ﬁeld of robotics, and — hence — the basic task of accurate path-following, is very similar. In the ﬁeld of CNC, the path is always speciﬁed, and we only have to work on interpolators. On-line interpolators, which can also be regarded as on-line trajectory generators, are the focus of current research in machine tools. An introduction to NURBS can be found, for example, in the textbook of Piegel [212] or in a short survey by him in [211].
Works on on-line NURBS interpolation [48, 52, 54, 132, 157] usually consider the complete system dynamics for setting up CNC control units, and since the path is completely known in advance, the dynamics can also be calculated beforehand, but this way, unforeseen and unmodeled eﬀects are excluded, and the responsibility of proper functioning is passed to the tracking controllers. In order to support these controllers, it is necessary to adapt the desired trajectory on-line in order to prevent them from bringing actuators to saturation and therewith increasing the tracking error. All mentioned realtime NURBS interpolation techniques are suited for a priori-speciﬁed paths represented by NURBS, and hence these works are related to the survey about on-line trajectory generation for improving the path accuracy (p. 19).
Besides these on-line methods, we can also ﬁnd recent works in the ﬁeld of CNC machine tools that transfer basic (oﬀ-line) methods from the ﬁeld of robotics. Dong, Ferreira, and Stori [69] present an oﬀ-line algorithm to calculate a varying feedrate for CNC machine tools in order to achieve a time-optimal trajectory. The approach from 2007 uses the algorithm of Bobrow/Pfeiﬀer/Shin [27, 28, 208, 238, 239] as the basis for calculating a feedrate progression for a given path.

2.4.3 Robot Motion Control
Regarding Fig. 2.2 (p. 15), the ﬁeld of robot motion control is the third ﬁeld besides path and trajectory planning that relates to this book. Although the latter two subsections focused on robotic manipulators, we address a wide ﬁeld of robotic systems in general and hence do not focus speciﬁcally on any concrete motion control scheme or any concrete kinematic. Only brief overviews of robot motion control in general and hybrid switched-system control are given in the following.
Actuator/Joint Control in Robotics
The overview of low-level robot motion control schemes in the Springer Handbook of Robotics [55] was already mentioned earlier. Additional textbooks describing this subject are by de Wit, Siciliano, and Bastin [278], by Kozlowski

24

2 Literature Survey: Trajectory Generation

[135], by Sciavicco and Siciliano [229], and by Khalil and Dombre [127]. Many of the described approaches are based on the early works of Whitney [274] and Paul [206]. Another important issue is embedding rigid body dynamics to set up a dynamic model of the robot. The works of Featherstone [81, 82, 83] are to be mentioned as fundamental to this ﬁeld.
In the following part, we will focus on hybrid switched-system control, which constitutes the next control layer above the actuator controller. For a hybrid switched-system controller, it is essential that the underlying actuator control scheme is stable, that is, if we cannot prove stability for the inner control loops, stability for the outer loops will be even harder to prove.

Hybrid Switched-System Control
Hybrid switched-control systems are systems that comprise a family of continuously working subsystems and a supervisory discrete system that switches between them. Fig. 2.3 shows an abstract and simple scheme of a hybrid switched-system control architecture for a one-DOF system, that is, with one actuator only (e.g., a simple linear positioning unit). This system can be controlled on the basis of diﬀerent sensor signals (distance, vision, and force/torque), and depending on the current task and/or depending on the current system state and/or depending on time, one of the controllers can be selected. The force/torque, the distance, and the visual servo controllers of Fig. 2.3 are closed-loop controllers; the velocity and the position controller are open-loop controllers (i.e., on-line trajectory generators) as they will be proposed in this work. The diﬀerence between these latter two modules is

Fig. 2.3 Abstract control scheme of a hybrid switched-system for one single DOF, that is, one single actuator. The dotted vertical lines will be explained in Sec. 2.5 (p. 30).

2.4 State of the Art in Robotics Research

25

that the velocity controller does not consider target positions and only leads a single DOF to a certain velocity under given acceleration and/or jerk (additionally also the derivative of the jerk) constraints. Therefore, it is of a much simpler manner than the open-loop position controller. The system depicted in Fig. 2.3 can, of course, be extended to multiple DOFs, as will be shown in Chap. 7 (p. 105).
When we take a multi-DOF robotic manipulation system with many different sensors for granted, and when we consider a system that enables the execution of sensor-guided motion control commands in any DOF, it becomes self-evident that we need to switch discretely between several continuously working (open- and/or closed-loop) controllers at any time. Hence the analysis of hybrid switched-system control is one fundamental part of the work presented here.
Especially the works of Branicky [30, 31] and Liberzon [163, 164] provide elementary concepts to develop and analyze hybrid switched-system control techniques. In particular the stability analysis is of fundamental interest here, because the stability of a switched-system cannot be assured by the stability of each single sub-controller. To prove the stability of hybrid switched-systems can be extremely diﬃcult and many researchers are working on analyzing such stability questions. It may happen that a set of stable subsystems becomes unstable if the switching between them occurs inappropriately [32, 164, 277]. In the ﬁeld of stability analysis, we can distinguish between techniques for linear [66, 164, 181] and nonlinear [67, 179, 279] switching systems.
The discrete switching system by itself can of course not work without the respective continuously working subsystems. Hence, we also refer to basic works for the two most relevant candidates: force/torque control and visual servo control. Distance control (cf. Fig. 2.3) usually works in one DOF only and is a trivial task.

Force/Torque Control
Robotic applications such as grinding, assembly, or deburring involve an extensive contact between the robot and its environment. In order to establish this contact, force/torque control is applied. In all previously mentioned works in this section, only pose and/or position control was regarded, and this is the ﬁrst scenario, in which a further sensor is part of the feedback control loop.1 These sensors can be either wrist-mounted force/torque sensors (e.g., [15, 119]) or joint torque sensors. The latter method was, for example, successfully realized with the DLR light-weight arms [8, 149], which possess joint-integrated torque sensors. Force/torque control, based on sensor signals from wrist-mounted sensors, can be applied to a much wider range of robot systems, since only actuator position feedback — as it is common for
1 Force control concepts can be distinguished in active and passive methods. Passive ones do not consider a force/torque sensor in the feedback control loop [276] and are excluded here.

26

2 Literature Survey: Trajectory Generation

industrial robots — is required. The following paragraphs give a brief overview of this ﬁeld.
Whitney [275] and Mason [176] belong to the pioneers in the ﬁeld of compliant motion control. Based on their work, numerous approaches have been published in this ﬁeld. Khatib [129] formulated his key work about the operational space approach, and especially the group of De Schutter [226, 227, 228] contributed promising concepts to the community and coined the term Task Frame Formalism [40], which enables the development of compliant motion solutions on an abstract programming level.
These works understand force/torque control as one basic element of compliant motion concepts [267]. Three diﬀerent approaches are known from literature: 1. Impedance control [113], which uses relationships between acting forces/torques and manipulator pose to adjust the mechanical impedance of the end-eﬀector to external forces/torques; 2. Parallel control [53], which enables to control both, force/torque and pose, along the same task space direction. 3. Hybrid force/torque and pose control, which controls force/torque and pose in two orthogonal subspaces [217]. To realize this approach, we have to pay attention to the problem of orthogonality as stated by Duﬀy [72], who extended the approach such that it is consistent, independent of units, and independent of any origin coordinate system.
General overviews about the ﬁeld of force/torque control can be found in the Springer Handbook of Robotics [267] and, for example, in the textbooks of Siciliano and Villani [241] or Gorinevsky, Formalsky, and Schneider [102], respectively. The previously mentioned textbooks of de Wit et al. [278], Craig [62], Khalil et al. [128], Kozlowski [135], Sciavicco et al. [229], and Spong et al. [246] also give brief surveys of this ﬁeld. Another good overview of this ﬁeld can be found in the work of Vukobratovi´c and Sˇurdilovi´c [268].
The PhD thesis of Reisinger, who belongs to the same research group as the author does, contains a control framework for the contact transition of force/torque-controlled parallel kinematic machines [220].
Visual Servo Control
If computer vision data is used for robot motion control, we speak about visual servo control. Together with force/torque control, powerful robotic systems can be achieved, because — similar to human beings — robots can use two very complementary sensors, one to recognize the global task environment, and one for ﬁne (contact) motions. A camera may be mounted directly on a robot (eye-in-hand) or the camera can be ﬁxed somewhere in the robot’s workcell, such that it observes the robot motion from a stationary pose. The ﬁeld of visual servo control consists of three domains: low-level image processing, computer vision, and control theory. Here, only a brief overview with regard to hybrid switched-system control is given.

2.4 State of the Art in Robotics Research

27

Basic overviews were presented by Chaumette and Hutchinson [45, 46, 47], which are regarded as a very good introduction for control engineers, who often are not familiar with the ﬁeld of computer vision. The origins for most works on visual servo control can be found in the publications of Weiss, Sanderson, and Neuman [273] and of Feddema and Mitchell [84]. Detailed introductions to image processing and computer vision algorithms can be found, for example, in the textbooks of Wahl [271], by Forsyth [93], and of Ma, Soatto, Koˇseck´a, and Sastry [171].
Regarding Fig. 2.3, visual servo control is supposed to be applied as one continuously working submodule in a hybrid switched-system. Baeten and De Schutter [16] present a very comprehensive work, in which computer vision and force/torque control become uniﬁed in the Task Frame Formalism [40]. Another more recent approach of Gans and Hutchinson [95, 96, 97] suggests two visual servo controllers as submodules in a hybrid switched-system. Assuming an eye-in-hand camera setup, the ﬁrst control module uses the camera position to calculate an error signal in the feedback loop of the control law and the second submodule uses image features. Stability is proven by means of a state-based switching scheme.

2.4.4 Human-Inspired Motion Analysis
When considering reﬂexes and human motion patterns as inspiration for the development of robotic systems, as described in the explanation of human neurophysiology (Sec. 1.2, p. 6), we also have to compare both worlds with each other, and we should try to build a bridge between both ﬁelds. Flash and Hogan [91] present a mathematical model based on human arm movements. A set of tasks (including compliant motion tasks) was used to observe trajectories taken by a human arm. The observed trajectories, in particular the magnitude of the jerk integrated over the entire movement, were used to rate the performance of an executed trajectory. In a later work of Flash [90], it is analyzed what human arm trajectories would look like if test candidates performed an aimed arm movement to a visually recognized target location, and if this target location suddenly changed. Even if it is not clear how this motor task is performed, it could be stated that after a new visual stimulus appears, an old “plan” is aborted and a new one appears during the movement. A further work of Henis and Flash [110] underlines this book; here time intervals between a visual stimulus and the respective trajectory modiﬁcation are investigated. Depending on the current trajectory, that is, the current state of motion with regard to the old and the new target, such an interval takes between 10 and 300 milliseconds. Till today, it is not clear how our neurophysiological system exactly works. Human motion patterns are obviously generated on diﬀerent levels. A monosynaptic reﬂex, as described in Sec. 1.2 (p. 6), constitutes the lowest level. The motion patterns are furthermore represented in multiple layers in the human motor cortex of

28

2 Literature Survey: Trajectory Generation

the cerebrum (cf. Fig. 1.6, p. 6), which contains regions that are involved in the planning, control, and execution of human motor skills [232, 263, 272].
We can also ﬁnd works that consider human-like reﬂexes in the ﬁeld of robotics, in particular in the ﬁelds of humanoid, biped, or quadruped robots, in which common motion pattern generators are employed to generate setpoints for low-level controllers that are responsible for standing upright. After a (sensor) event, this pattern can be adapted by adding a further previously learned pattern in order to assure that the system stands upright. Zaier et al. [282, 283] propose such a control scheme for humanoid robots. The learned pattern, which is added to the currently generated one, always fades smoothly in and out, in order to prevent jerky motions. The same idea was applied to prosthetics in [230].
In [106], Haddadin, Albu-Sch¨aﬀer, De Luca, and Hirzinger present a very impressive work on the detection of unforeseen collisions and respective reaction concepts. Based on previous works of the authors [103, 104, 105, 170], ﬁve diﬀerent collision (= sensor event) reaction strategies are investigated2: 1) The robot shows no reaction at all and continues to follow the reference trajectory; 2) The robot is stopped as soon as a collision is detected. This is obtained by using the actual joint position, which was measured at the time instant of collision detection, as set-point for the position controller; 3) Switch from position control to zero-gravity torque control [6, 7], letting the robot behave in a very compliant way; 4) Switch to torque control with gravity compensation but, in contrast to 3), use joint torque feedback and the signal of the estimated external torque, which is used as a collision signal, to scale down both the motor inertia as well as the link inertia, thus obtaining an even “lighter” robot; 5) Use the estimated external torque to implement an admittance controller. By deﬁning the desired velocity in the opposite direction of the external torque estimation, the robot “ﬂees” from this disturbance. The strategies 3 – 5 contain switchings from trajectory-following control to sensorguided robot motion control; this monograph considers the opposite way of switching: from sensor-guided motion back to trajectory-following control (cf. Fig. 1.4, p. 4).

2.4.5 Own Works
This subsection shall brieﬂy classify a selection of previous works of the author with regard to the previously surveyed ﬁelds of robotics research. Starting with works on force/torque control for robotic manipulation systems, in particular adaptive control and model-following control schemes [87, 136, 198, 260], especially works on practical implementations of the Task Frame Formalism [137, 138, 139] were done by the author. Another ﬁeld addresses the fusion of force/torque and acceleration signals in order
2 The rest of this paragraph is written in accordance with [106].

2.5 Conclusions and Classiﬁcation of This Work

29

to separate contact forces/torques and forces/torques caused by inertial effects [143, 144, 145] with the aim to improve force/torque control quality in practical applications [147, 148]. [88] introduces Manipulation Primitives as an interface to hybrid switched-systems applied in the ﬁeld of robot motion control. Besides these objectives, software engineering and real-time aspects commonly play a fundamental role for practical and elegant implementations of the mentioned techniques; over the years, a framework based on a dedicated real-time middleware was conceived and ﬁnally presented in [86]. Besides these basic works, experimental achievements in these ﬁelds were presented in [140, 141, 142]. The last work to be mentioned here is [146], which is closely related to this book and presents a preliminary stage of on-line trajectory generation in hybrid switched-systems.

2.5 Conclusions and Classiﬁcation of This Work
After this broad and, in some areas, thorough survey, we are now able to concretize the motivation for this work and to classify it within the robotics research landscape.
The majority of the surveyed concepts for oﬀ-line and also on-line motion generation produce a motion along a speciﬁed path. But, is this a good approach? — For purely position/pose and/or trajectory-following controlled motions: Sure and without restriction of any kind! But: When we execute sensor-guided motions, for example, by force/torque or by visual servo control, we do not have a predeﬁned path anyway, because the robot motion directly depends on the sensor signal. We have to dismiss the path during sensor-based motion control! As soon as we embed sensor-guided or sensorguarded motions, there is no predeﬁned path anymore. In particular, we have to say good-bye to trajectory planning and reference trajectories along previously speciﬁed paths. There is no path that can be exactly followed, because everything may depend on sensors whose signals cannot be foreseen.
For further advancements in the ﬁeld of robotics, sensor integration is absolutely indispensable! We can ﬁnd plenty of approaches in the scientiﬁc arena, but when looking at the state of the art in technology (Sec. 2.3, p. 13), almost none of these approaches can be found. The author believes that there is one missing part in the robot control architecture as indicated in Fig. 1.4 (p. 4) that enables switchings from sensor-guided to trajectory-following operations. Furthermore, commercial robot manufacturers have to develop reliable and deterministically working machines. These companies need concepts to react safely to sensor malfunctions. How should a robot behave if a sensor stops delivering a signal during a high-speed sensor-guided motion? If a robot performs a sensor-guided motion in all of its DOFs (e.g., zero-force-control during a teach-in process) how can the controller — except when performing an emergency stop — take over the guidance of the robot if something unforeseen happens?

30

2 Literature Survey: Trajectory Generation

Fig. 2.4 Input and output values of the on-line trajectory generation algorithm.
These are simple questions that are mostly not relevant for research institutions. On the one hand, we (researchers) often complain about inaccessible commercial control units, and that sensor-guided motions are not possible, but on the other hand, we also do not have a general concept that is able to generate set-points for a trajectory from arbitrary initial states of motion to arbitrary target states of motion under consideration of kinematic and dynamic constraints — as would be required for practical realizations.
One of the goals of the author is to contribute to the solutions of these problems. The concept proposed in this monograph does not deliver a complete solution — it is just one further piece of technology to be developed with this work. To place this work in the wide landscape of robotics research, the author suggests considering two diﬀerent points of view:
Horizontal view Here, we take a model of multiple horizontal layers for robot motion control into account. As depicted in Fig. 1.5 (p. 5), on-line trajectory generation is considered together with sensor-based motion control as one horizontal layer in an abstract robot control model. This layer constitutes the interface between higher-level (on-line and/or oﬀ-line) task and motion planning and lower-level actuator control. This point of view seems to be common in the ﬁeld of computer science.
Vertical view Here, we consider vertical layers of a hybrid switched-system control scheme as shown in Fig. 2.3 (p. 24), which shows such a simple scheme and indicates the layered structure via the dotted lines. The on-line trajectory generation algorithm is regarded as one continuously working submodule that is able to take over control from any arbitrary state of motion and to transfer the system to a desired state of motion in the shortest possible time. This ﬁgure resembles the view of control engineers.
The aim of this work is to develop an algorithm for time-discrete systems as depicted in Fig. 2.4. This on-line trajectory generation algorithm can also be regarded as feedforward or open-loop controller. One can also consider it as a feedback on the current state. At a time instant Ti the algorithm receives the parameters of the current state of motion, the parameters of the desired state of motion, and the motion constraints, depending on the machine kinematics and dynamics, whereas the dynamics are only represented by constant

2.5 Conclusions and Classiﬁcation of This Work

31

kinematic motion constraints in this book (cf. Fig. 2.4). Embedding dynamics while keeping the possibility of instantaneous reactions to unforeseen events alive is considered as a future work, which is discussed in Chap. 9.5 (p. 164). All the algorithm of Fig. 2.4 has to calculate is the respective motion setpoints for the time instant Ti+1, which is subsequently used as a command variable for lower-level control.

Chapter 3
Mathematical Conventions and Problem Formulation

For a clear presentation of the required mathematics, it is necessary to introduce a certain nomenclature and to arrange some conventions that hold for the context of this monograph. Besides the introduction of these, we introduce a basic classiﬁcation of diﬀerent types and variants of on-line trajectory generation. Based on these ﬁrst two sections in this chapter, the problem formulation in the introductory chapter is subsequently repeated in a formal way.

3.1 Notation and Nomenclature

This section introduces the nomenclature used in this paper, deﬁnes some

important terms, and gives a ﬁrst impression of how the regarded trajectories

are mathematically represented.

We consider PC- or micro-controller-based systems for robot motion con-

trol, such that we assume a time-discrete overall system with a set of time

instants

T = {T0, . . . , Ti, . . . , TN} with Ti = Ti−1 + T cycle and i ∈ {1, . . . , N} ,

(3.1)

where T cycle represents the cycle time of the system. Time-discrete values are represented by capital letters, time-continuous values by lower case letters. The position of the robotic system at instant Ti is

Pi = (1Pi, . . . , kPi, . . . , K Pi)T ,

(3.2)

where K is the number of DOFs. Velocities, accelerations, and jerks are analogously represented by Vi, Ai, and Ji. A complete state of motion at instant Ti is described by the matrix

Mi = Pi, Vi, Ai, Ji
T
= 1Mi, . . . , kMi, . . . , KMi ,

(3.3)

T. Kr¨oger: On-Line Trajectory Generation in Robotic Systems, STAR 58, pp. 33–43.

springerlink.com

c Springer-Verlag Berlin Heidelberg 2010

34

3 Mathematical Conventions and Problem Formulation

where the vector kMi is the k-th row of the matrix Mi. Boundary conditions for motion properties are denoted as

Bi = Vimax, Aimax, Jimax, Dimax
T
= 1Bi, . . . , kBi, . . . , K Bi ,

(3.4)

where Dimax is the maximum value for the derivative of jerk at time instant Ti. A target state of motion is denoted by

Mitrgt = =

Pitrgt , Vitrgt , Aitrgt , Jitrgt 1Mitrgt , . . . , kMitrgt , . . . , K Mitrgt T .

(3.5)

TN is the time instant at which Mitrgt will be reached. As we will explain later, time-continuous polynomials are needed for the internal representation
of trajectories:

l k

pi(t

)

=

a4(t

−

Δ t )4

+

a3(t

−

Δ t )3

+

a2(t

−

Δ t )2

+

a1(t

−

Δt)

+

a0

(3.6)

constitutes a fourth-order polynomial describing the position progression for
DOF k, which is time-shifted by Δt, and which was calculated at time instant
Ti. The index l is described later in this section. Polynomials for velocity, acceleration, and jerk progressions are analogously denoted by lvi(t), lai(t), and l ji(t). In summary, we obtain a matrix of polynomials:

lmi(t) = l pi(t), l vi(t), l ai(t), l ji(t)

=

l 1

mi(t

),

.

.

.

,

l k

mi(t

),

.

.

.

,

l K

mi(t

)

T

(3.7)

where a single row, that is, the polynomials of one single DOF k, is denoted

by

l k

mi(t

)

=

l k

pi(t

),

l k

vi

(t

),

lkai(t

),

l k

ji

(t

)

.

(3.8)

Each set of motion polynomials lmi(t) for all K DOFs is accompanied by a set of corresponding time intervals

lVi =

l1ϑi,

.

.

.

,lk

ϑi,

.

.

.

,

l K

ϑi

,

where

l k

ϑi

=

lkti, (l+1k)ti

,

(3.9)

in

which

a

set

of

polynomials

l k

mi(t

)

for

one

single

DOF

k

is

valid.

A

whole

motion trajectory Mi(t) is ﬁnally composed of a set of motion polynomials

with according time intervals:

Mi(t) = 1mi(t), 1Vi , . . . , lmi(t), lVi , . . . , Lmi(t), LVi . (3.10)

3.1 Notation and Nomenclature

35

Fig. 3.1 Example of time-synchronization of a simple third-order trajectory for three translational DOFs.

Depending on the type of OTG algorithm (cf. Sec. 3.2), the initial state of
motion M0, and the target state of motion M0trgt , the value L determines the required number of polynomials (i.e., the number of single trajectory seg-
ments) to describe the complete trajectory from M0 to M0trgt . The trajectory segments are connected to each other as:

∀ k ∈ {1, . . . , K} :

1k ti

= Ti

1 k

mi(Ti

)

= kMi

l k

mi

(lkti)

=

(l−1) k

mi(lk

ti)

with l

∈

{2, . . . , L}

Lk mi(tisync) = kMitrgt .

From eqns. (3.9) – (3.11) we also infer

(3.11)

(L+1)kti ≡ tisync .

(3.12)

One important property of OTG is that all DOFs that are selected for ttrhaejseacmtoeryt-imfoelloinwsitnagnct,onnatrmole,lyhaavtetistyoncreinacohrdthereitrotaacrhgieetvsetatitme eo-fsmynocthioronnMiziatrtgitoant. As a consequence of this requirement, we can already state that

TN − tisync ≤ T cycle ,

(3.13)

36

3 Mathematical Conventions and Problem Formulation

that is, the desired target state of motion has been reached after a time of N T cycle.
Fig. 3.1 clariﬁes the meaning of time-synchronization. Just to give an impression of time dimensions, T cycle is in the range of one millisecond or less; the whole algorithm is designed to be applicable on a very low control level.
Now, we know how to describe a complete motion trajectory Mi(t) at a time instant Ti. It constitutes the minimum set of parameters to handle sets of trajectories for OTG. For a better understanding and to clarify these intro-
ductory equations, Fig. 3.2 depicts a simple (translational) motion trajectory
for one single DOF k.

Fig. 3.2 Example of a very simple case of a fourth-order motion trajectory for one DOF k consisting of L = 15 matrices of polynomials lmi(t) (cf. eqn. 3.7). The input parameters are kM0 = 0, kB0 = 9.4 mm/s, 22.4 mm/s2, 160 mm/s3, 2000 mm/s4 , and kM0trgt = 8.8 mm, 0 mm/s, 0 mm/s2, 0 mm/s3 (cf. [155]).

3.1 Notation and Nomenclature

37

Fig. 3.3 Input and output values of the OTG algorithm for multiple DOFs (z−1 represents a hold element). The dotted lines indicate suggestively how the output values of the OTG are usually fed back.

For the last part of this section, we explain the accordance of these introductory descriptions with the input and output values of the OTG algorithm as it will be described in Chaps. 4 – 6. Fig. 3.3 details the input parameters

Wi = =

Mi, Mitrgt , Bi, Si
T
1Wi, . . . , kWi, . . . , KWi

(3.14)

and all output values Mi+1 of the OTG algorithm, where Wi is a (K × 13) matrix. The selection vector

Si = (1si, . . . , ksi, . . . , K si) with Si ∈ K

(3.15)

is a Boolean vector and determines which of the K DOFs are to be controlled

by the OTG. The set

= {0, 1}

(3.16)

38

3 Mathematical Conventions and Problem Formulation

is considered as the set of binary numbers. All DOFs that are not controlled by the OTG open-loop controller, are not considered by the algorithm.
As will be discussed in Chap. 7 (p. 105), the way the output values Mi+1 are processed depends on how the OTG algorithm is embedded in a robot motion control scheme. Hence, the term lower-level control (cf. Fig. 3.3) considers the underlying control layers from the OTG algorithm on. For example, the algorithm can be directly used in joint space, such that it delivers command variables for a joint position controller, or it can be be part of a hybrid switched-system, such that Mi+1 contributes to a desired motion state for a controller in Cartesian space.
For a complete list of variables used for the derivation of the algorithm, as well as a description of the super- and subscript meanings, please refer to the preface.

3.2 Classiﬁcation of On-Line Trajectory Generators
This section deﬁnes diﬀerent types and variants of OTGs. Depending on the type, the algorithmic complexity and the practical relevance diﬀer strongly.

3.2.1 Type Classiﬁcation

In general, we can denote, that the output values of the OTG algorithm are
a function f of the input parameters Wi, and that the OTG algorithm itself is memoryless:

Ê Ê Mi+1 = f (Wi) , where f : αK × K −→ β K .

(3.17)

α and β are type-dependent integer values, and Table 3.1 shows a summary of types of OTG. The OTG block of Fig. 3.3 — if fully connected to all input
parameters and output values — corresponds to Type IX. Depending on the
type, not all input and output variables are used. Type VIII, for example, does not oﬀer to specify Jitrgt . For example, Fig. 3.2 shows a Type VI trajectory and Fig. 3.1 a Type III trajectory. The case β = 4 means that the position progression is described by polynomials up to the fourth order; thus, even the
Ê derivative of the jerk is limited (Dimax ∈ K). All further types are deﬁned
analogously. To ﬁnalize Table 3.1, one may denote the trivial and practically irrelevant case with rectangular velocity proﬁles as Type 0 (with α = 3, β = 1). Of course, it would also be possible to extend Table 3.1 by higher-order trajectories (Type X, XI, etc.), but the complexity strongly increases with
increasing type numbers, such that the development of these algorithms is
hardly possible, as will be ﬁgured out in Chap. 9.12 (p. 175).
A very speciﬁc version of Type I was already suggested in [146]. It works
like Type II with unlimited jerks. These two types may oﬀer sensor integration
possibilities for experimental purposes, for example, in research institutions.

3.2 Classiﬁcation of On-Line Trajectory Generators

39

Table 3.1 Diﬀerent types of OTG algorithms. The type number deﬁnes the set of available input parameters Wi and output parameters Mi+1 (cf. eqns. (3.3), (3.4), (3.5), (3.14), and (3.17)).

∀ (i, k) ∈
× {1, . . . , K}

kkkVAJiiitttrrrgggttt

= = =

0 0 0

∧ ∧

Ê kkkVAJiiittt

rgt rgt rgt

∈ = =

0 0

∧ ∧

ÊÊ kkkVAJiiitttrrrgggttt

∈ ∈ =

0

∧ ∧

ÊÊÊ kkkVAJiiitttrrrgggttt

∈ ∈ ∈

∧ ∧

Ê kAimax ∈ ∧

Type I

Type II

kJimax = ∞ ∧ α = 5, β = 2 α = 6, β = 2

—

—

kDimax = ∞

Ê kAimax ∈ ∧ Ê kJimax ∈ ∧

Type III

Type IV

Type V

α = 7, β = 3 α = 8, β = 3 α = 9, β = 3

—

kDimax = ∞

Ê kAimax ∈ ∧ Ê kJimax ∈ ∧ Ê kDimax ∈

Type VI Type VII Type VIII Type IX α = 9, β = 4 α = 10, β = 4 α = 11, β = 4 α = 12, β = 4

But due to the non-smooth bang-bang or trapezoidal trajectory characteristics [126], they are not relevant for industrial applications, as has already been stated in [120]. To achieve long lifetimes of mechanical systems, a jerk limitation is required (Types III to V). Furthermore, smooth trajectories whose jerk or even the derivative of jerk is limited lead to better trajectory-following behavior and to less excitation of structural natural frequencies in the system. Compared to Type III, Type IV and V additionally provide the possibility of specifying target velocity vectors and/or target acceleration vectors in space, which is important for the consideration of system dynamics. Target acceleration vectors are considered as the curvature of target velocity vectors and become relevant for planned switchings between control spaces, which will be discussed in Chap. 9.12 (p. 175).
3.2.2 Variant Classiﬁcation
The distinction between diﬀerent variants, Variant A and Variant B, is basically not required at all, but this additional classiﬁcation simpliﬁes explanations of the algorithmic details of the OTG algorithms presented in the next three chapters.
Regarding diﬀerent variants of OTG, we distinguish between constant and non-constant boundary values and deﬁne two variants, A and B:

40

3 Mathematical Conventions and Problem Formulation

• Variant A: Bi = const ∀ i ∈ • Variant B: Bi = const .
The second slightly more advanced variant is the one that will be relevant for practical implementations. Variant A only helps to explain the algorithm in a more comprehensive way.

3.3 Formal Problem Formulation
Based on the previous two sections, we now render the problem formulation of Chap. 1.1.3 more precisely. Therefore, we start with the deﬁnition of the term time-optimality and distinguish between two diﬀerent kinds:
Deﬁnition 3.1 (Kinetic time-optimality). A system is transferred from an initial state of motion Mi at instant Ti into a desired target state of motion Mitrgt within the shortest possible time without any consideration of couplings between individual DOFs.
If we consider a system with K DOFs, that is, K actuators, each actuator possess a maximum force (or torque). Depending on the mass (or the moment of inertia), a constant maximum linear (or angular) acceleration value results, if Newton’s Second Law of Motion is applied. This acceleration value can be calculated for each of the K DOFs, and all acceleration values together constitute Aimax, that is one of the input vectors of the OTG algorithm.
Deﬁnition 3.2 (Dynamic time-optimality). A system is transferred from an initial state of motion Mi at instant Ti into a desired target state of motion Mitrgt within the shortest possible time with consideration of the whole system dynamics.
For the OTG algorithm itself, that is, for all calculations within the block of Fig. 3.3, only kinetic time-optimality is regarded. The important consequence of kinetic time-optimality is, that all K DOFs can be considered as linearly independent, that is, decoupled. How robot kinematics and dynamics can be combined with this approach is described in Chap. 9.5 (p. 164).
For a clear and unambiguous speciﬁcation of the problem to be solved by an on-line trajectory generation algorithm, we distinguish between four different criteria (i) – (iv), which all have to be met by the algorithm.
(i) Criterion for Time-Optimality
The problem to be solved in this work is to calculate all parameters of Mi(t) at instant Ti, such that all selected DOFs reach their target state of motion Mitrgt in the shortest possible time tisync:

3.3 Formal Problem Formulation

41

∀ (k, l) ∈ {1, . . . , K} × {1, . . ., L} :

⎫

l k

vi

(t

)

l k

ai(t

)

≤ ≤

kVimax k Aimax

⎪⎪⎪⎪⎪⎪⎬

l k

ji(t

)

l k

di(t

)

≤ ≤

k Jimax k Dimax

⎪⎪⎪⎪⎪⎪⎭

with t

∈

lkti, (l+1k)ti

,

such that

tisync −→ min .

tisync is a parameter of Mi(t) (cf. eqns.(3.9) – (3.12)).

(3.18) (3.19)

(ii) Criterion for Time-Synchronization

The time tisync plays a very central role in this work. To ensure that Vitrgt , Aitrgt , and Jitrgt are reached in Pitrgt at tisync, we can repeat the aspect of timesynchronization (eqn. (3.11)) again:

Lk mi(tisync) = kMitrgt ∀ k ∈ {1, . . . , K} .

(3.20)

(iii) Criterion for Motion Constraints
Equation (3.18) guarantees that the motion variables of Mi(t) are kept within their respective bounds of Bi. In Variant A (Bi = const ∀ i ∈ ), this is clear and simple, but in Variant B, it of course can happen that:
• one or more of the elements of Mi exceed their bounds of Bi (e.g., 1Vi = 5 m/s and 1Vimax = 4 m/s), or
• one or more of the elements of Mi are within their bounds, but a future excess of their bounds Bi is unavoidable (e.g., 2Vi = 4 m/s, 2Vimax = 5 m/s, 2Ai = 2 m/s2, and 2Jimax = 1 m/s3: Even if −2Jimax would be applied permanently, the velocity 2v(t) would unavoidably increase to 6 m/s).
If one of these two conditions is true at Ti, the OTG Variant B algorithm has to determine and calculate further trajectory segments, which are applied upstream to the ones that are calculated to satisfy eqns. (3.18) and (3.19). These Variant B trajectory segments have to lead the variables of Mi that have exceeded their respective boundary values of Bi, or that will exceed their respective boundary values of Bi back into their limits within the shortest possible time, such that these values can always be kept within their bounds.
We take arbitrary values for Wi for granted; the only (trivial) constraint for Wi is given by

42

3 Mathematical Conventions and Problem Formulation

∀ k ∈ {1, . . . , K} :

kVitrgt ≤ kVimax ∧ kAitrgt ≤ kAimax ∧ kJitrgt ≤ kJimax .

(3.21)

As already stated in eqn. (3.19), the challenge is to ﬁnd a motion trajectory eMsti(pt)ostshibaltettriamnesfetirsysnct.heBusttaftoerotfhme octuirornenfrtocmonMtrioltocyMclitergat twTiti,hionnltyheMsih+o1rtisneeded, because in the next control cycle, we might have completely new in-
put values Wi+1 due to an unforeseen event or switching action. Hence, only
Mi+1 is forwarded to the output. These values are then used as input values for lower-level control.

(iv) Criterion for Consistency
This leads to the interesting requirement, that if the input values Mitrgt , Bi, and Si remain constant for i ∈ {0, . . . , N} (cf. eqn. (3.13)), and if the output values Mi+1 are directly fed back as input values for the following control cycle (cf. dotted lines of Fig. 3.3), then the following consistency criterion must be fulﬁlled.
If Mitrgt , Bi, and Si remain constant for i ∈ {0, . . . , N}, then:
• the value of the synchronization time must remain constant during the whole trajectory execution, that is, tisync = const ∀ i ∈ {0, . . . , N}. This fact is relevant for time-synchronization, such that Vitrgt , Aitrgt , and Jitrgt are coinstantaneously reached in Pitrgt at tisync;
• all trajectories Mu(t) with u ∈ {1, . . . , N} must exactly ﬁt into the one of M0(t); and
• furthermore, any trajectory Mu(t) with u ∈ {1, . . . , N} must exactly ﬁt into all previously calculated motion trajectories Mv(t) with v ∈ {0, . . . , u − 1}.
This criterion guarantees that the resulting trajectories of the OTG algorithm behave exactly as oﬀ-line planned ones, for example, bang-bang and/or trapezoidal acceleration proﬁles (cf. [29, 43, 126, 196]).

3.4 Summary
To summarize this chapter brieﬂy: We introduced a dedicated notation and described the task of OTG very generally without oﬀering solutions. The problem was formulated formally, whereas four diﬀerent criteria (i) – (iv) were speciﬁed. Each single criterion is essential and has to be met by the OTG algorithm. The ﬁnal and desired algorithm consists of three steps, and a part of the ﬁrst step is also applicable to and relevant for one-DOF systems. In order to derive the OTG algorithm step by step, we ﬁrst solve a part of the addressed problem in one-dimensional space in Chap. 4. Chap. 5 is

3.4 Summary

43

based on Chap. 4 and subsequently gives the complete solution in multidimensional space. The Type IV OTG algorithm includes the Types I – III (cf. Table 3.1) and is the highest type that has been developed by the author. This type will be used to produce, illustrate, and explain examples within this monograph. Each chapter explains the concept of OTG in a very generic way and illustrates the ideas by means of Type IV.

Chapter 4
Solution for One Degree of Freedom

This work introduces both, an OTG algorithm for one-DOF systems and an OTG algorithm for systems with multiple DOFs, as they are common in the ﬁeld of robotics. Also the one-DOF solution that is presented in this chapter delivers new signiﬁcant advantages for servo drive control and the technology of frequency inverters. Furthermore, it simpliﬁes the comprehension of this work, since we introduce the OTG algorithm step by step.

4.1 Generic Algorithm for On-Line Trajectory Generation

4.1.1 Problem Formulation for One-DOF Systems

The problem formulation for one single DOF is very similar to the one for
multiple DOFs (cf. Chap. 3.3, p. 40). The input values of the multi-DOF
OTG algorithm, which are vectors, become scalars, and the matrices Wi, Mitrgt , Bi, Mi, Mi+1 become vectors (rows of former matrices), as depicted in Fig. 4.1.
We take arbitrary values for the elements of

Mi = (Pi, Vi, Ai, Ji) Mitrgt = Pitrgt , Vitrgt , Aitrgt , Jitrgt
Bi = (Vimax, Aimax, Jimax, Dimax) Wi = Mi, Mitrgt , Bi, Si

(4.1) (4.2) (4.3) (4.4)

for granted. If the value of Si is ‘1’1 at a time instant Ti, it is our aim to calculate a trajectory Mi that transfers the system from its current state of
1 For the rest of this chapter, we assume Si = 1.

T. Kr¨oger: On-Line Trajectory Generation in Robotic Systems, STAR 58, pp. 45–68.

springerlink.com

c Springer-Verlag Berlin Heidelberg 2010

46

4 Solution for One Degree of Freedom

Fig. 4.1 Input and output values of the Type IX OTG algorithm for one DOF. (cf. Fig. 3.3, p. 37).

motion Mi into its current target state of motion Mitrgt under consideration of the boundary constraints Bi and in the minimum possible time timin. In accordance with eqn. (3.10), a trajectory Mi for one DOF consists of L trajectory
segments

l mi(t) = l pi(t), lvi(t), lai(t), l ji(t) with l ∈ {Λ + 1, . . . , L} (4.5)

and corresponding time intervals

lϑi = l−1ti, lti with l ∈ {Λ + 1, . . . , L} .

(4.6)

If Variant A is applied (i.e., Bi is constant for all i ∈ ),

Λ =0

(4.7)

holds. Λ speciﬁes the number of intermediate trajectory segments that are selected by the B-Variants; this issue is described in the next subsection. If

4.1 Generic Algorithm for On-Line Trajectory Generation

47

we know all parameters of Mi, we can simply calculate the desired output values for lower-level control

Mi+1 = (Pi+1, Vi+1, Ai+1, Ji+1) .

(4.8)

The calculation of eqn. (4.8) is described in a general way in the next subsection and will be concretized by means of the Type IV OTG algorithm in Sec. 4.2.

4.1.2 Generic Solution
At this point we distinguish between Variant A, in which the values of Bi are considered as constant, and Variant B, in which the elements of Bi may vary over time.

Generic Solution: Variant A

The key idea of this work is that there is a ﬁnite set of possible motion
proﬁles, of which one transfers one single selected DOF from the initial state of motion Mi to its target state of motion Mitrgt within the shortest possible time timin (time-optimally). This ﬁnite set is denoted by2

PStep1 = 1Ψ Step1, . . . , rΨ Step1, . . . , RΨ Step1 ,

(4.9)

where R is the number of elements in PStep1 and depends on the type of OTG. A concrete proﬁle is denoted by rΨ Step1. The kind of motion proﬁle considered
depends on the type of OTG used (cf. Table 3.1, p. 39):

Types I-II : Velocity proﬁles Types III-V : Acceleration proﬁles Types VI-IX : Jerk proﬁles

(β = 2) (β = 3) (β = 4) .

The ﬁrst task for the calculation of Mi is the execution of a function f

Ê f : α −→ PStep1 ,

(4.10)

which is represented by a decision tree in order to select the motion proﬁle that leads to the time-optimal trajectory, and that simultaneously enables us to determine timin for the considered DOF. Once the time-optimal proﬁle ΨiStep1 has been selected, a system of nonlinear equations can be set up and solved to calculate the coeﬃcients of all polynomials lmi(t) ∀ l ∈ {1, . . . , L} and the respective time intervals lϑi ∀ l ∈ {1, . . . , L}. As a result,
2 The algorithm for the multi-dimensional case consists of three steps. As the set for the one-dimensional case is the same as the one for the ﬁrst step in the multidimensional case, we use the same notation in order to keep the representation unique.

48

4 Solution for One Degree of Freedom

Lti = timin

(4.11)

holds. Each motion proﬁle rΨ Step1 with r ∈ {1, . . . , R} leads to a system of

nonlinear equations, and each system is solvable for a certain domain rDStep1

with

Ê rDStep1 ⊂ α .

(4.12)

For the decision tree that implements eqn. (4.10) it is absolutely essential

that

R
Ê rDStep1 ≡ α

(4.13)

r=1

holds. If this is not the case, the tree is erroneous, and the algorithm will not
work for certain input parameters, which would be unacceptable for its practical application. In the work of Broqu`ere, Sidobre, and Herrera-Aguilar [38]
as well as in the contribution of Liu [167], which suggest similar approaches
for one-DOF systems, eqn. (4.13) does not hold, and, hence, these approaches are not applicable in general, but only for some (practically hardly relevant)
special cases. As an alternative to decision trees for the selection of the correct motion
proﬁle ΨiStep1, one could set up R systems of nonlinear equations, calculate all solutions, take all valid solutions for timin, and choose the minimum one. But this procedure is computationally very expensive, too expensive, in fact, especially if low values for T cycle are desired.
After we have calculated all L trajectory segments to describe Mi, we only have to ﬁnd the valid time interval lˆϑi with lˆ ∈ {1, . . . , L}, such that

lˆti ≤ Ti + T cycle ≤ lˆ+1ti

(4.14)

is satisﬁed (cf. eqns. (3.9) and (3.10), p. 34). The output values Mi+1 can ﬁnally be calculated by

Mi+1 = lˆmi Ti + T cycle .

(4.15)

Up to now, we only have considered Variant A, which requires constant values of Bi. The proposed procedure will now be extended by Variant B to make this approach generally valid.

General Solution: Variant B
Variant B works in the same way as A does, but here a further decision tree is connected upstream of the Variant A decision tree. If the boundary values Bi are functions of time, the OTG Variant B has to be applied. The case in

4.2 Solution for Type IV

49

which one or more elements of the initial motion state values Mi exceed their corresponding constraints of Bi has to be considered in this variant, and it may happen at any discrete time instant Ti with i ∈ , in which

|Vi| > Vimax and/or |Ai| > Aimax and/or |Ji| > Jimax and/or |Di| > Dimax .

(4.16)

Furthermore, motion states Mi may occur, which are within their respective bounds Bi at instant Ti, but which will lead to an unavoidable future exceeding of Bi at a time instant Ti+u:

|Vi+u| > Vimax and/or |Ai+u| > Aimax and/or
Æ |Ji+u| > Jimax and/or |Di+u| > Dimax with u ∈ \{0} .

(4.17)

Equations (4.16) and (4.17) correspond to the criteria of Chap. 3.3 (p. 41).
If one or more of the cases in eqns. (4.16) and (4.17) are true, the Variant
B decision tree has to select and parameterize intermediate trajectory segments lmi with l ∈ {1, . . . , Λ } with corresponding time intervals lϑi with l ∈ {1, . . . , Λ } (cf. eqns. (4.5) and (4.6)) in order to guide these values back into their bounds, and furthermore to bring the system into a state of motion
after which the motion variables can be kept within the boundary values of
Bi. Therefore, this set of intermediate trajectory segments is determined and executed prior to the segments of Variant A: lmi with l ∈ {Λ + 1, . . . , L} and lϑi with l ∈ {Λ + 1, . . . , L}. Corresponding to the type of OTG, velocity proﬁles (Type I, II), acceleration proﬁles (Type III – V), or jerk proﬁles (Type
VI – IX) are applied, respectively.

4.2 Solution for Type IV
Compared to the general OTG algorithm of the previous section, this section exemplarily introduces one concrete type of OTG: Type IV. This ﬁrst leads us to the following general parameters for the algorithm: α = 8, β = 3, Aitrgt = 0 ∧ Jitrgt = 0 ∀ i ∈ , and Dimax may contain inﬁnite values for any i ∈ (cf. Table 3.1, p. 39). In simpler words, this type generates kinetically time-optimal and time-synchronized trajectories whose velocity, acceleration, and jerk values are limited, and the speciﬁcation of target velocities Vitrgt , which are reached in Pitrgt , is possible.
Fig. 4.2 illustrates all input and output values of the Type IV OTG algorithm. In order to facilitate the understanding of this section and to enable a better understanding, App. D (p. 201) additionally explains the problem that is solved here in a non-scientiﬁc and simple way.

50

4 Solution for One Degree of Freedom

Fig. 4.2 Input and output values of the Type IV OTG algorithm.

4.2.1 Type IV, Variant A

The goal of this subsection is to calculate all trajectory parameters lmi(t) with l ∈ {1, . . . , L} and corresponding time intervals lϑi ∀ l ∈ {1, . . . , L}, in
short: Mi. In Variant A, we assume constant boundary values Bi, that is,

Vimax = const ∧ Aimax = const ∧ Jimax = const ∀ i ∈ .

(4.18)

According to the previous chapter, the Type IV OTG algorithm requires the selection of an acceleration proﬁle, which enables us to set up a system of

Fig. 4.3 A subset of the acceleration proﬁle set PStep1 of Type IV, Variant A. The dotted horizontal line indicates the maximum acceleration values, and the numbers in the top right corner indicate the numbers of trajectory segments L for the respective proﬁle.

4.2 Solution for Type IV

51

nonlinear equations in order to calculate the parameters of Mi. Fig. 4.3 shows a subset of the possible acceleration proﬁles PStep1. Compared to triangle (Tri) proﬁles, trapezoid (Trap) proﬁles always reach the maximum acceleration value Aimax. All proﬁles that do not contain a zero-acceleration phase do not reach the maximum velocity Vimax.

Determining ΨiStep1

In the following, we answer the question: How can we determine the timeoptimal acceleration proﬁle ΨiStep1 at a time instant Ti, that is, how can we select the element of PStep1 that leads to timin? Due to the high complexity, only a small cutout of the Type IV decision tree is shown in Fig. 4.4. The
tree actually acts as function

Ê f : 8 −→ PStep1

(4.19)

and determines the time-optimal acceleration proﬁle ΨiStep1. As described by eqn. (4.20), it is essential, that the tree covers the whole input domain of the
Type IV, Variant A OTG algorithm:

R
Ê rDStep1 = 8
r=1

(4.20)

Ê where rDStep1 ⊂ 8 denotes the domain in which the system of equations
for the acceleration proﬁle rΨ Step1 is solvable. If eqn. (4.20) does not hold,

the OTG algorithm cannot be used as an open-loop controller, because there

would remain motion states, for which the algorithm would not be able to

calculate Mi and thus Mi+1. This paragraph discusses the decision tree of Fig. 4.4 in detail. Decision

1A.0013 checks, whether the current acceleration value Ai is positive or neg-

ative. The left branch is designed for positive values of Ai. Decision 1A.002

calculates this value

the velocity value is less than Vitrgt ,

if we bring Ai down to zero (by applying Jimax). If the left branch is taken. Hence, we already know

that −Vimax ≤ Vi ≤ Vitrgt . It is our aim to reach Vitrgt , and Decision 1A.003

checks whether a triangle or a trapezoid proﬁle is required for this. If a trape-

zoid proﬁle is required, Decision 1A.004 checks whether the position would be less or greater than the target position Pitrgt . If we the resulting position value is still less than (i.e., we are still faced with) Pitrgt , we need to increase the trapezoid acceleration proﬁle, that is, we deﬁnitely need a PosTrap. . . Neg. . .

proﬁle. Decision 1A.005 then checks the velocity value that would be achieved

if we accelerate to +Vimax by applying a trapezoid proﬁle and subsequently

3 Part A of Step 1 of the OTG algorithm for the multi-dimensional case uses the same decision tree. We use the same notation (1A) in order to keep the representation consistent again.

52

4 Solution for One Degree of Freedom

Fig. 4.4 Cutout of the Type IV, Variant A decision tree to determine an acceleration proﬁle ΨiStep1, that leads to the minimum-time solution timin.

decelerate with a negative triangular proﬁle that the resulting velocity value is less than Vitrgt , we

reaches −Aimax deﬁnitely need

exactly. If a negative

triangle proﬁle as the second part of the composed acceleration proﬁle. Now,

we only have to check whether +Vimax can be reached in order to obtain Vitrgt in Pitrgt (Decision 1A.006). All further decisions work analogously to the de-

scribed ones. For the development of this kind of decision tree, it is absolutely

4.2 Solution for Type IV

53

Fig. 4.5 The PosTriNegTri proﬁle with all relevant variables, such that a system of equations represented by eqns. (4.21) – (4.32) can be set up and solved in order to calculate the parameters of Mi.

Ê essential that a tree covers the whole input domain (here: 8), such that the
algorithm can work with arbitrary input values Wi.

Parameterizing ΨiStep1 (Example: ΨiStep1 = PosTriNegTri)

Once we know the correct acceleration proﬁle ΨiStep1 for the trajectory at instant Ti, we can set up a system of equations that corresponds to this proﬁle. Depending on the proﬁle, the procedure of parameterizing ΨiStep1 diﬀers. In this section, we only derive the procedure for one concrete proﬁle, that is, the
PosTriNegTri proﬁle (top right in Fig. 4.3). For the practical realization, all
R acceleration proﬁles have to be considered, and respective algorithms have
to be implemented, of course. Fig. 4.5 shows this PosTriNegTri-acceleration proﬁle and all relevant variables, such that we can set up a system of equations
to calculate the parameters of Mi. In this simple case, we only need L = 4 trajectory segments. The system of equations can be directly derived from
Fig. 4.5 and is given by eqns. (4.21) – (4.32). In this full-length way, we obtain 12 equations with 12 unknown variables timin, 2ti, 3ti, 4ti, 2vi, 3vi, 4vi, 2 pi, 3 pi, 4 pi, aipeak1, and aipeak2:

2ti − Ti =

a peak1 − Ai Jimax

3ti

−

2ti

=

a peak1 Jimax

4ti

−

3ti

=

−

a peak2 Jimax

timin

−

4ti

a peak2 = − Jimax

(4.21) (4.22) (4.23) (4.24)

54

4 Solution for One Degree of Freedom

2vi

−

Vi

=

1 2

2ti − Ti

Ai + a peak1

3vi

−

2vi

=

1 2

3ti − 2ti

a peak1

4vi

−

3vi

=

1 2

4ti − 3ti

a peak2

Vitrgt

−

4vi

=

1 2

timin − 4ti

a peak2

2 pi − Pi = Vi

2ti − Ti

+

1 2

Ai

2ti − Ti 2

+

1 6

Jimax

2ti − Ti 3

3 pi − 2 pi = 2vi

3ti − 2ti

+ 1 a peak1 2

3ti − 2ti 2

−

1 6

Jimax

3ti − 2ti 3

4 pi − 3 pi = 3vi

4ti − 3ti

−

1 6

Jimax

4ti − 3ti 3

Pitrgt − 4 pi = 4vi

timin − 4ti

+ 1 a peak2 2

timin − 4ti 2

+

1 6

Jimax

timin − 4ti 3

(4.25) (4.26) (4.27) (4.28)
(4.29)
(4.30) (4.31)
(4.32)

Numerical Issues
Although these systems of equations are nonlinear for all elements of the set PStep1, we are able to ﬁnd closed-form analytical solutions by employing computer algebra programs; this would be the straightforward way. However, these expressions become very large, not all solutions are valid, and problems with numerical stability appear. Even after appropriate simpliﬁcations and a reduction of the problem to a root-ﬁnding problem of quartic equations, it is not possible to solve this problem robustly and with a consistently high accuracy [111, 245]. In [111] robustness test results of diﬀerent methods for root-ﬁnding of quartics are shown, and none of the methods work reliably. For this work, diﬀerent methods (Ferrari, Neumark, and Yacoub) were implemented to ﬁnd the real roots of quartics in order to solve eqns. (4.21) – (4.32), but in particular at the boundary areas of the domains rDStep1 with r ∈ {1, . . . , R}, the solutions tend to contain complex numbers due to numerical inaccuracies. Another problem is that there may be up to four real solutions for one system of equations, and it becomes diﬃcult to extract the correct one, especially if the solutions are very close to each other. When random ﬂoating-point numbers [−1000, 1000] were used for the elements of Wi, a wrong solution was calculated every ≈ 60, 000 cycles, which is of course unacceptable in practice. Another indication that the problem of root-ﬁnding of quartics cannot be solved robustly is that neither the libraries of the

4.2 Solution for Type IV

55

Numerical Algorithms Group (NAG) [257] nor the GNU Scientiﬁc Library (GSL) [100] nor the library of Press et al. [215] provide solutions for this problem.
The next idea was to perform a QR decomposition [245, 251] for the problem of quartic polynomials. With this method, it was possible to ﬁnd solutions for the quartic root-ﬁnding problem, but this led to another problem: real-time capability. If a certain accuracy has to be achieved, the number of required iterations depends on the condition number of the factorization matrix [215]; and the condition number in turn depends on the input values Wi, which are arbitrary. Furthermore, the problem that several solutions are found, which may lie very close to each other, remains.
As a result, the usage of analytical solution methods is not a way to success, and the following question remains unanswered: How can we ﬁnd a solution method for the systems of equations of P Step1 that works robustly for any combination of input variables Wi? In the following, a method is proposed that complies with this requirement, and that enables an eﬃcient and real-time capable solution of this particular problem.
The eqns. (4.21) – (4.32) can be transformed to a one-dimensional rootﬁnding problem. We take one element of the set of unknowns, for example, aipeak1, and set up a position-error function depending on this element:

Ê Ê PosTriNegTri pierr1 aipeak1 :

−→ .

(4.33)

The derivation of PosTriNegTri pierr1 aipeak1 is done manually on the base of
eqns. (4.21) – (4.32); since the description of the function is rather long, it
can be found in App. B.1 (p. 189). Here, we assume PosTriNegTri pierr1 aipeak1
to be a transcendental function that can be set up on the base of the system of equations for ΨiStep1 = PosTriNegTri.
This results in a very simple and standard problem of curve sketching,
which can be solved numerically. As we will see in the following, we are able
to calculate an interval minaipeak1, maxaipeak1 from which we know, that our
desired value aipeak1 lies within it. But as we will see, it may happen that there are up to two4 valid values for aipeak1 within this interval, and we are only interested in the minimum one, because it delivers the time-optimal solution with the minimum value for timin (cf. Fig. 4.5). As a result, we also need the derivative of PosTriNegTri pierr1 aipeak1

PosTriNegTri pierr1

aipeak1

d = d aipeak1

PosTriNegTri pierr1

aipeak1

4 This number will be derived in detail in Chap. 5.1.1 (p. 73).

(4.34)

56

4 Solution for One Degree of Freedom

in order to solve an extremum problem for PosTriNegTri pierr1 aipeak1 and to

determine a smaller interval minaipeak1, maxaipeak1 that contains one, and only

one, root. The full-length form of PosTriNegTri pierr1 aipeak1 can be found in

App. B.2 (p. 189).

Algorithm 4.1 shows the calculation steps to attain minaipeak1 and maxaipeak1. Due to the previously executed decision tree for determining ΨiStep1, we know that Aimax ≥ Ai ≥ 0 holds (cf. PosTriNegTri acceleration proﬁle in Fig. 4.4). The lower bound minaipeak1 is calculated in lines 1 – 8. Line 1 simply calculates the velocity v(Ai 0) we would reach if Ai was decreased to zero by applying Jimax. If v(Ai 0) is greater than Vitrgt (line 2), we can already set minaipeak1 to Ai (line 3). Otherwise, we have to calculate an acceleration peak value with which Vitrgt is exactly reached. Here, we only apply a positive triangle-shaped proﬁle, that is, in line 7 we compute a simple acceleration proﬁle consisting of two segments: Applying +Jimax until minaipeak1 and then −Jimax until Vitrgt is reached. The resulting value for minaipeak1 constitutes the lower bound.
The lines 9 – 25 of Algorithm 4.1 calculate the upper bound maxaipeak1. We ﬁrst calculate two possible values. The ﬁrst one, maxaipeak1,a (line 11), is determined in order not to exceed ±Aimax and the second one, maxaipeak1,v (line 17), in order not to exceed +Vimax. For the calculation of maxaipeak1,a, we compute an acceleration proﬁle consisting of four segments as commented in line 10. If the resulting value is greater than Aimax, we set maxaipeak1,a to Aimax in line 19. maxaipeak1,v is calculated analogously. At the end (lines 21 – 25) we set the actual value of maxaipeak1 to the lower value of maxaipeak1,a or maxaipeak1,v, respectively.

As a result, we know that the function PosTriNegTri pierr1 aipeak1 is contin-

uous between minaipeak1 and maxaipeak1. If this interval contains two roots, we have to check for a local minimum or maximum by ﬁnding the (only) root

maipeak1 of PosTriNegTri pierr1 aipeak1 in minaipeak1, maxaipeak1 . The mathematical

literature provides diﬀerent methods for this standard problem. An overview

of such numerical methods can be found in [73]. In our case, only inclusion

methods come into consideration, and the most eﬃcient inclusion method is

the Anderson-Bj¨orck-King method [12, 73, 131]. Since this method may have

robustness and thus real-time capability problems, it was adapted for this

application by combining it with the simple bisection method. The details on

the modiﬁed algorithm are presented and discussed in App. A (p. 185).

After the local minima and maxima of PosTriNegTri pierr1 aipeak1 are calcu-

lated, we set

maxaipeak1 := maipeak1 ,

(4.35)

4.2 Solution for Type IV

57

Algorithm 4.1 Calculate the interval limits for the desired root of PosTriNegTri pierr1 aipeak1 .

Require: Vitrgt , Vimax, Vi, Aimax, Ai, Jimax, with Vimax ≥ Vi, Aimax ≥ Ai ≥ 0, Jimax ≥ 0

Ensure: minaipeak1, maxaipeak1

1: v(Ai

0)

:=

Vi

+

(Ai)2 2 Jimax

2: if v(Ai 0) > Vitrgt then

3: minaipeak1 := Ai

4: else

5:

Calculate minaipeak1 for the profile

6:

Ai minaipeak1 0, so that v = Vitrgt

7:

minaipeak1 :=

(Ai)2 + 4 Jimax Vitrgt − Vi 2

8: end if

9:

Calculate maxaipeak1,a for the profile

10:

Ai maxaipeak1,a 0 −Aimax 0, so that v = Vitrgt

11: maxaipeak1,a :=

Jimax 2 (Ai)2 + 2 Aimax 2 + Jimax 3 Vitrgt −Vitrgt

√ 2

Jimax

12: if maxaipeak1,a > Aimax then

13: maxaipeak1,a := Aimax

14: end if

15:

Calculate maxaipeak1,v for the profile

16:

Ai maxaipeak1,v 0, so that v = Vimax

17: maxaipeak1,v :=

(Ai)2 + 4 Jimax (Vimax − Vi) 2

18: if maxaipeak1,v > Aimax then

19: maxaipeak1,v := Aimax

20: end if

21: if maxaipeak1,v < maxaipeak1,a then 22: maxaipeak1 := maxaipeak1,v

23: else

24: maxaipeak1 := maxaipeak1,a

25: end if

58

4 Solution for One Degree of Freedom

such that we ﬁnally obtain the desired interval minaipeak1, maxaipeak1 , which
contains only one root (the desired value of aipeak1). We can again use the modiﬁed method of Anderson-Bj¨orck-King here. Once we know aipeak1, we know the ﬁrst unknown variable of eqns. (4.21) – (4.32). The calculation of
the other eleven unknowns is trivial, as is the calculation of the parameters of lmi(t) with l ∈ {1, . . . , 4} and lϑi with l ∈ {1, . . . , 4}. These two steps can be developed in a straightforward way and are shown in App. B.3 (p. 190).
Finally, with

∀ l ∈ {1, . . . , 4} : l mi(t) = l pi(t), l vi(t), l ai(t), l ji(t) lVi = l ϑi

with lϑi = lti, l+1ti

(4.36) (4.37)

the one-dimensional Type IV, Variant A trajectory Mi is completely described for one DOF at time instant Ti:
Mi(t) = 1mi(t), 1Vi , 2mi(t), 2Vi , 3mi(t), 3Vi , 4mi(t), 4Vi . (4.38)

According to eqns. (4.14) and (4.15), Mi+1 can be calculated by ﬁnding the respective time interval lˆ, such that

lˆti ≤ Ti + T cycle ≤ lˆ+1ti

(4.39)

holds, and then we simply calculate the output values for lower-level control

by

Mi+1 = lˆmi Ti + T cycle .

(4.40)

These values are then used as set-points for lower-level motion controllers. This part of the book exemplarily presented how to set up the PosTri-
NegTri acceleration proﬁle. The complexity of the OTG algorithm diﬀers strongly, depending on the proﬁle and its number of equations and unknown variables. For clariﬁcation: This intricately seeming procedure is only required because there is no analytical solution for the systems of equations for the acceleration proﬁles that can be computed absolutely robustly. All the chosen mathematical tools are of a very basic nature, but in this concrete case, these methods lead to suﬃcient results, and they perform eﬃciently and very robustly. Another advantage of the proposed method compared to the analytical one is that we directly obtain the desired solution for the timeoptimal trajectory, and diﬃcult selections of correct solutions can be omitted.
For a better understanding of this part of the book, we will apply this procedure to concrete values of Wi in the next part.

4.2 Solution for Type IV

59

Example of Parameterizing the PosTriNegTri Acceleration Proﬁle

This part explains the previously proposed procedure step by step by means
of a concrete example. Let us take an arbitrary set of input values W0 at instant T0 = 0 ms:

P0 = −499 mm
V0 = −335 mm/s A0 = 152 mm/s2 A0max = 972 mm/s2

VP00ttrrggtt

= =

−90 mm −347 mm/s

V0max = 985 mm/s

J0max = 324 mm/s3 .

(4.41)

As the ﬁrst step in the ﬁrst control cycle at T0, we apply the decision tree of Fig. 4.4 in order to determine the correct acceleration proﬁle rΨ Step1, which leads to the time-optimal trajectory. As a result we obtain the proﬁle Ψ0Step1 = PosTriNegTri, such that we can set up the function PosTriNegTri p0err1 a0peak1
corresponding to the respective system of equations (eqns. (4.21) – (4.32)). In
the next step, we determine the interval mina0peak1, maxa0peak1 in which the
position-error function PosTriNegTri p0err1 a0peak1 is continuous, and in which
the desired value of a0peak1 is located. Applying Algorithm 4.1 to the concrete input values of eqn. (4.41) leads to

mina0peak1 = 152.000 mm/s2 and maxa0peak1 = 662.746 mm/s2 . (4.42)
We know that for a0peak1 ∈ 152.000 mm/s2, 662.746 mm/s2 up to two roots can be present. To illustrate this, the top part of Fig. 4.6 shows the progression of the position-error function PosTriNegTri p0err1 a0peak1 in this interval. Since the function values at the bounds have diﬀerent signs, we already know that there is only one root in this interval. For other input parameters, for example, P˜0trgt = −1090 mm, the abscissa in the top part of Fig. 4.6 would be shifted down by 1000 units (dash-dotted line)5. Then, two valid solutions for a0peak1 could be found, and only the lower one would be relevant. For such a case, the derivative of the position-error function, as shown in the bottom part of Fig. 4.6, would be required to calculate the extremum of PosTriNegTri p0err1 a0peak1 :

ma0peak1 = 285.255 mm/s2 ,

(4.43)

which would subsequently be used as the upper interval limit in order to calculate the correct value of a0peak1 (dashed lines in Fig. 4.6).
5 For these input values, the PosTriNegTri acceleration proﬁle would not be the timeoptimal proﬁle anymore. The NegTriPosTri acceleration proﬁle would lead to the time-optimal solution here, but the PosTriNegTri proﬁle also delivers two valid nontime-optimal solutions.

60

4 Solution for One Degree of Freedom

Fig. 4.6 Progressions of the position-error function and its derivative within the interval [152.000 mm/s2, 662.746 mm/s2].

Regarding the initial input values of eqn. (4.41), we apply the modiﬁed Anderson-Bj¨orck-King method, and we obtain the desired value

a0peak1 = 511.155 mm/s2

(4.44)

as indicated by the dotted line in the top part of Fig. 4.6. By applying the assignments for the other eleven unknowns (App. B.3, p. 191, eqns. (B.13) – (B.23)), we obtain the following solution:

timin = 5.795 s 3t0 = 2.686 s 2v0 = 32.555 mm/s 4v0 = 44.382 mm/s 3 p0 = −227.969 mm
a0peak1 = 511.155 mm/s2

2t0 = 1.109 s 4t0 = 4.240 s 3v0 = 435.764 mm/s 2 p0 = −703.408 mm 4 p0 = 246.573 mm
a0peak2 = −503.603 mm/s2 .

(4.45)

Afterwards, the parameters of M0 are computed by using eqns. (B.24) – (B.47). If we assume a cycle time T cycle of one millisecond and refer to

4.2 Solution for Type IV

61

Fig. 4.7 Resulting trajectory Mi with i ∈ {0, . . . , 5795} for the given input values of eqn. (4.41). The dashed lines indicate the times 2t0, 3t0, and 4t0 calculated in
eqn. (4.45).

eqn. (4.39), we can ﬁnd lˆ = 1. The output values M1 are subsequently calculated by eqn. (4.40):

P1 = −499.334 mm A1 = 152.324 mm/s2

V1 = −334.847 mm/s J1 = 324 mm/s3 .

(4.46)

These values (cf. eqn. (4.41)) are used as set-points for lower-level control during the current control cycle. Hence, it would take us 5795 cycles until

62

4 Solution for One Degree of Freedom

Fig. 4.8 Variant B decision tree, which is executed upstream to the one of Variant A. It is the task of this decision tree to bring all motion state values Mi into their limits Bi and to guarantee, that they remain within these bounds.
the desired target state of motion Mitrgt is ﬁnally reached. If no sensor event occurs, the consistency criterion (Chap. 3.3, p. 42) must be fulﬁlled. Hence, if we execute the OTG algorithm again at T1 = 1 ms, we use the output values M1 from eqn. (4.46) as input values for the control cycle at T1 = 1 ms, and exactly the same trajectory must be calculated, that is, M1 must exactly ﬁt

4.2 Solution for Type IV

63

Fig. 4.9 Intermediate acceleration proﬁles for the Λ intermediate trajectory segments determined by the decision tree of Fig. 4.8.
into M0. The same holds, of course, for all following control cycles at instants Ti with i ∈ {2, . . . , 5795}, as can be seen in Fig. 4.7, which depicts the resulting trajectory for the input values of eqn. (4.41). This is possible because we always compute the time-optimal trajectory, which transfers the system from M0 to M0trgt in the shortest possible time. That means for every motion state between M0 and M0trgt the time-optimal trajectory to reach M0trgt automatically ﬁts into M0. The most important part to guarantee this essential property is the decision tree of Fig. 4.4. This tree as well as the acceleration proﬁle set PStep1 must be complete and error-free, such that eqn. (4.13) holds (cf. p. 48).
Let us ﬁnally summarize this subsection brieﬂy: The complete Type IV, Variant A OTG algorithm for one DOF was introduced and discussed. The acceleration proﬁle PosTriNegTri belongs to the simplest ones and was chosen for a detailed demonstration. Finally, a very concrete example trajectory was calculated in order to improve the comprehension of the applied techniques.

4.2.2 Type IV, Variant B

Of much higher relevance than Variant A is Variant B, because it can cope
with varying constraint values Bi. Furthermore, Variant B fulﬁlls the criterion for motion constraints (cf. Chap. 3.3, p. 41).
As generally described in Sec. 4.1.2 (p. 47), Λ additional trajectory segments lmi with l ∈ {1, . . . , Λ } with corresponding time intervals lϑi with l ∈ {1, . . . , Λ } (cf. eqns. (4.5) and (4.6)) have to be selected and parameterized. These intermediate trajectory segments are executed prior to the other
(L − Λ ) segments of the Variant A. Fig. 4.8 shows the respective decision tree in a compressed version. The
execution of the intermediate trajectory segments shown in Fig. 4.9 is ﬁnished at Λ+1ti, and we have to assure, that

−Vi max ≤ vi Λ+1ti ≤ +Vi max ∧ −Ai max ≤ ai (Λ+1)ti ≤ +Ai max

(4.47)

64

4 Solution for One Degree of Freedom

hold. Furthermore, we have to ensure that if we bring ai (Λ+1)ti to zero by
applying the maximum possible jerk Jimax, the maximum velocity value of Vimax is not exceeded again (neither positively nor negatively). Therefore, the plain condition

vi (Λ +1)ti

±

ai (Λ +1)ti Jimax

2
≤ Vimax

(4.48)

has to be fulﬁlled. The compressed version in Fig. 4.8 takes advantage of sign
switchings. Since this tree is executed prior to all decision trees of OTG Types
III-V and also prior to the further decision trees of the multi-dimensional
case, the letter X has been chosen to replace the actual tree identiﬁer. Deci-
sion X.001 leads to a switching of signs for the initial and for the target state
of motion if the current acceleration value Ai is negative. Hence, Ai is positive for decision X.002. This decision checks whether Aimax is currently exceeded. If it is exceeded, we set up a ﬁrst intermediate acceleration proﬁle segment (NegLin), which brings Ai down to Aimax by applying −Jimax. The decisions X.003 and X.004 check whether Vimax is positively or negatively exceeded. Since our current acceleration value is positive, decision X.003 calculates the
velocity value that we would obtain if we were to bring the acceleration value
to zero (which increases the velocity value). If the resulting velocity is then greater than +Vimax, we decrease the acceleration to zero by applying −Jimax again (NegLin), perform a switching of signs, and let the decisions X.005 to
X.008 bring the velocity value into its bounds. Decision X.004 only checks whether −Vimax is exceeded. If this is the case, we continue at decision X.005. For this decision, we know that the velocity is less than −Vimax, and the acceleration is positive (no matter if the branch of decision X.003 or X.004 has been taken). If we would now increase the acceleration to +Aimax, decision X.005 checks whether the resulting velocity value is greater or less than −Vimax. If it is less, we know that a simple acceleration increase brings the velocity value back into its limits, but we have to make sure, that it can remain within these. For this purpose, decision X.006 checks whether +Vimax would be exceeded if we subsequently decreased the acceleration value to zero. If this
is not the case (left branch), a simple PosLin proﬁle segment, which applies +Jimax, complies with the requirements of eqns. (4.47) and (4.48). Otherwise (right branch), we would increase the acceleration value to a certain peak value, and subsequently decrease it again, such that we would reach +Vimax exactly after the full decrease to zero (proﬁle segment PosLinNegLin). The
decisions X.007 and X.008 work analogously. In the last step, we have to
re-switch the signs again if they have been switched before (decision X.009).
Finally, we can assure that the conditions of eqns. (4.47) and (4.48) are ful-
ﬁlled and will not be breached again, and we can continue with the decision
trees of Variant A as presented in Sec. 4.2.1.

4.2 Solution for Type IV

65

Fig. 4.10 Resulting Type IV, Variant B trajectory Mi with i ∈ {0, . . . , N} for the given input values of eqn. (4.49). The dashed lines indicate the bounds of the single trajectory segments, and the dotted lines indicate the motion constraints Bi.
Once the Λ intermediate trajectory segments are determined, they have to be parameterized. This is done in the same way as for the acceleration proﬁles of Variant A (eqns. (4.21) – (4.32)), but the resulting systems of equations are of trivial nature and can be solved in a straightforward way without any numerical problems.

66

4 Solution for One Degree of Freedom

Example of a Type IV, Variant B Trajectory

For a better comprehension, we illustrate the functionality of the Type IV, Variant B OTG algorithm by means of a concrete example. Let us assume some given input values W0 at instant T0 = 0 ms:

P0 = −100 mm
V0 = −270 mm/s A0 = −450 mm/s2 A0max = 300 mm/s2

VP00tt

rgt rgt

= =

300 mm −100 mm/s

V0max = 300 mm/s

J0max = 900 mm/s3 .

(4.49)

If the target motion state and the boundary values remain constant, the trajectory of Fig. 4.10 results from the input values W0 of eqn. (4.49). In the ﬁrst step, we select intermediate trajectory segments by applying the decision tree from Fig. 4.8. Here, we would take the following path:

X.001 → Change of signs → X.002 → NegLin → X.003 → NegLin → Change of signs → X.005 → X.007 → PosLinHld → X.009 → Decision tree of Variant A .

This results in Λ = 4 intermediate trajectory segments, which result from the decision tree of Variant B:

NegLin =⇒ PosLin NegLin =⇒ PosLin
PosLinH l d

One segment One segment Two segments

1m0(t), 1V0 2m0(t), 2V0 3m0(t), 3V0 , 4m0(t), 4V0 .

At T0, both conditions, eqn. (4.47) and eqn. (4.48), are not fulﬁlled. These Λ = 4 trajectory segments lead to a new state of motion Λ m0((Λ+1)t0), which
satisﬁes eqns. (4.47) and (4.48), and we can execute the Variant A decision
tree. The result of this tree is the Ψ0Step1 = PosTrapZeroNegTrap acceleration proﬁle. Finally, we obtain L = 4 + 7 = 11 trajectory segments, whereas the
ﬁfth segment is actually not existent, because 5a0 5t0 = Aimax and thus 5t0 ≡ 6t0 holds (cf. Fig. 4.10).

4.3 Summary and Applications
This chapter introduced the general OTG algorithm in Variant A and also in Variant B for one single DOF. Both variants fulﬁll the time-optimality and the consistency criteria, but only Variant B fulﬁlls the criterion for motion constraints (cf. Chap. 3.3, p. 41). The presented approaches were exemplarily detailed by means of the Type IV on-line trajectory generation algorithm.
The three major scientiﬁc contributions of this chapter are the following:
Finite set of motion proﬁles The basic idea of this work is, that a ﬁnite set PStep1 with R motion proﬁles rΨ Step1 exist, from which one proﬁle leads to the time-optimal trajectory.

4.3 Summary and Applications

67

Equation (4.13)
R
Ê rDStep1 ≡ α
r=1
Each motion proﬁle rΨ Step1 leads to a nonlinear system of equations, and
Ê each system of equations possesses a concrete input domain rDStep1. The
union of all domains is equivalent to the complete input space α of the OTG algorithm (p. 48). Decision trees
Ê How can we describe and represent borders in the α space? This is done
by decision trees. The α input values of the OTG algorithm at instant Ti, that is, the elements of Wi, are used to ﬁnd a path through the tree in order to select the only correct motion proﬁle ΨiStep1 ∈ PStep1, which leads to the time-optimal trajectory.
Before we extend the concept to multi-DOF systems, such that also the realization of the criterion for time-synchronization can be demonstrated, we should emphasize that we already developed an important and practically highly relevant byproduct for manufacturers of frequency inverters and servo drive systems.
All available products of the world’s leading companies for electrical drive technologies (e.g.,6 Bernecker + Rainer Industrie Elektronik GmbH [22], Lenze AG [159], Rockwell Automation [221], SEW-EURODRIVE [233], Siemens AG [242], YASKAWA Electric Corporation [281]) do not oﬀer a general option for specifying and executing jerk-limited trajectories. Commonly only Type II trajectories with unlimited jerks are generated. All these manufacturers are aware of the problem, and all of them know that jerk limitation is indispensable for a wide ﬁeld of applications. Nevertheless, usually only a pseudo jerk limitation is oﬀered, which does not work in general but only in special modes.
Let us exemplarily take the manual of a Lenze 9400 StateLine TMfrequency inverter [158], which is an up-to-date, high-quality, and high-performance device, to represent the state of the art in technology in this ﬁeld. The ﬁrst possibility to enable a kind of jerk limitation is using a current set-point ﬁlter in the velocity control loop at a certain frequency [Hz], with a certain width [Hz], and with a certain depth [dB]. Of course, this simple idea limits the jerk of an executed trajectory, but the jerk limitation depends on the currently executed motion and cannot be deterministically planned. Furthermore — depending on the application — the ﬁltering eﬀect might be undesired, for example, during a high-performance motion that requires low tracking errors.
A second opportunity for jerk limitation is the option of specifying a socalled “S-ramp time.” This time is comparable to a real jerk limitation and is directly related to Jimax, but this works only if the drive is controlled manually,
6 In alphabetical order.

68

4 Solution for One Degree of Freedom

and it is required that the initial speed and the initial acceleration are zero. Hence, this is also not practicable for common operation.
Even a simple stop, that is, a controlled decrease of the current velocity to zero, at an unforeseen time instant, leads to an inﬁnite jerk. To solve this problem, the Type III OTG algorithm would already satisfy the demands. This chapter already presented the more advanced Type IV OTG algorithm, which would not only enable the performing of a jerk-limited stop motion but also a jerk-limited motion to a certain velocity unequal to zero.
Apart from the beneﬁt of exerting such “smooth” motions, it would additionally become possible to consider the rotor response time by specifying a maximum jerk for a concrete motor. In turn, this leads to a better control behavior of the whole servo system.
The Type IV, Variant B OTG algorithm would overcome many of the problems the aforementioned companies deal with. The algorithm works robustly, is real-time capable, and its interface (Fig. 4.2, p. 50) is very simple, such that an integration into existing systems could be realized without very much eﬀort. Additionally, the usage as submodule in a hybrid switched-system controller (cf. Fig. 2.3, p. 24) is, of course, possible.

Chapter 5
Solution in Multi-dimensional Space

The previous chapter introduced the concept of OTG for one single DOF. This chapter extends the proposed class of algorithms to the multi-dimensional case, and we will see how to fulﬁll the time-synchronization criterion. The OTG algorithm in multi-dimensional space consists of three basic steps; the ﬁrst step is based on the methodologies introduced in Chap. 4. Finally, this concept will be suitable as a submodule in a hybrid switched-system controller for a robotic system with multiple DOFs. As in the previous chapter, we ﬁrst introduce the general OTG algorithm, and subsequently, the Type IV OTG algorithm is exemplarily outlined.

5.1 General Variant A Algorithm for On-Line Trajectory Generation
This section describes the Variant A OTG algorithm for multiple DOFs generally, such that it is applicable to all types and variants of OTG. In contrast to the last chapter, which considered only one DOF, we consider K DOFs here. The input values of the algorithm are represented by the matrix Wi and the output values by the matrix Mi+1 (cf. Fig. 3.3, p. 37).
We assume that the algorithm is executed at the time instant Ti; all types of OTG require the same three algorithmic steps:
Step 1 Calculation of the minimum possible synchronization time tisync.
Step 2 Synchronization of all selected DOFs to tisync and calculation of all trajectory parameters Mi.
Step 3 Calculation of all output values Mi+1 based on Mi.
These three steps are depicted in Fig. 5.1, which shows the overall structogram of the OTG algorithm. The following three subsections describe each step in detail.

T. Kr¨oger: On-Line Trajectory Generation in Robotic Systems, STAR 58, pp. 69–97.

springerlink.com

c Springer-Verlag Berlin Heidelberg 2010

70

5 Solution in Multi-dimensional Space

Fig. 5.1 Nassi-Shneiderman structogram of the OTG algorithm.

5.1.1 Step 1: Calculating the Synchronization Time tisync

This step is the most complex one, although it only computes the synchronization time tisync, that is, one scalar value. It is a function

Ê f : αK × K −→ Ê .

(5.1)

As can be seen in Fig. 5.1, Step 1 can be subdivided into three parts: the individual calculation of the minimum execution time ktimin for each selected DOF k; the calculation of the set of possibly existing inoperative time inter-
vals kZi, in which a selected DOF k cannot be synchronized; and ﬁnally the determination of tisync.

Minimum Execution Times
At this particular point, we beneﬁt from the last chapter, in which we calculated complete trajectories Mi for single DOFs. Here we are interested in one particular parameter of Mi: We need the minimum execution time ktimin for each selected DOF k, which is required to transfer the DOF k from its initial state of motion kMi to its target state of motion kMitrgt . Hence, we execute the algorithm for the one-dimensional case of Chap. 4 only until we have calculated ktimin. This is done for every single selected DOF, such that we attain up to K times ktimin with k ∈ {1, . . . , K}.

5.1 General Variant A Algorithm for On-Line Trajectory Generation

71

Inoperative Time Intervals

After the minimum execution time ktimin for a DOF k has been calculated, we have to check, whether it is possible to execute the trajectory for this DOF within any time t > ktimin. If this is the case, no inoperative time intervals kZi = {} exist; depending on the type of OTG, kZi may contain up to Z = 3 time intervals, in which a selected DOF k cannot be synchronized. Referring
to Table 3.1 (p. 39) this property can be expressed by

Z = α − 2β − 1 ,

(5.2)

such that the following values of Z appear:

Types I, III, VI : Z = 0 Types II, IV, VII : Z = 1
Types V, VIII : Z = 2 Type IX : Z = 3 .

The reason for this characteristic is simple: For each of the target motion state parameters kVitrgt , kAitrgt , and kJitrgt , there may be one interval in which one of these values cannot be reached. Hence, eqn. (5.2) is exactly in
accordance with Table 3.1.
A single element of a set kZi is denoted by

z k

ζi

=

z k

tibegin,

zktiend

, with z ∈ {1, . . . , Z} ,

(5.3)

such that we obtain if Z > 0. It is clear, that

kZi =

1k ζi

,

.

.

.

,

Z k

ζi

(5.4)

ktimin ≤ zktibegin ≤ zktiend ∀ (z, k) ∈ {1, . . . , Z} × {1, . . . , K}

(5.5)

naturally holds.

To explain the origin of these inoperative time intervals, Fig. 5.2 illustrates

an example of a simple Type II trajectory for one single DOF k with simple

bang-bang

characteristics

and

one

inoperative

time

interval

1 k

ζi.

At

T0

=

0 ms,

let us assume the following input values for the Type II trajectory of Fig. 5.2:

kP0 = 50 mm

kV0 = 80 mm/s

kkVP00ttrrggtt

= =

300 mm 70 mm/s

kV0max = 200 mm/s

kA0max = 20 mm/s2

kS0 = 1

⎫

kM0 k M0t rgt kB0

⎪⎪⎪⎪⎪⎪⎪⎪⎬ ⎪⎪⎪⎪⎪⎪⎪⎪⎭

kW0

.

(5.6)

72

5 Solution in Multi-dimensional Space

Fig. 5.2 Example of an inoperative time interval 1kζi for one translational DOF k calculated by a Type II on-line trajectory generation algorithm. The interval limits are 1ktibegin = 4950 ms and 1ktiend = 10050 ms. During all three trajectories, either +kA0max = 20 mm/s2 or −kA0max = −20 mm/s2 is applied as value for kai(t) (cf. eqn. (5.6)). The desired target state of motion kM0trgt can only be reached if tisync ∈ ktimin, 1ktibegin or tisync ≥ 1ktiend .
The time-optimal case for transferring the DOF from kM0 to kM0trgt would take ktimin = 2820 ms by applying a PosTri velocity proﬁle (solid line). If other DOFs require more time, this DOF k can also reach kMitrgt after 1ktibegin = 4950 ms (or any time between ktimin and 1ktibegin) by applying another velocity proﬁle. But it is impossible to transfer DOF k to kMitrgt in a time 1ktibegin < t < 1ktiend with 1ktiend = 10050 ms. If we decreased the velocity to less than 25.5 mm/s (dotted line in Fig. 5.2), there would not be enough space to accelerate again

5.1 General Variant A Algorithm for On-Line Trajectory Generation

73

to kV0trgt = 70 mm/s. In such a case, the respective DOF has to decrease its velocity until the velocity is negative and the distance to kP0trgt equals the required acceleration distance (dashed line). The execution of this second
NegTri velocity proﬁle would be ﬁnished at 1ktiend. For all times t ≥ 1ktiend the synchronized motion of DOF k is possible again. As a result for the input
values of eqn. (5.6), an inoperative time interval of

1 k

ζi

=

[4950 ms,

10050 ms]

(5.7)

exists.
It is absolutely essential that the OTG algorithm is able to provide a solu-
Ê tion for any set of input values Wi ∈ αK × K. If this cannot be guaranteed,
the concept will be incomplete, unsafe, and thus practically irrelevant. We
must be able to specify a set of times for each selected DOF k

kIi =

ktimin

,

1k tibegin ,

1k tiend

,

.

.

.

,

Z k

tibegin,

Zk tiend

,

(5.8)

which contains ktimin and all interval limits of the set kZi. It belongs to the nature of motion proﬁles of PStep1 that one particular proﬁle can deliver up to two valid solutions:
• If the system of equations of a motion proﬁle rΨ Step1 (e.g., eqns. (4.21) – (4.32), p. 53) delivers only one valid solution, this solution speciﬁes one element of the set of times kIi.
• If two valid solutions are available for a system of equations, two neighbored elements of the set kIi can be speciﬁed.
More than two solutions are not possible, because then at least one element of kMitrgt cannot be reached. Let us explain this important property by means of two examples.

Example 5.1. The system of equations for the PosTri velocity proﬁle of
Fig. 5.2 delivers one (and only one) valid solution, which yields the min-
imum execution time ktimin. It is impossible, that this proﬁle can deliver a
second valid solution for the given input values kWi of eqn. (5.6), because
all velocity peak values that are greater than the one from the ﬁrst solution would lead to an irreversible overshooting of kPitrgt . The system of equations for the NegTri velocity proﬁle, however, delivers two valid solutions. The ﬁrst one contains the left bound 1ktibegin of the inoperative time interval, and the second one contains the respective right bound 1ktiend . Apart from these two solutions, no further valid solutions are possible, because kPitrgt could not be reached then.

Example 5.2. This example builds the bridge to Chap. 4.2.1 (p. 55), where we already claimed, that a particular motion proﬁle can deliver up to two valid solutions to set up a trajectory. From the example of eqn. (4.41) (p. 59), we learned that the PosTriNegTri acceleration proﬁle leads to the time-optimal

74

5 Solution in Multi-dimensional Space

motion for that DOF. The plot of the position-error function of Fig. 4.6

(p. 60) illustrates how the solution for the value of a0peak1 is calculated. But the

ﬁgure contains a second piece of information: If we subtract 1000 mm from the

original value of the desired target position P0trgt , two solutions can be found

for the PosTriNegTri acceleration proﬁle. If applied as DOF k of a multi-DOF

system, these two solutions would lead to the bounds 1ktibegin and 1ktiend of the

inoperative

time

interval

1 k

ζi.

Further

valid

solutions

are

not

possible,

because

kPitrgt would not be reached then.

Whether a solution of a system of equations for a motion proﬁle rΨ Step1

contributes to the elements of the set kIi, is speciﬁed by further decision trees.

We need 2 Z further decision trees — that is, two for each possible inoperative

Iinf toenrveaolrzkζmi o—reininoorpdeerrattioveobtitmaieninatceorvmaplslezktζei

set kIi for exist for a

each selected DOF k. selected DOF k, each

decision tree determines a certain motion proﬁle whose system of equations

leads to a solution that contains a lower or an upper bound of an inoperative
time interval zkζi. The quintessence of this paragraph is that (2 Z + 1) decision trees are re-
quired to calculate the minimum execution times ktimin and the set of all inoperative time intervals kZi for all selected DOFs k ∈ {1, . . . , K}. All these
values are subsequently required for the determination of the minimum synchronization time tisync.

Determining tisync

After the minimum execution times and all existing inoperative time intervals

have been First, the

calculated for all selected DOFs, tisync greatest time of all minimum execution

can be determined easily. times is determined. tisync

cannot be less than this value. In the second step, we have to consider that

tisync

must

not

be

part

of

any

inoperative

time

interval

z k

ζi

with

(z, k)

∈

{1, . . . , Z} × {1, . . . , K}. Fig. 5.3 illustrates an example with four DOFs, where

tisync = 12tiend is determined as the minimum possible synchronization time.

Fig. 5.3 Example of the determination of tisync for K = 4 DOFs. Here: tisync = 12tiend.

5.1 General Variant A Algorithm for On-Line Trajectory Generation

75

5.1.2 Step 2: Synchronization

Due to Step 1, we know that every selected DOF is able to reach its target

state of motion execution time

k k

tMimitinrgtisatletsissyntch. aItnistiscynlec,arinthpartinfocirpaalll

DOFs k, whose minimum an inﬁnite number of so-

lutions can be found to parameterize a trajectory that transfers a respective

DOF from kMi to kMitrgt in tisync. For the proposed OTG algorithm it is impor-

tant to work deterministically, such that we are interested in one particular

solution for every selected DOF. Thus, we have to ﬁnd the same solution for

the same input values, and furthermore, a continuous change of input values

must result in a continuous and jump-free change of the trajectory param-

eters Mi. To cope with these demands, we apply an optimization method to a certain trajectory property. Depending on the type of OTG, one of the

following criteria has to be fulﬁlled for each selected DOF k ∈ {1, . . . , K}:

Types I – II : Types III – V : Types VI – IX :

tisync
kai(t) dt
Ti tisync
k ji(t) dt
Ti tisync
kdi(t) dt
Ti

→ min → min → min .

(5.9) (5.10) (5.11)

Equations (5.9) – (5.11) constitute the simplest case, which leads to simple rectangular proﬁles for the acceleration (eqn. (5.9)), the jerk (eqn. (5.10)), or the derivative of jerk (eqn. (5.11)). This is an important simpliﬁcation of the problem, because this way we can apply the same kind of motion proﬁles in Step 2, which we already know from Step 1.

Remark 5.1. In order to explain, why the minimization criteria of eqns.

(5.9) – (5.11) leads to rectangular motion proﬁles more comprehensively, let

us consider the following sample input values for Step 2 of the simple Type I

OTG algorithm at instant T0 = 0 ms:

kP0 = −200 mm kV0 = 0 mm/s kP0trgt = 300 mm kV0max = 500 mm/s kA0max = 400 mm/s2 kS0 = 1 t0sync = 2830 ms .

kM0 k M0t rgt kB0

⎫ ⎪⎪⎪⎪⎪⎪⎬ ⎪⎪⎪⎪⎪⎪⎭ kW0

(5.12)

76

5 Solution in Multi-dimensional Space

The minimum execution time for this set of input parameters kW0 for DOF k is kt0min = 2.237 ms, but since the minimum execution of at least one other selected DOF is assumed to be greater, we assume a synchronization time of t0sync = 2.830 ms as the resulting value from Step 1 of the Type I OTG algorithm. As a result, there are inﬁnite possibilities for Step 2 to set up a
trajectory for DOF k; three of them are shown in Fig. 5.4. The trajectory
represented by the solid line fulﬁlls eqn. (5.9). This criterium can only be fulﬁlled if only ±kA0max or zero acceleration are utilized. For the OTG Types III – V, only ±kJ0max or a jerk value of zero are allowed to be utilized for all k ∈ {1, . . . , K}, and for the OTG Types VI – IX the same holds for the maximum derivative of jerk, kD0max.
Wi and tisync act as input parameters for this second step, in which a similar procedure as in the ﬁrst part of Step 1 is applied. The key idea — that there
is a ﬁnite set of motion proﬁles to set up the ﬁnal motion trajectories — is
employed again. The elements of this set, PStep2, diﬀer from the ones of Step 1, because tisync is considered as an additional input value. These motion proﬁles are denoted as

PStep2 = 1Ψ Step2, . . . , sΨ Step2, . . . , SΨ Step2 ,

(5.13)

where S denotes the number of elements in PStep2 and depends on the type of OTG. According to Table 3.1 (p. 39), a decision tree that acts as function

Ê f :

α+1 \ H −→ PStep2

(5.14)

is required, which determines a motion proﬁle sΨ Step2 for each selected DOF k. The meaning of H will be described below. Compared to Step 1, Step 2 always requires only one decision tree, which is executed once for every selected DOF and control cycle. But compared to Step 1, there are two signiﬁcant diﬀerences:

1. While in Step 1 more than one system of equations may achieve a valid
solution (cf. Fig. 4.6, p. 60), in Step 2 — that is responsible for the actual
calculation of the trajectory parameters of Mi — only one element of PStep2 leads to a solvable system of equations. This fact is rooted in the nature of
the Step 2 motion proﬁles and leads to a deterministic behavior, that is,
there can always be only one possible trajectory, which transfers a selected DOF k from kMi to kMitrgt in tisync. 2. If we denote the input domain of the system of equations that corresponds to the motion proﬁle sΨ Step2 as

Ê sDStep2 ⊂ α+1 ,

(5.15)

we do not have such an equivalence as described by eqn. (4.13) for Step 1 (p. 48):

5.1 General Variant A Algorithm for On-Line Trajectory Generation

77

Fig. 5.4 Three diﬀerent, valid Type I trajectories for the input values of eqn. (5.12). The solid line represents the trajectory that fulﬁlls the minimization criterium of eqn. (5.9).

S
Ê sDStep2 ≡ α+1 .
s=1

(5.16)

Due to the inoperative time intervals kZi for each selected DOF k, the (α + 1)-dimensional space contains holes, in which none of the systems of equations that correspond to the motion proﬁles of PStep2 is solvable, and in which the decision tree of eqn. (5.14) does not deliver a solution. These
holes in the (α + 1)-dimensional space are represented by the set

Ê H ⊂ α+1 .

(5.17)

78

5 Solution in Multi-dimensional Space

Fig. 5.5 Two-dimensional illustration of eqn. (5.18), that is, the union of all input domains sDStep2 of the systems of equations for the motion proﬁles of Step 2, PStep2. The black areas represent H.

As a result, the union of all input domains of the systems of equations for the Step 2 motion proﬁles PStep2 can be described in eqn. (5.18). This equation is illustrated by Fig. 5.5. We can also logically conclude here that the set of holes H is disjunctive with the union of all input domains:

S

S

Ê sDStep2 = α+1 \ H =⇒

(sDStep2 ∩ H) = { } . (5.18)

s=1

s=1

Furthermore, it is an important property that the union of pairwise intersections of all Step 2 input domains

S

S=

sDStep2 ∩ uDStep2 ∀ u ∈ {1, . . . , S} u = s

s=1

(5.19)

constitutes α-dimensional hyperplanes in the (α + 1)-dimensional space. These hyperplanes are described in detail by the decision tree of eqn. (5.14). The fact that S represents only hyperplanes in the input space of Step 2 is essential for the deterministic behavior of the OTG algorithm, because this way there is only one possible motion proﬁle for any set of input values. If the (α + 1) input values for a selected DOF k are an element of S, two or even more motion proﬁles will lead to a solvable system of equations, but the solution will be exactly the same for all proﬁles. This fact emphasizes the overall consistency of the proposed concept.

Let us now answer the question: How can we describe the set of holes H?
This is an important question, because we have to prevent form entering such
a hole. Entering a hole would lead to an unsolvable problem, and no output
values Mi+1 could be calculated. The (α + 1)-dimensional space for one DOF k is spanned by the ﬁrst α
elements of kWi and by the synchronization time tisync. The values of kWi can be arbitrary, as described in the problem formulation in Chap. 3.3 (p. 40). Hence, the only parameter that can be responsible for H, is tisync, which was determined in Step 1. As described there, we need 2 Z decision trees

5.1 General Variant A Algorithm for On-Line Trajectory Generation

79

to

determine

the

limits

of

all

inoperative

time

intervals

z k

ζi

with

(z, k)

∈

{1, . . . , Z} × {1, . . . , K}. These 2 Z decision trees exactly describe the set of

holes H, because we mask the codomain of tisync and thus the (α + 1)-

dimensional input space.

An important insight at this point is that all (2 Z + 1) decision trees of Step

1 and the decision tree of Step 2 must exactly ﬁt each other. It is comparable to

a multi-dimensional puzzle game whose parts have to ﬁt each other absolutely

exactly, and if this were not the case, the game would not come to an end.

The same holds for the OTG algorithm: If the (2 Z + 1) Step 1 decision trees

do not ﬁt each other, the algorithm will be erroneous, and there will exist

input values Wi, to which no output values can be calculated. Once the correct motion proﬁle kΨiStep2 has been chosen for a DOF k by
the decision tree of eqn. (5.14), we can continue in the same way as we

did for the one-dimensional case described in Chap. 4: A further system of

nonlinear equations can be set up, and the solution of this system enables

us

to

parameterize

all

L

trajectory

segments

l k

mi

∀

l

∈

{1, . . . , L} as well as

all

corresponding

time

intervals

l k

ϑi

∀

l

∈

{1, . . . , L} for one selected DOF

k. Having done this for every selected DOF, all trajectory parameters of Mi

are ﬁnally calculated for the cycle at Ti.

5.1.3 Step 3: Calculation of Output Values

This third step of the OTG algorithm is trivial and works analogously to the

calculation of output values in the one-dimensional case. After the complete

trajectory Mi has been calculated for one time step Ti, we only have to

ﬁnd

the

valid

time

interval

lˆ k

ϑi

with lˆ

∈

{1, . . . , L} for each selected DOF

k ∈ {1, . . . , K}, such that the condition

lkˆti ≤ Ti + T cycle ≤ lˆ+k1ti

(5.20)

is satisﬁed. The output values Mi+1 can ﬁnally be calculated by

k Mi+1

=

lˆ k

mi

Ti + T cycle

∀ k ∈ {1, . . . , K} ,

(5.21)

such that the ﬁnal output matrix
T
Mi+1 = 1Mi+1, . . . , kMi+1, . . . , K Mi+1

(5.22)

is obtained. If we subsequently call the OTG algorithm again at Ti+1 and use

the the

same same

ianbpsuotluvtaelusyesn,cthhraotniisz,aMtioi+n1t,iMmeitrgttis+,yn1Bci

, and Si, = tisync,

we will compute exactly because we compute the

time-optimal trajectory again. This goes along with the consistency criterion

of Chap. 3.3 (p. 42). While the absolute value of tisync remains constant until

80

5 Solution in Multi-dimensional Space

the target state of motion has been reached, the time diﬀerence from each cycle to the synchronization time naturally decreases by Tcycle per cycle:

tisync − Ti − tis+yn1c − Ti+1 = Tcycle .

(5.23)

The resulting values Mi+1 are subsequently used for lower-level control.

5.1.4 Final Remarks on the General OTG Algorithm

This section introduced the general OTG algorithm for systems with multiple DOFs, such that all types and variants of OTG (cf. Table 3.1, p. 39) are addressed by this section. The complexity of the algorithm strongly depends on the implemented type: The higher the roman number of the OTG type, the higher is its algorithmic complexity. The measure of complexity is inﬂuenced in particular by two properties:

1. The total number

2Z + 2 = 2α −4β

(5.24)

of decision trees in Step 1 and Step 2 (cf. Table 3.1, p. 39, and eqn. (5.2), p. 71). Here, in particular the sum of the longest paths — to be more precise: the sum of all computationally most expensive paths — of the decision trees plays the key role. 2. The solvability of the systems of equations, which are generated from the elements in PStep1 and PStep2.
Analogous to the previous chapter, the algorithm for Type IV OTG will be detailed in Sec. 5.3 in order to exemplify the proposed concept by means of a concrete implementation.

5.2 Extension for Variant B
The extension from Variant A to B is very simple. The same Variant B decision tree, which has already been introduced for the one-dimensional case, is applied upstream of all (2Z + 2) decision trees. Thus, the two cases of eqn. (4.16) and eqn. (4.17) (p. 49) are treated for all selected DOFs k ∈ {1, . . . , K}, and we ﬁrst bring all DOFs that do not fulﬁll eqns. (4.16) and (4.17) back into their bounds of Bi. Subsequently the Variant A motion proﬁles transfer all DOFs to their target state of motion Mitrgt .
5.3 Type IV On-Line Trajectory Generation
This section concretizes the proposed general concept of Sec. 5.1 by means of the Type IV on-line trajectory generation algorithm. As we did in Chap. 4.2 (p. 49), we ﬁrst specify the general parameters of the algorithm based on

5.3 Type IV On-Line Trajectory Generation

81

Table 3.1 (p. 39): α = 8 and β = 3 indicate that the target acceleration vector Aitrgt and the target jerk vector Jitrgt equal the zero vector at any time instant Ti with i ∈ while we can specify a target velocity vector Vitrgt , which is exactly reached at the target position Pitrgt . Regarding the motion constraints, maximum velocities Vimax, maximum accelerations Aimax, and maximum jerks Jimax are taken into account, and each selected DOF k can exhibit up to Z = 1 inoperative time interval 1kζi. Four decision trees are required:
• Three decision trees are required for the Step 1 calculations of
– the minimum execution times ktimin for every selected DOF k ∈ {1, . . . , K}, – the lower limits ktibegin of the inoperative time interval 1kζi for every
selected DOF k ∈ {1, . . . , K}, and – the respective upper limits ktiend for every selected DOF k ∈ {1, . . . , K},
and
• one decision tree is necessary for Step 2.
We organize this section in the same way as the corresponding Sec. 4.2 of the previous chapter: After the introduction of the Type IV, Variant A algorithm, we subsequently describe the algorithm for the B-Variant.
A non-scientiﬁc problem formulation described in very simple words can again be found in App. D.3 (p. 203).

5.3.1 Type IV, Variant A
Step 1
As depicted in the general structogram in Fig. 5.1 (p. 70), it is the goal of this step to calculate the synchronization time tisync. After the calculation of the minimum execution times ktimin for all selected DOFs k ∈ {1, . . . , K}, we subsequently check all selected DOFs to see whether they exhibit an inoperative time interval 1kζi, in order to ﬁnally determine the value for tisync.
Minimum Execution Time
The procedure for the calculation of the minimum execution times ktimin for all selected DOFs k ∈ {1, . . . , K} was already described in Chap. 4.2.1 (p. 50). We apply the decision tree 1A of Fig. 4.4 (p. 52) in order to determine an acceleration proﬁle kΨiStep1 of the set PStep1. A subset of PStep1 was presented in Fig. 4.3 (p. 50). Once we know the proﬁle kΨiStep1, which leads to the time-optimal trajectory for DOF k, we can set up a system of nonlinear equations (e.g., eqns. (4.21) – (4.32), p. 53, for the PosTriNegTri acceleration proﬁle). Then, a position-error function is generated, which only depends on one of the unknown variables of the system of equations. We are interested in

82

5 Solution in Multi-dimensional Space

one particular root of this function: The root that delivers the time-optimal solution for the given input parameters kWi. For this purpose, we determine an interval, from which we know that the root lies within it (e.g., Alg. 4.1, p. 57). After we know the interval bounds, the modiﬁed Anderson-Bj¨orckKing method (cf. App. A, p. 185) is applied in order to calculate the root numerically. Using this root value, all remaining unknowns of the system of equations can be calculated as exemplarily shown in App. B.3 (p. 190). In contrast to the one-dimensional case, we do not calculate all unknown variables, and we do not parameterize a trajectory, but we only calculate the value of ktimin.

Inoperative Time Intervals

According to Sec. 5.1.1, we have to look for Z = 1 inoperative time interval

per selected DOF. If such an interval exists for one DOF k, we have to calcu-

late

1k tibegin

and

1k tiend

to

determine

1 k

ζi

—

the

only

possible

element

of

kZi

(cf.

eqn. 5.3). For this purpose, we need two further decision trees, 1B and 1C,

one for the calculation of 1ktibegin and one for 1ktiend . These two trees describe

the set of holes

H ⊂ Ê9

(5.25)

in the input domain of the systems of equations for Step 2 (cf. eqn. (5.14)). They work very similarly to the one from Fig. 4.4 (p. 52) and are explained in the following. The result of the ﬁrst decision tree, 1B, is an acceleration proﬁle kΨˇiStep1 ∈ PStep1 that delivers the system of equations to determine 1ktibegin, the second decision tree, 1C, selects a proﬁle kΨˆiStep1 ∈ PStep1 in order to compute 1ktiend.

Remark 5.2. Because these decision trees would engross too much space, they cannot be depicted completely in a book, thesis, or script. To give an impression of the complexity: The tree 1B — written in font size of 10 pt, prepared in a minimized version, and with all nodes tightly arranged — can just be plotted on a poster of DIN A0 size.1 Even the description would ﬁll a book of several hundred pages, such that here only an impression shall be imparted, and only the basic conceptual ideas are explained. The cutouts of the four Type IV decision trees presented in Figs. 4.4, 5.6, 5.7, and 5.8 can only be considered as small samples. The decision tree of the extension for Variant B (Fig. 4.8, p. 62), however, is presented in extenso. A deeper discussion on this topic can be found in Chap. 9.10 (p. 173).

The decision tree 1B of Fig. 5.6 determines the acceleration proﬁle for the calculation of 1ktibegin. Compared to the tree 1A of Fig. 4.4, in which we tried to reach the target state of motion kMitrgt as fast as possible, we try to reach
1 The actual 1B decision tree as developed by the author engrosses two DIN A0 posters (also in a minimized version and with a font size of 10 pt but with potential for tightening).

5.3 Type IV On-Line Trajectory Generation

83

Fig. 5.6 Cutout of the Type IV decision tree 1B for the determination of an acceleration proﬁle kΨˇiStep1 ∈ PStep1 for the calculation of ktibegin.
kMitrgt within the next possible greater time, which can be achieved with another acceleration proﬁle or with another set of proﬁle parameters. The result can either be an acceleration proﬁle kΨˇiStep1 or the insight that there is no inoperative time interval 1kζi, that is, 1ktibegin = ∞ and 1ktiend = ∞. If the

84

5 Solution in Multi-dimensional Space

result is an acceleration proﬁle, which we denote with kΨˇiStep1, we set up the respective system of equations in order to calculate the proﬁle’s execution time 1ktibegin. If the system of equations delivers two solutions (cf. Examples 5.1 and 5.2, p. 73), we have to be careful: If the determined proﬁle kΨˆiStep1 is the same proﬁle as kΨiStep1 that we used to calculate the minimum execution time 1ktimin, we have to take the greater solution; otherwise, that is, kΨˆiStep1 = kΨˇiStep1, the lesser one is the correct one, because the greater one would already have speciﬁed the upper interval limit 1ktiend .
Fig. 5.7 depicts the third decision tree for the Type IV OTG algorithm.

This tree is only applied if we know from the result of the previously executed

tree

that

an

inoperative

time

interval

1 k

ζi

exists,

that

is,

compared

to

the

tree

1B of Fig. 5.6, in tree 1C we already know that an upper time interval limit

1ktiend is present. While tree 1B started at 1ktimin and searched from the left to the right on the time axis to ﬁnd the left interval limit 1ktibegin, we now start from the right to ﬁnd 1ktiend . That means we ﬁrst try to reach the target state of motion kMitrgt of a selected DOF k with a Step 1 acceleration proﬁle, which would require the greatest possible execution time. If the target velocity kVitrgt is negative (Decision 1C.001), we try to reach kPitrgt by ﬁrst applying the maximum velocity +kVimax (Decision 1C.004/1C.011). Afterwards, we try
to decrease the positive acceleration face Trap 1C.004 or a Tri (1C.011) step

by step until we ﬁnd a proﬁle kΨˆiStep1 whose system of equations is solvable. If the system of equations delivers two valid solutions for the desired upper

interval bound 1ktiend , the maximum one is the correct one, because the lesser one would be 1ktibegin.
Now, we have calculated all minimum execution times ktimin and all inoperative time intervals 1kζi = 1ktibegin, 1ktiend for all selected DOFs k ∈ {1, . . . , K}, and we know the complete set of all possible candidates for tisync.

Determining tisync

As shown in the structogram of Fig. 5.1 (p. 70), the determination of the minimum possible value of tisync is the last substep of Step 1. It works exactly in the same way as generally described in Sec. 5.1.1 (p. 74). We ﬁrst determine
the greatest element of all minimum execution times, and in a second step, we make sure, that tisync is not an element of the set of inoperative time intervals Zi.

Step 2
In accordance with Sec. 5.1.2, Step 2 calculates the coeﬃcients of all sets of motion polynomials lmi(t). That means, we need an acceleration proﬁle kΨiStep2 for each single selected DOF k that facilitates the desired timesynchronization, such that all selected DOFs reach their kPitrgt and kVitrgt

5.3 Type IV On-Line Trajectory Generation

85

Fig. 5.7 Cutout of the Type IV decision tree 1C for the determination of an acceleration proﬁle kΨˆiStep1 ∈ PStep1 for the calculation of ktiend.

exactly at tisync is the

tisync. ninth

Apart from the eight input values of Wi input value for the decision tree from Fig.

for 5.8,

each DOF which acts

k, as

function

Ê f : 9 \ H −→ PStep2 ,

(5.26)

86

5 Solution in Multi-dimensional Space

Fig. 5.8 Cutout of the Type IV decision tree for Step 2 to determine an acceleration proﬁle kΨiStep2 ∈ PStep2 for one DOF k ∈ {1, . . . , K}.

Ê that is, the tree has to cover the complete input domain 9 \ H for all systems
of equations (cf. eqn. (5.26)):

Ê sDStep2 ⊂ 9
S
Ê sDStep2 = 9 \ H .
s=1

(5.27) (5.28)

5.3 Type IV On-Line Trajectory Generation

87

Fig. 5.9 A subset of the acceleration proﬁle set PStep2 of Type IV.

Due to Step 1, we already know that the nine-element input vector is not an

element of H. It is important that the optimization criterion of eqn. (5.10)

(p. 75) is met by the decision tree and thus by the acceleration proﬁles of Step

2, PStep2. The essential consequence of eqn. (5.10) is that only rectangular jerk proﬁles can be applied, and the jerk progression can only take three values:

zero, the positive, or the negative maximum jerk value.

A subset of the acceleration proﬁles of PStep2 is shown in Fig. 5.9, and a selection of these proﬁles is supposed to be parameterized during Step

2 in order to calculate the trajectory Mi at a time instant Ti. Fig. 5.8 shows a cutout of the Step 2 decision tree and was drawn analogously to

the previous three decision trees of Figs. 4.4, 5.6, and 5.7. As with Decision

1A.001, Decision 2.001 checks whether the current acceleration value kAi is

positive or negative. Assuming the left branch is selected, we let Decision

2.002 check whether the velocity value would be greater or less than kvitrgt

if −kJimax was applied 2.003 checks whether k

to decrease the acceleration value to zero. Decision Aimax must be applied to reach kvitrgt , that is, we ﬁnd

out whether a positive triangle or trapezoidal acceleration proﬁle would lead

tsopekcvtitsrg,tw. W heethaesrsuthmeeretshualttiangtrpaopseiztiooindavlapluroeﬁolfeDisOrFeqkuairtetdis.ynDc eiscigsiroenat2e.r0o0r4leinssthan k pitrgt if kvitrgt would be reached as soon as possible by applying a trape-

zoidal acceleration proﬁle (PosTrap). If the resulting value is less, we know

that we have to increase the hold time of the trapezoidal acceleration proﬁle,

that is, a PosTrapZeroNeg. . . proﬁle would be required. Before we decide, whether kΨiStep2 = PosTrapZeroNegTri or kΨiStep2 = PosTrapZeroNegTrap is correct, Decision 2.005 veriﬁes whether we would have enough time to ap-

ply a positive trapezoidal acceleration proﬁle directly followed by a negative triangle-shaped proﬁle that exactly touches −kAimax, such that kvitrgt is ﬁnally
reached. If we do not have enough time for this acceleration progression,

