
JavaScript is disabled on your browser. Please enable JavaScript to use all the features on this page. Skip to main content Skip to article
Elsevier logo ScienceDirect

    Journals & Books 

Register Sign in

    View  PDF
    Download Full Issue 

Outline

    Highlights
    Abstract
    Keywords
    1. Introduction
    2. Related work with homotopy classes
    3. Homotopy classes generation
    4. Homotopic path planning algorithms
    5. Results
    6. Conclusions and future work
    Acknowledgments
    Appendix. Applicability to unknown environments
    References
    Vitae 

Show full outline
Cited By (22)
Figures (24)

    (a) Reference frame
    (b) Topological graph
    (a) A simple wrap in path βk1αk0βk1
    (b) A wrap in path αm0αk0βk2αk1
    (c) Self-crossing in path βk1βm1αm0βk2
    Fig.3. Lower bound in dashed red and channel in solid black for the homotopy class…

Show all figures
Tables (4)

    Table 1
    Table 2
    Table 3
    Table 4 

Elsevier
Robotics and Autonomous Systems
Volume 64 , February 2015, Pages 44-58
Robotics and Autonomous Systems
A comparison of homotopic path planning algorithms for robotic applications
Author links open overlay panel Emili Hernandez Marc Carreras Pere Ridao
Show more
Add to Mendeley
Share
Cite
https://doi.org/10.1016/j.robot.2014.10.021 Get rights and content
Highlights

•

    We present three path planners to generate solutions that follow homotopy classes.
•

    Homotopy classes provide an added value to the path planning problem.
•

    Our method generates paths with the topology of the optimal solution much faster.
•

    We show extensive results in synthetic scenarios and on a bathymetric map.

Abstract

This paper addresses the path planning problem for robotic applications using homotopy classes. These classes provide a topological description of how paths avoid obstacles, which is an added value to the path planning problem. Homotopy classes are generated and sorted according to a lower bound heuristic estimator using a method we developed. Then, the classes are used to constrain and guide path planning algorithms . Three different path planners are presented and compared: a graph-search algorithm called Homotopic A ∗ (HA ∗ ), a probabilistic sample-based algorithm called Homotopic RRT (HRRT), and a bug-based algorithm called Homotopic Bug (HBug). Our method has been tested in simulation and in an underwater bathymetric map to compute the trajectory of an Autonomous Underwater Vehicle (AUV). A comparison with well-known path planning algorithms has also been included. Results show that our homotopic path planners improve the quality of the solutions of their respective non-homotopic versions with similar computation time while keeping the topological constraints.

    Previous article in issue
    Next article in issue 

Keywords
Path planning
Homotopy
Marine robotics
1. Introduction

Path planning is one of the most studied problems in robotics. The goal of the algorithms is to find a safe path to guide a robot in the Configuration Space (C-Space)  [1] . Graph-based search algorithms look for the global optimal path in the C-Space which is obtained with an exhaustive exploration of the search space [2] , [3] . Most of these algorithms use a heuristic function to speed up the exploration process by first selecting the most promising states according to the heuristics  [4] . On the other hand, probabilistic sample-based path planners, most of them based on the Rapidly-exploring Random Tree (RRT)  [5] , perform the exploration by growing a tree incrementally until the goal is reached. These algorithms do not perform an exhaustive exploration in C-Space, therefore, they provide a solution very quickly at the expense of its quality. Even bug-based algorithms  [6] , initially developed to perform reactive motion planning, can also be considered for path planning purposes. Their simple navigation strategies alternate “go straight” and “follow boundary” behaviors when an obstacle is detected are suitable to generate paths in a C-Space.

Although the aforementioned strategies generate paths towards a goal state taking into account the non-traversable states due to obstacles, none of them report the topological information of how they are avoided. Because of this, we use homotopy classes to provide a topological description of the paths.

A homotopy class is the set of all possible trajectories from a start to a goal point that avoids obstacles in the same manner [7] , [8] . Given two paths, they are said to be homotopic if one can be deformed into the other without encroaching any obstacle. Providing this extra layer of topological information is an added valued to the path planning problem, and knowing the homotopy class before the computation of the path itself has several advantages for robotic applications . First, it is possible to constrain the path search into those areas of the search space that satisfy the homotopy class speeding up the path computation, which is very useful for low-powered navigation computers commonly used in autonomous robots. Second, if the homotopy class of the optimal path is known, it is possible to generate a good solution very quickly. Third, homotopy classes allow avoidance of obstacles in a specific manner which is of interest in surveillance, coverage and map exploration applications. For instance, homotopy classes can be selected to reinforce surveillance in specific areas, to avoid navigation patterns and to ensure that different areas of interest are explored from a topological point of view. They can also be used to constrain specific parts of the environment to avoid dangerous or unwanted areas in coverage applications. Multi-robot map exploration can also be improved using homotopy classes if each robot explores the environment following a different homotopy class.

The work presented in this paper is focused on, but not constrained to, path planning for Autonomous Underwater Vehicle (AUV) applications. Although the problem is naturally formulated in 3d, for certain scenarios of interest the problem can be simplified to 2d. For instance, a survey and/or search mission where the robot is supposed to fly at a fixed altitude, in bottom-following mode, while acquiring opto-acoustic imagery. Under these conditions, we can consider a 2d map parallel to the seafloor, where any area with a slope greater than a certain threshold behaves as a 2d obstacle. This is the case for applications like benthic habitat mapping, underwater archeology or cable/pipe inspection, being also the target for the system proposed.

In this paper we use homotopy classes to guide path planning algorithms topologically. We generate the homotopy classes that can be followed in any 2d workspace using the method presented in  [9] and improved in  [10] . Using the topological information, path planners do not have to explore the whole space but the space confined in a homotopy class. Then, using a lower bound heuristic estimator, the homotopy classes that most probably contain the lower cost solutions are known. Thus, the algorithm can generate some good solutions quickly. Three well known algorithms have been adapted to compute paths for each homotopy class generated, expanding on our preliminary work: the Homotopic A ∗ ( HA ∗ )  [11] , the Homotopic RRT (HRRT)  [10] and the Homotopic Bug (HBug)  [12] , [13] . The completeness of our method is ensured because in case the goal is not reachable, no homotopy classes will exist and, consequently, no paths will be generated. The homotopy class of the global optimal path is guaranteed to be generated by the algorithm. Constraining the path search to the topology of the optimal solution allows generating good solutions with non-exhaustive search-based methods at a fraction of their computation time. This is an advantage in large environments because these algorithms can be very slow.

The paper also presents an extension of our previous results. The efficiency and scalability of our method has been tested in synthetic scenarios. Furthermore, the path planners have been compared with their non-homotopic versions and with themselves. Finally, the paper extends the results of an experiment under the scope of the TRIDENT European project (EU FP7 ICT-248497), in which we initially explored the generation of homotopic trajectories on a bathymetric map using the HA ∗   [14] . The bathymetric map was generated by means of a Multibeam Profiling Sonar (MPS) and a Differential Global Positioning System (DGPS), which was used to generate a 2d Occupancy Grid Map (OGM) at the depth in which the AUV navigates. Our method has been applied to compute paths that the AUV must follow to reach a goal position avoiding obstacles in different manners. Extended analysis of the HA ∗ execution and new results using the HRRT and the HBug on the bathymetric map are provided, leading to a discussion on the suitability of each path planner for robotic applications.

The paper is structured as follows: Section  2 details the relevant literature about homotopy classes for robotic applications; Section  3 describes the method to generate the homotopy classes from the workspace; Section  4 details the path planners that we propose which follow the homotopy classes previously generated; Section  5 reports the results; Section  6 presents the conclusions and future work.
2. Related work with homotopy classes

From the path planning point of view, the literature about homotopy classes can be classified in three different groups: the computation of the shortest homotopic path solutions that require a homotopy class as an input; those solutions that constrain the search topologically based on previous paths generated in the C-Space; and the automated generation of homotopy classes approaches that do not require generating any prior path in the C-Space.
2.1. The shortest homotopic path problem

Computing the shortest homotopic path using a non optimal path or homotopy class as an input has been studied since the 1980s. The funnel algorithm   [15] is a well-known reference for triangulated environments. Although it was not explicitly designed to be used with homotopy classes, it generates the shortest path in a simple polygonal environment provided as an input which implicitly constrains it topologically. Other approaches generate the shortest homotopic solution for paths defined by closed curves  [16] and adding constraints such as weighted regions  [17] .

In non-triangulated environments some authors proposed algorithms that efficiently compute the shortest homotopic path for a set of input paths that do not self-intersect  [18] . This restriction was overcome in  [19] and additional constraints such as path thickness were added in  [20] . In the same vein, Grigoriev and Slissenko proposed a method to construct the shortest path for a given homotopy class that does not intersect in a scenario with semi-algebraic obstacles  [21] .

Despite the set of proposals that perform the computation efficiently for any possible path, the problem becomes intractable when there is no input homotopy class or path. Because of this, these solutions are difficult to apply in robot path planning. On the other side, some of these algorithms are suitable for an optimization process, when a path has been already generated by a path planner.
2.2. Constraining path search topologically

There is also a group of methods that compute the shortest path and then identify its homotopy class. This process can be done during the path search or once the whole path has been computed. Then, the topology of the path is encoded in order to restrict the next path search, which ensures that the new shortest path will have a different topology and hence, belong to another homotopy class. By repeating this process, it is possible to obtain the k -shortest paths of k -homotopy classes. In  [22] , [23] , two step methods were proposed: first, for each node of the environment they compute the shortest path that passes through it and then, the number of paths are pruned to generate the shortest path for each homotopy class. Other approaches generate a graph based on a Voronoi diagram computed from the areas to avoid which is then traversed using Depth-First Search (DFS)-based algorithms  [24] . Bhattacharya et al. proposed a method to perform path planning with homotopy class constraints using graph-search algorithms. The graph that represents the environment is expanded with Complex Analysis values to characterize homotopy classes while computing the path  [25] . This method has recently been extended to work on 3d environments and formulated for n d C-Spaces  [26] . In  [27] , it has also been applied to plan the path and control a flexible cable towed by two robots to separate two types of objects in a planar environment.

Although these methods have the clear advantage of starting with the computation of the global shortest path for robotic applications , if we are interested in the solution of the k path it requires computing all the previous paths.
2.3. Homotopy classes generation approaches

There is a small group of methods that first compute the homotopy classes and then search for a path that follows them. In order to generate the homotopy classes, a data structure that encodes the topology of the environment as a graph is required. Then, the homotopy classes can be systematically generated by exploring the graph with a graph-search algorithm.

Jenkins proposed a method to generate homotopy classes for any 2d workspace with obstacles by turning the workspace into a topological graph, which allows the systematic generation of homotopy classes using graph-search algorithms  [28] . Then, the shortest paths for each homotopy class were generated assuming circular obstacles in the workspace  [29] . However, some constraints imposed by obstacles in the workspace are not taken into account into the topological graph, which allows generating homotopy classes that cannot be followed back in the workspace.

In  [30] , homotopy classes characterized fixed routes topologically in a factory environment that allowed unmanned vehicles to avoid collisions among them while keeping the topology and  [31] proposed to build a Probabilistic Road Map (PRM)  [32] to take into account topological constraints for motion planning.

These methods offer the flexibility of computing a path that does not belong to the homotopy class of the global optimal path without having to compute any previous paths. However, generating homotopy classes systematically can make the problem intractable depending on the number of classes generated. This issue can be overcome by using some restriction criteria during the classes generation such as allowing only homotopy classes in their canonical form and avoiding those that self-intersect or repeat cycles.
3. Homotopy classes generation

Given a workspace with obstacles, in  [9] , [10] we extended the method proposed by Jenkins   [28] to generate the homotopy classes that can be followed in any 2d workspace. The method first builds a reference frame which determines the topological relationships between obstacles in the workspace and is used to name the homotopy classes. The reference frame is then used to build the topological graph which allows the computation of homotopy classes systematically.
3.1. Reference frame

Given a workspace with n obstacles, the reference frame determines, in the metric space, the topological relationships between obstacles and is used to name the homotopy classes. The whole construction process is summarized in three steps:

1.

    Select a random point inside each obstacle and label it b k , where k = 1 . . n .
2.

    Select the central point c of the reference frame. This point cannot be inside an obstacle or on the n ( n − 1 ) / 2 lines determined by the pairwise choices of distinct b k .
3.

    Construct n lines l k joining c with each b k . Each line is partitioned into m + 1 segments, where m is the number of obstacles that intersect with l k in the workspace. The segments from b k and away from c are labeled with β k s , and the segments in the opposite direction are labeled α k s , where s = 0 . . u with u ∈ Z + for the segments of l k from c that pass through b k and s = 0 . . v with v ∈ Z − for the segments in the opposite direction.

Using the reference frame, any path p can be defined topologically by the sequence of labels of the segments crossed in order from the start to the end point. Fig. 1 (a) depicts a reference frame for a scenario with two obstacles. The path p is labeled β 1 1 α 1 0 α 2 0 α 1 0 α 2 0 α 2 0 α 1 0 α 1 − 1 . There are two special cases when defining paths in the reference frame: when p does not cross any rays then p = 0̸ ; and when p crosses through c meaning that all the α k 0 ’s are simultaneously crossed, all α k 0 are added in subindex order to the sequence.

    Download : Download full-size image 

(a) Reference frame.

    Download : Download full-size image 

(b) Topological graph.

Fig. 1 . Topological path represented in: (a) the reference frame as p = β 1 1 α 1 0 α 2 0 α 1 0 α 2 0 α 2 0 α 1 0 α 1 − 1 (solid line) and one possible representation of its canonical sequence p ′ = β 1 1 α 1 0 α 2 0 α 1 − 1 (dashed line); (b) representation of its canonical sequence in the topological graph.
3.2. Computation of the canonical sequence

It is possible to know whether the paths that do not follow the same crossing-ray order in the reference frame are homotopic through their canonical sequence  [33] . The canonical sequence is the simplest representation of a path without changing its topology, and only one canonical sequence exists for each homotopy class, but each canonical sequence can be represented by infinite trajectories in the workspace. With the notation used in the reference frame, it is computed by first sorting the α k 0 ’s substrings according to the subindex of the path in non-decreasing order. Then, all the elements of the sequence that have the same character by pairs are removed. This process is repeated until no changes are made in the sequence. For instance, once path β 1 1 α 1 0 α 2 0 α 1 0 α 2 0 α 2 0 α 1 0 α 1 − 1 gets its α k 0 ’s substring sorted, it becomes β 1 1 α 1 0 α 1 0 α 1 0 α 2 0 α 2 0 α 2 0 α 1 − 1 . At this point the α 1 0 and α 2 0 pairs can be canceled β 1 1 α 2 0 α 1 − 1 obtaining β 1 1 α 1 0 α 2 0 α 1 − 1 . Since it cannot be shortened, it represents the canonical sequence of the path. Fig. 1 (a) depicts one possible solution in the workspace of this canonical sequence.
3.3. Topological graph

The reference frame is used to compute a topological graph G , providing a model to describe the relationships between regions of the metric space. Its construction can be divided into three steps:

1.

    The lines in the reference frame divide the metric space into regions or wedges and the obstacles that intersect with more than one line at the same time split these wedges into sub-wedges . Each sub-wedge represents a node of G .
2.

    Each node of G is labeled according to the wedge w and sub-wedge s w using the notation w . s w ; w ∈ N is numbered counterclockwise. For each w , its corresponding s w ∈ N is numbered sequentially starting by 1 for the one closest to c .
3.

    Two nodes of G are interconnected according to the number of segments they share in the reference frame. Each edge of G is labeled with the same label of the segment that crosses it in the reference frame.

In the reference frame, a path is defined according to the segments it crosses, whereas in G it turns into traversing the graph from the start node to the end node. Note that the start and end nodes of G are those sub-wedges in the reference frame where the start and end points are located. Fig. 1 (b) depicts the canonical sequence β 1 1 α 1 0 α 2 0 α 1 − 1 in the topological graph.
3.4. Systematic homotopy classes computation

Once the topological graph is constructed, it is traversed using a modified version of the Breadth-First Search (BFS) algorithm. The BFS is a graph search algorithm that begins at the root node and explores all the neighboring nodes. Then, for each of those nearest nodes, it explores their unexplored neighbors. The process is repeated until the goal is found. Unlike the standard BFS, which stops when all vertexes have been visited, the modified algorithm continues until there are no more homotopy class candidates to explore or the length of the last homotopy class candidate is larger than a given threshold.
3.4.1. Restriction criteria

During the BFS execution , several restriction criteria are applied to avoid the generation of any homotopy classes which either self-intersect or its canonical sequence is duplicated and has already been considered. All classes that satisfy any of the following restriction criteria are ignored to avoid using them as a root for future homotopy classes:

•

    Simple wrap . Any string that contains a substring of the form α k s … χ k t … α k u or β k s … χ k t … β k u where χ = ( α , β ) with s = u represents a class that wraps around an obstacle and is self-crossing. Fig. 2 (a) shows an example of a path that accomplishes the simple wrap criterion.

        Download : Download full-size image 

    (a) A simple wrap in path β k 1 α k 0 β k 1 .

        Download : Download full-size image 

    (b) A wrap in path α m 0 α k 0 β k 2 α k 1 .

        Download : Download full-size image 

    (c) Self-crossing in path β k 1 β m 1 α m 0 β k 2 .

    Fig. 2 . Restriction criteria examples during the homotopy class generation process. Any homotopy class that wraps an obstacle or self-crosses is discarded.

    Table 1 . Homotopy classes with their generation index and their lower bound normalized according to the cost of the A ∗ solution.
    Idx	Homotopy class	LB
    1	β 1 1 β 2 1 	0.94
    2	α 2 − 1 α 1 − 1 	0.95
    3	β 1 1 α 1 0 α 2 0 α 1 − 1 	1.04
    4	α 2 − 1 α 1 0 α 2 0 β 2 1 	1.08
•

    Wrap . Any string that contains a substring of the form χ k s … χ k t … χ k u where χ = ( α , β ) with s , t , u ≥ 0 and s > t < u or with s , t , u ≤ 0 and s < t > u represents a class that wraps around an obstacle and is self-crossing. Fig. 2 (b) shows an example of a path that accomplishes the wrap criterion.
•

    Self-crossing . Any string that contains a substring of the form χ k s … β m t … α m u … χ k v where χ = ( α , β ) with s , v ≥ 0 and s < v or with s , v ≤ 0 and s > v represents a class that self-crosses. The reversed substring χ k s … α m t … β m u … χ k v with s , v ≥ 0 and s > v or with s , v ≤ 0 and s < v also represents a class that self-crosses. Fig. 2 (c) shows an example of a path that accomplishes the self-crossing criterion.
•

    Duplicated . Duplicated strings are not allowed in the list of homotopy class candidates. If a string is not in its canonical form , it can be simplified without modifying its topology. Then, it is ensured that the resultant string has already been computed by the BFS algorithm because it would be shorter than the input string. Finally, the algorithm cannot traverse the same edge on two consecutive occasions. By doing that, a string with a repeated pair would be generated. Consequently, the pair would be simplified and the string discarded for being duplicated.

Table 1 shows the homotopy classes computed for the workspace depicted in Fig. 1 applying all the restriction criteria with their index of generation according to the BFS algorithm.
3.5. Lower bound estimator

The number of homotopy classes generated by the BFS algorithm highly depends on the number of the nodes in the topological graph. Therefore, in most scenarios it is not possible to compute all the correspondent paths of the homotopy classes in the workspace in real-time. In order to set up a preference order when choosing the homotopy classes to compute their paths, a modified version of the funnel algorithm   [15] is used to obtain a quantitative measure for each homotopy class estimating its quality. This algorithm computes the shortest path within a channel , which is a polygon formed by the vertexes of the segments in the reference frame that are traversed in the topological graph. The modification consists of accumulating the Euclidean distance between the points while they are being added to the channel’s shortest path. Hence, the result of the funnel algorithm is a lower bound of the optimal path in the workspace of the selected homotopy class.

The lower bound estimator is used to set up a preference order to compute the homotopy classes path in the workspace when operating under time restrictions. Note that the segments of the reference frame constrain the region where the paths can go through, but do not take into account the whole shape of the obstacles. For that reason, a homotopy class with a smaller lower bound may have a longer path in the workspace than another homotopy class with a higher lower bound.

Fig. 3 depicts an example where the funnel algorithm computes the lower bound for the homotopy class β 1 1 α 1 0 α 2 0 α 1 − 1 . The solid lines represent the channel and the dashed red line is the path after applying the funnel algorithm. It is worth noting that the modified algorithm takes into account that some subsegments may self-intersect when creating the channel as can be seen with the α 1 0 and α 2 0 segments in the figure. Table 1 shows the lower bound for each homotopy class obtained in this example. All lower bounds have been normalized according to the cost of the path obtained with the A ∗ , which belongs to class 2 ( α 2 − 1 α 1 − 1 ), using an A8 connectivity in a discretized representation of the environment. Some values are lower than 1 since the A ∗ solution takes into account the shape of the obstacles while the computation of the lower bound does not.

    Download : Download full-size image 

Fig. 3 . Lower bound in dashed red and channel in solid black for the homotopy class β 1 1 α 1 0 α 2 0 α 1 − 1 , index 3 in Table 1 .
4. Homotopic path planning algorithms

Once the homotopy classes are computed and sorted according to their lower bound, a path planning algorithm has to find a path in the workspace that follows a given homotopy class which essentially implies turning a topological path into a metric path. The only link between the workspace and the topological space is the reference frame. It allows checking whether a metric path in the workspace is following a topological path by following the intersections in order from the initial configuration to the current configuration. For this purpose, three well known algorithms have been adapted to compute paths for a single homotopy class.
4.1. Homotopic A ∗

The Homotopic A ∗ ( HA ∗ ) is a graph-based search algorithm based on the A ∗   [4] that instead of exploring the entire search space, it only explores the zones in the workspace that satisfy a given homotopy class by checking the intersections with the reference frame before taking into consideration the node as a candidate to be explored.

The HA ∗ is written in pseudocode in Algorithm 1. The nodes in the algorithm are tuples that contain the configuration of robot q and the topological path from q start to q . These values are accessible through the functions Q and P respectively. Just like the A ∗ , open nodes are processed according to their position in a priority queue OPEN . Each node in this queue is ordered according to the sum of its current path cost from the start, g ( n ) , and a heuristic estimation of its path cost to the goal, h ( n , n goal ) . The node with the minimum sum is at the top of the priority queue.

The algorithm receives as input the start configuration q start , the goal configuration q goal , a candidate homotopy class to follow H and the reference frame F . The configurations q start and q goal are used to set up the initial node n start and the goal node n goal (line 21).

The function ComputePath computes the shortest path that follows H . It starts by adding the n start into the OPEN queue. As node n with the minimum g ( n ) + h ( n , n goal ) is different from n goal , the algorithm pops n to the top of the queue. For all the configurations q ′ reachable from Q ( n ) , the function FindIntersections (line 13) returns the intersections of the segment [ Q ( n ) , q ′ ] with F sorted by distance. Note that it is possible to intersect more than one segment of the reference frame depending on how close Q ( n ) and q ′ are to the c point. Then the UpdateH (line 14) generates the new topological path according to the intersections. No intersections with F means that the explored configuration is in the same sub-wedge of the C-Space and the function returns P ( n ) . If there are intersections and these intersections follow H , the function returns P ( n ) ∪ I in order to create a new node candidate n ′ . Whether n ′ is in the OPEN queue or not is then checked. If not, it is added to the queue with a priority g ( n ′ ) plus the heuristic h ( n ′ , q goal ) (line 18). If it is, and the cost g ( n ) plus the cost of traversing from n to n ′ , c ( n , n ′ ) is less than its current cost (line 19), g ( n ′ ) is set to this new lower value. This process is repeated until the n goal is found or OPEN has no more nodes to be expanded.

    Download : Download full-size image 

Fig. 4 (a) depicts an example of an HA ∗ execution in a discrete version of the workspace shown during the generation of the homotopy classes for the homotopy class β 1 1 α 1 0 α 2 0 α 1 − 1 using an A8 connectivity and the Euclidean distance as heuristic estimator. The explored states are depicted in gray.

    Download : Download full-size image 

(a) HA ∗ solution.

    Download : Download full-size image 

(b) HRRT solution.

    Download : Download full-size image 

(c) HBug solution.

Fig. 4 . Execution of the proposed path planners for homotopy class β 1 1 α 1 0 α 2 0 α 1 − 1 : (a) HA ∗ path with the explored states depicted in gray; (b) a solution found by the HRRT with the generated exploration tree in gray; (c) HBug solution with the boundary nodes n x in gray, the lines used to compute the directions in dashed gray and the direction the path follows at each obstacle in red. (For interpretation of the references to color in this figure legend, the reader is referred to the web version of this article.)
4.1.1. Complexity analysis

The HA ∗ , shown in Algorithm 1, is based on the A ∗ , which has a time complexity O ( N d ) on the dimension d in a grid-based search space  [34] . Two additional methods have been implemented for searching a path according to a homotopy class: FindIntersection and UpdateH in lines 13 and 14 respectively.

FindIntersection time complexity depends on the time to check intersection T int , the number of the reference frame segments | F | , which is fixed for a HA ∗ execution, and the sorting process of the intersections found: (1) T f i = | F | T int + | F | ≈ O ( 1 ) .

UpdateH time complexity depends on the number of intersections with the reference frame segments returned by FindIntersection and the simple operation time to update it T u . In the worst case scenario the number of intersections could be the number of the segments in the reference frame | F | : (2) T u h = | F | T u ≈ O ( 1 ) .

Although FindIntersection and UpdateH are in the inner loop, their order does not affect the dominant complexity of the algorithm. Therefore, the overall time complexity is O ( N d ) , with d = 2 in the context of the paper.
4.1.2. Theoretical properties

The HA ∗ inherits two properties from the A ∗ algorithm:

Lemma 1

The H A ∗ computes the optimal solution from s to g for given homotopy class H .

Assumption 1

HA ∗ uses an admissible heuristic function .

Proof

The HA ∗ imposes an additional restriction with respect to the A ∗ in the exploration process by expanding only those nodes that satisfy H , which is A ∗ same principle of exploring nodes according to their priority. See proof in  [35] . □

Lemma 2

The H A ∗ is complete.

Proof

Refer to  [35] . □

4.2. Homotopic rapidly-exploring random tree

The Homotopic RRT (HRRT) is based on the goal-biased RRT  [5] algorithm which has been shown to be very efficient in time, even in complex workspaces  [36] , [37] . The algorithm allows a constrained growing of the tree only in those directions that satisfy a given homotopy class. Before adding a new node into the tree, the topological path traversed is checked to ensure that it belongs to the homotopy class by computing the intersections of the path with the reference frame.

The HRRT is detailed in Algorithm 2. It receives as input the start configuration q start , the goal configuration q goal , a candidate homotopy class to follow H and the reference frame F . The nodes on tree T are tuples that contain the configuration of the robot q and the topological path from q start to q . These values are accessible through the functions Q and P respectively. Just like the RRT, the function Extend (line 20) iteratively extends tree T until the distance between the configuration of n new ( Q ( n new ) ) and n goal ( Q ( n goal ) ) is lower than a distThreshold .

The extension of the tree starts by selecting a random configuration q rand from the C-Space with the function ComputeQRand . Then, the NearestNeighbor function returns the nearest node n nearest regarding a random configuration q rand by looking for the node whose topological path is closer to P ( n goal ) (line 4). If there is more than one candidate, the node selected is the closest to the goal according to the Euclidean distance. After q new is computed using the function ComputeQNew , FindIntersections (line 11) checks whether the segment [ Q ( n nearest ) , q new ] intersects with any segment in reference frame F . The function returns the intersected edges sorted by distance from Q ( n nearest ) . Then, the function UpdateH (line 12) generates the new topological path H ′ according to the intersections. No intersections with F means that the tree grows in the n nearest sub-wedge and hence, the function returns P ( n nearest ) . If there are intersections and these follow the topological path, the function returns P ( n nearest ) ∪ I in order to create a new candidate node n new to be added to the tree; otherwise a null path is returned and no node is added to the tree.

    Download : Download full-size image 

Fig. 4 (b) depicts an execution example of the HRRT with an exploration tree and the solution obtained with no post-processing. The homotopy class to follow is β 1 1 α 1 0 α 2 0 α 1 − 1 . Note that the algorithm constrains the expansion of the tree only into those zones that accomplish the input homotopy class, thus, in this example, segments α 1 − 1 or β 2 1 in the reference frame do not have to be crossed by the tree.
4.2.1. Complexity analysis

The time complexity analysis of the HRRT, shown in Algorithm 2, depends on the number of times the tree is expanded with Extend function. Assuming that N Extend calls are executed and leaving the simple assignation operations aside, the time to generate a tree that follows a homotopy class can be calculated as the sum of time for N iterations of operations in lines 8–12 and 15: (3) T ( N ) = T q rand ( N ) + T n n ( N ) + T q new ( N ) + T f i ( N ) + T u h ( N ) + T add ( N ) where T q rand , T n n , T q new , T f i , T u h , T add are the time to compute ComputeQRand , NearestNeighbor , ComputeQNew , FindIntersetions , UpdateH and Add a node to the tree respectively.

T q rand , T q new and T add are simple operations that can be done in constant time at each iteration so they are O ( N ) in the algorithm. Finding the NearestNeighbour at each iteration requires checking the distance with all previous configurations added to the tree: (4) T n n ( N ) = ∑ i = 1 N ( i − 1 ) T dist = N 2 − N 2 T dist ≈ O ( N 2 − N ) where T dist is the time that takes to calculate the distance. As stated before, FindIntersection time complexity depends on the time to check intersection T int , the number of the reference frame segments | F | , which is fixed for a HRRT execution, and the sorting process of the intersections found: (5) T f i ( N ) = N ( | F | T int + | F | ) ≈ O ( N ) .

UpdateH time complexity depends on the number of intersections with reference frame segments returned by FindIntersection and the simple operation time to update it T u . In the worst case scenario the number of intersections could be the number of the segments in the reference frame | F | : (6) T u h ( N ) = N | F | T u ≈ O ( N ) .

The complexity of the algorithm is the combination of the main operations during the Extend process: (7) O ( N ) + O ( N 2 − N ) + O ( N ) + O ( N ) + O ( N ) + O ( N ) ≈ O ( N 2 − N ) ≈ O ( N 2 ) .
4.2.2. Convergence

The HRRT is derived from the RRT algorithm adding a constrained growing of the tree according to a homotopy class.

Lemma 3

The HRRT is probabilistically complete for a given homotopy class H .

Assumption 2

H may or may not allow connecting s and g .

Proof

Refer to  [38] . □

4.3. Homotopic Bug

The Homotopic Bug (HBug) is the third approach to generate paths according to a homotopy class. Although Bug-based planners are reactive algorithms designed for on-line robot navigation that can be applied to robots with low computational capabilities, it is possible to use them to perform deliberative path planning on a C-Space  [39] . The HBug is based on the Bug2  [40] . It is an opportunistic algorithm that takes advantage of the already computed lower bound path, which is similar to the Bug2’s m -line but satisfying a homotopy class constraints. Essentially, the HBug tries to follow the lower bound path obtained with the modified funnel algorithm which ensures that the homotopy class is being satisfied. However, as mentioned before, the segments in the reference frame constrain the regions the paths can go through, but do not take into account the shape of the obstacles. For this reason, the lower bound path may intersect with the obstacles. In such cases, the obstacle boundary is followed in a clockwise or counterclockwise direction according to the homotopy class until the lower bound path leaves the obstacle. This process is repeated for all the obstacles intersected by the lower bound path.

The HBug is detailed in Algorithm 3. It receives as input parameters the lower bound path P , a candidate homotopy class to follow H and the reference frame F . Note that the first and last elements of P are the start ( s ) and goal ( g ) nodes respectively.

The algorithm is a three step process. First, the function BoundaryNodes checks the intersections of P with the obstacles in the C-Space. Every time that P hits or leaves an obstacle, a boundary node is created. Each node contains the contact point c and the obstacle label k , which is the subindex of the point b k that represents the obstacle in the reference frame. These parameters are accessible through the functions Q and Obst respectively. Then, ObstacleNodes computes the nodes O based on the boundary nodes N previously computed. Each obstacle node contains the first boundary node that hits obstacle n h , the last node in its boundary without changing the obstacle n l , and the direction d to surround the obstacle while following H (line 18). Finally, the function BuildPath creates the path P ′ in the workspace by joining the boundary of each obstacle o i ∈ O from n h to n l with the direction d .

The direction d to surround an obstacle is set according to the direction of a hit node n h towards its successor n h + 1 1 with respect to point b k that represents the obstacle in the workspace in the reference frame. Note that n h and n h + 1 are ensured to belong to the same obstacle since for any point that hits an obstacle there has to be another that releases it. The perpendicular dot product between vectors ( Q ( n h ) − b k ) and ( Q ( n h + 1 ) − b k ) computes the boundary following the direction (line 12). If the result is less than 0, the direction from n h to n h + 1 is counterclockwise; if it is greater than 0, the direction is clockwise.

The result of the perpendicular dot product can be 0 if the vectors ( Q ( n h ) − b k ) and ( Q ( n h + 1 ) − b k ) are parallel, which means that n h , n h + 1 and b k belong to the same l k in the reference frame (line 13). In such cases, d is obtained according to two conditions: the initial direction selected to cross l k from the start point, and the number of times that l k is crossed until α k or β k , denoted by χ k , of the homotopy class, on which n h + 1 relies, is reached. The initial direction is obtained with the dot product from the start s to the first χ k with the same subindex as l k 2 (line 14). The number of times that l k is crossed depends on the number of χ k found in the homotopy class from the beginning to the index i k , which indicates the position of the χ k that contains n h + 1 (line 16).

Fig. 4 (c) depicts an example scenario where the HBug is applied. The homotopy class to follow is β 1 1 α 1 0 α 2 0 α 1 − 1 . The dashed line represents its lower bound path, which intersects the first obstacle generating two boundary nodes, n 1 and n 2 , both located on line l 1 in the reference frame. The point that represents the obstacle is b 1 , also on l 1 , which makes the perpendicular dot product between ( Q ( n 1 ) − b 1 ) and ( Q ( n 2 ) − b 1 ) unable to set the direction ( d = 0 ). Therefore, using the start point s and a point of the edge β 1 1 , the initial direction is set clockwise. The last edge involved in this situation is α 1 0 , located in the second position in the homotopy class. The number of edges with subindex 1 up to this position is 2, thus, the direction is not changed. Then, the lower bound path intersects the second obstacle in n 3 and n 4 . Using the base point b 2 , the perpendicular dot product sets the direction as counterclockwise. Finally, the path is composed from s to g with the boundaries of obstacle 1 (from n 1 to n 2 ) and obstacle 2 (from n 3 to n 4 ) joined by straight lines.

    Download : Download full-size image 

4.3.1. Complexity analysis

The time complexity analysis of the HBug, shown in Algorithm 3, is the combined complexity of the BoundaryNodes , ObstacleNodes and BuildPath operations.

BoundaryNodes computation time T b n depends on the number of nodes N explored along the lower bound path P and on the contour points found during this process. The worst case scenario can be represented by a highly cluttered environment with a single cell obstacles and P intersecting with all of them. Each intersection generates 2 contour points and the maximum number of obstacles is N / 2 : (8) T b n ( N ) = N + 2 N 2 T b = N ( 1 + T b ) ≈ O ( N ) where T b is the time of the simple operation to create a node.

ObstacleNodes is the highest complexity operation since it looks for the last contour node of a specific obstacle. In the worst case scenario with single cell obstacles its complexity at each iteration is O ( 1 ) because the next node leaves the obstacle, but in other environments with fewer but more complex obstacles, an obstacle can be crossed k times making this operation O ( k ) . Therefore, the overall complexity of the method is O ( k N ) ≈ O ( N ) .

BuildPath takes N obstacle nodes found in the previous step and connects them exploring the contour of the obstacle they belong to. The Boundary operation, in line 23, is O ( N ) and the complexity of this method is O ( N 2 ) .

Combining the complexity of the methods analyzed returns the complexity of the HBug: (9) O ( N ) + O ( N ) + O ( N 2 ) ≈ O ( N 2 ) .
4.3.2. Theoretical properties

The HBug algorithm has been designed to be used together with the automated computation of the homotopy classes. Nevertheless, the algorithm itself has several properties:

Lemma 4

The HBug is complete.

Proof

Let us prove it by contradiction assuming that the algorithm is incomplete and there is a path from s to g that follows an homotopy class H . This implies that the solution has a finite length and intersects obstacles a finite number of times. Two cases can arise: no termination or incorrect termination.

Let us assume that the algorithm does not terminate. However, based on  [40] , each obstacle node has a pair of hit and leave nodes ( n h and n l ) which ensure that n l is closer to the goal than n h when following H . This implies there exists a finite number of nodes which will be exhausted by the algorithm and terminate.

The algorithm could only finish incorrectly by avoiding obstacles in a manner that H is not satisfied, which requires contradicting the definition of the perpendicular dot product  [41] when computing the turning direction. □

Lemma 5

Given a lower bound path P , that follows homotopy class H , the upper bound U B in the C-Space is (10) U B ≤ L B + ∑ i = 1 n p i where L B is the length of the P , n is the number of obstacles in the environment that crosses with P and p is the perimeter of the obstacles involved.

Assumption 3

Exists a solution and the position of g and the obstacles are known.

Proof

Based on the Bug2 upper bound proof  [40] , there is no path that can be shorter than LB and in the worst case scenario each obstacle intersected by LB could be completely circumnavigated. □

5. Results

The topological path search and the path planning algorithms we propose have been implemented and tested in different scenarios with irregular obstacles, the most commonly found in unstructured underwater environments. In order to identify the obstacles in the scenarios, a modified version of the Component Labeling (CL) algorithm  [42] has been applied, which efficiently labels connected cells and their contours in grayscale images at the same time. For the construction of the reference frame, the c point has been set at a fixed position in order to ensure the same topological graph construction and homotopy classes generation through different executions. The homotopy classes have been set at a maximum of 20 character length. In order to show all the possible results, no time restrictions have been taken into consideration.

All the results have been computed using a laptop with a dual core processor at 1.83 GHz and 2 GB of RAM . The quality and performance of the solutions obtained with the HA ∗ , HRRT and HBug have been measured using the path cost and computation time.
5.1. Cluttered scenario

This experiment shows the results obtained with the path planning method in a cluttered environment represented by a 200 × 200 pixels bitmap with five irregular obstacles (see Fig. 5 ). The construction of the reference frame, the topological graph and the generation of the homotopy classes with their lower bound computation took 7.9 ms. Table 2 lists the homotopy classes sorted by their lower bound with the path cost for the HA ∗ , the HRRT and the HBug algorithms. To ensure the stability of the results, the path cost for the HRRT is the average of 100 executions using a step of 10 cells. Path costs and lower bounds have been normalized with respect to the A ∗ path cost. The HA ∗ generates the optimal path for each homotopy class. Most of the solutions obtained with the HBug have a lower cost than the HRRT solutions, however, the difference is very small.

    Download : Download full-size image 

(a) α 2 1 α 1 1 β 4 1 α 3 1 α 5 1 .

    Download : Download full-size image 

(b) β 2 2 α 1 1 β 4 1 α 3 1 α 5 1 .

Fig. 5 . Paths generated with HA ∗ (solid-red), HRRT (dashed-cyan) and HBug (dashed-green) algorithms for the two homotopy classes with the smaller lower bound in the cluttered environment. (For interpretation of the references to color in this figure legend, the reader is referred to the web version of this article.)

Table 2 . Homotopy classes with the cost of the paths of Fig. 5 scenario sorted by their lower bound.
N°	Idx	Homotopy class	LB	HA ∗ 	HRRT	HBug
1	2	α 2 1 α 1 1 β 4 1 α 3 1 α 5 1 	0.89	1 	1 . 32 	1 . 35
2	8	β 2 2 α 1 1 β 4 1 α 3 1 α 5 1 	0.90	1 . 03 	1 . 37 	1 . 32
3	3	α 2 1 α 1 1 β 4 1 α 3 1 β 5 2 	0.97	1 . 28 	1 . 64 	1 . 62
4	9	β 2 2 α 1 1 β 4 1 α 3 1 β 5 2 	0.99	1 . 30 	1 . 69 	1 . 58
5	1	α 5 0 α 3 0 α 4 0 α 1 0 α 2 0 	1.05	1.11	1 . 42 	1 . 31
6	11	β 2 2 β 1 2 β 4 2 α 3 2 β 5 2 	1.06	1.36	1 . 74 	1 . 63
7	10	β 2 2 β 1 2 β 4 2 α 3 2 α 5 1 	1.08	1.26	1 . 61 	1 . 55
8	13	β 2 2 β 1 2 β 4 3 β 3 3 β 5 2 	1.12	1.18	1 . 45 	1 . 36
9	5	α 2 1 β 1 2 β 4 2 α 3 2 β 5 2 	1.24	1.71	2 . 31 	2 . 23
10	4	α 2 1 β 1 2 β 4 2 α 3 2 α 5 1 	1.26	1.61	2 . 18 	2 . 13
11	12	β 2 2 β 1 2 β 4 3 β 3 3 α 5 1 	1.27	1.45	1 . 93 	1 . 81
12	7	α 2 1 β 1 2 β 4 3 β 3 3 β 5 2 	1.33	1.53	2.03	1.95
13	6	α 2 1 β 1 2 β 4 3 β 3 3 α 5 1 	1.45	1.80	2.49	2.40

Fig. 5 depicts the paths of the two homotopy classes with smaller lower bound in Table 2 generated with the HA ∗ , the HRRT and the HBug path planners. Fig. 6 depicts the accumulated computation time for each path, which takes into account the computation of the reference frame, the topological graph, the homotopy classes with their lower bound and the paths generation. The generation of the paths for the whole set of homotopy classes took almost 4.5 s using the HA ∗ . The path of the fifth class (index 1) was the fastest to be generated (94.4 ms) and the path of the eleventh class (index 12) the slowest (603.8 ms). The total computation time with the HRRT was reduced to 0.6 s with the fifth class (index 1) being the fastest one to be generated (12.2 ms) and the ninth class (index 5) the slowest (88.1 ms). Finally, the total computation time using the HBug was only 8.5 ms. The fastest path (class 7, index 10) was generated in 32 μ s and the class 13 (index 6) path was the slowest one to be generated with only 76 μ s . These low values justify the almost flat line for this path planner when compared with the HA ∗ and the HRRT in Fig. 6 .

    Download : Download full-size image 

Fig. 6 . Accumulated computation time of the paths using HA ∗ , HRRT and HBug algorithms for each homotopy class on Table 2 sorted according their lower bound.

Table 3 . The homotopy classes of the Fig. 7 environment with the smaller lower bound.
N°	Idx	Homotopy class
1	25	α 1 5 − 1 α 9 0 α 12 0 α 1 0 α 4 0 α 6 0 α 5 0 α 8 1 α 3 − 1 α 11 2 α 13 2 β 7 2 α 2 − 2 α 14 2 β 10 2
2	26	α 1 5 − 1 α 9 0 α 12 0 α 1 0 α 4 0 α 6 0 α 5 0 α 8 1 α 3 − 1 α 11 2 α 13 2 β 7 2 α 2 − 2 β 14 3 β 10 2
3	5	α 1 0 − 1 α 1 4 − 1 β 2 1 α 7 − 1 α 1 3 − 1 α 1 1 − 1 α 3 0 α 8 0 β 5 1 α 6 1 α 4 − 1 α 1 − 2 α 12 2 β 9 2 α 15 2
4	1	α 1 0 − 1 α 1 4 − 1 β 2 1 α 7 − 1 α 1 3 − 1 α 1 1 − 1 α 3 0 α 8 0 α 5 0 α 6 0 α 4 0 α 1 − 2 α 12 2 β 9 2 α 15 2
5	41	α 1 5 − 1 α 9 0 α 12 0 α 1 0 β 4 1 α 6 − 1 α 5 − 1 α 8 1 α 3 − 1 α 11 2 α 13 2 β 7 2 α 2 − 2 α 14 2 β 10 2

When operating under time restrictions, it is possible to stop the path search when the lower bound of the next homotopy class to be computed is higher than the minimum cost of the paths already computed. In such cases, it is ensured that the best path has already been computed because it is not possible to obtain a path with a lower cost than its lower bound. For instance, in Table 2 the HA ∗ would stop before computing a path for the fifth homotopy class (index 1) since its lower bound (1.05) is higher than the path length obtained with the first class (index 2, cost 1). The accumulated computation time would be 1.54 s (see Fig. 6 ). On the other hand, the HRRT and HBug algorithms would stop before computing the path of the two last classes with a lower computation time than the HA ∗ (0.53 s for the HRRT and 8.4 ms for the HBug) at the expense of higher path costs.
5.2. Large scenario

The scalability of our method has been tested in a 1000 × 1000 pixels bitmap scenario with 15 irregular obstacles (see Fig. 7 ). The construction of the reference frame, the topological graph and the generation of 112 homotopy classes with their lower bound computation took 0.304 s. Table 3 shows the five homotopy classes with the smaller lower bound. Fig. 8 depicts the normalized cost obtained with the HA ∗ , HRRT and HBug with respect to the optimal path cost for each homotopy class sorted by their normalized lower bound.

    Download : Download full-size image 

Fig. 7 . Paths of the five homotopy classes with the smaller lower bound computed with the HBug. The class associated to the index can be found in Table 3 .

    Download : Download full-size image 

Fig. 8 . Normalized cost and normalized lower bound for paths of each homotopy class.

Fig. 9 shows the computation time for each path represented in log scale. The paths computed with the HA ∗ took between 7.49 s, for the class of the optimal global path (class 1, index 25), and 53.69 s for the class 75 to be generated with a cost 1.6 times of the global optimal solution . The mean computation time was 30.99 s. The HRRT computed the best solution in 0.069 s (class 1, index 25) with a cost 1.4 times the global optimal solution. However, the fastest path was generated in 0.038 s (class 14, index 93) with a path cost 1.83 times the global optimal solution. On the other hand, the slowest (class 70, index 19) took 1.248 s with a cost of 2.19 times the global optimal solution. The mean computation time for each path was only 0.239 s, almost 130 times faster than the HA ∗ at the expense of computing higher cost solutions. The HBug computation time goes from 1.12 × 1 0 − 4 s (class 1, index 25) with a path cost only 1.05 times the optimal solution to 1.98 × 1 0 − 4 s with a cost 2.24 times above the global optimal solution (class 110, index 102). The mean computation per path was only 1.50 × 1 0 − 4 s , almost 1600 times faster than the HRRT and 2×10 5 times faster than the HA ∗ . In this environment, the paths for the whole set of homotopy classes were computed in 16.8 ms, which is almost negligible when compared with the 304 ms spent in the generation of the reference frame, topological graph and the homotopy classes with their lower bound.

    Download : Download full-size image 

Fig. 9 . Computation time for paths of each homotopy class.

When operating under time restrictions the HA ∗ would stop the path generation process before computing the path of the third homotopy class (index 5 in Table 3 ) with an accumulated time of 31.25 s. The HRRT would compute until the eightieth homotopy class (index 35) in 19.167 s. Finally, the HBug would generate paths until the fifth homotopy class (index 41) in 304.5 ms taking into account all the steps of the method. Fig. 7 depicts these paths generated with the HBug.
5.2.1. Comparative results

The proposed path planners have been compared against the A ∗   [4] , the RRT  [5] , their respective anytime versions (Anytime Repairing A ∗ ( ARA ∗ )  [43] and Anytime-RRT (ARRT)  [44] ) and the Bug2 algorithm  [40] . A ∗ , RRT and Bug2 are designed to compute only one path towards the goal; the ARA ∗ and ARRT compute several paths but without taking into account their homotopy. Because of this, the comparison is against the five homotopy classes with the smaller lower bound shown in Table 3 . Fig. 10 depicts the comparison. The data obtained with the RRT and the ARRT are the average of 100 executions to ensure the stabilization of the results.

    Download : Download full-size image 

Fig. 10 . Comparison of the HA ∗ , HRRT and HBug paths of the five homotopy classes with the smaller lower bound vs. A ∗ , RRT, ARA ∗ , ARRT and Bug2 algorithms.

The A ∗ returned the optimal path in 11.90 s. The ARA ∗ generated the first solution in 7.40 s and found the optimal solution after 301 s. The RRT algorithm took 0.012 s to compute a path with a cost 1.48 times the global optimal solution. The ARRT took 3.13 s to obtain the first solution and 78.30 s to compute all of them, ensuring that any new solution generated is closer to the optimal one. The Bug2 algorithm computed the path in 0.044 s with a cost 1.90 times the optimal solution. In order to obtain the best possible path with this algorithm, we have manually chosen the directions to surround the obstacles: the m -line, which connects the start with the goal, intersects with the obstacles labeled b 1 , b 7 and b 10 ; the directions are clockwise for b 1 , counter-clockwise for b 7 and clockwise for b 10 .

The HA ∗ computed the optimal path (index 25) in 7.79 s and obtained the path for the five selected homotopy classes in 71.61 s. The computation of the optimal path of the best homotopy class with the HA ∗ , which corresponds to the A ∗ solution, was 1.53 times faster than the A ∗ . The computation of the first path took 0.390 s longer than the first solution of the ARA ∗ , but the ARA ∗ needed more iterations to refine the path to obtain the same solution as the HA ∗ . The best HRRT solution (index 25) was computed in 0.373 s with a cost 1.40 times the optimal one, and obtained the path for the five homotopy classes with the smaller lower bound in 0.603 s.

The HRRT computation time was better than the A ∗ and the ARRT. The reduced computation time of the RRT could not be reached due to the computation of the homotopy classes and the extra load of checking the topological restrictions of the HRRT. Despite class with index 25 had a lower cost than the RRT solution, the difference was small. The HBug computed the best solution (index 25) in 0.304 s with a cost 1.05 times the optimal one, and obtained the path for the whole set of homotopy classes in 0.321 s. As stated earlier, the computation of the paths with the HBug for each homotopy class offers a very good performance. Only the RRT and Bug2 had lower computation times at the expense of finding higher cost solutions. Note that most of the time was spent in the computation of the reference frame, the topological graph and the generation of the homotopy classes with their lower bound.

Until now, the quality of all the solutions has been compared with the A ∗ cost, which generates the global optimal path. However, the standard A ∗ is not able to take into account any topology during the path generation. On the other hand, the HA ∗ computes the shortest path for each homotopy class, which is the optimal solution according to the topological constraints. Therefore, a comparison of the solutions generated with the HRRT and the HBug against the HA ∗ cost for each specific homotopy class is depicted in Fig. 11 . The HRRT generates solutions between 1.35 (class 15, index 73) and 1.82 (class 83, index 61), with a mean of 1.57 times with respect to the optimal path cost for the specific homotopy class generated with the HA ∗ . The HBug generates solutions between 1.03 (class 5, index 41) and 1.19 (class 100, index 101), with a mean of 1.1 times with respect to the optimal path cost computed with the HA ∗ .

    Download : Download full-size image 

Fig. 11 . HRRT and HBug paths cost with respect to the HA ∗ cost for each homotopy class.
5.3. Experiment in the Formigues Islands

Our path planning method has also been considered as a part of the TRIDENT European project (EU FP7 ICT-248497) which is focused on providing a new methodology for multipurpose underwater intervention tasks with diverse potential applications like underwater archeology, oceanography and offshore industries , going beyond present-day methods typically based on manned and/or purpose built systems. A team of two cooperative heterogeneous robots with complementary skills, an Autonomous Surface Vessel (ASV) and an AUV  [45] endowed with a dexterous manipulator will be used to perform underwater manipulation tasks.

The experiments of the project consist of two steps. In the first step, the AUV is deployed from the ASV to perform a path following survey, in which it gathers optical/acoustic data from the seafloor to do an accurate terrain tracking. After the survey, the AUV docks in the ASV and sends the data back to a ground station where a map is set up and a target object is identified by the end user. In the second step, the ASV navigates towards a waypoint near the intervention area where the AUV is launched to search for the object. When the object has been found, the AUV switches to free floating navigation mode to start the manipulation process.

Our proposal is used in the second step of the experiments when the AUV has to compute safe paths for the intervention based on the generated map. The method has been applied to a bathymetric map. The path planning method is in charge of generating the different homotopy classes for the environment. After that, the homotopic path planners compute the paths for each class. Since the target for the intervention has to be selected by the user once the vehicle has performed the survey and reached the surface, time is not a constraint. Selecting the trajectory to reach the intervention area prevents the AUV from traversing undesirable areas with strong local currents due to the obstacles configuration or muddy areas not suitable to navigate close by, which can be perceived by the survey sensors but not by the on-line navigation sensors.

The bathymetry was gathered with a Multibeam Profiler Sonar (MPS) Model 837B “Delta T” 1000 from Imagenex. This sensor is a multiple receiver sonar system designed to provide detection over a wide field of view for bottom profiling applications. The MPS has 480 beams spread in a 120° swath overture with a beam rate frequency of 5–10 Hz, depending on the depth of the scanned area. The sensor has a Motion Reference Unit (MRU) sensor to capture roll, pitch and heading.

The experiment took place in the Formigues Islands, on the Catalan coast. A DGPS sensor took georeferenced positions while the MPS was gathering data during a survey mission in an area of 100 × 58 m . The datasets gathered with the MPS and the DGPS were merged with commercial software provided by Imagenex to generate the bathymetric map, depicted in Fig. 12 with a 0.2 m resolution.

    Download : Download full-size image 

Fig. 12 . Bathymetric map obtained in the Formigues Islands.

Table 4 . The five homotopy classes with the smaller lower bound in Fig. 13 scenario.
N°	Idx	Homotopy class
1	5	α 6 − 1 α 7 1 β 9 1 α 3 − 1 α 11 0 α 10 0
2	9	α 6 − 2 β 7 2 β 9 2 α 3 − 1 α 11 0 α 10 0
3	6	α 6 − 1 α 7 1 β 9 1 α 3 − 1 α 11 0 β 10 1
4	10	α 6 − 2 β 7 2 β 9 2 α 3 − 1 α 11 0 β 10 1
5	12	α 6 − 2 β 7 2 β 9 2 α 3 − 1 β 11 1 β 10 1

In the experiment, it was assumed that the vehicle would navigate at a 7.5 m depth. Therefore, using an Occupancy Grid Map (OGM) technique  [46] , the cells in the bathymetric map with a lower depth were mapped as occupied and the cells with a higher depth were mapped as free. Fig. 13 depicts the resultant C-Space as a 500 × 290 bitmap. The construction of the reference frame, the topological graph and the generation of 45 homotopy classes with their lower bound computation took 0.273 s. Although in the application only a specific homotopy class has to be selected by the operator, we have executed the proposed path planners for all homotopy classes to provide a detailed example in a real dataset. Fig. 14 depicts the normalized cost with respect to the optimal path cost computed with the A ∗ algorithm and Fig. 15 shows the computation time. In both images the homotopy classes have been sorted by their normalized lower bound. Table 4 shows the five best homotopy classes according to their lower bound. Their paths generated with the HA ∗ are depicted in Fig. 13 .

    Download : Download full-size image 

Fig. 13 . Paths of the five homotopy classes with the smaller lower bound generated using the HA ∗ . The class associated to the index can be found in Table 4 .

    Download : Download full-size image 

Fig. 14 . Normalized cost and normalized lower bound for paths of each homotopy class.

    Download : Download full-size image 

Fig. 15 . Computation time for paths of each homotopy class.

Using the HA ∗ the whole process was computed in 99.2 s, with HRRT it took 14.959 s and HBug only needed 0.275 s. When operating under real-time constraints, it is possible to stop before computing the class 11 path when using the HA ∗ . In such cases, the process would take 34.396 s. Using the HRRT the process would stop with the path computation of class 26 (index 17) taking 8.145 s and with the HBug would require computing until path of class 23 (index 26) in 0.274 s. As observed in the synthetic scenarios, the time to compute the paths with the HBug is almost negligible. Note that the computation times take into account all the steps of the process.
5.4. Discussion

The method of generating the homotopy classes was initially combined with the HRRT because RRT-based solutions have been used with success in contexts where high performance is required. The HRRT constrains the growing of a tree to those directions that satisfy a given homotopy class. With respect to the RRT, every time a new node is generated, it is checked whether the branch that connects the tree with the new node intersects any segment of the reference frame. This extra computational load prevents the HRRT from reaching the performance of the RRT, but ensures growth only in those regions that satisfy the homotopy class.

The HA ∗ computes the optimal path cost for an input homotopy class. It is a graph-based search algorithm that exhaustively explores those parts of the search space that satisfy the class. Although it is the slowest of the solutions proposed, it can be used to provide a ground truth.

The HBug is an opportunistic algorithm that takes advantage of the homotopy classes generation process. During the path computation it only considers those nodes of the C-Space that belong to the lower bound path as long as it does not traverse an obstacle. When it does, the algorithm only looks for the free space around the intersected obstacle. Since the number of explored nodes by the HBug is drastically reduced and the computation time is improved from 3 to 5 orders of magnitude when compared with the HRRT and HA ∗ algorithms respectively.

As a conclusion, the HA ∗ should be used when optimal solutions are required at the expense of low performance. On the other hand, the HBug is suitable for applications in which time to perform path planning is highly constrained. Finally, the HRRT should be avoided since the HBug generates, most of the times, lower cost solutions with a fraction of the computation time. Furthermore, our method can be an alternative to traditional path planners in applications with large scenarios that require computing good solutions in a short time. In these situations it can generate a solution that has the same topology than the optimal solution at a fraction of the time when compared to the A ∗ or anytime path planners. Note that the RRT and the Bug2 can generate the path even faster, but they do not guarantee the topology of the optimal solution.

Although the completeness of each stand-alone homotopic path planner depends on the algorithm they are based on, using them together with the homotopy class generation method provides deterministic completeness: if a homotopy class is generated implies there exists a path that avoids obstacles according to it; otherwise, the path does not exist if the homotopy class cannot be generated. In the latter case the path planner execution would not be required.
6. Conclusions and future work

In this paper we have addressed the path planning problem for robotic applications using homotopy classes. The topological information of the homotopy classes provides an important added valued to the path planning problem. Our approach first generates a set of homotopy classes for any 2d workspace provided as an input. Then, they are sorted according to a lower bound heuristic estimator. The homotopy classes are used to guide and to constrain topologically the path search. To take advantage of the homotopy classes we have adapted three well-known path planners from the graph-based search, probabilistic sample-based and bug-based approaches. The path planners have been tested in different simulated scenarios and compared against their respective non-homotopic, anytime versions and with themselves, showing a reduction of the computation time while keeping the topological constraints. The applicability of our proposal has been tested in a 100 × 58 m bathymetric map gathered with an MPS.

As future work, we will implement the HA ∗ and the HBug into the Girona 500 AUV taking into account the kinodynamic constraints of the vehicle. A path following algorithm will be in charge of guiding the vehicle autonomously according to the generated trajectories. All the system parts will be tested working together in a controlled unknown environment.
Acknowledgments

This research was sponsored by the Spanish Government under the grant DPI2011-27977-C03-02 and the TRIDENT EU FP7-Project under the Grant Agreement No. ICT-248497 .
Appendix. Applicability to unknown environments

A robot requires a navigation system to generate collision-free trajectories to carry out a mission. Generally, the navigation system is sub-divided in two groups: the global and the local navigation systems  [47] . The former consists of a low resolution map building module and a path planner module that generates a path from the start to a goal position. The latter contains a localization system that computes the position of the robot within the global map, a higher resolution map of the robot surroundings and a local navigator with reactive obstacle avoidance capabilities that follows the global path.

The homotopic path planning method is intended to be used as part of the global navigation system and the local navigation system has to generate the motion commands that follow the topologically constrained paths. Depending on the mission, the global map can be generated from scratch using data from the on-board navigation sensors or from previous existing data. A common approach is to generate a map based on topographic information, bathymetric data or by performing a two step mission as described in Section  5.3 , in which the first run is used to collect data and to generate a map with the on-board sensors of the vehicle. In this case, the localization system estimates the robot position within the global map and updates it, if necessary.

When prior environment information is provided, the current implementation of our method is robust enough to deal with small changes such as updated size or shape of obstacles already detected that do not modify the topology. In  [14] , [13] we showed that the computation of homotopy classes can be applied to an OGM generated with an imaging sonar sensor. The OGM was suitable for an AUV navigation as it took into account basic robot constraints such as size and turning radius for building the map.

In dynamic or unknown environments only those persistent obstacles detected over successive sensor readings that are bigger than a certain area should be considered for the global map, since adding multiple small obstacles can increase the complexity of the topological space and hence, the number of homotopy classes. When obstacles are added/removed, the reference frame and the topological graph change and may invalidate the homotopy classes previously generated. Our current implementation recomputes the homotopy classes from scratch. Although this process is done efficiently adding a minimum overhead to the whole process, a further study on how homotopy classes can be adapted to dynamic environments and how they evolve when new obstacles are added is needed.
References

[1]
    H. Choset, K.M. Lynch, S. Hutchinson, G.A. Kantor, W. Burgard, L.E. Kavraki, S. Thrun
    Principles of Robot Motion: Theory, Algorithms, and Implementations
    MIT Press, Cambridge, MA (2005)
    Google Scholar
[2]
    J. Barraquand, B. Langlois, J.-C. Latombe
    Numerical potential field techniques for robot path planning
    IEEE Trans. Syst. Man Cybern., 22 (2) (1992), pp. 224-241
    View Record in Scopus Google Scholar
[3]
    D. Ferguson, M. Likhachev, A. Stentz, A guide to heuristic-based path planning, in: Proc. of the Inter. Workshop on Planning under Uncertainty for Autonomous Systems, Int. Conf. on Automated Planning and Scheduling, ICAPS, June, 2005.
    Google Scholar
[4]
    P. Hart, N. Nilsson, B. Raphael
    A formal basis for the heuristic determination of minimum cost paths
    IEEE Trans. Syst. Sci. Cybern., 4 (2) (1968), pp. 100-107
    Google Scholar
[5]
    S.M. LaValle
    Planning Algorithms
    Cambridge University Press, Cambridge, UK (2006)
    Available at: http://planning.cs.uiuc.edu/
    Google Scholar
[6]
    J. Ng, T. Braunl
    Performance comparison of bug navigation algorithms
    J. Intell. Robot. Syst., 50 (2007), pp. 73-84, 10.1007/s10846-007-9157-6
    View Record in Scopus Google Scholar
[7]
    J. Munkres
    Topology; A First Course
    Prentice-Hall (1974)
    Google Scholar
[8]
    H. Seifert, W. Threlfall, J. Birman, J. Eisner
    Seifert and Threlfall, A Textbook of Topology, Pure and Applied Mathematics, Academic Press (1980)
    Google Scholar
[9]
    E. Hernández, M. Carreras, J. Antich, P. Ridao, A. Ortiz, A topologically guided path planner for an AUV using homotopy classes, in: Proc. of the IEEE Int. Conference on Robotics and Automation, ICRA. Shanghai, China, May, 2011, pp. 2337–2343.
    Google Scholar
[10]
    E. Hernández, M. Carreras, P. Ridao, A path planning algorithm for an AUV guided with homotopy classes, in: Proc. of the 21st Int. Conf. on Automated Planning and Scheduling, ICAPS. Freiburg, Germany, June, 2011.
    Google Scholar
[11]
    E. Hernández, M. Carreras, J. Antich, P. Ridao, A. Ortiz, A search-based path planning algorithm with topological constraints. Application to an AUV, in: Proc. of the 18th IFAC World Congress. Milan, Italy, August, 2011.
    Google Scholar
[12]
    E. Hernández, M. Carreras, P. Ridao, A bug-based path planner guided with homotopy classes, in: Proc. of the 9th Int. Conf. on Informatics and Control, Automation and Robotics, ICINCO. Rome, Italy, July, 2012.
    Google Scholar
[13]
    E. Hernández, M. Carreras, P. Ridao, A. Mallios, Homotopic path planning for an AUV on maps improved with scan matching, in: Proc. of IFAC Workshop on Navigation, Guidance and Control of Underwater Vehicles, NGCUV, Porto, Portugal, April, 2012.
    Google Scholar
[14]
    E. Hernández, M. Carreras, E. Galceran, P. Ridao, Path planning with homotopy class constraints on bathymetric maps, in: OCEANS, 2011 IEEE, Spain, June, 2011, pp. 1–6.
    Google Scholar
[15]
    B. Chazelle, A theorem on polygon cutting with applications, in: 23rd Annual Symposium on Foundations of Computer Science, SFCS, November, 1982, pp. 339–349.
    Google Scholar
[16]
    J. Hershberger, J. Snoeyink
    Computing minimum length paths of a given homotopy class
    Comput. Geom., Theory Appl., 4 (1991), pp. 331-342
    Google Scholar
[17]
    S.-W. Cheng, J. Jin, A. Vigneron, Y. Wang
    Approximate shortest homotopic paths in weighted regions
    O. Cheong, K.-Y. Chwa, K. Park (Eds.), Algorithms and Computation, Lecture Notes in Computer Science, vol. 6507, Springer, Berlin, Heidelberg (2010), pp. 109-120
    CrossRef View Record in Scopus Google Scholar
[18]
    A. Efrat, S. Kobourov, A. Lubiw
    Computing homotopic shortest paths efficiently
    R. Möhring, R. Raman (Eds.), Algorithms—ESA 2002, Lecture Notes in Computer Science, vol. 2461, Springer, Berlin, Heidelberg (2002), pp. 277-288
    View Record in Scopus Google Scholar
[19]
    S. Bespamyatnikh
    Computing homotopic shortest paths in the plane
    J. Algorithms, 49 (2003), pp. 284-303
    Article Download PDF Google Scholar
[20]
    B. Speckmann, K. Verbeek
    Homotopic rectilinear routing with few links and thick edges
    A. López-Ortiz (Ed.), LATIN 2010: Theoretical Informatics, Lecture Notes in Computer Science, vol. 6034, Springer, Berlin, Heidelberg (2010), pp. 468-479
    CrossRef View Record in Scopus Google Scholar
[21]
    D. Grigoriev, A. Slissenko
    Polytime algorithm for the shortest path in a homotopy class amidst semi-algebraic obstacles in the plane
    Proc. of the Int. Symposium on Symbolic and Algebraic Computation (ISSAC), ACM, New York, NY, USA (1998), pp. 17-24
    View Record in Scopus Google Scholar
[22]
    Y. Fujita, Y. Nakamura, Z. Shiller, Dual Dijkstra search for paths with different topologies, in: IEEE Int. Conf. on Robotics and Automation, ICRA, vol. 3, September, 2003, pp. 3359–3364.
    Google Scholar
[23]
    Z. Shiller, Y. Fujita, D. Ophir, Y. Nakamura, Computing a set of local optimal paths through cluttered environments and over open terrain, in: IEEE Int. Conf. on Robotics and Automation, ICRA, vol. 5, April-1 May, 2004, pp. 4759–4764.
    Google Scholar
[24]
    B. Banerjee, B. Chandrasekaran, A framework for planning multiple paths in free space, in: Proc. of 25th Army Science Conference. Orlando, FL, 2006.
    Google Scholar
[25]
    S. Bhattacharya, V. Kumar, M. Likhachev, Search-based path planning with homotopy class constraints, in: Proc. of the National Conference on Artificial Intelligence, AAAI, vol. 2. Atlanta, Georgia, USA, July, 2010, pp. 1230–1237.
    Google Scholar
[26]
    S. Bhattacharya, M. Likhachev, V. Kumar
    Topological constraints in search-based robot path planning
    Auton. Robots, 33 (3) (2012), pp. 273-290
    CrossRef View Record in Scopus Google Scholar
[27]
    S. Kim, S. Bhattacharya, V. Kumar, Path planning for a tethered mobile robot, in: IEEE Int. Conf. on Robotics and Automation, ICRA, vol. 22, 2014.
    Google Scholar
[28]
    K.D. Jenkins
    The shortest path problem in the plane with obstacles: A graph modeling approach to producing finite search lists of homotopy classes
    (Master’s thesis)
    Naval Postgraduate School, Monterey, California (1991)
    June
    Google Scholar
[29]
    A. Cuerington
    The shortest path problem in the plane with obstacles: Bounds on path lenghts and shortest paths within homotopy classes
    (Master’s thesis)
    Naval Postgraduate School, Monterey, California (1991)
    June
    Google Scholar
[30]
    R. Milgram, S. Kaufman, Topological characterization of safe coordinated vehicle motions, in: IEEE Int. Conf. on Robotics and Automation, ICRA, vol. 3, 2000, pp. 2039–2045.
    Google Scholar
[31]
    E. Schmitzberger, J. Bouchet, M. Dufaut, D. Wolf, R. Husson, Capture of homotopy classes with probabilistic road map, in: IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, IROS, vol. 3, 2002, pp. 2317–2322.
    Google Scholar
[32]
    L. Kavraki, P. Svestka, J.-C. Latombe, M. Overmars
    Probabilistic roadmaps for path planning in high-dimensional configuration spaces
    IEEE Trans. Robot. Autom. (ICRA), 12 (4) (1996), pp. 566-580
    View Record in Scopus Google Scholar
[33]
    S. Cabello, Y. Liu, A. Manler, J. Snoeyink, Testing homotopy for paths in the plane, in: Proc. of the Symposium on Computational Geometry, SoCG. Barcelona, Spain, June, 2002, pp. 160–169.
    Google Scholar
[34]
    J. Pearl
    Heuristics: Intelligent Search Strategies for Computer Problem Solving
    Addison-Wesley Longman Publishing Co., Inc., Boston, MA, USA (1984)
    Google Scholar
[35]
    R. Dechter, J. Pearl
    Generalized best-first search strategies and the optimality of A ∗
    J. ACM, 32 (3) (1985), pp. 505-536
    View Record in Scopus Google Scholar
[36]
    S.M. LaValle, J.J. Kuffner, Randomized kinodynamic planning, in: Proc. of the IEEE Int. Conf. on Robotics and Automation, ICRA, vol. 1, September, 1999, pp. 473–479.
    Google Scholar
[37]
    J. Kim, J. Ostrowski, Motion planning a aerial robot using rapidly-exploring random trees with dynamic constraints, in: IEEE Int. Conf. on Robotics and Automation, ICRA, vol. 2, September, 2003, pp. 2200–2205.
    Google Scholar
[38]
    S.M. LaValle, J.J. Kuffner
    Randomized kinodynamic planning
    Int. J. Robot. Res., 20 (5) (2001), pp. 378-400
    View Record in Scopus Google Scholar
[39]
    J. Antich, A. Ortiz, J. Minguez, A bug-inspired algorithm for efficient anytime path planning, in: IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, IROS, October, 2009, pp. 5407–5413.
    Google Scholar
[40]
    V. Lumelsky, A. Stepanov
    Path-planning strategies for a point mobile automaton moving amidst unknown obstacles of arbitrary shape
    Algorithmica, 2 (1987), pp. 403-430
    View Record in Scopus Google Scholar
[41]
    F.S. Hill Jr.
    The Pleasures of “Perp Dot” Products
    Academic Press Professional, Inc., San Diego, CA, USA (1994), pp. 138-148
    Article Download PDF View Record in Scopus Google Scholar
[42]
    F. Chang, C. -J. Chen, C.-J. Lu
    A linear-time component-labeling algorithm using contour tracing technique
    Comput. Vis. Image Underst., 93 (2004), pp. 206-220
    Article Download PDF View Record in Scopus Google Scholar
[43]
    M. Likhachev, G. Gordon, S. Thrun
    ARA ∗ : Anytime A ∗ with provable bounds on sub-optimality
    Proc. of the Advances in Neural Inforamtion Processing Systems. NIPS, vol. 16, MIT Press (2004)
    Google Scholar
[44]
    D. Ferguson, A. Stentz, Anytime RRTs, in: Proc. of the IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, IROS, October, 2006, pp. 5369–5375.
    Google Scholar
[45]
    D. Ribas, N. Palomeras, P. Ridao, M. Carreras, A. Mallios
    Girona 500 AUV, from survey to intervention
    IEEE/ASME Trans. Mechatronics, 17 (1) (2012), pp. 46-53
    View Record in Scopus Google Scholar
[46]
    E. Hernández, P. Ridao, A. Mallios, M. Carreras, Occupancy grid mapping in an underwater structured environment, in: Proc. of the 8th IFAC Int. Conference on Manoeuvring and Control of Marine Craft, MCMC, Guaruja, Sao Paulo, Brazil, September, 2009.
    Google Scholar
[47]
    J. Mínguez, L. Montesano, L. Montano, An architecture for sensor-based navigation in realistic dynamic and troublesome scenarios, in: IEEE/RSJ Int. Conf. on Intelligent Robots and Systems, IROS, vol. 3, September, 2004, pp. 2750–2756.
    Google Scholar

Cited by (22)

    Path planning for autonomous underwater vehicles based on interval optimization in uncertain flow fields
    2021, Ocean Engineering
    Show abstract
    Multi-homotopy class optimal path planning for manipulation with one degree of redundancy
    2020, Mechanism and Machine Theory
    Show abstract
    Topology-guided path integral approach for stochastic optimal control in cluttered environment
    2019, Robotics and Autonomous Systems
    Show abstract
    Closed-loop randomized kinodynamic path planning for an autonomous underwater vehicle
    2019, Applied Ocean Research
    Citation Excerpt :

    Path planning is a complex task in overcoming the kinematic constraints such as time varying environment, high-dimensional spaces, cluttered obstacles and dynamic constraints such as limited amount of force, torque, velocity and acceleration, coupling between the degrees of freedom and limited number of actuators, shallow water effect, external disturbance, the vehicle inherent nonlinear dynamic, structured and unstructured model uncertainty, time varying coefficients, etc. There exist many path planning algorithms and more new ones are being proposed with respect to AUVs: imperialist competitive algorithm [8], wolf pack algorithm [9], differential evolution [10], smooth-RRT [11], RRT* [12], five evolutionary methods namely particle swarm optimization, shuffled frog leaping algorithm, ant colony optimization, memetic algorithms, genetic algorithms [13], voronoi-diagram-based [14], legendre pseudo spectral method [15], homotopic A*, homotopic RRT, homotopic Bug [16], electromagnetic homing guidance system [17], hybrid-genetic algorithm [18], anti-helical motion [19], fuzzy algorithm [20] and receding horizon optimization [21]. Among the most algorithms mentioned above, the kinematic constraints are commonly applied in AUV path planning and the least ones are concerned with the dynamic constraints.
    Show abstract
    Bounded curvature path planning with expected length for Dubins vehicle entering target manifold
    2017, Robotics and Autonomous Systems
    Citation Excerpt :

    Park et al. [27] proposed the divide-and-conquer strategy, which can solve path planning with homotopic constraints via mixed-integer programming. Derived from widely-studied path planning approaches, three path planners including homotopic A*, homotopic RRT, and homotopic bug algorithm are addressed and compared in [28]. As there exist gaps between the initial path and the expected path under some conditions, the homotopy-based method is suitable to handle the gaps which are similar to obstacles.
    Show abstract
    Tangle-free exploration with a tethered mobile robot
    2020, Remote Sensing

View all citing articles on Scopus

Emili Hernandez received his M.Sc. and Ph.D. degrees in computer engineering from the University of Girona, Girona, Spain in 2005 and 2012 respectively. His research interests include planning and path planning focused on autonomous underwater robots, localization and map building for online navigation purposes. He has been involved in National and European research projects related with underwater robotics. He is currently a postdoctoral researcher at the Autonomous Systems Lab. (ASL) at the Commonwealth Scientific and Industrial Research Organization (CSIRO), Australia.

Marc Carreras received the M.Sc. in Industrial Engineering (1998) and the Ph.D. in Computer Engineering (2003) from the University of Girona, Spain. His research activity is mainly focused on robot learning and intelligent control architectures of autonomous underwater vehicles. He joined the Institute of Informatics and Applications, University of Girona in September 1998. Currently, he is an associate professor with the Department of Computer Engineering of the University of Girona and member of the Research Center in Underwater Robotics (CIRS) of Girona. He is involved in National and European research projects and networks about underwater robotics.

Pere Ridao received the M.Sc. in Computer Science in 1993 from the Technical University of Catalonia, Spain, and the Ph.D. in Computer Engineering in 2001 from the University of Girona, Spain. His research activity is focused on control architectures, navigation and mission control systems for underwater robots. He is an associate professor with the Computer Engineering Department of the University of Girona and the head of the Research Center in Underwater Robotics (CIRS). He is a member of the IFAC’s Technical Committee on Marine Systems and the Spanish RAS chapter, and secretary of the Spanish OES chapter.

1

    When the lower bound path intersects with an obstacle only once, the n h + 1 node is also the n l node.

2

    Note that the start point cannot be in line l k in the reference frame since the perpendicular dot product would also be 0.

View Abstract
Copyright © 2014 Elsevier B.V. All rights reserved.
Recommended articles

    Adaptive “load-distributed” muscle coordination method for kinematically redundant musculoskeletal humanoid systems
    Robotics and Autonomous Systems, Volume 64, 2015, pp. 59-69
    Download PDF View details
    Extensions of the heuristic topological qualitative semantic: Enclosure and fuzzy relations
    Robotics and Autonomous Systems, Volume 63, Part 2, 2015, pp. 214-218
    Download PDF View details
    Magnetic field constraints and sequence-based matching for indoor pose graph SLAM
    Robotics and Autonomous Systems, Volume 70, 2015, pp. 92-105
    Download PDF View details

1 2 Next
Article Metrics
Citations

    Citation Indexes: 22 

Captures

    Exports-Saves: 3
    Readers: 46 

plumX logo
View details
Elsevier logo with wordmark

    About ScienceDirect
    Remote access
    Shopping cart
    Advertise
    Contact and support
    Terms and conditions
    Privacy policy 

We use cookies to help provide and enhance our service and tailor content and ads. By continuing you agree to the use of cookies .

Copyright © 2022 Elsevier B.V. or its licensors or contributors. ScienceDirect® is a registered trademark of Elsevier B.V.

ScienceDirect® is a registered trademark of Elsevier B.V.
RELX group home page
