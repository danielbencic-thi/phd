IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Loading [MathJax]/jax/element/mml/optable/BasicLatin.js

Skip to Main Content
Scheduled Maintenance: On Tuesday, April 19, IEEE Xplore will undergo scheduled maintenance from 1:00-5:00pm ET. During this time, there may be intermittent impact on performance. We apologize for any inconvenience.

    IEEE.org
    IEEE Xplore
    IEEE-SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Conferences > 2019 International Conference...
Real-Time Minimum Snap Trajectory Generation for Quadcopters: Algorithm Speed-up Through Machine Learning
Publisher: IEEE
Cite This
PDF
  << Results   
Marcelino M. de Almeida ; Rahul Moghe ; Maruthi Akella
All Authors
View Document
5
Paper
Citations
541
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Equations of Motion and Differential Flatness
    III.
    The Minimum Snap Algorithm
    IV.
    Neural Network Methodology
    V.
    Results and Analysis

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
Media
More Like This
Footnotes

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: This paper addresses the problem of generating quadcopter minimum snap trajectories for real time applications. Previous efforts addressed this problem by either employin... View more
Metadata
Abstract:
This paper addresses the problem of generating quadcopter minimum snap trajectories for real time applications. Previous efforts addressed this problem by either employing a gradient descent method, or by greatly sacrificing optimality for faster solutions that are amenable for onboard implementation. In this work, outputs of the gradient descent method are used offline to train a supervised neural network. We show that the use of neural networks results typically in two orders of magnitude reduction in computational time. Our proposed approach can be used for warm-starting onboard implementable iterative methods with an “educated ” initial guess. This work is motivated by the application for human-machine interface in which a human provides desired trajectory through a smart-tablet interface, which has to be translated into a dynamically feasible trajectory for a quadcopter. The proposed solution is tested in thousands of different examples, demonstrating its effectiveness as a booster for minimum snap trajectory generation for quadcopters.
Published in: 2019 International Conference on Robotics and Automation (ICRA)
Date of Conference: 20-24 May 2019
Date Added to IEEE Xplore : 12 August 2019
ISBN Information:
ISSN Information:
INSPEC Accession Number: 18903438
DOI: 10.1109/ICRA.2019.8793569
Publisher: IEEE
Conference Location: Montreal, QC, Canada
Contents
SECTION I.
Introduction

Real time path planning for quadcopters have been subject of extensive research in the last decade. This is typically an arduous task due to the fact that quadcopters are nonlinear underactuated systems. Some prior literature that explores trajectory generation for quadcopters include the use of learning from demonstration [1] , sequential composition with parameter adaptation [2] , reinforcement learning and iterative adaptation [3] , reachable sets [4] , among others. However, the solution that has been most extensively used in literature for trajectory generation stems from the work of [5] , which uses a set of truncated basis functions to plan a trajectory that satisfies waypoint specifications by solving a quadratic programming problem to minimize translational snap (fourth derivative of position).

The solution of [5] stands out among other solutions in the literature due to its flexibility, optimality, and simplicity. The work in [5] showed that quadcopters are differentially flat systems [6] for outputs \mathbf { y } = \left[ \mathbf { r } ^ { T } , \psi \right] ^ { T } , where r is the vehicle’s position, and \psi is the vehicle’s heading. It has been proven that the states and inputs of a quadcopter can all be uniquely determined from given values of \mathbf { r } , \mathbf { \mathbf { r } } , \mathbf { r } , \mathbf { r } ^ { ( 3 ) } , \mathbf { r } ^ { ( 4 ) }\psi , \dot { \psi } and \ddot{\psi} . Then, one can plan trajectories in the output space and then map them back into the original space [6] . The work of [5] proposed a path planner that minimizes r^{(4)} (translational snap) and \ddot{\psi} (heading acceleration). This method is commonly known as the minimum snap planner for quadcopters.

The minimum snap problem statement [5] can be summarized as follows: given initial and final states for a quadcopter, and given a set of ordered intermediate waypoints for it to traverse, find the solution that goes through all the waypoints minimizing the integral of the two-norm of snap, arriving at its final state at a prescribed time T .

A key component for solving the minimum-snap algorithm is to determine the optimal time t i to go through every intermediate waypoint P i (time allocation problem). Solving for the time allocation makes the problem non-convex, requiring the use of nonlinear programming methods.

When solutions are not needed in real time 1 , or if the number of waypoints is low (say, less than 5), the time allocation problem can be quickly solved through gradient descent methods until convergence to a local minimum [5] [7] [8] [9] . These methods typically start from a naive initial guess, such as based on a trapezoidal velocity profile [9] .
Fig. 1. - (a) Minimum snap solution time for Backtracking Gradient Descent and for NLOPT. (b) Minimum snap solution time when time allocation is fixed. Solutions obtained using an Intel Core i5-4690K-3.5GHz.
Fig. 1.

(a) Minimum snap solution time for Backtracking Gradient Descent and for NLOPT. (b) Minimum snap solution time when time allocation is fixed. Solutions obtained using an Intel Core i5-4690K-3.5GHz.

Show All

Figure 1 (a) shows the computational time that it takes to solve minimum snap with time allocation using either the Backtracking Gradient Descent method from [5] or the NLopt solver [10] . Clearly, the solution time scales poorly with the number of waypoints, preventing either method from being a real-time generalized solution for large number of waypoints. This contrasts with the solution time for minimum snap using fixed time allocation (see Figure 1 (b) 2 ), which shows that the solution without optimal time allocation is typically obtained two orders of magnitude faster than the gradient descent method. Hence, if the optimal time allocations are known a priori ( Figure 1 (b) ) then the optimization problem is solved 100 times faster than when there is need to solve for those ( Figure 1 (a) ).

When minimum snap is required to be calculated in real time, common approaches tend to loosen the problem constraints or sacrifice optimality to promote faster solutions. In [11] , the authors use a kinodynamic planner to find P i together with t i , and uses this time allocation without performing further optimizations. The work in [12] starts from a trapezoid velocity profile and increases time allocations until the computed solutions satisfies bounds on maximum velocity, acceleration and jerk. The solution in [13] does not optimize the time segments, but allows the intermediate waypoints P i to change within a bounded safe region, allowing for an implicit time optimization (although limited by the safe region).

In this paper, we show that feedforward Neural Networks (NN) can be trained to learn and determine the optimal time segments. Apart from [11] (which precludes the use of planners other than the kinodynamic one), none of the aforementioned methods provide a definitive approach to determine good initial guesses for the time allocation. Hence, a well-trained NN-based solution has the potential to significantly complement currently available techniques by quickly providing a mathematically interpolated initial guess for the time allocations. In this paper, we show how to exploit certain invariance properties of the minimum snap problem to train Neural Networks that can work for any set of input waypoints. Although our work focuses on minimum snap problems, the methodology herein can be easily adapted to the minimization of different derivatives of position (velocity, acceleration, jerk, etc).
A. Motivation

Although most of the prior literature that uses minimum snap focuses on increasing autonomy of a quadcopter, this work is strongly motivated by the need for allowing real-time human interface for quadcopter flight missions. If a human operator commands a quadcopter by sketching a 2D trajectory on a tablet, this trajectory needs to be transformed into a dynamically feasible trajectory, which can be accomplished using minimum snap interpolation. However, the number of points in a hand-drawn trajectory (spatial discretization) is usually considerable, and the solution time for such a problem can usually take minutes, which is unacceptable for most real-time applications (see Figure 1 (a) ). Also, waypoints too close to each other (spatially) over-constrain the problem, making it hard to generate dynamically feasible trajectories.

In light of the aforementioned major technical challenges, we compress the hand-drawn trajectory until it is reduced to a set of waypoints that robustly maintains the structure of the original trajectory. To accomplish such a reasonable compression, we adopt the algorithm of [14] , which was originally developed for extracting keyframes from motion capture system data.
B. Structure of the paper

The paper is organized as follows: Section II presents the dynamical model for a quadcopter, highlighting its properties of differential flatness. Section III presents the minimum snap problem formulation, its solution, and some properties therein. Section IV presents our technical approach to render the problem within the framework of neural networks. Section V presents results and performance analysis of our method. Section VI provides some final considerations, and Section VII presents conclusions to this work.
SECTION II.
Equations of Motion and Differential Flatness

Fig. 2. - Quadcopter and its frames.
Fig. 2.

Quadcopter and its frames.

Show All

This work considers a dynamic model based on the coordinate frames from Fig. 2 , involving a fixed world frame W and a moving body frame B , with z W parallel to the gravity vector g . The transformation from body frame B to world frame W is parametrized by the translation r , and the rotation matrix R_{B}^{W} .

The input vector for this system is composed by the quadcopter’s total thrust T and body moments \tau =[ \tau_{1} \tau_{2} \tau_{3}]^{T} Thus, the control input for the system is defined as u = \left[ { T } { \tau ^ { T } } \right] ^ { T } The combination of these quantities can be linearly mapped into thrust applied by each propeller f i , i \in \{1,2, 3, 4\} .

Assuming that the vehicle’s center of mass is located at the origin of B , the translational motion can be described as: \begin{equation*}m \mathbf { r } = T \mathbf { z } _ { B } - m g \mathbf { z } W \tag{1}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}m \mathbf { r } = T \mathbf { z } _ { B } - m g \mathbf { z } W \tag{1}\end{equation*}

where g is the norm of the gravity vector g , and m is the vehicles’s mass.

Defining the angular velocity of the quadcopter’s body with respect to the world frame as \omega_{BW}=px_{B}+qy_{B}+rz_{B} , the rotational dynamics is described as follows: \begin{equation*}\dot{R}_{B}^{W}=R_{B}^{W}[\omega_{BW\times}], \tag{2}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}\dot{R}_{B}^{W}=R_{B}^{W}[\omega_{BW\times}], \tag{2}\end{equation*} \begin{equation*}\dot{\omega}_{BW}=J^{-1}(-\omega_{BW}\times J\omega_{BW}+\tau), \tag{3}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}\dot{\omega}_{BW}=J^{-1}(-\omega_{BW}\times J\omega_{BW}+\tau), \tag{3}\end{equation*}

where J is the inertia tensor matrix referenced to the vehicle’s center of mass along the axes of the body frame B .

As shown in [5] and [15] , quadcopters are differentially flat systems [6] for outputs y= [r^{T}\ \psi]^{T} , where \psi is the vehicles yaw angle, or heading. The work in [5] shows that the states r, \dot{r} , R_{B}^{W}, \omega_{BW} , and inputs u can all be uniquely determined from given values of r, \dot{r} , r \ddot{}, r^{(3)} , r^{(4)} , \psi, \dot{\psi} and \ddot{\psi} . Then, one can plan trajectories in the output space and then map them back into the original space [6] with the state variables of Eqs. 1 to 3. The plan is made upon the following linear model [15] : \begin{equation*}\begin{bmatrix} { \mathbf { r } ^ { ( 4 ) } } \\ { \ddot { \psi } } \end{bmatrix} = \begin{bmatrix} { \mathbf { w } _ { r } } \\ { w _ { \psi } } \end{bmatrix}, \tag{4}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}\begin{bmatrix} { \mathbf { r } ^ { ( 4 ) } } \\ { \ddot { \psi } } \end{bmatrix} = \begin{bmatrix} { \mathbf { w } _ { r } } \\ { w _ { \psi } } \end{bmatrix}, \tag{4}\end{equation*}

where \boldsymbol { w } \triangleq \left[ \boldsymbol { w } _ { \boldsymbol { r } } ^ { T } \quad w _ { \psi } \right] ^ { T } \in \mathbb { R } ^ { 4 } is the input vector in the flat space. The remainder of this paper assumes constant yaw angle (\dot{\psi}=\ddot{\psi}=w_{\psi}=0) , without loss of generality. Thus, it plans using only the snap input w r . This paper pursues generating minimum snap trajectories, which seeks to minimize the cost function: \begin{equation*}J = \int _ { 0 } ^ { T } \left\| \mathbf { r } ^ { ( 4 ) } ( t ) \right\| ^ { 2 } d t = \int _ { 0 } ^ { T } \left\| \mathbf { w } _ { r } ( t ) \right\| ^ { 2 } d t. \tag{5}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}J = \int _ { 0 } ^ { T } \left\| \mathbf { r } ^ { ( 4 ) } ( t ) \right\| ^ { 2 } d t = \int _ { 0 } ^ { T } \left\| \mathbf { w } _ { r } ( t ) \right\| ^ { 2 } d t. \tag{5}\end{equation*}

SECTION III.
The Minimum Snap Algorithm

This section briefly reviews the solution of [5] for generating minimum snap trajectories. This algorithm solves the problem of starting at an initial point P 0 at time t 0 =0 and passing through m waypoints P k , k \in\{1, 2, \cdots, m\} , reaching the final state P m at time t m = T .

The minimum snap algorithm solves separately for each cartesian degree of freedom x, y and z . The trajectory for each of these states, denoted as \sigma _ { i } ( t ) , i \in \{ x , y , z \} , is written as piecewise polynomials of order n over m time intervals: \begin{equation*}\sigma _ { i } ( t ) = \begin{cases}{ \sum _ { j = 0 } ^ { n } a _ { j , 1 } t ^ { j } , } & { t _ { 0 } \leq t \lt t _ { 1 } } \\ { \sum _ { j = 0 } ^ { n } a _ { j , 2 } t ^ { j } , } & { t _ { 1 } \leq t \lt t _ { 2 } } \\ { \vdots } \\ { \sum _ { j = 0 } ^ { n } a _ { j , m } t ^ { j } , } & { t _ { m - 1 } \leq t \leq t _ { m } } \end{cases}, \tag{6}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}\sigma _ { i } ( t ) = \begin{cases}{ \sum _ { j = 0 } ^ { n } a _ { j , 1 } t ^ { j } , } & { t _ { 0 } \leq t \lt t _ { 1 } } \\ { \sum _ { j = 0 } ^ { n } a _ { j , 2 } t ^ { j } , } & { t _ { 1 } \leq t \lt t _ { 2 } } \\ { \vdots } \\ { \sum _ { j = 0 } ^ { n } a _ { j , m } t ^ { j } , } & { t _ { m - 1 } \leq t \leq t _ { m } } \end{cases}, \tag{6}\end{equation*}

This problem can be written in the following quadratic programming form [5] : \begin{equation*}\begin{cases} { \min _ { a , \delta t } } & { \mathbb { J } ( \mathbf { \delta } \mathbf { t } ) = \mathbf { a } ^ { T } \mathbf { Q } a } \\ { \text {s.t.} } & { \mathbf { A } _ { e q } \mathbf { a } = \mathbf { b } _ { e q } } \\ { } & { \mathbf { A } _ { \text {ineq} } \mathbf { a } \leq \mathbf { b } _ { \text {ineq} } } \end{cases} \tag{7}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}\begin{cases} { \min _ { a , \delta t } } & { \mathbb { J } ( \mathbf { \delta } \mathbf { t } ) = \mathbf { a } ^ { T } \mathbf { Q } a } \\ { \text {s.t.} } & { \mathbf { A } _ { e q } \mathbf { a } = \mathbf { b } _ { e q } } \\ { } & { \mathbf { A } _ { \text {ineq} } \mathbf { a } \leq \mathbf { b } _ { \text {ineq} } } \end{cases} \tag{7}\end{equation*}

where \mathbf { a } \triangleq \left[ { \mathbf { a } _ { 1 } ^ { T } } { \cdots } { \mathbf { a } _ { m } ^ { T } } \right] ^ { T } is the vector of solution variables, and a _ { i } \triangleq \left[ a _ { 0 , k } \quad \cdots \quad a _ { n , k } \right] ^ { T } is the vector of polynomial coefficients for the interval t _ { k - 1 } \leq t \lt t _ { k } . The matrices Q, A_{eq} and A ineq are function of the time allocation \mathbf { \delta } t \triangleq \left[ { \delta t _ { 1 } } { \cdots } { \delta t _ { m } } \right] ^ { T } , where \delta t _ { k } \triangleq t _ { k } - t _ { k - 1 } . Equality constraints in (7) are used to constrain position, velocity, orientation, or angular velocity through waypoints, as well as enforcing continuity of \sigma_{i}(t) and its derivatives. Inequality constraints are added to enforce safety constraints, such as collision avoidance, maximum velocity, or maximum acceleration.

For a fixed time allocation \delta t , the problem in Eqs. 7 reduces to a linear quadratic programming problem, which can be solved in polynomial time. On the other hand, if dt is free, the optimal time allocation problem can be stated as: \begin{equation*}\begin{cases}{ \min _ { \mathbf { \delta } t } } & { \mathbb { J } ( \mathbf { \delta } t ) } \\ { \text {s.t.} } & { \sum \delta t _ { k } = t _ { m } } \\ { } & { \delta t _ { k } \geq 0 } \end{cases} \tag{8}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}\begin{cases}{ \min _ { \mathbf { \delta } t } } & { \mathbb { J } ( \mathbf { \delta } t ) } \\ { \text {s.t.} } & { \sum \delta t _ { k } = t _ { m } } \\ { } & { \delta t _ { k } \geq 0 } \end{cases} \tag{8}\end{equation*}

Assuming that (i) the problem has only position equality constraints in the waypoints, (ii) it has no inequality constraints, and (iii) that the vehicle starts from rest and finishes at rest. Property 1 - If we solve (8) with t_{m}=T and find a trajectory \sigma_{i}(t) with derivatives \dot{\sigma}_{i}(t) , \ddot{\sigma}_{i}(t) , \sigma_{i}^{(N)}(t) , then the optimal trajectory for t_{m}=T/\alpha , for \alpha\gt0 , is \sigma_{i}(\alpha\cdot t) with derivatives \alpha \dot { \sigma } _ { i } ( \alpha \cdot t ) , \alpha ^ { 2 } \ddot { \sigma } _ { i } ( \alpha \cdot t ) , \ldots , \alpha ^ { N } \sigma _ { i } ^ { ( N ) } ( \alpha \cdot t ) , for 0\leq t\leq T/\alpha (see [5] ).

Property 2 - If we solve (8) with t_{m}=T and find a solution \delta t=\delta t^{\ast} and optimal cost \mathbb { J } = \mathbb { J } ^ { * } , then the solution for the same problem with t_{m}=\alpha T is \delta t=\alpha\cdot\delta t^{\ast} and has optimal cost \mathbb { J } = \alpha ^ { - 7 } \mathbb { J } ^ { * } In other words, the optimal time allocation scales linearly with the final time t m , but the optimal cost scales with the inverse of the 7-th power of the final time.

Property 3 - If we solve (8) for waypoints P_{k}, k \in \{ 0,1 , \cdots , m \} and find a solution \delta t=\delta t^{\ast} , then the solution for the problem with waypoints sHP_{k}, k\in \{ 0,1 , \cdots , m \} , where s\gt0 is a scaling factor and H is a homogeneous transformation, will also have optimal time allocation \delta t=\delta t^{\ast} In other words, the optimal time allocation is invariant to scaling and homogeneous transformations on the waypoints.
SECTION IV.
Neural Network Methodology

This section presents our methodology to render the minimum snap time allocation problem within the framework of a supervised feedforward Neural Network. The goal is to train a NN offline that takes as inputs a set of waypoints, and produces a set of time allocations as outputs. Since the main objective of this work is to transform user-provided trajectories into quadcopter feasible trajectories, the approach herein presented is developed to work with 2D waypoints. At the same time, we note that our approach can be readily extended to 3D cases as well, which would be more applicable to Minimum Snap fitting combined with sampling-based methods [8] [9] [12] , instead of the human-machine interface explored in this work. In 3D, the training set can be obtained from the solution of multiple path planning problems using, for instance, sampling-based methods [16] [17] [18] [19] .

This section is divided as follows: Subsection IV-A discusses about the datasets that were used to train the NN. Subsection IV-B presents the algorithm that is used to decimate hand-drawn trajectories into a set of keyframes. Subsection IV-C introduces a methodology for pre-processing the data such that the solution exploits the minimum snap properties of Section III . Subsection IV-D presents the Neural Network architecture that is used to learn optimal time allocations, and Subsection IV-E summarizes the algorithm pipeline.
A. Data Collection

Properly training a NN often requires a hefty amount of data. The quantity of data needed is typically a function of the problem itself, but our experience shows that it is enough to use some ten-thousands of data points. In addition, a crucial practice when training a NN is to have different datasets to train, to validate, and to test. The present work uses the SIGN dataset [20] for training and validation, while the Intuidoc-Loustic Gestures DataBase (ILGDB) [21] is used for testing.

Both datasets comprise of single-stroke pen gestures. The SIGN dataset has 33154 tablet hand-drawn gestures, while ILGDB has 6627. The reason to use different datasets is to demonstrate that one can train a NN with data obtained from a particular dataset and have it still working with independently collected data. In fact, the SIGN dataset comprises of mostly simple and smooth gestures, while the ILGDB has a wider variety of trajectories (see [20] and [21] for description of their gestures).
B. Curve Decimation

As mentioned in Section I-A , hand drawn trajectories are decimated into a set of keyframes. This speeds up the minimum snap calculation (by reducing the number of waypoints), and also avoids over-constraining the trajectory. The approach employed by this work uses a decimation procedure [14] that ranks importance of all points in a space, then iteratively removes the least important one.

Assuming that the initial curve has N points \{r_{1},\ r_{2}\cdots r_{N}\} , the algorithm in [14] always preserve the points r 1 and r N . Given that the desired final keyframes are expected to deviate from the initial curve by at most D_{\max} and the final set has at least N_{\min} points, the method is described below:

Step 1. For i=2 to i=N-1 , for each i , define the line that connects r_{i-1} to r_{i+1} as l(i) .

Step 2. Calculate the importance I(i) of the point r i as being the distance between r i and the line l(i) : \begin{equation*}I(i)=D(r_{i},\ l(i)). \tag{9}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}I(i)=D(r_{i},\ l(i)). \tag{9}\end{equation*}

Step 3. Define k as the index for the least important point. If l(k)\geq D_{\max} , then terminate the algorithm. Otherwise, decimate the least important point r k . Set N=N-1 . Step 4. If N \gt N _ { \min } , return to Step 1. Otherwise, terminate the algorithm.

Figure 3 shows some examples of original curves from the databases along with their decimated counterparts. The termination criterion for those examples was to have N_{\min}= 30 points in the final curve.
Fig. 3. - Sample trajectories from the datasets (blue solid curves starting at black square) and their corresponding decimated counterparts (red crosses). (a) to (d) are examples from SIGN, while (e) to (h) come from ILGDB.
Fig. 3.

Sample trajectories from the datasets (blue solid curves starting at black square) and their corresponding decimated counterparts (red crosses). (a) to (d) are examples from SIGN, while (e) to (h) come from ILGDB.

Show All

C. Data Pre-Processing

Training a Supervised Neural Network requires an input set of data \mathbb { X } = \left\{ \mathbb { X } _ { 1 } , \cdots , \mathbb { X } _ { n } \right\} and an output set of data O= \{\mathbb{O}_{1},\ \cdots,\ \mathbb{O}_{n}\} . Each X j represents a set of m +1 waypoints, and each \mathbb{O}_{j} represents a set of m time allocations. When trained, a Neural Network is expected to work only within the range of values for which it was trained. In order to train a NN for finding the optimal \delta t ’s, it is possible to invoke the properties from Section III to keep inputs and outputs of the training data within compact sets, allowing to use the trained NN for any set of inputs.

The output sets \mathbb{O}_{j} can be obtained offline by solving minimum snap through gradient descent for every set of input waypoints. The optimal outputs were obtained through the Backtracking Gradient Descent (BGD) method from [5] with termination criterion of 1% relative error. The BGD method is sensitive to the initial guess, and it can be driven to local minima.

In order to keep the possible values of the time allocations \delta t_{i} within a compact set, every problem is solved for t_{m}=1 seconds. This way, each \delta t_{i} can be interpreted as the fraction of time that the vehicle should spend between waypoints P_{i-1} and P i . Defining \delta t_{m} as the solution for t_{m}=1 , then \delta t= T\cdot\delta t_{m} is the solution for an arbitrary t_{m}=T (see Property 2 in Section III ).

A naive way to populate the set \mathbb { X } would be to fill it with x i and y i positions of every waypoint P_{i}= [x_{i}\ y_{i}]^{T} . However, Property 3 from Section \mathrm{I}\Pi states that the optimal time allocation \delta t is invariant to homogeneous transformations on the waypoints. By populating \mathbb { X } with the waypoints \boldsymbol { P } _ { i } , then one has to expect that the NN will “learn” the invariance property.

Instead, we find it more suitable to populate X with a waypoint representation that is agnostic to homogeneous transformations, such as the range-angle parametrization. The range vector \boldsymbol { r } \triangleq \left[ { r _ { 1 } } { \cdots } { r _ { m } } \right] ^ { T } is populated as the distance between two consecutive waypoints r _ { i } \triangleq \left\| \boldsymbol { P } _ { i } + \boldsymbol { P } _ { i - 1 } \right\| while the angle vector \boldsymbol { a } \triangleq \left[ { a _ { 2 } } { \cdots } { a _ { m } } \right] ^ { T } is populated as a _ { i } \triangleq \angle \left( \boldsymbol { V } _ { i - 1 } , \boldsymbol { V } _ { i } \right) where \boldsymbol { V } _ { i } \triangleq \boldsymbol { P } _ { i } - \boldsymbol { P } _ { i - 1 } . The angles a i are positive when they are the result of a positive rotation around z= [0\ 0\ 1] , and negative otherwise.

Writing the input set as range-angle pairs unloads the burden from the NN from having to learn the homogeneous invariance property. In order to keep the possible values of range within a compact set, all the ranges can be scaled by a common factor \overline { \boldsymbol { r } } \triangleq \left[ { \overline { r } _ { 0 } } { \cdots } { \overline { r } _ { m - 1 } } \right] ^ { T } = s \cdot \boldsymbol { r } , with s\gt0 , such that 0\lt\overline{r}_{i}\leq 1, \forall i\in\{0,\ m-1\} . Since the optimal time allocation \delta t is also invariant to scaling on the waypoints, the optimal values of \delta t are not affected by this transformation. Thus, for a given set j of m+1 waypoints, the inputs are defined as \mathbb { X } _ { j } = \left[ { \overline { \boldsymbol { r } } ^ { T } } { \boldsymbol { a } ^ { T } } \right] ^ { T }
D. Neural Network Architecture

In order to train the neural network, we use the input-output pairs obtained through the method described in Section IV-C . We apply the rectified linear unit (ReLU) nonlinearity on the output of each of the hidden layers [22] . Using ReLU over other activation functions like sigmoid makes the network train faster as it does not require exponential computations. The gradient of ReLU also does not saturate for high input values. A softmax activation function on the output layer ensures the outputs to lie within the domain 0\leq\delta t_{i}\leq 1 and \sum\delta t_{i}=1 .

The error was calculated based on the cross entropy loss function [23] . The network was trained in a supervised mode and the weights and biases of the hidden layers and the weights of the output layer were initialized using the Xavier’s initialization method [24] . The biases of the output layer were initialized at a constant of 0. We used the Adam optimizer [25] with \beta_{1}=0.9 and \beta_{2}=0.999 . The learning rate was reduced by a factor of 5 after every 10k iterations. The training was stopped when the error on the validation set started increasing as a way to prevent “overfitting”.

At the time of this paper, we have trained 28 neural networks, each of them corresponding to the number of input waypoints in the range from 3 waypoints to 30 waypoints. Based on need, it is also possible to train networks for more than 30 waypoints. It took us over a month to obtain the BGD solutions to all data sets, and about a week for training the neural networks (Intel i5-4690k CPU with Nvidia GTX 1080 GPU).
E. Algorithm Pipeline

The pipeline in Figure 4 summarizes the proposed algorithm for a trained NN. The input to the systems are the waypoints P_{k}, k\in\{0,\ 1,\ \cdots\ m\} and the desired final time T . The waypoints are transformed in range-angle, and the ranges are normalized. The normalized ranges and the angles are the inputs for the trained NN, which outputs the time fractions \delta t_{m} . The output of the algorithm is then \delta t= T\cdot\delta t_{m} , which can be used as a prior for minimum snap.
Fig. 4. - Algorithm Pipeline Schematic Illustration.
Fig. 4.

Algorithm Pipeline Schematic Illustration.

Show All

SECTION V.
Results and Analysis

To show proof of concept, we trained a NN that is able to take 30 waypoints as inputs, and produce 29 \delta t ’s as outputs. As mentioned before, the SIGN dataset was used for training (85% of the data) and validation (15% of the data). Every gesture from the SIGN dataset that had more than 30 points was decimated down to get 30 waypoints. The gestures that had less than 30 points were discarded, amounting to 29274 trajectories in the train-validation dataset. We construct a fully connected feed-forward neural network of size 57 \times 84 \times 72 \times 64 \times 48 \times 29 with weights and biases.

In order to test the outcome of the trained NN, the ILGDB dataset was used (none of the trajectories in ILGDB were used for training). Again, the gestures from the dataset that had more than 30 points were decimated down to get 30 waypoints and gestures that had less than 30 points were discarded, amounting to 6259 trajectories in the ILGDB dataset. For every set j of 30 waypoints, we solve the minimum snap problem using Backtracking Gradient Descent, getting the locally optimal cost J_{BGD}(j) .The cost J_{NN}(j) is obtained when solving minimum snap with fixed time allocations using the \delta t ’s that were given by the NN. For the sake of comparison with other methods in the literature [9] , we also get the cost J_{TVP}(j) by solving minimum snap with fixed time allocations with \delta t ’s given by a trapezoidal velocity profile [9] with maximum velocity 5m/s and maximum acceleration 2.5m/s^{2} . The costs J_{BGD}(j) , J_{NN}(j) and J_{TVP}(j) are obtained for the same final time t_{m}=T dictated by the final time calculated by the TVP method.

Because the minimum snap cost is sensitive to the 7-th power of the time allocations (see Property 2 in Section III ), the optimal costs are normalized by a 7-th root: \begin{equation*}J _ { B G D } ( j ) \triangleq J _ { B G D _ { i } } ^ { \frac { 1 } { 7 } } ( j ) , \quad J _ { N N } ( j ) \triangleq J _ { N N } ^ { \frac { 1 } { \gamma } } ( j ) , \quad J _ { T V P } ( j ) \triangleq J _ { T V P } ^ { \frac { 1 } { 7 } } ( j )\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}J _ { B G D } ( j ) \triangleq J _ { B G D _ { i } } ^ { \frac { 1 } { 7 } } ( j ) , \quad J _ { N N } ( j ) \triangleq J _ { N N } ^ { \frac { 1 } { \gamma } } ( j ) , \quad J _ { T V P } ( j ) \triangleq J _ { T V P } ^ { \frac { 1 } { 7 } } ( j )\end{equation*}

The Percent Relative Error (PRE) between NN and the BGD method is defined in (10) . Similarly, the PRE between TVP and the BGD method is defined in (11) . Note that E_{a,b}^{rel} is positive when method b outperforms method a , and negative otherwise. \begin{equation*}E _ { N N , B G D } ^ { r e l } ( j ) = 100 \cdot \left[ \overline { J } _ { N N } ( j ) - \overline { J } _ { B G D } ( j ) \right] \cdot J _ { B G D } ^ { - 1 } ( j )\tag{10}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}E _ { N N , B G D } ^ { r e l } ( j ) = 100 \cdot \left[ \overline { J } _ { N N } ( j ) - \overline { J } _ { B G D } ( j ) \right] \cdot J _ { B G D } ^ { - 1 } ( j )\tag{10}\end{equation*} \begin{equation*}E _ { T V P , B G D } ^ { r e l } ( j ) = 100 \cdot \left[ \overline { J } _ { T V P } ( j ) - \overline { J } _ { B G D } ( j ) \right] \cdot J _ { B G D } ^ { - 1 } ( j ) \tag{11}\end{equation*}
View Source Right-click on figure for MathML and additional features. \begin{equation*}E _ { T V P , B G D } ^ { r e l } ( j ) = 100 \cdot \left[ \overline { J } _ { T V P } ( j ) - \overline { J } _ { B G D } ( j ) \right] \cdot J _ { B G D } ^ { - 1 } ( j ) \tag{11}\end{equation*}

Figure 5 (a) shows a histogram distribution for E_{NN,BGD}^{rel} . On average, the NN method is 12% worse than BGD, with a standard deviation of \sigma _ { N N } = 11 \% . The NN method outperformed BGD 7.5% of the time 3 . In contrast, Figure 5 (b) shows a histogram distribution for E_{TVP,BGD}^{rel} . In average, the TVP method provides a guess that is 192% worse than BGD 1 , with a standard deviation of \sigma_{TVP}= 140%. Within those trials, the NN method provided a better initial guess than TVP 99.14% of the time, demonstrating that NN is more powerful than techniques that are currently used in the literature to guess the optimal time allocation.
Fig. 5. - Histograms of PREs $E _ { N N , B G D } ^ { r e l }$ (a), $E _ { T V P , B G D } ^ { r e l }$ (b).
Fig. 5.

Histograms of PREs E _ { N N , B G D } ^ { r e l } (a), E _ { T V P , B G D } ^ { r e l } (b).

Show All

Figure 6 presents some minimum snap results obtained for time allocations given by the NN method (red dotted lines) and the TVP method (black dotted lines). Figure 6 shows that the NN calculated trajectories are quite close to the original ones, while the TVP time allocations are clearly less optimal for when the trajectories have sharp turns, as in Figs. 6-(b),(e),(h), and seems to perform slightly worse for the smooth trajectories in Figs. 6-(c),(g) . Table I compares the relative errors between NN and TVP for the sample trajectories of Fig. 6 . Overall, TVP’s performance is much farther from the BGD optimals than NN, except for the case in 6(d), in which TVP is slightly better. It is also worth mentioning that the trajectories in Figs. 6-(e),(f),(g),(h) were not used to train the NN.
TABLE I PRE For NN AND TVP For Some Sample Trajectories
Table I- PRE For NN AND TVP For Some Sample Trajectories
Fig. 6. - Minimum snap with time allocations obtained from the NN (red dotted curves) and TVP (black dotted curves) compared with original hand-drawn trajectories (solid blue curves).
Fig. 6.

Minimum snap with time allocations obtained from the NN (red dotted curves) and TVP (black dotted curves) compared with original hand-drawn trajectories (solid blue curves).

Show All
Fig. 7. - Human-machine interface example with a hypothetical map. Image (a) displays a hand-drawn trajectory on the map and the compressed waypoints. Image (b) displays the compressed waypoints and the minimum snap solutions obtained through BGD and NN. Image (c) displays the compressed waypoints and the minimum snap solutions obtained through BGD and TVP.
Fig. 7.

Human-machine interface example with a hypothetical map. Image (a) displays a hand-drawn trajectory on the map and the compressed waypoints. Image (b) displays the compressed waypoints and the minimum snap solutions obtained through BGD and NN. Image (c) displays the compressed waypoints and the minimum snap solutions obtained through BGD and TVP.

Show All

Fig. 7 shows an example of the utilization of a hand-drawn trajectory to interpolate a minimum snap trajectory on a map. The user draws a desired trajectory ( Fig. 7 -(a) - trajectory was drawn from the bottom to the top of the map), which is compressed into a smaller set of waypoints (green circles). Fig. 7 -(b) compares the solutions obtained through BGD and NN, demonstrating that NN obtains a decent approximation for the optimal time allocations (E_{NN,BGD}^{rel}= 18.9% in this case). On the other hand, the time allocation suggested by TVP leads to collision in the first phase of the trajectory, as seen in Fig. 7 -(c) ( E_{TVP,BGD}^{rel}= 136.7% in this case). The collision aspect can be remedied by utilizing the method described in [8] , but would require multiple minimum-snap solutions, whereas the same was not needed in BGD or NN for the given example. In terms of computational time, it took 3. 23s to obtain the BGD solution, while it takes less than 0. 05s to obtain trajectories in NN and TVP (see Figure 1 for a comparison of time improvement when abandoning BGD into the use of NN and TVP for initial time guess).
SECTION VI.
Final Considerations

The properties that were used to design the input/output pairs of the NN rely on the assumption that (i) the problem has only position equality constraints in the waypoints, (ii) it has no inequality constraints, and (iii) that the vehicle starts from rest and finishes at rest. Although these are reasonable for tablet-based human commands, one might argue that these assumptions have a strong negative impact in other applications, such as in motion planning.

In practice, most works in the literature solve minimum snap with only a set of position waypoints (no velocity, acceleration or jerk equality constraints) [8] [9] [26] , so (i) really is not a commonly prohibitive assumption. Also, assumption (ii) is typical in many works [7] [12] , even when there are maximum velocity and acceleration constraints. A common workaround for assumption (ii) is to extend final time T until these quantities are within desired bounds, which is an effective method due to Property 1 presented in Section III .

As opposed to assumptions (i) and (ii), assumption (iii) can be limiting in autonomous navigation applications. This would require the vehicle to always start from rest, but autonomous systems are typically recalculating paths many times per second while in motion. This assumption can potentially be circumvented by adding an extra input to the NN with the vehicle’s initial velocity, and retraining it.
SECTION VII.
Conclusion

This paper presents a methodology for employing a Neural Network as a tool for obtaining a guess of time allocations when generating minimum snap trajectories for quadrotors. The results demonstrate that using a trained NN lead to a better initial guess of time allocations than the tools that are available in current literature. In addition, the NN approach produces a result two orders of magnitude faster than gradient descent when solving a 30 waypoint problem for 2D rest-to-rest maneuvers.

For future work, we expect to train more neural networks for problems with higher number of waypoints and for different initial/terminal velocities. The ideas herein presented can also be extended to other motion planners, such as minimum acceleration, or minimum jerk.

Another interesting line of future research would be to combine the outputs of the NN method with the minimum snap solutions presented in [12] and [13] . Instead of setting a waypoint as an equality constraint, both these methods specify waypoints through inequalities, allowing the waypoint to be anywhere within a safe convex region, which implicitly optimize allocation time as well. In addition, [12] provides a fast refinement method for dealing with intermediate large velocities, acceleration or jerk, allowing to improve trajectories without performing BGD.

Authors
Figures
References
Citations
Keywords
Metrics
Media
Footnotes
   Back to Results   
More Like This
Computational Complexity Certification for Real-Time MPC With Input Constraints Based on the Fast Gradient Method

IEEE Transactions on Automatic Control

Published: 2012
Convergence and Iteration Complexity of Policy Gradient Method for Infinite-horizon Reinforcement Learning

2019 IEEE 58th Conference on Decision and Control (CDC)

Published: 2019
Show More
References
1. P. Abbeel, Apprenticeship learning and reinforcement learning with application to robotic control, ProQuest, 2008.
Show in Context Google Scholar
2. D. Mellinger, N. Michael and V. Kumar, "Trajectory generation and control for precise aggressive maneuvers with quadrotors", The International Journal of Robotics Research , 2012.
Show in Context CrossRef Google Scholar
3. S. Lupashin, A. Schöllig, M. Sherback and R. D’Andrea, "A simple learning strategy for high-speed quadrocopter multi-flips", Robotics and Automation (ICRA) 2010 IEEE International Conference on , pp. 1642-1648, 2010.
Show in Context View Article Full Text: PDF (1106KB) Google Scholar
4. J. H. Gillula, H. Huang, M. P. Vitus and C. J. Tomlin, "Design of guaranteed safe maneuvers using reachable sets: Autonomous quadrotor aerobatics in theory and practice", Robotics and Automation (ICRA) 2010 IEEE International Conference on , pp. 1649-1654, 2010.
Show in Context View Article Full Text: PDF (1972KB) Google Scholar
5. D. Mellinger and V. Kumar, "Minimum snap trajectory generation and control for quadrotors", Robotics and Automation (ICRA) 2011 IEEE International Conference on , pp. 2520-2525, 2011.
Show in Context View Article Full Text: PDF (1980KB) Google Scholar
6. M. Van Nieuwstadt, M. Rathinam and R. Murray, "Differential flatness and absolute equivalence of nonlinear control systems", SIAM Journal on Control and Optimization , vol. 36, no. 4, pp. 1225-1239, 1998.
Show in Context CrossRef Google Scholar
7. M. Cutler and J. P. How, "Analysis and control of a variable-pitch quadrotor for agile flight", Journal of Dynamic Systems Measurement and Control , vol. 137, no. 10, 2015.
Show in Context CrossRef Google Scholar
8. C. Richter, A. Bry and N. Roy, "Polynomial trajectory planning for aggressive quadrotor flight in dense indoor environments", Robotics Research , pp. 649-666, 2016.
Show in Context Google Scholar
9. S. Liu, M. Watterson, S. Tang and V. Kumar, "High speed navigation for quadrotors with limited onboard sensing", Robotics and Automation (ICRA) 2016 IEEE International Conference on , pp. 1484-1491, 2016.
Show in Context Google Scholar
10. S. G. Johnson, The nlopt nonlinear-optimization package, 2014.
Show in Context Google Scholar
11. R. Allen and M. Pavone, "A real-time framework for kinodynamic planning with application to quadrotor obstacle avoidance", AIAA Guidance Navigation and Control Conference , pp. 1374, 2016.
Show in Context CrossRef Google Scholar
12. S. Liu, M. Watterson, K. Mohta, K. Sun, S. Bhattacharya, C. J. Taylor, et al., "Planning dynamically feasible trajectories for quadrotors using safe flight corridors in 3-d complex environments", IEEE Robotics and Automation Letters , vol. 2, no. 3, pp. 1688-1695, 2017.
Show in Context View Article Full Text: PDF (1559KB) Google Scholar
13. J. Chen, T. Liu and S. Shen, "Online generation of collision-free trajectories for quadrotor flight in unknown cluttered environments", Robotics and Automation (ICRA) 2016 IEEE International Conference on , pp. 1476-1483, 2016.
Show in Context View Article Full Text: PDF (1204KB) Google Scholar
14. S. Li, M. Okuda and S. Takahashi, "Embedded key-frame extraction for cg animation by frame decimation", Multimedia and Expo 2005. ICME 2005. IEEE International Conference on , pp. 1404-1407, 2005.
Show in Context View Article Full Text: PDF (169KB) Google Scholar
15. M. M. de Almeida and M. Akella, "New numerically stable solutions for minimum-snap quadcopter aggressive maneuvers", American Control Conference (ACC) 2017 , pp. 1322-1327, 2017.
Show in Context View Article Full Text: PDF (525KB) Google Scholar
16. L. E. Kavraki, P. Svestka, J.-C. Latombe and M. H. Overmars, "Probabilistic roadmaps for path planning in high-dimensional configuration spaces", IEEE transactions on Robotics and Automation , vol. 12, no. 4, pp. 566-580, 1996.
Show in Context View Article Full Text: PDF (1960KB) Google Scholar
17. S. M. LaValle, Rapidly-exploring random trees: A new tool for path planning, 1998.
Show in Context Google Scholar
18. S. Karaman, M. R. Walter, A. Perez, E. Frazzoli and S. Teller, "Anytime motion planning using the rrt", Institute of Electrical and Electronics Engineers , 2011.
Show in Context View Article Full Text: PDF (1406KB) Google Scholar
19. F. Hauer and P. Tsiotras, "Deformable rapidly-exploring random trees", Proceedings of the Robotics: Science and Systems Conference , pp. P08, 2017.
Show in Context CrossRef Google Scholar
20. A. Almaksour, E. Anquetil, S. Quiniou and M. Cheriet, "Personalizable pen-based interface using lifelong learning", Frontiers in Handwriting Recognition (ICFHR) 2010 International Conference on , pp. 188-193, 2010.
Show in Context View Article Full Text: PDF (613KB) Google Scholar
21. N. Renau-Ferrer, P. Li, A. Delaye and E. Anquetil, "The ilgdb database of realistic pen-based gestural commands", Pattern Recognition (ICPR) 2012 21st International Conference on , pp. 3741-3744, 2012.
Show in Context Google Scholar
22. V. Nair and G. E. Hinton, "Rectified linear units improve restricted boltzmann machines", Proceedings of the 27th international conference on machine learning (ICML-10) , pp. 807-814, 2010.
Show in Context Google Scholar
23. R. A. Dunne and N. A. Campbell, "On the pairing of the softmax activation and cross-entropy penalty functions and the derivation of the softmax activation function", Proc. 8th Aust. Conf. on the Neural Networks Melbourne , vol. 181, pp. 185, 1997.
Show in Context Google Scholar
24. X. Glorot and Y. Bengio, "Understanding the difficulty of training deep feedforward neural networks", Proceedings of the Thirteenth International Conference on Artificial Intelligence and Statistics , pp. 249-256, 2010.
Show in Context Google Scholar
25. D. P. Kingma and J. Ba, "Adam: A method for stochastic optimization", arXiv preprint arXiv:1412.6980 , 2014.
Show in Context Google Scholar
26. Y. Lin, F. Gao, T. Qin, W. Gao, T. Liu, W. Wu, et al., "Autonomous aerial navigation using monocular visual-inertial fusion", Journal of Field Robotics , vol. 35, no. 1, pp. 23-51, 2018.
Show in Context CrossRef Google Scholar
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
