IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Loading [MathJax]/extensions/MathZoom.js

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
ADVANCED SEARCH
Conferences > 2021 IEEE/RSJ International C...
Trajectory Splitting: A Distributed Formulation for Collision Avoiding Trajectory Optimization
Publisher: IEEE
Cite This
PDF
Changhao Wang ; Jeffrey Bingham ; Masayoshi Tomizuka
All Authors
2
Paper
Citations
93
Full
Text Views

    Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Related Works
    III.
    Mathematical Background
    IV.
    Trajectory Splitting Algorithm
    V.
    Simulation and Experiments

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
Media
Abstract:
Efficient trajectory optimization is essential for avoiding collisions in unstructured environments, but it remains challenging to have both speed and quality in the solutions. One reason is that second-order optimality requires calculating Hessian matrices that can grow with O(N 2 ) with the number of waypoints. Decreasing the waypoints can quadratically decrease computation time. Unfortunately, fewer waypoints result in lower quality trajectories that may not avoid the collision. To have both, dense waypoints and reduced computation time, we took inspiration from recent studies on consensus optimization and propose a distributed formulation of collocated trajectory optimization. It breaks a long trajectory into several segments, where each segment becomes a subproblem of a few waypoints. These subproblems are solved classically, but in parallel, and the solutions are fused into a single trajectory with a consensus constraint that enforces continuity of the segments through a consensus update. With this scheme, the quadratic complexity is distributed to each segment and enables solving for higher-quality trajectories with denser waypoints. Furthermore, the proposed formulation is amenable to using any existing trajectory optimizer for solving the subproblems. We compare the performance of our implementation of trajectory splitting against leading motion planning algorithms and demonstrate the improved computational efficiency of our method.
Published in: 2021 IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS)
Date of Conference: 27 Sept.-1 Oct. 2021
Date Added to IEEE Xplore : 16 December 2021
ISBN Information:
ISSN Information:
INSPEC Accession Number: 21407143
DOI: 10.1109/IROS51168.2021.9636846
Publisher: IEEE
Conference Location: Prague, Czech Republic
SECTION I.
Introduction

Finding optimal, collision-free trajectories is important for robots to interact with people and the environment. Sampling and optimization are two of the most powerful ways to achieve the goal. Optimization allows defining the problem in terms of constraints and finding solutions that optimize performance. Currently, collocation-based optimization methods, such as TrajOpt [1] , solve a non-linear program (NLP) using non-linear optimization algorithms like sequential quadratic programming (SQP) [2] . The structure of the NLP leads to at least O ( N 2 ) time complexity concerning the number of waypoints to satisfy second-order optimality criteria. Therefore, increasing the density of waypoints quadratically increases the computation time. In comparison, sampling-based planners, such as rapidly-exploring random trees (RRT) [3] , are able to be parallelized to achieve a higher computation efficiency.

Our goal is to combine the expressiveness and quality of optimization-based techniques with the computational advantages of parallelization in sampling-based methods. We propose a method that separates the trajectory optimization problem into a set of subproblems that can be solved in a distributed manner.

Prevailing methods for parallel or distributed optimization mainly focus on multi-agent planning [4] , [5] with limited research applying the techniques to single-agent planning. Brendan. et al [6] pioneered in this field by applying the operator splitting method to convex optimal control problems. They proposed splitting an optimal control problem into subproblems by constraint. This idea is further studied in [7] and applied to more challenging control scenarios. If it were applied to a collision-avoiding trajectory problem for a robot, two subproblems would be created. One subproblem would satisfy only the robot dynamics and the other would only avoid the collision. These problems would then be fused using an iterative consensus update to find the optimal trajectory. However, even with this splitting scheme, the number of variables for each subproblem remains the same, and it still suffers from the O ( N 2 ) time complexity. Furthermore, splitting by constraint may create subproblems with different complexity. Some subproblems may dominate the computation time, and others should wait until the most complicated subproblem is finished in order to begin the next consensus iteration.

To deal with those problems, we propose to split the problem by the path variables, creating subproblems for segments of the trajectory. In this way, the problem complexity can be equally distributed. These segments are then fused together using a consensus update scheme similar to the method described above. This proposed method of "trajectory splitting" exploits the observation that complexity decreases as path-length decreases and in this way offers a more efficient approach of solving trajectory optimization for certain classes of problems. Moreover, the proposed splitting scheme is amenable to be incorporated with any existing trajectory optimizers to solve the subproblem. To the authors’ knowledge, this is the first approach to parallelizing optimization-based trajectory planning by splitting the path variables in order to equally distribute the problem complexity to each trajectory segment. The contributions of the proposed method are listed as follows:

    A novel formulation of trajectory optimization problems via splitting the trajectory into segments that can equally distribute the problem complexity.

    A distributed optimization algorithm to solve the proposed formulation for better computational efficiency.

    An implementation of the trajectory splitting algorithm with a state-of-the-art collision checker and optimization solver.

    Comprehensive comparisons of the proposed trajectory splitting algorithm against existing methods using both simulation and real-world experiments.

SECTION II.
Related Works

Motion planning algorithms are nominally classified into two broad categories, sampling, and optimization. Sampling methods are well suited for problems where any feasible solution is acceptable and gradient information is difficult or expensive to compute. Probabilistic roadmap (PRM) [8] solves the planning problem by constructing a complete map of the workspace and then using a search algorithm to find a feasible path from the map. One major problem of PRM is the computation time. It is time-consuming to build a complete roadmap, especially in high-dimensional space. RRT [3] deals with this problem by incrementally building a graph and checking feasible paths at the same time. In practice, RRT and its variants [3] , [9] are still some of the most powerful ways to deal with the planning problem. They are efficient and can easily be parallelized [3] for even better performance. However, since sampling-based planners are stochastic, they may find different solutions for the same problem, and the solution quality and the computation time may also have a large variance. This problem has been reported in several papers [10] , [11] . It is still an active research area to improve the robustness of sampling planners.

Though sampling planners are effective to find feasible paths, it is often preferable to obtain ‘optimal’ paths that satisfy an objective. RRT* [3] , an optimal variant of traditional RRT, is able to obtain optimal paths with the help of an additional ‘rewire’ operation. Exploiting the probabilistic completeness property provides a theoretical guarantee of globally optimal solutions. However, in practice, the planner is only given finite time to find a path and thus, RRT* performance declines sharply as the dimensionality of the scenario increases [11] .

Optimization, on the other hand, provides a way to go beyond finding a feasible solution and offers a means to seek ‘better’ solutions based on an objective. State-of-the-art trajectory optimization algorithms start with an infeasible solution and evolve a trajectory to minimize a defined cost and satisfy all constraints. CHOMP [10] pioneered this approach for collision avoidance planning problems in robotics, proposing a covariant gradient descent update rule to optimize the trajectory. To deal with non-differentiable constraints, STOMP [12] proposed a stochastic update rule. TrajOpt [1] introduced an SQP formulation to solve the planning problems. Recently, there has been considerable progress in this field [13] , [14] , and these efforts suggest new approaches to optimization-based planning has the potential to be both computationally efficient and retain high-quality solutions.
SECTION III.
Mathematical Background

In this section, we introduce the preliminaries of the proposed method. The classic trajectory optimization formulation by collocation is introduced in Section III-A . The mathematical background of consensus optimization and alternating direction method of multipliers (ADMM) is illustrated in Section III-B .
A. Trajectory Optimization Formulation

A common discrete form of trajectory planning can be formulated as an optimization problem with the following form:
min τ  s .t .  c ( τ ) x i + 1 = f ( x i ) g ( x i ) ≤ 0 i = 1 , ⋯ , N − 1 (1)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\begin{array}{cc} {\mathop {\min }\limits_\tau }&{c(\tau )} \\ {{\text{ s}}{\text{.t}}{\text{. }}}&{{x_{i + 1}} = f\left( {{x_i}} \right)} \\ {}&{g\left( {{x_i}} \right) \leq 0} \\ {}&{i = 1, \cdots ,N - 1} \end{array}\tag{1}\end{equation*}

where τ = {x 1 ,• ⋯ ,x N } denotes a discretized robot trajectory, and x i denotes the robot state (position, velocity, and acceleration). c (•) is a human designed cost function, f (•) may include the robot kinematics or dynamics constraints, and g (•) is the robot state constraint. In this paper, we assume the cost function and constraints are separable (or block-separable) c ( τ ) = ∑ N i = 1 c i ( x i ) .
B. ADMM and Consensus Optimization

Consensus optimization [15] considers the problem with separable objectives:
min x 1 , ⋯ , x N , z ∈ R N ∑ i = 1 N c i ( x i ) s .t .  x i = z i = 1 , ⋯ , N (2)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\begin{array}{l} \mathop {\min }\limits_{{x_1}, \cdots ,{x_N},z \in {\mathbb{R}^N}} \quad \sum\limits_{i = 1}^N {{c_i}\left( {{x_i}} \right)} \\ {\text{s}}{\text{.t}}{\text{. }}{x_i} = z\quad i = 1, \cdots ,N \end{array} \tag{2}\end{equation*} where x i is called a local variable, and z is a global value that each local variable tries to achieve.

ADMM [15] , an augmented Lagrangian method [16] , is able to parallelize the consensus problem and solve it efficiently. The augmented Lagrangian of (2) is shown in (3) , where y i denotes the Lagrange multiplier of the corresponding consensus constraint. Similar to penalty methods, the augmented Lagrangian adds an additional constraint term to the original Lagrangian in order to penalize the constraint violation, and ρ is a weight that controls the constraint violation.
L = ∑ i = 1 N [ c i ( x i ) + y T i ( x i − z ) + ( ρ / 2 ) ∥ x i − z ∥ 2 (3)
View Source Right-click on figure for MathML and additional features. \begin{equation*}L = \sum\limits_{i = 1}^N {\left[ {{c_i}\left( {{x_i}} \right) + y_i^T\left( {{x_i} - z} \right) + (\rho /2){{\left\| {{x_i} - z} \right\|}^2}} \right.} \tag{3}\end{equation*}

Based on the augmented Lagrangian in (3) , ADMM can solve the original problem in a distributed way as shown in Fig. 1 . First, ADMM initializes N separate agents (solver) in order to update each local variable x i . Then, a central unit collects the solution from the agent and updates the dual variable accordingly y i . The update rule is then given by:
x k + 1 i = arg min x i [ c i ( x i ) + y k T i ( x i − z k ) + ( ρ / 2 ) ∥ ∥ x i − z k ∥ ∥ 2 ] y k + 1 i = y k i + ρ ( x k + 1 i + z k + 1 ) z k + 1 = 1 N ∑ i = 1 N x k + 1 i (4)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\begin{array}{l} x_i^{k + 1} = \arg \mathop {\min }\limits_{{x_i}} \left[ {{c_i}\left( {{x_i}} \right) + y_i^{kT}\left( {{x_i} - {z^k}} \right) + (\rho /2){{\left\| {{x_i} - {z^k}} \right\|}^2}} \right] \\ y_i^{k + 1} = y_i^k + \rho \left( {x_i^{k + 1} + {z^{k + 1}}} \right) \\ {z^{k + 1}} = \frac{1}{N}\sum\limits_{i = 1}^N {x_i^{k + 1}} \end{array} \tag{4}\end{equation*}

Fig. 1. - An illustration of the ADMM update rule to solve consensus problems. ADMM solves the problem in a distributed manner, where it creates N separate agents to solve each subproblem. A central unit then collects the results obtained from each agent and updates the dual variable until a stopping criterion is met.
Fig. 1.

An illustration of the ADMM update rule to solve consensus problems. ADMM solves the problem in a distributed manner, where it creates N separate agents to solve each subproblem. A central unit then collects the results obtained from each agent and updates the dual variable until a stopping criterion is met.

Show All

The convergence and optimality condition of ADMM is illustrated in Theorem 1. For the convex consensus optimization problem, a globally optimal solution is guaranteed.

The ADMM algorithm has also been extensively applied to non-convex, coupling optimization problems [17] , [18] . Recently, convergence criteria for general non-convex problems have been studied and we refer readers to [17] for further details. We will discuss convergence for our implementation and similar problems in Section IV-E . In summary, ADMM algorithms show amazing practical success in solving both convex and general nonlinear optimization problems even while the theoretical proof of convergence is forthcoming.

Assumption 1: c i ( x ) ,i = 1 ,•⋯,N are closed, proper, and convex.

Assumption 2: The augmented Lagrangian L 0 contains a saddle point

Theorem 1: Under Assumptions 1 and 2, the ADMM iteration satisfies the following [15] :

    Residual convergence: x i − z → 0 as k → ∞

    Objective convergence: ∑ N i = 1 c i ( x i ) → f ∗ as k → ∞

    Dual convergence: y k i → y ∗ i , i = 1 , ⋯ , N as k → ∞

It is worth noticing that (2) is a simplified form of the consensus problem. For the general form [15] , each local variable, or even each element, can have its own consensus constraints. The above update rule can be easily transformed to the general case by replacing the consensus constraint, and the optimality and convergence analysis still hold for the general formulation.
SECTION IV.
Trajectory Splitting Algorithm

Trajectory optimization aims at finding a smooth and collision-free trajectory between two predefined states. Similar to previous methods [1] , we formulate the motion planning problem as an NLP as introduced in Section III-A . While in contrast with other methods, which directly apply optimization algorithms (such as, covariant gradient descent or SQP) to solve the entire problem, we propose splitting the trajectory into several segments and solving them in a distributed manner for better computational efficiency. The splitting formulation as a consensus optimization will be introduced in Section IV-A , IV-B . The collision avoidance constraints will be formalized in Section IV-C . The optimization update rule will be explained in Section IV-D . In the end, we provide the stopping criterion and convergence analysis of the proposed algorithm.
Fig. 2. - Illustration of trajectory splitting algorithm. The waypoints are denoted by the yellow dots, and the orange dots are the splitting points xsi. The trajectory splitting algorithm is able to find feasible trajectory pieces in parallel and then connect them together.
Fig. 2.

Illustration of trajectory splitting algorithm. The waypoints are denoted by the yellow dots, and the orange dots are the splitting points x si . The trajectory splitting algorithm is able to find feasible trajectory pieces in parallel and then connect them together.

Show All
A. Intuition for Trajectory Splitting: A Three Waypoint Example

Let us begin with an example with three waypoints x 1 ,x 2 ,x 3 . Consider we want to split the trajectory at x 2 creating a leading trajectory of τ 1 = {x 1 ,x 2 }, and a trailing trajectory of τ 2 = { x ′ 2 , x 3 } . Here x ′ 2 is a slack variable that is defined to be equal to x 2 . According to the consensus formulation in (2) , in order to achieve the consensus between x 2 and x ′ 2 , a global variable z is introduced to enforce this constraint. Therefore, we can rewrite the three waypoint trajectory optimization problem in (1) as follows:
min x 1 , x 2 , x ′ 2 , x 2 , z c 1 ( x 1 ) + 1 2 c 2 ( x 2 ) + 1 2 c 2 ( x ′ 2 ) + c 3 ( x 3 ) s .t . x 2 = z , x ′ 2 = z x 2 = f ( x 1 ) , x 3 = f ( x ′ 2 ) g ( x i ) ≤ 0 , i = 1 , 2 , 3 g ( x ′ 2 ) ≤ 0 (5)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\begin{array}{l} \mathop {\min }\limits_{{x_1},{x_2},x_2^\prime ,{x_2},z} \quad {c_1}\left( {{x_1}} \right) + \frac{1}{2}{c_2}\left( {{x_2}} \right) + \frac{1}{2}{c_2}\left( {x_2^\prime } \right) + {c_3}\left( {{x_3}} \right) \\ {\text{s}}{\text{.t}}{\text{.}}\quad {x_2} = z,\quad x_2^\prime = z \\ {x_2} = f\left( {{x_1}} \right),\quad {x_3} = f\left( {x_2^\prime } \right) \\ g\left( {{x_i}} \right) \leq 0,\quad i = 1,2,3 \\ g\left( {x_2^\prime } \right) \leq 0 \end{array} \tag{5}\end{equation*}

Notice that the problem is separable between these two trajectory pieces, except for the first two consensus constraints. According to the consensus optimization update rule in (4) , each trajectory segment τ 1 , and τ 2 can be updated by solving the following optimization where the dual variable update follows the same manner as in (4) .
min x 1 , x 2 c 1 ( x 1 ) + 1 2 c 2 ( x 2 ) + y T 1 ( x 2 − z ) + ( ρ / 2 ) ∥ x 2 − z ∥ 2 s .t . x 2 = f ( x 1 ) g ( x 1 ) ≤ 0 , i = 1 , 2 min x ′ 2 , x 3 1 2 c 2 ( x ′ 2 ) + c 3 ( x 3 ) + y T 2 ( x ′ 2 − z ) + ( ρ / 2 ) ∥ x ′ 2 − z ∥ 2 s .t . x 3 = f ( x ′ 2 ) g ( x ′ 2 ) ≤ 0 g ( x 3 ) ≤ 0 (6) (7)
View Source Right-click on figure for MathML and additional features. \begin{align*} & \begin{array}{l} \mathop {\min }\limits_{{x_1},{x_2}} \quad {c_1}\left( {{x_1}} \right) + \frac{1}{2}{c_2}\left( {{x_2}} \right) + y_1^T\left( {{x_2} - z} \right) + (\rho /2){\left\| {{x_2} - z} \right\|^2} \\ {\text{s}}{\text{.t}}{\text{.}}\quad {x_2} = f\left( {{x_1}} \right) \\ g\left( {{x_1}} \right) \leq 0,\quad i = 1,2 \end{array} \tag{6} \\ & \begin{array}{l} \mathop {\min }\limits_{x_2^\prime ,{x_3}} \quad \frac{1}{2}{c_2}\left( {x_2^\prime } \right) + {c_3}\left( {{x_3}} \right) + y_2^T\left( {x_2^\prime - z} \right) + (\rho /2){\left\| {x_2^\prime - z} \right\|^2} \\ {\text{s}}{\text{.t}}{\text{.}}\quad {x_3} = f\left( {x_2^\prime } \right) \\ g\left( {x_2^\prime } \right) \leq 0 \\ g\left( {{x_3}} \right) \leq 0 \end{array} \tag{7}\end{align*}

Remark 1: Constraints can be incorporated into the objective function via indicator functions. Therefore, it does not affect the update rule for the ADMM formulation.
B. General Trajectory Splitting Formulation
Algorithm 1: Trajectory Splitting
Table 1:- Trajectory Splitting

Consider we split the trajectory into M +1 segments, and the position that splitting happens is denoted by x s i , where s i is the index of the i th splitting point on the original trajectory as shown in Fig. 2 . Similar to the previous example, we introduce the slack variable x ′ s i as a copy of the splitting point. In order to enforce that the trajectories are connected with each other, a global variable z i is used for this constraint:
x s i = z i x ′ s i = z i , i = 1 , ⋯ , M (8)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\begin{array}{l} {x_{{s_i}}} = {z_i} \\ x_{{s_i}}^\prime = {z_i},\quad i = 1, \cdots ,M \end{array} \tag{8}\end{equation*} and we use y i,1 and y i,2 to denote the Lagrangian multipliers of the consensus constraints above. Thus, we can formulate the augmented Lagrangian L i for each trajectory piece as shown in (9) . Then the primal update rule for each trajectory segment is given in (10) .

L 1 = ∑ j = 1 s 1 − 1 c j ( x j ) + 1 2 c s 1 ( x s 1 ) + y T 1 , 1 ( x s 1 − z 1 ) + ( ρ / 2 ) ∥ x s 1 − z 1 ∥ 2 … L i = 1 2 c s i − 1 ( x ′ s i − 1 ) + ∑ j = s i + 1 s i + 1 c j ( x j ) + 1 2 c s i ( x s i ) + y T i − 1 , 2 ( x ′ s i − 1 − z i − 1 ) + ( ρ / 2 ) ∥ x s i − 1 − z i − 1 ∥ 2 + y T i , 1 ( x s i − z i ) + ( ρ / 2 ) ∥ x s i − z i ∥ 2 … L M = ∑ j = s M + 1 N c j ( x j ) + 1 2 c s M ( x ′ s M ) + y T M , 1 ( x ′ s M − z M ) + ( ρ / 2 ) ∥ x ′ s M − z M ∥ 2 τ k + 1 i = min τ i L i s .t . x j + 1 = f ( x j ) g ( x j ) ≤ 0 ∀ x j ∈ τ i (9) (10)
View Source Right-click on figure for MathML and additional features. \begin{align*} & \begin{array}{l} {L_1} = \sum\limits_{j = 1}^{{s_1} - 1} {{c_j}\left( {{x_j}} \right) + \frac{1}{2}{c_{{s_1}}}\left( {{x_{{s_1}}}} \right) + y_{1,1}^T\left( {{x_{{s_1}}} - {z_1}} \right) + (\rho /2){{\left\| {{x_{{s_1}}} - {z_1}} \right\|}^2}} \\ \ldots \\ {L_i} = \frac{1}{2}{c_{{s_{i - 1}}}}\left( {x_{{s_{i - 1}}}^\prime } \right) + \sum\limits_{j = {s_i} + 1}^{{s_i} + 1} {{c_j}\left( {{x_j}} \right) + \frac{1}{2}{c_{{s_i}}}\left( {{x_{{s_i}}}} \right) + y_{i - 1,2}^T\left( {x_{{s_{i - 1}}}^\prime - {z_{i - 1}}} \right) + (\rho /2){{\left\| {{x_{{s_{i - 1}}}} - {z_{i - 1}}} \right\|}^2} + y_{i,1}^T\left( {{x_{{s_i}}} - {z_i}} \right) + (\rho /2){{\left\| {{x_{{s_i}}} - {z_i}} \right\|}^2}} \\ \ldots \\ {L_M} = \sum\limits_{j = {s_M} + 1}^N {{c_j}\left( {{x_j}} \right) + \frac{1}{2}{c_{{s_M}}}\left( {x_{{s_M}}^\prime } \right) + y_{M,1}^T\left( {x_{{s_M}}^\prime - {z_M}} \right) + (\rho /2){{\left\| {x_{{s_M}}^\prime - {z_M}} \right\|}^2}} \end{array} \tag{9} \\ & \begin{array}{l} \tau _i^{k + 1} = \mathop {\min }\limits_{{\tau _i}} \quad {L_i} \\ {\text{s}}{\text{.t}}{\text{.}}\quad {x_{j + 1}} = f\left( {{x_j}} \right) \\ g\left( {{x_j}} \right) \leq 0 \\ \forall {x_j} \in {\tau _i} \end{array} \tag{10}\end{align*}

The overall algorithm is illustrated in Alg. 1 . In practice, the trajectory τ can be initialized as a straight line that goes from the initial point to the target point, or it can be given as a feasible solution from sampling-based planners. The Lagrange multipliers y i,1 , y i,2 can be initialized as zero vectors. The number of splitting M could be any integer that is smaller than the number of waypoints, and the waypoints are then uniformly separated into each subproblem.
C. Collision Avoidance Constraints

We consider collision-avoidance constraint g ( x i ) ≤ 0 as a function of signed distance [1] . As shown in Fig. 3 , the signed distance function denotes the minimum distance between two objects, where the sign is determined by whether the surfaces of the objects interpenetrate. We mathematically define the signed distance function between two objects A and B by:
sd ( A , B ) = dist ( A , B ) − penetration ( A , B ) (11)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\operatorname{sd} (A,B) = \operatorname{dist} (A,B) - {\text{penetration}}(A,B)\tag{11}\end{equation*} where the ‘dist’ function is defined as the minimum translation distance to just cause contact between the surfaces of a pair of objects:
dist = inf { ∥ T ∥ : ∃ p A ∈ A , p A + T ∈ B } (12)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\operatorname{dist} = \inf \left\{ {\left\| T \right\|:\exists {p_A} \in A,{p_A} + T \in B} \right\}\tag{12}\end{equation*} and similarly, the ‘penetration’ function denotes the minimum translation that moves the two objects out of contact:
penetration = inf { ∥ T ∥ : ∀ p A ∈ A , p A + T ∉ B } (13)
View Source Right-click on figure for MathML and additional features. \begin{equation*}{\text{penetration}} = \inf \left\{ {\left\| T \right\|:\forall {p_A} \in A,{p_A} + T \notin B} \right\}\tag{13}\end{equation*}

In our implementation, we approximated the signed distance using methods from the Flexible Collision Library (FCL) [19] . In turn, this signed distance method was used to formulate a collision-avoidance constraint where the signed distance between the robot and each obstacle had a strictly positive value along the entire trajectory. An additional approximation was adopted by utilizing the Jacobian for the contact point from the signed distance, as introduced in [1] . With this technique, assume the object A is a robot link and its position is determined by the robot state x. Then, the signed distance is defined by contact points denoted by p A for the robot link and p B for an obstacle. A static assumption is made to arrive at the approximation given in (14) by assuming the contact point p A is not a function of x :
s d A B ( x ) ≈ n ^ ( F w A ( x ) p A − F w B p B ) (14)
View Source Right-click on figure for MathML and additional features. \begin{equation*}s{d_{AB}}(x) \approx \hat n\left( {F_A^w(x){p_A} - F_B^w{p_B}} \right)\tag{14}\end{equation*} where F w A and F w B are the homogeneous transformation from A , and B frames to the world coordinate, and n ^ is the direction that points from p B to p A .

In addition, the gradient of this constraint can be computed as a Jacobian of the signed distance sd AB with the following approximation:
∇ s d A B ( x ) ≈ n ^ T J p A ( x ) (15)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\nabla {\text{s}}{{\text{d}}_{AB}}(x) \approx {\hat n^T}{J_{{p_A}}}(x)\tag{15}\end{equation*} where J p A denotes the robot translation Jacobian at p A .

D. Optimization

The key to this algorithm is the separation of the trajectory optimization problem into several subproblems that can be solved independently. For each subproblem in (10) , it is expressed in a standard form for trajectory optimization; therefore, existing optimization algorithms, such as gradient descent, SQP [2] , CHOMP [10] , and TrajOpt [1] can be directly applied.

In our implementation, we use the optimization library IPOPT [20] as the basis of our subproblem solver. IPOPT implements a primal-dual interior-point filter line search algorithm to solve the general nonlinear optimization problems, and the convergence of this algorithm is proved in [21] .
Fig. 3. - Illustration of signed distance function. The signed distance value is positive if objects are collision free, and the value is negative if they are in collision.
Fig. 3.

Illustration of signed distance function. The signed distance value is positive if objects are collision free, and the value is negative if they are in collision.

Show All
E. Stopping Criterion and Convergence Analysis

Similar to [22] , we choose to use the primal residuals as the stopping criterion:
∥ ∥ r k ∥ ∥ 2 ≤ ε (16)
View Source Right-click on figure for MathML and additional features. \begin{equation*}{\left\| {{r^k}} \right\|_2} \leq \varepsilon \tag{16}\end{equation*} where ε is a predefined positive scalar, and splitting tolerance r k is the average of constraint violations:
∥ ∥ r k ∥ ∥ 2 = 1 M ( ∑ i = 1 M ∥ ∥ q k s i − q ′ k s i ∥ ∥ 2 ) 1 2 (17)
View Source Right-click on figure for MathML and additional features. \begin{equation*}{\left\| {{r^k}} \right\|_2} = \frac{1}{M}{\left( {\sum\limits_{i = 1}^M {{{\left\| {q_{{s_i}}^k - q_{{s_i}}^{\prime k}} \right\|}^2}} } \right)^{\frac{1}{2}}}\tag{17}\end{equation*}

The convergence of the proposed trajectory splitting algorithm can be divided into three cases:

    Convex : According to Theorem 1, if the objective functions and constraints are convex (the equality constraint should be linear), the proposed trajectory splitting algorithm is guaranteed to converge to a global optimal solution. An example of this type of problem is the Linear-Quadratic Regulators (LQR). For the LQR problem, the trajectory splitting algorithm is guaranteed to find a global optimal solution.

    Restricted prox-regular [17] : Recent studies provide the convergence of ADMM on non-convex, non-smooth problems. [17] proves the condition that if the objectives and constraints satisfy the restricted prox-regular condition, then the ADMM algorithm will converge to a stationary point. In our scenario, if the dynamics constraint f (•) is linear, and the nonlinear collision constraint g (•) is restricted prox-regular, then the solution ( τ,y,z ) obtained from Alg. 1 will converge to a stationary point ( τ * ,y * ,z * ) for the augmented Lagrangian in (9) . According to [17] , restricted prox-regular is a weaker condition than prox-regular and semi-convex [23] . As studied in [14] , the signed distance function between two convex objects is semi-convex; therefore, a large set of trajectory optimization problems fall into this category. This includes mobile robot planning with convex obstacles and linear kinematics (as shown in Section V-B ).

    General non-convex : For the general non-convex case, the convergence of ADMM is still an active field of optimization research. The multi-joint robotic motion planning problem falls into this category. Though the signed distance function of convex obstacles satisfies the semi-convex condition, the nonlinear robot forward kinematics violates these conditions and makes the planning problem extremely challenging. This is a common problem encountered by all the existing trajectory optimization algorithms. Though there is no theoretical proof of convergence yet, our practical observation from simulation and experiments show that the trajectory splitting algorithm converges reasonably for this challenging scenario (as shown in Section V-C , and Section V-D ).

SECTION V.
Simulation and Experiments
A. Robot Model

The proposed trajectory splitting algorithm is tested in two scenarios. The first scenario is a simple 2D case with a sphere obstacle (as shown in Fig. 5 ), and the second is on a 6-DoF FANUC LRMATE 200iD robot (as shown in Fig. 4 ).

For the 2D example, the robot state x is defined as the Cartesian position, and velocity in 2D: x = [ p x , p y , p ˙ x , p ˙ y ] T , where p x , and p y denote the position in x and y axes.

For the multi-jointed robot case, the robot state x is selected to include the robot joint angle θ ∈ ℝ 6 , joint velocity θ ˙ ∈ R 6 , and joint acceleration θ ¨ ∈ R 6 . For optimization, we use linear double-integrator dynamics as the equality constraint:
[ θ i + 1 θ ˙ i + 1 ] = [ I 0 T I I ] [ θ i θ ˙ i ] + [ 0 T I ] θ ¨ i (18)
View Source Right-click on figure for MathML and additional features. \begin{equation*}\left[ {\begin{array}{c} {{\theta _{i + 1}}} \\ {{{\dot \theta }_{i + 1}}} \end{array}} \right] = \left[ {\begin{array}{cc} {\mathbf{I}}&{T{\mathbf{I}}} \\ {\mathbf{0}}&{\mathbf{I}} \end{array}} \right]\left[ {\begin{array}{c} {{\theta _i}} \\ {{{\dot \theta }_i}} \end{array}} \right] + \left[ {\begin{array}{c} {\mathbf{0}} \\ {{\mathbf{TI}}} \end{array}} \right]{\ddot \theta _i}\tag{18}\end{equation*} where 0 ∈ ℝ 6 × 6 , and I ∈ ℝ 6 × 6 are the zero and identity matrices, and T is a positive scalar that denotes the robot travel time in-between each consecutive waypoint pair. The objective function is selected to minimize the summation of joint velocities in (19) for the minimum path length trajectory.

c ( x ) = ∑ i = 1 N ∥ ∥ θ ˙ i ∥ ∥ 2 (19)
View Source Right-click on figure for MathML and additional features. \begin{equation*}c(x) = \sum\limits_{i = 1}^N {{{\left\| {{{\dot \theta }_i}} \right\|}^2}} \tag{19}\end{equation*}
Fig. 4. - Simulation benchmark results showing four different planning problems and the results obtained by the trajectory splitting algorithm in the bookcase scenario. The algorithm is able to find the local optimal solution for each trajectory segment efficiently and connect them together in a smooth trajectory.
Fig. 4.

Simulation benchmark results showing four different planning problems and the results obtained by the trajectory splitting algorithm in the bookcase scenario. The algorithm is able to find the local optimal solution for each trajectory segment efficiently and connect them together in a smooth trajectory.

Show All
TABLE I Simulation Benchmark of 6-DOF Robot Planning
Table I- Simulation Benchmark of 6-DOF Robot Planning
Fig. 5. - A 2D example of trajectory splitting. The planning problem is split into three segments and solved in a distributed manner. The trajectory is initialized using linear interpolation. As the optimization begins, each segment is very short and there is a large splitting error since the individual problems have an objective that minimizes segment distance. As the optimization progresses, the consensus update reduces the splitting error and a continuous, smooth trajectory is obtained.
Fig. 5.

A 2D example of trajectory splitting. The planning problem is split into three segments and solved in a distributed manner. The trajectory is initialized using linear interpolation. As the optimization begins, each segment is very short and there is a large splitting error since the individual problems have an objective that minimizes segment distance. As the optimization progresses, the consensus update reduces the splitting error and a continuous, smooth trajectory is obtained.

Show All
B. Simulation in 2D

We first evaluate the effectiveness of the proposed trajectory splitting algorithm in a 2D scene with a sphere obstacle.
Fig. 6. - Parameter sweeps for the trajectory splitting algorithm, where Trajsplit_2, Trajsplit_3, Trajsplit_5 denote using the splitting algorithm to separate a trajectory into two, three, and five pieces. Computation time decreases as splitting error tolerance in the stopping criterion is increased. In general, increasing the number of split segments does not guarantee a shorter computation time. For these problems, three segments provide a nice balance between the number of ADMM iterations and subproblem complexity.
Fig. 6.

Parameter sweeps for the trajectory splitting algorithm, where Trajsplit_2, Trajsplit_3, Trajsplit_5 denote using the splitting algorithm to separate a trajectory into two, three, and five pieces. Computation time decreases as splitting error tolerance in the stopping criterion is increased. In general, increasing the number of split segments does not guarantee a shorter computation time. For these problems, three segments provide a nice balance between the number of ADMM iterations and subproblem complexity.

Show All

The collision avoidance constraint is formulated as:
∥ ∥ ∥ [ p x p y ] − [ p o x p o y ] ∥ ∥ ∥ 2 ≥ r 2 o (20)
View Source Right-click on figure for MathML and additional features. \begin{equation*}{\left\| {\left[ {\begin{array}{c} {{p_x}} \\ {{p_y}} \end{array}} \right] - \left[ {\begin{array}{c} {{p_{ox}}} \\ {{p_{oy}}} \end{array}} \right]} \right\|^2} \geq r_o^2\tag{20}\end{equation*} where p o and r o denote the obstacle center position and its radius. As we can see from the simulation results in Fig. 5 , the trajectory is split into three segments. The evolution of the solution initially produces short segments with a large splitting error that is refined through the consensus iteration to produce the final smooth trajectory.

C. Simulation on Multi-jointed Robot

We benchmarked the proposed trajectory splitting algorithm against existing state-of-the-art motion planners and optimization solvers, which include sampling-based methods RRT, RRT*, LBKPIECE in OMPL/Moveit, and an optimization-based method CHOMP in MoveIt using default parameters. We also implemented an optimization baseline using IPOPT with FCL as the collision checker. Our implementation of the trajectory splitting planner is based on the IPOPT baseline and uses the python multiprocess library to achieve parallelization.
Fig. 7. - Parameter sweeps for the trajectory splitting algorithm, where Trajsplit_2, Trajsplit_3, Trajsplit_5 denote using the splitting algorithm to separate a trajectory into two, three, and five pieces. Reducing the splitting error tolerance results in smoother trajectories at the cost of greater computation time. These problems show a good reasonable trade-off in quality and performance by setting the splitting error tolerance to 10 degrees with two or three split segments.
Fig. 7.

Parameter sweeps for the trajectory splitting algorithm, where Trajsplit_2, Trajsplit_3, Trajsplit_5 denote using the splitting algorithm to separate a trajectory into two, three, and five pieces. Reducing the splitting error tolerance results in smoother trajectories at the cost of greater computation time. These problems show a good reasonable trade-off in quality and performance by setting the splitting error tolerance to 10 degrees with two or three split segments.

Show All

Fig. 4 shows the 4 of the benchmark results obtained from the proposed trajectory splitting algorithm. We manually selected 5 start poses and 5 end poses to construct 25 unique planning problems. The planning time limit is set to 5 seconds. Since MoveIt planners can only compute paths instead of trajectories, to make the comparison fair, we also only compute the joint path and ignore the dynamics constraint in (18) for this benchmark. The initialization for the IPOPT baseline and the trajectory splitting algorithms is set to be a straight line.

Table. I shows the benchmark results. TrajSplit_3 and TrajSplit_5 denote the proposed splitting methods that split a trajectory into 3 and 5 segments respectively. Sampling-based planners, such as RRT, and LBKPIECE performs well in these tasks. They all achieve a 100% success rate in this setting. However, since those sampling planners are stochastic, they may generate different paths for the same problem, and the computation time and solution quality also has a very large variance (for example, RRT is normally efficient to deal with those problems, but sometimes it may take over 3.7 seconds to obtain a sub-optimal solution). We noticed in our benchmarking, that the sampling-based planners sometimes generated non-intuitive motion with much larger average path lengths than the optimization-based planners. RRT* is a sampling-based method that tries to deal with the optimality problem. However, for all our tasks, RRT* was not able to find an optimal solution within the 5 seconds limit and the solution quality was qualitatively poor relative to the other optimization-based planners we compared. Similar results have been reported in other paper [11] . These data corroborate that RRT* is not as competitive in terms of computation efficiency.

The CHOMP algorithm in MoveIt was able to obtain optimal paths efficiently. However, the robustness of the optimization-based planner was low. In our benchmark, the planner was often caught in a local minimum and incapable of finding a feasible solution when the start pose was close to the obstacle. In contrast, the IPOPT baseline was slower but more robust, and able to solve most of the problems, which was expected as IPOPT is built for general NLP and not for speed. Our proposed trajectory splitting method demonstrated a nice balance between speed and solution quality when the splitting error tolerance was set to 10 degrees and split into three segments. The splitting error is negligible considering the robot has 6 DOF. Trade-offs in quality and speed were straightforward by adjusting the number of splits and tolerance of the splitting error. However, the most efficient setup required balancing the number of segments that may benefit the computation time for a single primal update with additional ADMM iterations that may be required to meet the stopping criterion. The typical failure case of the proposed trajectory splitting algorithm comes from the misalignment of the splitting point that penetrates the obstacle. Due to the splitting of the trajectory, each segment tends to keep away from the obstacle. When the obstacle is thinner than the distance that results from the splitting error tolerance, the intermediate trajectory may penetrate the obstacle. We will address this problem in future work.

We further tested the behavior of our method by tuning hyperparameters: number of segments and splitting tolerance. We illustrate the variation of the computation time and path length for different splitting tolerance and different splitting segment numbers. As shown in Fig. 7 , splitting a trajectory into more pieces resulted in a longer path length due to the splitting residual. In practice, there was a trade-off between the computation time and the splitting residual tolerance as shown in Fig. 6 . To balance the solution quality and the efficiency, people may need to carefully tune these two parameters for different types of requirements.
D. Experiments

We tested the effectiveness of the trajectory splitting algorithm in a real-world scenario using a 6 DOF FANUC LRMATE 200id robot. As shown in Fig. 8 , the robot picks a bottle from a wooden chair and places it into a bookshelf. The trajectory was initialized with linear interpolation in joint space and the problem was split into two segments with a splitting tolerance of 10 degrees. The solution was obtained from Alg. 1 , and the assembled trajectory was sent as a list of joint space positions to the robot for execution. The snapshots from the video show the continuity of the complete trajectory, free from any collision. Note that with this splitting error tolerance a small motion artifact is observable between the two split segments.
Fig. 8. - Experiment snapshots. The robot picks a bottle onto the bookshelf. Using the proposed trajectory splitting framework, the problem is split into two pieces and solved in a distributed manner. The splitting happens in the middle of the trajectory, and we can observe a tiny splitting residual during the execution in the experiment video.
Fig. 8.

Experiment snapshots. The robot picks a bottle onto the bookshelf. Using the proposed trajectory splitting framework, the problem is split into two pieces and solved in a distributed manner. The splitting happens in the middle of the trajectory, and we can observe a tiny splitting residual during the execution in the experiment video.

Show All
SECTION VI.
Conclusions

Modern computational hardware is replete with opportunities for parallel computation, e.g. multi-core CPUs, GPUs, and TPUs. Our algorithm offers a novel scheme to exploit parallelism in trajectory optimization and a framework for balancing trajectory quality with computational speed. Planning tasks that require fast solve times can choose fewer segments and looser splitting tolerances to obtain quick, reasonable quality solutions. Conversely, high-accuracy trajectories can be obtained with increased segments and tighter splitting tolerance with modest increases in planning time.

For the limitations, the current implementation requires tuning of hyper-parameters. Furthermore, tight-tolerance for reducing jumps in the trajectory at the split points currently requires many more ADMM updates to achieve consensus, which can eat away gains made through parallelizing the sub-problems. In future works, we plan to incorporate advances from Fast ADMM [24] to address slow consensus convergence and explore using different optimizers for solving the subproblems to further improve robustness and speed.

Authors
Figures
References
Citations
Keywords
Metrics
Media
   Back to Results   
More Like This
Path Planning of Mobile Robot Based on Hybrid Multi-Objective Bare Bones Particle Swarm Optimization With Differential Evolution

IEEE Access

Published: 2018
Mobile Robot Path Planning by Improved Brain Storm Optimization Algorithm

2018 IEEE Congress on Evolutionary Computation (CEC)

Published: 2018
Show More
References
1. J. Schulman, J. Ho, A. X. Lee, I. Awwal, H. Bradlow and P. Abbeel, "Finding locally optimal collision-free trajectories with sequential convex optimization" in Robotics: science and systems, Citeseer, vol. 9, no. 1, pp. 1-10, 2013.
Show in Context CrossRef Google Scholar
2. P. T. Boggs and J. W. Tolle, "Sequential quadratic programming", Acta numerica , vol. 4, pp. 1-51, 1995.
Show in Context CrossRef Google Scholar
3. S. M. LaValle, Planning algorithms., Cambridge university press, 2006.
Show in Context CrossRef Google Scholar
4. F. Rey, Z. Pan, A. Hauswirth and J. Lygeros, "Fully decentralized admm for coordination and collision avoidance", 2018 European Control Conference (ECC) , pp. 825-830, 2018.
Show in Context View Article Full Text: PDF (1089) Google Scholar
5. M. Li, N. Cheng, J. Gao, Y. Wang, L. Zhao and X. Shen, "Energy-efficient uav-assisted mobile edge computing: Resource allocation and trajectory optimization", IEEE Transactions on Vehicular Technology , vol. 69, no. 3, pp. 3424-3438, 2020.
Show in Context View Article Full Text: PDF (1380) Google Scholar
6. B. O’Donoghue, G. Stathopoulos and S. Boyd, "A splitting method for optimal control", IEEE Transactions on Control Systems Technology , vol. 21, no. 6, pp. 2432-2442, 2013.
Show in Context View Article Full Text: PDF (240) Google Scholar
7. V. Sindhwani, R. Roelofs and M. Kalakrishnan, "Sequential operator splitting for constrained nonlinear optimal control", 2017 American Control Conference (ACC) , pp. 4864-4871, 2017.
Show in Context View Article Full Text: PDF (578) Google Scholar
8. L. E. Kavraki, P. Svestka, J.-C. Latombe and M. H. Overmars, "Probabilistic roadmaps for path planning in high-dimensional configuration spaces", IEEE transactions on Robotics and Automation , vol. 12, no. 4, pp. 566-580, 1996.
Show in Context View Article Full Text: PDF (1960) Google Scholar
9. J. J. Kuffner and S. M. LaValle, "Rrt-connect: An efficient approach to single-query path planning", Proceedings 2000 ICRA. Millennium Conference. IEEE International Conference on Robotics and Automation. Symposia Proceedings (Cat. No. 00CH37065) , vol. 2, pp. 995-1001, 2000.
Show in Context View Article Full Text: PDF (758) Google Scholar
10. M. Zucker, N. Ratliff, A. D. Dragan, M. Pivtoraiko, M. Klingensmith, C. M. Dellin, et al., "Chomp: Covariant hamiltonian optimization for motion planning", The International Journal of Robotics Research , vol. 32, no. 9-10, pp. 1164-1193, 2013.
Show in Context CrossRef Google Scholar
11. J. Meijer, Q. Lei and M. Wisse, "Performance study of single-query motion planning for grasp execution using various manipulators", 2017 18th International Conference on Advanced Robotics (ICAR) , pp. 450-457, 2017.
Show in Context View Article Full Text: PDF (1386) Google Scholar
12. M. Kalakrishnan, S. Chitta, E. Theodorou, P. Pastor and S. Schaal, "Stomp: Stochastic trajectory optimization for motion planning", 2011 IEEE international conference on robotics and automation. , pp. 4569-4574, 2011.
Show in Context View Article Full Text: PDF (3679) Google Scholar
13. M. Mukadam, J. Dong, X. Yan, F. Dellaert and B. Boots, "Continuous-time gaussian process motion planning via probabilistic inference", The International Journal of Robotics Research , vol. 37, no. 11, pp. 1319-1340, 2018.
Show in Context CrossRef Google Scholar
14. C. Liu, C.-Y. Lin and M. Tomizuka, "The convex feasible set algorithm for real time optimization in motion planning", SIAM Journal on Control and optimization , vol. 56, no. 4, pp. 2712-2733, 2018.
Show in Context CrossRef Google Scholar
15. S. Boyd, N. Parikh and E. Chu, Distributed optimization and statistical learning via the alternating direction method of multipliers., Now Publishers Inc, 2011.
Show in Context Google Scholar
16. D. P. Bertsekas, "Nonlinear programming", Journal of the Operational Research Society , vol. 48, no. 3, pp. 334-334, 1997.
Show in Context CrossRef Google Scholar
17. Y. Wang, W. Yin and J. Zeng, "Global convergence of admm in nonconvex nonsmooth optimization", Journal of Scientific Computing , vol. 78, no. 1, pp. 29-63, 2019.
Show in Context CrossRef Google Scholar
18. Q. Liu, X. Shen and Y. Gu, "Linearized admm for nonconvex nonsmooth optimization with convergence analysis", IEEE Access , vol. 7, pp. 76 131-76 144, 2019.
Show in Context View Article Full Text: PDF (3806) Google Scholar
19. J. Pan, S. Chitta and D. Manocha, "Fcl: A general purpose library for collision and proximity queries", 2012 IEEE International Conference on Robotics and Automation. , 2012, 3866.
Show in Context View Article Full Text: PDF (1445) Google Scholar
20. A. Wächter and L. T. Biegler, "On the implementation of an interior-point filter line-search algorithm for large-scale nonlinear programming", Mathematical programming , vol. 106, no. 1, pp. 25-57, 2006.
Show in Context CrossRef Google Scholar
21. A. Wächter and L. T. Biegler, "Line search filter methods for nonlinear programming: Motivation and global convergence", SIAM Journal on Optimization , vol. 16, no. 1, pp. 1-31, 2005.
Show in Context CrossRef Google Scholar
22. Z. Zhou and Y. Zhao, "Accelerated admm based trajectory optimization for legged locomotion with coupled rigid body dynamics", 2020 American Control Conference (ACC) , pp. 5082-5089, 2020.
Show in Context View Article Full Text: PDF (1070) Google Scholar
23. A. Colesanti and D. Hug, "Hessian measures of semi-convex functions and applications to support measures of convex bodies", manuscripta mathematica , vol. 101, no. 2, pp. 209-238, 2000.
Show in Context CrossRef Google Scholar
24. T. Goldstein, B. O’Donoghue, S. Setzer and R. Baraniuk, "Fast alternating direction optimization methods", SIAM Journal on Imaging Sciences , vol. 7, no. 3, pp. 1588-1623, 2014.
Show in Context CrossRef Google Scholar
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
