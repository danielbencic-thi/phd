University of Pennsylvania
ScholarlyCommons
Publicly Accessible Penn Dissertations 2013
Robot Motion Planning Under Topological Constraints
Soonkyum Kim University of Pennsylvania, soonkyum@seas.upenn.edu
Follow this and additional works at: https://repository.upenn.edu/edissertations Part of the Mechanical Engineering Commons, and the Robotics Commons
Recommended Citation Kim, Soonkyum, "Robot Motion Planning Under Topological Constraints" (2013). Publicly Accessible Penn Dissertations. 883. https://repository.upenn.edu/edissertations/883
This paper is posted at ScholarlyCommons. https://repository.upenn.edu/edissertations/883 For more information, please contact repository@pobox.upenn.edu.

Robot Motion Planning Under Topological Constraints
Abstract My thesis addresses the the problem of manipulation using multiple robots with cables. I study how robots with cables can tow objects in the plane, on the ground and on water, and how they can carry suspended payloads in the air. Specifically, I focus on planning optimal trajectories for robots.
Path planning or trajectory generation for robotic systems is an active area of research in robotics. Many algorithms have been developed to generate path or trajectory for different robotic systems. One can classify planning algorithms into two broad categories. The first one is graph-search based motion planning over discretized configuration spaces. These algorithms are complete and quite efficient for finding optimal paths in cluttered 2-D and 3-D environments and are widely used [48]. The other class of algorithms are optimal control based methods. In most cases, the optimal control problem to generate optimal trajectories can be framed as a nonlinear and non convex optimization problem which is hard to solve. Recent work has attempted to overcome these shortcomings [68]. Advances in computational power and more sophisticated optimization algorithms have allowed us to solve more complex problems faster. However, our main interest is incorporating topological constraints. Topological constraints naturally arise when cables are used to wrap around objects. They are also important when robots have to move one way around the obstacles rather than the other way around. Thus I consider the optimal trajectory generation problem under topological constraints, and pursue problems that can be solved in finite-time, guaranteeing global optimal solutions.
In my thesis, I first consider the problem of planning optimal trajectories around obstacles using optimal control methodologies. I then present the mathematical framework and algorithms for multi-robot topological exploration of unknown environments in which the main goal is to identify the different topological classes of paths. Finally, I address the manipulation and transportation of multiple objects with cables. Here I consider teams of two or three ground robots towing objects on the ground, two or three aerial robots carrying a suspended payload, and two boats towing a boom with applications to oil skimming and clean up. In all these problems, it is important to consider the topological constraints on the cable configurations as well as those on the paths of robot. I present solutions to the trajectory generation problem for all of these problems.
Degree Type Dissertation
Degree Name Doctor of Philosophy (PhD)
Graduate Group Mechanical Engineering & Applied Mechanics
First Advisor Vijay Kumar
Keywords Motion Planning, Robot, Topology
Subject Categories Mechanical Engineering | Robotics
This dissertation is available at ScholarlyCommons: https://repository.upenn.edu/edissertations/883

ROBOT MOTION PLANNING UNDER TOPOLOGICAL CONSTRAINTS
Soonkyum Kim
A DISSERTATION in
Mechanical Engineering and Applied Mechanics Presented to the Faculties of the University of Pennsylvania
in Partial Fulﬁllment of the Requirements for the
Degree of Doctor of Philosophy
2013
Supervisor of Dissertation
Vijay Kumar, Professor Department of Mechanical Engineering and Applied Mechanics
Graduate Group Chairperson
Prashant K. Purohit, Associate Professor Department of Mechanical Engineering and Applied Mechanics Dissertation Committee Mark Yim, Professor, Department of Mechanical Engineering and Applied Mechanics Vijay Kumar, Professor, Department of Mechanical Engineering and Applied Mechanics Robert Ghrist, Professor, Department of Mathematics Maxim Likhachev, Assistant Research Professor, Robotics Institute, Carnegie Mellon University

ROBOT MOTION PLANNING UNDER TOPOLOGICAL CONSTRAINTS
COPYRIGHT 2013 Soonkyum Kim
This work is licensed under the Creative Commons Attribution-NonCommercialShareAlike 3.0 License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/.

Acknowledgments
First, I would like to express my sincere gratitude toward my advisor, Prof. Vijay Kumar for his ceaseless, dedicated and invaluable advise and guidance during the course of my graduate studies at GRASP Laboritory in the University of Pennsylvania. I would also like to heartily thank Prof. Mark Yim and Prof. Maxim Likhachev for their valuable time and effort in serving as my dissertation committee members. I also like to thank Prof. Robert Ghrist, not only for being on my dissertation committee, but also for collaborating on the topological exploration problem. I would also like to thank Dr. Subhrajit Bhattacharya for valuable discussions and for collaborating on many of the problems presented in this thesis. I would like to express my gratitude toward Prof. Frank C. Park who introduced me to the ﬁeld of robotics.
My sincere appreciation goes to Dr. Koushil Sreenath for his collaboration on the problem of optimal trajectory generation under topological constraints. I would also like to thank Dr. Nathan Michael for collaborating on the aerial manipulation problem, and Dr. Peng Cheng for collaborating on the cooperative towing problem. My sincere thanks goes to Dr. Jornathan Fink for his collaboration on both the aforesaid problems. I would like to thank Prof. Gaurav Sukhatme and Hordur Heidarsson of USC for their collaboration on the ﬁeld experiments in the problem related to manipulation of a set of objects.
Finally, I would like to thank my family. I would like to thank my brother Sanggyum, with whom I have enjoyed endless discussions about various control problems. I thank my sister-in-law, Christina Kang-Yi, and her husband, John Chanu Yi for their warm support and concern. I sincerely appreciate my parents’ devotion and sacriﬁce. I would like to express my gratitude toward my parents-in-law for their devotion and for their adorable daughter. And, I would like to epxress my love to my little angels, David and Rachael, and my wife, Minki.
iii

ABSTRACT
ROBOT MOTION PLANNING UNDER TOPOLOGICAL CONSTRAINTS
Soonkyum Kim
Vijay Kumar
My thesis addresses the the problem of manipulation using multiple robots with cables. I study how robots with cables can tow objects in the plane, on the ground and on water, and how they can carry suspended payloads in the air. Speciﬁcally, I focus on planning optimal trajectories for robots.
Path planning or trajectory generation for robotic systems is an active area of research in robotics. Many algorithms have been developed to generate path or trajectory for different robotic systems. One can classify planning algorithms into two broad categories. The ﬁrst one is graph-search based motion planning over discretized conﬁguration spaces. These algorithms are complete and quite efﬁcient for ﬁnding optimal paths in cluttered 2-D and 3-D environments and are widely used [48]. The other class of algorithms are optimal control based methods. In most cases, the optimal control problem to generate optimal trajectories can be framed as a nonlinear and non convex optimization problem which is hard to solve. Recent work has attempted to overcome these shortcomings [68]. Advances in computational power and more sophisticated optimization algorithms have allowed us to solve more complex problems faster. However, our main interest is incorporating topological constraints. Topological constraints naturally arise when cables are used to wrap around objects. They are also important when robots have to move one way around the obstacles rather than the other way around. Thus I consider the optimal trajectory generation problem under topological constraints, and pursue problems that can be solved in ﬁnite-time, guaranteeing global optimal solutions.
In my thesis, I ﬁrst consider the problem of planning optimal trajectories around obstacles using optimal control methodologies. I then present the mathematical framework and algorithms for multi-robot topological exploration of unknown environments in which the main goal is to identify the different topological
iv

classes of paths. Finally, I address the manipulation and transportation of multiple objects with cables. Here I consider teams of two or three ground robots towing objects on the ground, two or three aerial robots carrying a suspended payload, and two boats towing a boom with applications to oil skimming and clean up. In all these problems, it is important to consider the topological constraints on the cable conﬁgurations as well as those on the paths of robot. I present solutions to the trajectory generation problem for all of these problems.
v

Contents

1 Introduction

1

1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

1.2 Literature review . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

1.3 Contribution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4

2 Preliminaries

5

2.1 Curves in (W − O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

2.2 Homology and Homotopy Invariants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

2.2.1 Homology of curves and Homology Invariants . . . . . . . . . . . . . . . . . . . . 5

2.2.2 Homotopy of curves and Homotopy Invariants . . . . . . . . . . . . . . . . . . . . 7

2.2.3 The Hurewicz map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.2.4 Augmented Graph . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

3 Trajectory Generation under Topological Constraints

12

3.1 Optimal Trajectory Generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

3.2 Optimal Trajectory with Homology Class Constraints . . . . . . . . . . . . . . . . . . . . . 15

3.2.1 Algorithm Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

3.2.2 Simulation Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3.3 Optimal Trajectory with Homotopy Class Constraints . . . . . . . . . . . . . . . . . . . . . 24

3.3.1 Algorithm Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

3.3.2 Simulation Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

3.4 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

4 Topological Exploration

29

4.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

4.2 The Quotient Space and H-signature . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

4.3 The Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

4.3.1 Representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

4.3.2 Multi-robot Exploration Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . 32

4.3.3 Distributed Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

4.4 Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

4.4.1 Partially Known Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

4.4.2 Simulations of Multi-Robot Topological Exploration . . . . . . . . . . . . . . . . . 38

vi

4.4.3 Experiment with a Single Robot . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 4.5 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

5 Manipulation with Cables

42

5.1 Cooperative Towing With Multiple Ground Robots . . . . . . . . . . . . . . . . . . . . . . 42

5.1.1 The Quasi-Static Model for Cooperative Towing . . . . . . . . . . . . . . . . . . . 42

5.1.2 Equilibrium Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

5.2 Kinematics and Statics of Cooperative Multi-Robot Aerial Manipulation with Cables . . . . 48

5.2.1 Kinematics of Planar Manipulation Systems . . . . . . . . . . . . . . . . . . . . . . 48

5.2.2 Direct Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

5.2.3 Direct problem: n = 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

5.2.4 Direct problem: n = 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

5.2.5 Stability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

5.3 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

6 Manipulation of A Set Of Objects

57

6.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

6.2 Problem Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

6.3 Separating Conﬁgurations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

6.4 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

6.4.1 Planning in Joint State-space . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64

6.4.2 Decoupled Planning: A Distributed Approach . . . . . . . . . . . . . . . . . . . . . 65

6.4.3 Sequential Planning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

6.5 Result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

6.5.1 Simulation Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

6.5.2 Dynamic Simulation and Fast Re-planning . . . . . . . . . . . . . . . . . . . . . . 71

6.5.3 Experiment Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

6.6 Sequential Manipulation of Large Number of Objects . . . . . . . . . . . . . . . . . . . . . 79

6.6.1 Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

6.6.2 Simulation Result . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

6.7 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

7 Conclusion

84

7.1 Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

7.2 Main Contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

7.3 Future Work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

A Heuristic distance function considering the homotopy class constraints

88

A.1 Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

A.2 Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91

vii

List of Figures
2.1 Illustration of homology class and homotopy class or curves. . . . . . . . . . . . . . . . . . 6 2.2 Examples of possible H-signature functions. . . . . . . . . . . . . . . . . . . . . . . . . . . 7 2.3 Examples of homotopy class invariant function on 2-dimensional plane. . . . . . . . . . . . 8 2.4 Examples where curves (τ1 and τ2) are homologous, but not homotopic. . . . . . . . . . . . 9 2.5 Example of augmented graph. The goal vertices of two different paths, τ1 and τ2, have the
same coordinates but considerd to be different vertex in the augmented graph. . . . . . . . . 11
3.1 The normal vector, ni,f , of the f th face of obstacle oi is pointing inward. p is an arbitrary point on the f thface. (a) An example of q ∈ Q when bi,f = 0. (b) An example of q ∈ Q when bi,f = 1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.2 (a) Overlapping subsets divided by values of binary variables representing each face of triangular obstacle. (b) Disjointed cells divided by values of binary variables representing each face but considering additional constraint. . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.3 An example of parallelogram obstacle. f is the index of each face. Red and magenta curves are infeasible trajectories between two feasible conﬁgurations, q1 and q2. Adjacent intermediate points(q3, q4 and q5) are satisfying additional constraint. . . . . . . . . . . . . . . . . 16
3.4 An example of calculating the h-signature with respect to a triangular obstacle. . . . . . . . 18 3.5 Starting from a piece-wise linear curve (cyan), we can progressively add points, to make the
trajectory smoother by increasing the order of differentiability by one at each step. . . . . . . 20 3.6 Simulation result of trajectory generation in four different homology classes with the same
initial conﬁguration (left bottom point) and ﬁnal conﬁgurations(right upper point). The ﬁrst obstacle is parallelogram and the second obstacle is triangle. The actual computation time(sec) and optimal costs are speciﬁed on the upper left corners of plots. (a) Hd = [−1, −1]T . (b) Hd = [−1, 0]T . (c) Hd = [0, −1]T . (d) Hd = [0, 0]T . . . . . . . . . . 22 3.7 Simulation result with anytime solutions. The computation time(sec) and optimal costs are speciﬁed on the upper left corners of each plot. . . . . . . . . . . . . . . . . . . . . . . . . 22 3.8 (a)-(d) Final trajectories in four different homology classes with two, three, four and ﬁve obstacles, respectively. (e)-(h) Cost of the trajectories along with computation time with two, three, four and ﬁve obstacles, respectively. The plots shows the change in cost with time plotted in log scale. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 3.9 An example of a trajectory corresponding to the word TPUVWQLJHG. . . . . . . . . . . . 24
viii

3.10 (a) Optimal trajectory without homotopy constraints (b)-(e) Trajectories with four different homotopy class constraints. The thick black curve is the optimal trajectory in each homotopy class and thin gray curves are the suboptimal trajectories for each word. The cost (J) for each case is speciﬁed on the upper left corners of plots. . . . . . . . . . . . . . . . . . . . . . . . 26
3.11 (a)-(e) Effect of varying the time distribution in each cell through iterations of the optimization (3.3.2). The number of iterations (itr) and cost are also speciﬁed on the upper left corner of each plot. Note that the cost converges to the local optimal cost of the case of Figure 3.10(b) in 6 iterations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
4.1 Partially explored environments. The group of robots (red dots) need to be split and deployed for exploration of the unknown regions (pale yellow region marked as L). The ﬁgures illustrate the distinction between frontier-based and topology-based deployments. . . . . . . . . 31
4.2 A simple illustration of a quotient map. The set L is collapsed to a point, q(L). Here we consider the Euclidean plane, R2, with its subset L being the entire region outside a small disk on the plane. Collapsing L to a single point gives us the topological 2-sphere. All nontrivial 1-cycles (or closed loops) that completely lie in L become trivial in the quotient space under the quotient map, q. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
4.3 Illustration of algorithm ToplogicalExplore. . . . . . . . . . . . . . . . . . . . . . . . . . . 33 4.4 Comparison between the frontier-based exploration algorithm (top row) of [100] and our
T opologicalExplore algorithm (bottom row) in a partially-known environment using 4 robots. The purple curves show parts of the planned paths, while black represents traversed paths. White is known/explored, while light yellow is the unknown region. . . . . . . . . . . 38 4.5 The SCARAB mobile robot platform [65] . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39 4.6 (a)-(h): Simulation result with 8 robots exploring an indoor ofﬁce-like environment. (i): Comparison of performance with frontier-based algorithm of [100] (in the same environment, with same number of robots and same initial conﬁgurations). . . . . . . . . . . . . . . 40 4.7 Experiment result with a single robot exploring an indoor ofﬁce-like environment. . . . . . . 40
5.1 Quasi-static manipulation: The object is supported by three support points, Si, with normal forces (out of the plane), λn,i and tangential frictional forces, λt,i. It is pulled by m cables, each exerting a force λc,j. Note the robot Rj pulls by moving the object with a prescribed (given) velocity, VRj . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
5.2 (Left) Arbitrary initial conﬁguration. (Right) Stable equilibrium conﬁguration. (This ﬁgure is taken from [24].) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
5.3 The equilibrium of two-robot towing. (This ﬁgure is taken from [24] and reproduced.) . . . 47 5.4 The planar system modeled as a four-bar-linkage. The suspended payload is the coupler with
an assumed center of mass at the middle point of the coupler. . . . . . . . . . . . . . . . . 49 5.5 A graphical depiction of the conditions presented in Proposition 5.2.2. (This ﬁgure is taken
from [40].) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52 5.6 A coupler curve with twelve equilibrium conﬁgurations. The stable and unstable conﬁgu-
rations are denoted by ﬁlled or open red diamonds. The stable conﬁgurations are shown in Figure 5.7. Note that tension constraints are ignored. . . . . . . . . . . . . . . . . . . . . . 56
ix

5.7 The six equilibrium conﬁgurations of Figure 5.6. Clearly Figures. 5.7(a)-5.7(c) are infeasible when considering tension constraints. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
6.1 The problem of separating the two types of objects. . . . . . . . . . . . . . . . . . . . . . . 58 6.2 An example of separating conﬁguration and a set of paths to the separating conﬁguration. . . 58 6.3 The solutions of object separating problem is not unique. . . . . . . . . . . . . . . . . . . . 59 6.4 An example of separating conﬁgurations achieve by intuition when considering point objects. 61 6.5 An example of separating conﬁgurations which requires smart controller for transporting. . . 61 6.6 Examples of separating conﬁgurations which do not satisfy Proposition 6.3.1. . . . . . . . . 63 6.7 Illustration for Proof of Proposition 6.3.2. . . . . . . . . . . . . . . . . . . . . . . . . . . . 63 6.8 The environment and its discretization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64 6.9 Decoupled and distributed planning: Optimal paths with different h-signatures found for the
two robots in parallel threads, and costs of compatible pairs are compared to ﬁnd the optimal compatible pair. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66 6.10 An example of heuristic cost(the sum of the length of green lines) of the path start from the green circle to the boundary while the desired homotopy class is hd = “r2+r3+”. In this example, we ignore the feasibility of the path with respect to objects. . . . . . . . . . . . . . 68 6.11 A simple 30 × 30 environment with r = b = 3. The green & yellow are the paths of the robots. The rays emanating from ζj are also shown. The dark gray segment indicates the initial cable conﬁguration. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 6.12 Decoupled, distributed plans. Initial cable is shown in gray/black. Paths are in green and yellow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70 6.13 Sequential plan. Initial cable is shown in gray/black. Paths are in green and yellow. . . . . . 71 6.14 The dynamic model showing a discrete model of the cable consisting of n rigid segments and two rigid circular objects. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72 6.15 The three types of contacts considered in the model. . . . . . . . . . . . . . . . . . . . . . . 74 6.16 When the center of an object lies in the yellow region, we need to check for contact between the ith segment of the cable and the object. The boundary of yellow region (i.e. the green lines) are perpendicular to (wi − wi−1). In this example, we need to check for contact between ith segment and o1, but not o2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75 6.17 Dynamic simulation for separation of objects. The gray curve is the cable, with black dots marking robots at its ends. Green curves are the planned paths. Magenta curves are the robot footprints. Red & blue disks are the rigid freely-ﬂoating objects. See http://youtu.be/GyCn8yDzO0 for video. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 6.18 Experiments with Autonomous Boats conducted by H. K. Heidarsson, University of Southern California [56]. Red and blue circles are Buoys (objects). Thin gray curve is the planned paths of two ASVs. The Black curve is the current cable conﬁguration. See http://youtu.be/vGgca2w2UdA for video. . . . . . . . . . . . . . . . . . . . . . . . . . . . 78 6.19 A large problem. Red and blue dots are object. Green curves are cable-robot teams. Light blue and red boxes are the baskets to bring objects. The dashed line is a smallest box to enclose all objects to be manipulated. Gray box is the workspace of the problem. The yellow boxes are the workspace of each cable-robot team. . . . . . . . . . . . . . . . . . . . 79
x

6.20 An example of coarse grid. the given workspace is split into set of cells whose boundaries are the reference rays, the cyan lines, and the grey lines. the topology class of path does not change when crossing the grey lines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
6.21 Dynamic simulation for separation of a large number of objects with multiple cable-robot teams via sequential manipulation. The red and blue dots are the objects. The green curves are the cables. The red and blue ’s are the baskets. Yellow boxes are the workspace of each cable-robot team. Magenta curves are the paths of the robots. See http://youtu.be/ZHrEIo8dGDA for video. . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
A.1 The cost of chpr(qi, rks) is sum of the length of green lines. This Figure illustrate the case when there is no reference line between the initial conﬁguration and goal reference line. The length of dashed green line can be replaced by proper admissible heuristic function based on graph structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
A.2 Examples of calculation of heuristic cost function. . . . . . . . . . . . . . . . . . . . . . . . 91
xi

Chapter 1
Introduction
1.1 Introduction
Path planning or trajectory generation for robotic systems is an active area of research in robotics. Many algorithms have been developed to generate path or trajectory for different robotic systems. One can classify planning algorithms into two broad categories. The ﬁrst one is graph-search based motion planning over discretized conﬁguration spaces. These algorithms are complete and quite efﬁcient for ﬁnding optimal paths in cluttered 2-D and 3-D environments and are widely used [48]. The other class of algorithms are optimal control based methods. In most cases, the optimal control problem to generate optimal trajectories can be framed as a nonlinear and non convex optimization problem which is hard to solve. Recent work has attempted to overcome these shortcomings [68]. Advances in computational power and more sophisticated optimization algorithms have allowed us to solve more complex problems faster. However, our main interest is incorporating topological constraints. Topological constraints naturally arise when cables are used to wrap around objects. They are also important when robots have to move one way around the obstacles rather than the other way around. Thus I consider the optimal trajectory generation problem under topological constraints, and pursue problems that can be solved in ﬁnite-time, guaranteeing global optimal solutions.
Early works on path planning or trajectory generation problem discussed the algorithms for mobile robots on the plane. Time optimal trajectories of differential drive mobile robots, which can rotate in position, can be computed by following sequence of primitive motions of rotating in position and straight moves [5]. If the vehicle has minimum turning radius, then the shortest path will consist of a sequence of arcs and straight lines [79]. Also, in [37] the authors ﬁnd smooth shortest path with restriction on average curvature. Elastic bands introduced the algorithm to deform the path mobile robots in dynamic environments [78], which has been extended to mobile manipulation problem [22, 103]. Of course, ﬁnding smooth optimal trajectory is still one of active research topic. Recently, such problem has been extended to 3D path planning of UAVs [64].
However, the development of communication and sensing allows us to control multiple robots to accomplish complicated tasks which are too hard or take too long for a single robot [8]. Search-and-rescue or exploration problem is one of suitable examples to show the necessity of utilizing multiple robots [11, 17, 87]. The most popular technique to efﬁciently deploy the groups of robots is frontier-based planning [102]. In frontier-based algorithm, two paths or trajectories are different if they reach different frontiers. However, the frontier is sensitive with sensor noise or resolution of the map. We are interested in robust algorithm to
1

distinguish the class of paths or trajectories. Also, we want to ﬁnd optimal paths or trajectories in different classes.
Cables are widely used in mechanical systems to transfer actuator powers. However, humans utilize cables or ropes to carry or manipulate various objects and there has been active research on utilizing cables in robot planning and control. We can transport a payload by towing with cables. Usually, this method requires one or multiple robot to carry a single payload. We can manipulate a larger number of small objects by skimming via cable. For efﬁciently manipulate objects, it is necessary to consider the conﬁguration of the cable in planning and control.
The topology can give us the answer of these problem. The paths or trajectories are different if they are in different topology classes. Also, the objects separation problem can be formulated to path planning problem with topological constraints of the cable conﬁguration and robot paths.
In my thesis, I ﬁrst consider the problem of planning optimal trajectories around obstacles using optimal control methodologies. I then present the mathematical framework and algorithms for multi-robot topological exploration of unknown environments in which the main goal is to identify the different topological classes of paths. Finally, I address the manipulation and transportation of multiple objects with cables. Here I consider teams of two or three ground robots towing objects on the ground, two or three aerial robots carrying a suspended payload, and two boats towing a boom with applications to oil skimming and clean up. I present solutions to the trajectory generation problem for all of these problems.
1.2 Literature review
Trajectory generation problem for robotic systems is one of the most active areas in robotics research. Some literatures focus on ﬁnding optimal trajectories in convex or unbounded spaces [6, 19]. However, the development of computational capacities allows algorithms for generating trajectories in cluttered, non-convex environments with kinematic and dynamic constraints in the form of constraints on communication, coverage, environment, time, etc (see kinodynamic planners [35], RRT trees [61], LQR trees [94], Elastic Roadmaps [103] and references within). Most of the algorithms are developed to ﬁnd optimal trajectories satisfying feasibility constraints. However, there have also been considerable amount of research interest in algorithms for generating trajectories for multi-agent problems [47, 28, 105]. In such problems it is often required that each robot follows different trajectories to cover or sense the whole work space as in searchand-rescue or surveillance problems. This brings forth the necessity of ﬁnding trajectories in topologically different classes. This requires that we impose constraints on the homotopy classes of the trajectories accordingly. However, in many practical robotic problems, homology class constraints act a suitable and convenient substitute for homotopy class constraints [14].
Early attempts at classifying homotopy classes in two dimensions include geometric methods [50, 46], homotopy preserving probabilistic road-map constructions [83], and triangulation-based path planning [27]. Two trajectories are said to be homotopic if one can be continuously deformed to another without intersecting any obstacle. Each set of trajectories that are homotopic forms an equivalence class, called a homotopy class. Considering laser beams as reference lines, topology of the path can be used to localize agents, compare homotopy class of paths and ﬁnd winding number of path [98], which can be extended to localization of multiple robots [96]. However, in many practical robotic problems, homology class constraints act as suitable and convenient substitutes for homotopy class constraints [15].
2

Exploration and mapping have been treated quite extensively in the robotics literature. The general problem can be formulated as ﬁnding the next best view or pose [77] to acquire information required to build a map of the environment [88]. In most settings, the spatial representation of the map is based on metric information. Indeed approaches like metric-based multi-robot coordinated exploration have been studied widely in the past [11, 17, 87]. In decision-theoretic approaches to exploration, mutual information and entropy are often used [87, 89, 85, 95] to guide robots to perform efﬁcient exploration. Simpler approaches involving the identiﬁcation of frontiers and segmentation representing the boundaries between unexplored and explored regions have also been widely used for deployment of robots in exploration and mapping of unknown or partially known environments [102, 41, 100].
The advantages of using ropes with robots for manipulation were demonstrated by Donald et al [34]. An interesting problem that arises in these settings is the modeling of the shape of the cable and the motion planning for the robots to control the position and shape of the cable. Motion planning for manipulation of rope-like ﬂexible objects is discussed in [82]. The problem of entangling and disentangling knots and the motion planning for this problem has been addressed in [60].
From the standpoint of robotics, towing is an important manipulation process [63]. The kinematics and dynamics of cable-actuated, parallel manipulators, which have been studied extensively [75, 20, 92, 99]. However, this body of literature primarily addresses the control of the cable extensions or forces in order to manipulate the payload. In contrast, towing involves cables of ﬁxed length where manipulation is accomplished by controlling the motions of the ”pivot points” in the parallel manipulators. While manipulation using cables has been studied in the context of distributed manipulation [33, 31, 32], these papers do not address the mechanics or control of the cooperative manipulation task.
The use of robots to tow objects using cables is discussed in [53, 23]. In [23], Cheng et al establish the quasi-static towing problem with n cables has a unique solution under certain conditions. In other words, if the robot motions are known, there is instantaneously a unique object motion. An extension of these ideas leads to using a cable with its ends tied to robots to cage and tow objects. Indeed this method is widely used in skimming operations on water surfaces [81, 54]. A description of the dynamics of such systems and an analysis of the problem of cooperative skimming are provided in [12, 4]. However, this work does not explicitly address the manipulation of objects.
In [66], manipulation and transportation with three aerial robots permits full six-dimensional pose control of a cable-actuated payload in three-dimensions despite the fact that the system is underactuated and limited by unilateral tension constraints for speciﬁc robots-cables-platform conﬁgurations. Aerial towing, the manipulation of a payload suspended by a cable from a moving aerial robot, has been studied in [70]. It is quite clear that the control of all six degrees of freedom requires more than one aerial robot and multiple cables. The underlying mechanics in such systems is closely related to the mechanics of cable-actuated parallel manipulators in three dimensions. In both cases, the position and orientation of the suspended payload can only be obtained by solving the kinematic equations and the equations of static equilibrium. The equilibrium solutions are conﬁgurations in which the gravity wrench is equilibrated by the wrenches exerted by the n cables. This means that the lines of action of the n cables can only belong to certain subspaces which are linear complexes (for n = 5), linear congruences (for n = 4) or reguli (for n = 3) [51, 76]. For n < 3, it is not possible to achieve an arbitrary position and orientation.
The cooperative aerial manipulation problem is more related to cable-actuated parallel manipulators in three dimensions, where in the former the platform pose is affected by robot positions and in the latter pose
3

control is accomplished by varying the lengths of multiple cable attachments. These systems offer similar workspace [92, 99], control [73, 74], and analysis [20].
The problem of ﬁnding a hypersurface separating two types of objects is studied as part of statistical classiﬁcation problems [18, 93]. However such methods are susceptible to ﬁnding curves that can have disjoint components, do not have guarantees on optimality, and are statistical in nature.
1.3 Contribution
The ﬁrst contribution of this thesis is generating an optimal trajectory that minimizes an integral cost functional (which depends on the trajectory), while also respecting kinematic constraints of the system, avoiding obstacles, and constraining the trajectory to a particular topology class. Although several of these subproblems have been solved separately (see [35, 61, 94, 97, 13, 14]), there is no literature, to our knowledge, that addresses the combined problem described above. We suggest the trajectory generation problem under topology class constraints which can be formulated as a MIQP or QP. This method can be used for trajectory generation for differentially-ﬂat systems [72] with a two-dimensional ﬂat output space, such as a kinematic car [71], or a tricycle robot [7], which not only produces a trajectory respecting the homology constraint, but also provides the nominal feedforward forces (due to the differential-ﬂatness property,) for use in feedback control for trajectory tracking.
The second contribution of this thesis is to present the mathematical framework and algorithms for multirobot topological exploration of unknown environments in which the main goal is to identify the different topological classes of paths. We consider two-dimensional conﬁguration spaces. At any point in time, the robot’s map consists of known, partially-mapped obstacles. The unknown, yet-to-be-explored area is mapped to a single point, thus giving us a quotient space. The topological classes on the quotient space allows us to deﬁne topological classes of paths connecting a robot pose to the unknown region in the original conﬁguration space. Robots explore this conﬁguration space choosing different homology classes when confronted by obstacles or walls.
The last contribution of this thesis is to manipulate multiple objects with only two robots connected with a cable. We will demonstrate how to control two robots efﬁciently to manipulate selected objects in the presence of other objects. The ﬁrst key contribution is a topological description of the problem of separating two sets of objects and the algebraic formulation of the separation problem. The second contribution is a complete motion planning algorithm that relies on graph search [25] to drive the robots in order to achieve separation and then transport the objects to speciﬁed destinations. We also derive a decoupled algorithm that has the advantage of only requiring to plan in the individual robot’s conﬁguration space instead of the joint state-space. To ﬁnd proper conﬁguration of the cable, we will restrict the topology class of the cable connecting two robots. Also we expand this problem to manipulate a large number of objects with multiple pairs of cable-robot teams.
4

Chapter 2
Preliminaries

In this chapter, we will brieﬂy review topology of paths/trajectories of robots and cables, which can be considered as a curve in the workspace.

2.1 Curves in (W − O)

Let W ⊂ R2 be a 2-dimensional simply connected and bounded region. Suppose it contains a set of objects,

O = O1 ∪ O2 ∪ · · · ∪ On ⊆ W , where O1, O2, · · · , On are n counts of objects. Each object, Oj is assumed

to be connected.

Both robot paths/trajectories and cable conﬁgurations are 1-dimensional curves in (W − O). They can

thus be deﬁned as continuous maps from the line segment [0, 1] to (W − O). We say a curve, γ : [0, 1] →

(W − O), is embedded [69] if γ(t) = γ(t ), ∀t = t (i.e. the curve does not intersect itself).

For a given curve, γ, we deﬁne −γ : t → γ(1 − t). That is, −γ is the same curve as γ, but with

opposite orientation. The line integral of a differential 1-form, ω = f dx + g dy, over γ is deﬁned as

γ ω :=

1 0

(f

γ˙ x

+ gγ˙y)

dt.

2.2 Homology and Homotopy Invariants
2.2.1 Homology of curves and Homology Invariants
Deﬁnition 2.2.1 (Homology classes of curves). Two curves γ1, γ2 : [0, 1] → (W − O) connecting the same start and end points, are homologous (or belong to the same homology class) iff γ1 together with γ2 (the latter with opposite orientation) forms the complete boundary of a 2-dimensional manifold embedded in (W − O) (not containing/intersecting any of the objects/obstacles) as shown in Figure 2.1(a) [15, 49].
A homology invariant is a function, H, from the space of all curves in (W − O) (with ﬁxed end points) to another much smaller space (in this case, a vector space), such that H(γ1) = H(γ2) iff γ1 is homologous to γ2. In [15] a homology class invariant (called the H-signature) was proposed, which is based on simple

5

O1

τ1

A

τ2

xs

O2

xg -τ3
-τ2 O3
τ3

O1

τ1

τ2

xs

O2

xg
O3 τ3

(a) τ1 is homologous to τ2 since τ1 −τ2 forms A, the (b) τ1 is homotopic to τ2 since there is a continuous se-

complete boundary of a 2-dimensional manifold embedded quence of trajectories representing deformation of one into

in (W − O). τ3 belongs to a different homology class since the other. τ3 belongs to a different homotopy class since it

τ1 −τ3 or τ2 −τ3 encloses O2.

cannot be continuously deformed into any of the other two.

Figure 2.1: Illustration of homology class and homotopy class or curves.

results from complex analysis. In particular,

1 H(γ) =
2πi



1 z−ζ1

,



    γ

1 z−ζ2

,

...

   dz  





1

z−ζn

(2.2.1)

where, z = x + iy is the complex representation of (x, y) ∈ W − O, and ζj = ζj,x + iζj,y are the complex representations of representative points inside the objects with respect to which we compute the H-signature ans shown in Figure 2.2(a). Thus, the function, H, is computed as the integration of the vector of differential 1-forms,

1 dz

ωj

=

2πi

z

, − ζj

(2.2.2)

over the curve γ. However, the possible choice of such invariants has been broadened in [16], where the choice of the
vector of differential 1-forms, which needs to be integrated over γ to obtain the invariant, has been proven to be any complete set of generators of the de Rham cohomology group, Hd1R(W − O). In particular, the bump 1-forms [21],

ωj = υ(y − ζj,y)δ(x − ζj,x) dx,

(2.2.3)

(where δ is the Dirac delta function, and its integral, υ, is the heaviside step function – that is, informally speaking, ωj are analogous to a Dirac delta distribution over rays emanating from ζj along positive Y axis) is a choice that has the simple interpretation of counting the number of times the curve, γ, crosses rays
6

xg

xg

O1 ζ1

O3 ζ3 O4 ζ4

xs

ζ2 O2

γ

ζ5 O5

O1 ζ1

O3 ζ3 O4 ζ4

xs Y

ζ2 O2

γ

X

ζ5 O5

(a) H-signature based on simple results from complex analysis.

(b) H-signature based on bump 1-forms.

Figure 2.2: Examples of possible H-signature functions.

emanating from ζj (Figure 2.2(b)). In particular, deﬁne, #jγ := γ ωj = (Number of times γ crosses the ray emanating from ζj from left to right) − (Number of times γ crosses the ray emanating from ζj from right
to left). Then,

 #1γ, 



H (γ )

=

 





#2γ, ...,



 

.





#nγ

(2.2.4)

For example, curve γ in Figure 2.2(b) has the H-signature of H(γ) = [0, 1, 0, −1, 0]T . For closed loops the value of H-signature won’t depend on the choice of the differential 1-forms, as long as they form a generating set of the ﬁrst de Rham cohomology group, Hd1R(W − O) [21], and will compute the winding numbers about ζj.
And we can ﬁnd more generalized form of the H-signature of the given curve, γ : [0, 1] → (W − O), with arbitrary reference lines.

1
#jγ = υ(dj · (γ(t) − ζj))δ(d˜j · (γ(t) − ζj)) dt
0

(2.2.5)

where dj = [dj,x, dj,y]T is the direction of the reference line and d˜j = [dj,y, −dj,x]T is the normal vector to the reference line. So, it is obvious that (2.2.3) is a special case of dj = [dj,x, dj,y]T = [0, 1]T . As a result,
we can choose arbitrary reference lines to calculate H-signature of the given curves and environments.

2.2.2 Homotopy of curves and Homotopy Invariants
Deﬁnition 2.2.2 (Homotopy classes of curves). Two curves γ1, γ2 : [0, 1] → (W − O) connecting the same start and end points, are homotopic (or belong to the same homotopy class) iff one can be continuously
7

r1
O1 ζ1 xs

r2 r3 r4 r5 r6 O4 xg ζ4 O5ζ5

O3 ζ3 ζ2 O2

γ

ζ6

O6

r1
O1 ζ1 xs

r2 r3 r4 r5 r6 O4 xg ζ4 O5ζ5

O3 ζ3 ζ2 O2

γ

ζ6

O6 η

(a) h-signature based on reference rays. “r1+ r2+ r3+ r2− r5− ”.

h(γ) = (b) h-signature of a closed loop. h(γ “r2+ r3+ r2− r6+ ”.

−η) =

Figure 2.3: Examples of homotopy class invariant function on 2-dimensional plane.

deformed into the other without intersecting any obstacle as sown in Figure 2.3(a). Formally, if γ1 : [0, 1] → (W − O) and γ2 : [0, 1] → (W − O) represent the two trajectories (with
γ1(0) = γ2(0) = xs and γ1(1) = γ2(1) = xg), then γ1 is homotopic to γ2 iff there exists a continuous map η : [0, 1] × [0, 1] → (W − O) such that η(α, 0) = γ1(α) ∀α ∈ [0, 1], η(β, 1) = γ2(β) ∀β ∈ [0, 1], and η(0, γ) = xs, η(1, µ) = xs ∀µ ∈ [0, 1] [15, 49].
Homotopy invariants, in general, are much more difﬁcult to design and compute. Homotopy groups, unlike homology groups, do not have the natural structure of a vector space [49]. However, for curves in 2-dimensional plane with punctures (i.e. obstacles/objects), there is a relatively simple representation of the homotopy group and a way of computing the homotopy class of a given curve [46, 50, 98, 49, 9]: We consider representative points, ζi as before, and parallel non-intersecting rays, r1, r2, · · · , rn, emanating from the objects respectively (Figure 2.3(a)). We form a word by tracing γ, and consecutively placing the letters of the rays that it crosses, with a superscript of ‘+1’ (assumed implicitly) if the crossing is from left to right, and ‘−1’ if the crossing is from right to left. Thus, for example, the word for γ in Figure 2.3(a) will be “r1+r2+r3+r2−r6+r6−r5−”. We can reduce this word by canceling the same letters that appear consecutively but with opposite superscript signs. Thus, the word for γ in Figure 2.3(a) can be reduced to “r1+r2+r3+r2−r5−”. This reduced word representation is a homotopy invariant for open curves (with ﬁxed end points), γ, and we will write this as h(γ) and call it the “h-signature of γ”. However, it is important to note that we cannot exchange position for arbitrary pairs of letters in the word (i.e. the juxtaposition of letters is non-commutative). Unlike the homology invariant, this is not a vector, but an element of the non-abelian group freely generated [86, 49] by {r1, r2, · · · , rn}. Thus, although words can’t be added in the sense of vectors, they can be concatenated under the non-commutative group operation, ‘ ’. Also, the inverse of a word, w, written as w−1, is the h-signature of the same curve but with opposite orientation (i.e. h(−γ) = (h(γ))−1), and is a word where the order of the letters are reversed, and the exponent of each letter is ﬂipped (so that w w−1 =“ ”, the identity element). Thus, (w1 w2)−1 = w2−1 w1−1. As an example, (“r1+r3+r2−”)−1 =“r2+r3−r1−”.
However, if the curve is a closed loop (e.g. (γ −η) in Figure 2.3(b)), there is no preferred starting
8

O3
τ1 O1

xg O2

xs τ2

Figure 2.4: Examples where curves (τ1 and τ2) are homologous, but not homotopic.

point from where we should start tracing the curve and write the word. Thus, for such curves we need to consider the cyclic permutations of the letters in the reduced words to be equivalent. That is, a word, “abcde” will be considered to be the same as “cdeab”. Thus, when reducing a word, we need to consider the cyclic permutations, and thus cancel a letter at the beginning of the word that appears at the end as well, but with opposite superscript signs. For example, in Figure 2.3(b), if we trace the curve, γ −η, starting at the point e, we get,

h(γ −η) =h(γ) h(−η) = h(γ) h(η)−1 =“r1+r2+r3+r2−r5−” “r1+r6−r5−” −1 = “r1+r2+r3+r2−r5−” “r5+r6+r1−” =“r1+r2+r3+r2−r5−r5+r6+r1−” = “r1+r2+r3+r2−r6+r1−” =“r2+r3+r2−r6+”(after canceling the letters at the start & the end)

(2.2.6)

which is the completely reduced word. The homotopy invariant of a curve, γ, is the reduced word constructed in the described way, with cyclic
permutations of a word being considered equivalent when γ is closed. It is easy to note that for closed curves, the value of the homology invariant described earlier as integral over the bump 1-forms, does not depend on the choice of the direction of the rays emanating from ζi. But the homotopy invariant word is highly dependent on the choice of the direction of the rays.

2.2.3 The Hurewicz map
While one may be tempted to think that the concepts of homology and homotopy are one and the same, that is in fact not true. While trajectories that are homotopic are also homologous, the converse is not necessarily true [15, 49]. For example, the two curves τ1 and τ2 are homologous, but not homotopic in Figure 2.2.3. This is due to existence of a homomorphisms, called the Hurewicz maps [49] from the homotopy groups to the homology groups, which are not necessarily isomorphisms. The Hurewicz map between the ﬁrst homotopy group, π1(X) [49], and the ﬁrst homology groups for any topological space, X, can be written explicitly as
9

the abelianization map (a group quotient map), h∗ : π1(X) → π1(X)/[π1(X), π1(X)], where [·, ·] is the commutator subgroup [45] of π1(X).
The Hurewicz map can be used to compute the H-signature (the homology invariant) from a given a hsignature (homotopy invariant) of a closed curve when the reference rays of H-signature and h-signature are the same for each object. To do this, we simply allow the letters in the given word to commute, thus reducing the word until each letter appear at most once with an exponent (which will be ±1 for embedded curves). We then place the exponent of each letter in the corresponding position of the H-signature vector. Equivalently, we start with a zero-vector for the H-signature, and then for each letter we add 1 to the corresponding component of the vector if the letter appears with a ‘+1’ exponent, and subtract 1 if it appears with a ‘−1’ exponent. We will also write h∗ to denote this map from the space of h-signatures (words) to the space of H-signatures (a vector space).
Thus, from the earlier example of Figure 2.3(a), we had h(γ) = “r1+r2+r3+r2−r5−”. Since the 6 components of the H-signature vector corresponds to the objects O1, O2, . . . , O6 respectively, starting with [0, 0, 0, 0, 0, 0]T , for ‘r1+’ we add 1 to the 1st component, for ‘r2+’ we add 1 to the 2nd component, for r3+ we add 1 to the 3rd component, for ‘r2−’ we subtract 1 from the 2nd component, and for ‘r5−’ we subtract 1 from the 5th component. Thus, we end up having H(γ) = h∗(“r1+r2+r3+r2−r5−”) = [1, 0, 1, 0, −1, 0]T .
2.2.4 Augmented Graph
Through this thesis, we will use an augmented graph in our graph-search planner. We will deﬁne an augmented graph in which a vertex includes additional information or component about topology of the path until this vertex. For example, if we build a graph of a mobile robot the vertex in the graph should be v = (x, y) and two vertices, v1 = (x1, y1) and v2 = (x2, y2), are the same if x1 = x2 and y1 = y2. However, the vertices in the augmented graph include topology class information to reach each vertex. then the vertex in the augmented graph will be v = (x, y, g) where g can be the H-signature for homology class or hsignature for homotopy class. In the augmented graph, two vertices, v1 = (x1, y1, g1) and v2 = (x2, y2, g2), are the same if x1 = x2, y1 = y2 and g1 = g2. By adapting this augmented graph, we can ﬁnd optimal paths to the same point for vertex in the original graph in different topology classes.
The Figure 2.2.4 shows an example with a single obstacle in a four-way-connected graph. Two paths, τ1 and τ2, have the same initial vertex, vs. In the original graph, the goal vertex, vg of the two paths are the same because they have the same coordinates. However, in the h-signature augmented graph, the goal vertex of τ1 would be vg1 = (xg, yg, “r1+”). While, the goal vertex of τ2 would be vg2 = (xg, yg, “ ”). So we have vg1 = vg2. In the same manner, the goal vertices of H-signature (using the bump form in (2.2.3)) graph will be vg1 = [xg, yg, [1]) and vg2 = [xg, yg, [0]) to result in vg1 = vg2.
10

τ1 vs

vg

O1 ζ1

τ2

Figure 2.5: Example of augmented graph. The goal vertices of two different paths, τ1 and τ2, have the same coordinates but considerd to be different vertex in the augmented graph.

11

Chapter 3
Trajectory Generation under
Topological Constraints
In this chapter, we present a method to generate an optimal trajectory restricted to a particular topology class. The optimality of the generated trajectory is achieved by formulating the trajectory generation problem as a Mixed-Integer Quadratic Program (MIQP) [84, 80]. As the H-signature is the homology class invariant function, we can ﬁnd shortest paths with graph-search based planner [10]. But we cannot add H-signature constraints to optimal control because the gradient of H-signature is zero almost everywhere. So, we introduce binary variables that not only encode information about the satisfaction of geometric constraints, but also incorporate information about the topology class. We will cleverly consider topology class constraints so that the suggested trajectory generation problem under topology class constraints can still be formulated as a MIQP. We illustrate the method with examples of minimum acceleration trajectory generation under different topology class constraints with potential application to differentially-ﬂat systems with a two-dimensional ﬂat output space. The work in this chapter was performed in close collaboration with Dr. Koushil Sreenath and Dr. Subhrajit Bhattacharya. Much of the work in Section 3.2 and Section 3.3 were reported in [58] and [59], respectively.
3.1 Optimal Trajectory Generation
We consider trajectory planning in a compact subset Q ⊂ R2 of a plane. Let O = {o1, o2, · · · , ono } be a set of convex, pair-wise disjoint obstacles in Q (The requirement of convexity of obstacles can be relaxed by considering a set of arbitrarily-shaped obstacles such that their convex hulls are pair-wise disjoint). Each obstacle oi ∈ O can be represented by a ni-sided convex polygon, whose faces deﬁne hyperplanes that partition Q into two half-spaces. A binary variable is used to indicate whether a point is on the feasible side of the hyperplane, as described in [80]. So a point q ∈ Q will be feasible and will avoid collision with an obstacle oi if there is at least one face f ∈ [1, ..., ni] satisfying ni,f · q ≤ si,f . Where ni,f is a normal vector to the f th face of obstacle oi pointing inward, and si,f = ni,f · p, for an arbitrarily chosen point p on the f th face as shown in Figure 3.1. Similar to obstacle avoidance using binary variables bi,f , as described in [80],
12

Inside

Inside

p
fth face→
q

n
i,f
oi

Outside

p
fth face→

n
i,f
oi

q
Outside

(a)

(b)

Figure 3.1: The normal vector, ni,f , of the f th face of obstacle oi is pointing inward. p is an arbitrary point on the f thface. (a) An example of q ∈ Q when bi,f = 0. (b) An example of q ∈ Q when bi,f = 1.

b=[0,1,1]

b=[1,0,1]

b=[0,1,1]

b=[0,0,1]

q
k+1

b=[1,0,1]

b=[1,0,0]

b=[0,0,1]

q
k
q
k−1

(a)

(b)

Figure 3.2: (a) Overlapping subsets divided by values of binary variables representing each face of triangular obstacle. (b) Disjointed cells divided by values of binary variables representing each face but considering additional constraint.

13

a given point is feasible with respect to obstacle oi if

ni,f · q ≤ si,f − δr + M bi,f for f = 1, ..., ni
ni
bi,f ≤ ni − 1,
f =1

(3.1.1)

where bi,f ∈ {0, 1} are binary variables (with bi,f = 0 indicating that the point lies on the feasible side of the f th face of the ith obstacle as shown in Figure 3.1(a)), and M > 0 is a large positive number. δr ≥ 0 is the radius of the disk encircling the ﬁnite-sized robot, along with some safety-padding around it. The second inequality in (3.1.1) implies that the point q will be feasible with respect to at least one face, i.e., for a given i, there exists at least one f such that bi,f = 0. Although (3.1.1) is a sufﬁcient condition for feasibility, this formulation breaks up Q into overlapping subsets as shown in Figure 3.2(a). The ﬁrst three plots in Figure 3.2(a) illustrate that the subset corresponding to b = [0, 0, 1] is the intersection of the two subsets corresponding to b = [0, 1, 1] and b = [1, 0, 1]. Considering the segment of trajectory in the last plot of Figure 3.2(a), the binary variable vector bk, corresponding to the point qk, is not unique, but could be any of b = [0, 1, 1], b = [0, 0, 1] and b = [1, 0, 1]. As a result, we can have the same trajectory (represented by the points on it) described by different sets of binary variables. Such duplication increases the size of the feasible region in the space of binary variables, resulting in redundant searches, and larger computation times. To eliminate such cases, we introduce some additional inequality constraints to build disjointed cells like in Figure 3.2(b),

−ni,f · q ≤ −si,f + δr + M (1 − bi,f ) for f = 1, ..., ni.

(3.1.2)

The ﬁrst inequality of (3.1.1) only guarantees that the point q is on the feasible side or outside of f th face when bi,f = 0. But the constraint (3.1.2) enforces that the point q be on the other side when bi,f = 1. Thus, the feasible region, Q, is partitioned into disjoint cells, each of which is bounded by hyperplanes deﬁned by the faces of the obstacles. (see Figure 3.2(b)). Moreover, each cell can be identiﬁed by a unique vector of binary variables, b = [bT1 , . . . , bTno ]T where bi = [bi,1, . . . , bi,ni ]T ∈ {0, 1}ni .
We parametrize the trajectory by splicing Ns segments of trajectories, each parametrized by linear combination of Np + 1 basis functions,

Np
q(t) = cj,k ek(t − tj) for tj ≤ t < tj+1,
k=0

(3.1.3)

for j ∈ [0, ..., Ns − 1], 0 = t0 ≤ t1 ≤ ... ≤ tNs = tf . Where ek(t) is any basis function and cj,k are coefﬁcients. So the whole trajectory is union of Ns subtrajectories The trajectory is restricted to be krtimes differentiable at the junction of each of the segments of trajectories, q(tj), for j ∈ [1, ..., Ns − 1]. Further, obstacle avoidance is achieved by enforcing (3.1.1) at some equally distributed intermediate points on each segment of trajectories. we choose the cost function to be the integration of the square of the norm of rth-derivative of the trajectory:

J(c) =

tf t0

dr q (t) dtr

2
dt

=

cT Hc.

(3.1.4)

14

where c = [cT0 , ...cTNs−1]T , and H depends only on the choice of the basis functions (note that we could choose a cost function that is a weighted sum of different order derivatives, and still keep it quadratic in c). The optimal trajectory generation problem can then be simpliﬁed as the following MIQP (Mixed-Integer Quadratic Program),

min cT Hc
c, b
s.t. Af c + Df b ≤ gf Abb ≤ gb Aeqc = 0

(3.1.5)

where b is the vector formed by stacking all the binary vectors, bk, corresponding to the intermediate points, qk, of the trajectory and hence is a coarse representation of the continuous trajectory q(t). The ﬁrst inequality captures the feasibility constraints of (3.1.1) for the intermediate points, the second inequality captures the constraint on sum of binary variables in (3.1.1), and Aeqc = 0 imposes rth order differentiability at the junction of the segments of trajectories and the boundary conditions of initial conﬁguration, q(0) = q0 and ﬁnal conﬁguration q(tf ) = qf .
Now in the following sections, we will discuss how to add homology or homotopy class constraints on this trajectory generation problem while maintaining the MIQP formulation.

3.2 Optimal Trajectory with Homology Class Constraints
To ﬁnd an optimal trajectory in a speciﬁc homology class, we can then add some topological constraints. If we add a constraint on the H-signature, which we described in the Chapter 2, such that the H-signature of the trajectory, H(q), should be some desired Hd. However, all the form of H-signature (2.2.1), (2.2.3) and (2.2.5) are the nonlinear equations of the trajectory. So, the quadratic program (3.1.5) becomes a non-convex problem with this homology class constraints. Furthermore, the gradient of the new constraint, H = Hd, will be zero almost everywhere, because the value of the H-signature does not change within a particular homology class, (i.e. the range of the H-signature is a set of discrete variables). So, the resulting problem is a non-convex problem, which is numerically hard to solve based on gradients of cost and constraints. So, we need a different way to enforce topological constraints.
3.2.1 Algorithm Description
In this Section, we will describe our algorithm to generate the optimal trajectory with homology constraints while ensuring that the problem remains a MIQP.
Additional feasibility condition
We start by noting that the feasibility (with respect to obstacles) of each intermediate point on the trajectory does not guarantee the feasibility of the whole trajectory. Consider an example with only one parallelogram obstacle as shown in Figure 3.2.1. In Figure 3.2.1, two adjacent intermediate points, q1 and q2, are both feasible with respect to the given obstacle, o1. The red curve in Figure 3.2.1 shows an infeasible curve
15

f=3

f=4 q1

o1 f=1

f=2 q5

q2 q3

q4

Figure 3.3: An example of parallelogram obstacle. f is the index of each face. Red and magenta curves are infeasible trajectories between two feasible conﬁgurations, q1 and q2. Adjacent intermediate points(q3, q4 and q5) are satisfying additional constraint.

connecting two points. Of course, the optimal trajectory could be feasible like the green curve. However, the line segment connecting the two points (the magenta curve) is infeasible. To avoid such undesirable cases, we need additional constraint between adjacent intermediate points. The curves in Figure 3.2.1 illustrates this additional constraint: Considering the corresponding binary variables of each point, q3 is only feasible with respect to face f = 1 and the next intermediate point, q4 is also feasible with respect to the same face. So, the line segment, connecting these two points is also feasible with respect to face f = 1. Moreover, both q5 and its previous point, q4, are feasible with respect to face f = 2. So the line segment joining them is also feasible. In contrast, consider the case of q1 and q2 in Figure 3.2.1. These two adjacent intermediate points do not share feasibility with respect to a common face – q1 is feasible with respect to only face f = 4 and q2 is feasible with respect to only face f = 1. So we cannot guarantee the feasibility of the line segment connecting these two points.
The above discussion suggests an additional constraint that two consecutive intermediate points should share a common hyperplane with respect to which they are feasible, and this should hold true for each obstacle. In other words, the binary variables corresponding to the adjacent intermediate points should either be the same or differ by only one component, and this condition should be satisﬁed with respect to all obstacles. This constraint then guarantees the feasibility of a straight line segment connecting the two intermediate points. We write b(o,k) to describe the vector of binary variables for the kth intermediate point formed by stacking together the binary variables for the different faces of the oth obstacle (thus, it is a nisized sub-vector of b). Thus the constraint involving the kth and k + 1th intermediate points with respect to oth obstacle can be describe as

b(o,k) − b(o,k+1)

2 2

=

=

b(o,k) · b(o,k) + b(o,k+1) · b(o,k+1) − 2b(o,k) · b(o,k+1) b(o,k) + b(o,k+1) − 2b(o,k) · b(o,k+1)

≤1

(3.2.1)

16

where, b denotes the sum of the elements of a binary vector, and the last equality holds since b · b = b for a vector of binary variables, b ∈ {0, 1}n. This additional constraint on the gradual change of the binary variables along the trajectory plays an important role in formulation of a new h-signature based on binary variables, as described in the next section. However, this constraint is quadratic in the binary variables, and we will discuss how we can reduce this constraint to a linear one in Section 3.2.1.

Deﬁne H-signature

To ﬁnd an optimal trajectory contained in a speciﬁc homology class, the H-signature deﬁned in Chapter 2 can be used. However, these function are homology class invariant whose gradients are zero almost everywhere. So, the homology class constraints based on H-signature are not proper for gradient-based numerical solvers.
However, we choose H-signature of (2.2.5) for this work. We can choose arbitrary reference ray of each obstacle but for convenience of calculation and notation, we choose the reference ray as the extension of face f = 1 in the direction of the last face f = nf as shown in Figure 3.2.1. Also, for the consistency of sign of winding number, the faces are numbered in counterclockwise direction like Figure 3.2.1. So, for a given it obstacle, the H-signature will be

tf
Hi (q(t)) = υ(di · (γ(t) − ζi))δ(ni,1 · (γ(t) − ζi)) dt
t0

(3.2.2)

where ni,1 is the normal vector the of the 1st face of the ith obstacle and di = R

π 2

ni,1 is the direction of

reference

ray,

which

is

rotating

the

normal

vector

by

π 2

and

ζi

is

an

arbitrary

point

on

the

1st

face.

However,

the gradient of this integration will be zero almost everywhere and is not proper constraint. Here, we need

to focus on the fact that geometric meaning of this integration is counting the number of times the trajectory

crosses the given reference ray. Moreover, this reference ray is one the the boundary or hyper plane that

splits the feasible space into cells. So the change of binary variable corresponding to the ﬁrst face bi,1 will

give us alternative way to integrate (3.2.2).

From this fact, it is obvious that we need to accumulate the value of bi,1,k+1−bi,1,k for ∀k (where by bi,j,k we mean the binary variable for the kth intermediate point corresponding to the jth face of the ith obstacle).

However, to avoid counting the number of intersection with the the other ray obtained by extending the face

f = 1 in the other direction (the green line in Figure 3.2.1), we need to count the case when the two adjacent

intermediate points are infeasible with respect to the second face f = 2, i.e. bi,2,k+1 = bi,2,k = 1. So, the H-signature with respect to an obstacle, oi, will be

Hi(b) =

bi,2,k+1 + 2

bi,2,k

(bi,1,k+1

−

bi,1,k) .

k

= bi,2,k (bi,1,k+1 − bi,1,k)
k

(3.2.3)

The second equality of above equation holds because bi,2,k+1 = bi,2,k when bi,1,k+1 = bi,1,k due to the constraint we deﬁned in (3.2.1). The H-signature with respect to all obstacles will be H = [h1, ..., hno ]T , where no is the number of obstacles. However, this new H-signature is also quadratic in binary variables. We will discuss how we can reduce this quadratic equation to a linear one in the next section.

17

(−1)

f = 3

f = 2 (−0)

o
1

f = 1

(+1)

(+0)

Figure 3.4: An example of calculating the h-signature with respect to a triangular obstacle.

Substitution binary variables
As the new constraint in (3.2.1) and the H-signature in (3.2.3) are quadratic with respect to the binary variables, we introduce some substitution binary variables that represent the product of two binary variables. For example, consider the product of two binary variables, bi · bj, for bi, bj ∈ {0, 1}. Then, we substitute bi · bj with a new binary variable dij ∈ {0, 1}, on which we impose the following three inequalities,

dij ≤ bi , dij ≤ bj , −2 + δ + bi + bj ≤ dij

(3.2.4)

where 0 < δ < 1 is a design parameter. The ﬁrst two inequalities in (3.2.4) enforce dij = 0 when bi = 0 or bj = 0, respectively. And the last inequality enforces dij = 1 when bi = bj = 1, because 0 < δ ≤ dij. So the above three constraints let us perform the substitution dij = bi · bj. Let d be the vector of substitution variables with which we need to replace all the quadratic terms in (3.2.1) and (3.2.3). Then we can rewrite the feasibility conditions of substitution binary variables, (3.2.4), as

Af,db + Bf,dd ≤ bf .

(3.2.5)

Then we can rewrite the quadratic constraint of (3.2.1) for the whole trajectory as

Ao,kb + Bo,kd ≤ bo,k

(3.2.6)

for all o and k. And the h-signature calculation of (3.2.3) becomes the following linear equation

Hi = Ai,hd.

(3.2.7)

So, we can reduce all equations containing quadratic terms in the binary variables to linear ones using the substitution binary variables.

18

Finding Optimal Trajectory in a given Homology Class
Since our goal is to design optimal trajectory with homology constraint, we can impose the new constraints of (3.2.5), (3.2.6), and (3.2.7) to the optimal trajectory generation problem (3.1.5) to formulate a new MIQP as follows

min cT Hc
c, b, d
s.t. Af c + Df b ≤ gf Abb ≤ gb Adb + Bdd ≤ bf Aob + Bod ≤ bo Aeqc = 0 Ahd = Hd

(3.2.8)

where b and d are vectors of binary variables as described earlier. The third inequality is the condition of substitution variables (3.2.5), the forth inequality is for additional feasibility constraint for continuous change of binary variables (3.2.6), and the last equality is for the homology constraint with respect to all obstacles (3.2.7). As the resulting problem is MIQP, we can get an anytime solution to this problem through numerical solvers like CPLEX [52]. However, we need enough number of segments of trajectories (Ns) and basis function (Np) to be able to obtain a feasible trajectory in the given homology class.
Proposition 3.2.1 (Completeness Guarantee). Suppose there exists an arbitrary trajectory τ (dark blue curve in Figure 3.5(a)), not touching any of the obstacles, in the homology class represented by the Hsignature of Hd, that crosses the cell boundaries (i.e. the hyperplanes) m or less number of times (for avoiding ambiguity we assume τ is generic and that it does not pass through the intersection of 2 or more hyperplanes). With the choice of basis functions ek(t) = tk in (3.1.3), and with Np > r, it is then sufﬁcient to choose Ns = 2r(m − 1) + 1 in order to guarantee existence of a solution for the problem in (3.2.8) (i.e. all the conditions being satisﬁed, and with ﬁnite cost).
Sketch of Proof. Consider the m − 1 consecutive cells that τ passes through. We choose m − 1 points, q10, q20, · · · , qm0 −1,
respectively in the interior of each of these cells. Now, two such consecutive cells together form a convex region (bounded by the hyperplanes the cells are individually bounded by, except for the one hyperplane that separates them). Thus, the piece-wise linear curve formed by joining these consecutive points (call this q0) give a trajectory consisting of m segments (cyan curve in Figure 3.5(a)), connecting the initial and ﬁnal points, not intersecting any of the obstacles, and is continuous (i.e. 0th order differentiable). The afﬁne segments are permitted by the choice of the basis functions (the parametrization may be chosen arbitrarily), thus giving values of coefﬁcients, cj,k, in (3.1.3) that describe this trajectory. Those, along with the binary vectors corresponding to each of these points, satisfy all the conditions in (3.2.8), except for the differentiability condition Aeqc = 0.
The main idea behind the proof of this proposition is that we can now replace each of the points qj0 by two points lying arbitrarily close to it, and thus “smoothen” the curve (Figure 3.5(b)). This smoothening is
19

Figure 3.5: Starting from a piece-wise linear curve (cyan), we can progressively add points, to make the trajectory smoother by increasing the order of differentiability by one at each step.
possible to achieve with just an unit increase in the degree of the basis functions (which is evident by looking at the individual components qx0(t) and qy0(t), as illustrated in Figure 3.5(c)) – in this case, going from linear to quadratic (it is always possible to ﬁnd a parabola that has two given lines with bounded slope as tangents, and then scale it down such that the contact points with the tangents lie within a small ball around the point of intersection of the lines).
Thus, now we have a new trajectory (call this q1), that is smooth everywhere, but not twice differentiable (red trajectory in Figure 3.5(b)). However, we can continue the same process of smoothening the derivatives of q(t) by adding points in a small neighborhood of the original tj’s, doubling the number of intermediate points at every step. The choice of this neighborhood can be arbitrarily small to ensure that the added points remain in the interior of the same cell. Continuing this until we have rth order differentiability requires 2r(m − 1) intermediate points. In this way, we can construct a trajectory that satisﬁes all the conditions of (3.2.8).

Computational Complexity
The resulting optimal trajectory generation problem is a MIQP, which can be solved by an anytime solver like CPLEX. Thus, if there exists a feasible solution, it will be found by CPLEX. Moreover, with additional time available for computation, a lower cost solution can be found. However, the computation time will increase with the complexity of the given MIQP. So, in this section, we will discuss the computational complexity of the trajectory generation problem (3.2.8). The number of continuous variable in the problem is

nc = 2(Np + 1)Ns

(3.2.9)

where there are Ns segments of trajectories of Np+1 basis function for each x and y. However, some equality constraints to satisfy initial and ﬁnal conﬁguration and the continuity between segments of trajectories will reduce the actual number of continuous variables by searching the null space of Aeq of (3.2.8). Again, the number of binary variables to describe feasibility with respect to each face of obstacle is

nb = Nc · Nf 20

(3.2.10)

where Nc is the number of intermediate points on the whole trajectory and Nf =

no i=1

ni

is

the

total

number of faces of all obstacles. Then the number of substitution binary variables is

nd = (Nc − 1)Nf + 2(Nc − 1)

(3.2.11)

where each term is related to the quadratic terms in (3.2.1) and (3.2.3), respectively. So the total number of binary variables will be nb + nd.
The number of constraint is also an important factor in computational complexity. The number of equality constraint will be

neq = 2(kr + 1)(Ns − 1) + 2 × 4 + no

(3.2.12)

where the ﬁrst term represent the continuity between segments of trajectories. The second term represents the equality constraint of initial and ﬁnal conﬁguration; position and velocity of x and y. The last term is related to the H-signature constraint, which is the same as the number of obstacles. However, this equality constraint will disappear because we search in the null space of this equality constraint while reducing the number of continuous variables in the same manner. Most of the constraints are inequality constraints and we have

nineq =2Nc · Nf + Nc · no + Nc · no + 3nd =5Nc · Nf + 2Nc · no + 6Nc − 3Nf − 6

(3.2.13)

where the ﬁrst term represents on which side of each face the intermediate point is located – the ﬁrst equation of (3.1.1) and equation of (3.1.2). The second term represents the second equation of (3.1.1) and the third term represents (3.2.1). The last term presents the condition of substitution binary variables (3.2.4). So the number of inequality constraint is bilinear with respect to the number of intermediate points and faces of obstacles.

3.2.2 Simulation Results
To illustrate how the suggested algorithm works, we performed some simulations to generate optimal trajectories of a point robot, δr = 0, in various homology classes of a given environment. For all simulations, we use polynomial basis functions, ek(t) = tk and minimize the integration of the norm of acceleration of trajectories, i.e. we choose r = 2 in (3.1.4). In the ﬁrst simulation, we ﬁnd optimal trajectories with two obstacles under homology constraint. As mentioned before, the planned trajectory could be for a differentially-ﬂat dynamical robot system such as a kinematic car [71], or a tricycle robot [7].
Figure 3.6 shows optimal trajectories with the same initial and ﬁnal conﬁgurations but with different desired h-signatures, and consequently different homology classes. For each homology class, the CPLEX solver ﬁnds the optimal trajectory. Comparing the computation time and cost of trajectories of each homology class, it can be observed that the optimal trajectory in the homology class corresponding to lower cost takes less time to compute. This is an expected phenomenon since in a branch-and-bound algorithm the tree of ﬁxed binary variables tends to expand to minimize the cost.
In searching for the optimal trajectory in a particular homology class (e.g. the one in Figure 3.6(c)),
21

t = 23.1032 cost = 0.81085

t = 12.4738 cost = 0.65345

t = 187.0652 cost = 2.9868

t = 3.3112 cost = 0.21916

(a)

(b)

(c)

(d)

Figure 3.6: Simulation result of trajectory generation in four different homology classes with the same
initial conﬁguration (left bottom point) and ﬁnal conﬁgurations(right upper point). The ﬁrst obstacle is
parallelogram and the second obstacle is triangle. The actual computation time(sec) and optimal costs are speciﬁed on the upper left corners of plots. (a) Hd = [−1, −1]T . (b) Hd = [−1, 0]T . (c) Hd = [0, −1]T . (d) Hd = [0, 0]T .

t = 2.3226 cost = 53.2028

t = 2.8408 cost = 7.492

t = 4.3114 cost = 6.4878

t = 29.904 cost = 2.9983

(a)

(b)

(c)

(d)

Figure 3.7: Simulation result with anytime solutions. The computation time(sec) and optimal costs are speciﬁed on the upper left corners of each plot.

the algorithm expands the nodes in the tree in such a way that feasible solutions corresponding to other homology classes, but with lower costs (e.g. the class in Figure 3.6(d)), are also obtained in the process.
If we want to ﬁnd trajectory in a certain homology class like one in Figure 3.6(c), the tree is expanded to minimize the cost and ﬁnds the trajectories with less cost but in other homology classes like one in Figure 3.6(d). Even though, it ﬁnds this optimal solution, it moves on to check other nodes that could have less cost, a process that ends up ﬁnding trajectories in other homology classes.
To show the anytime performance of the suggested algorithm, we performed some simulations with the same environment as earlier, and with the homology constraint of Figure 3.6(c). The CPLEX solver was terminated at different times to compare the resulting trajectories. As shown in Figure 3.7, the cost decreases as we allow more computation time. And as illustrated in the previous example in Figure 3.6, we will get the global optimal trajectory with enough computation time.
Next we present a series of four examples with increasing number of obstacles, and subsequently increasing complexity (see Figure 3.8). For all examples, we choose six segments of trajectories with nine basis functions, such that the number of continuous variables for optimization, as given by (3.2.9), is nc = 108. The optimizer is given a maximum time of one hour to search for a feasible trajectory. The resulting found trajectory will respect the homology constraint and may be either suboptimal or optimal. Figure 3.8(a)
22

2 1

2 3 1

2 4
3
1

2 4
3
5 1

(a)

(b)

(c)

(d)

Cost Cost Cost Cost

5 10 4

4

5

10

10

10

4

10

4

10

3

3

10

10

3 10

3 10

0

500 1000 1500 2000 2500 3000 3500 0

500 1000 1500 2000 2500 3000 3500 0

500 1000 1500 2000 2500 3000 3500 0

500 1000 1500 2000 2500 3000 3500

Time(sec)

Time(sec)

Time(sec)

Time(sec)

(e)

(f)

(g)

(h)

Figure 3.8: (a)-(d) Final trajectories in four different homology classes with two, three, four and ﬁve obstacles, respectively. (e)-(h) Cost of the trajectories along with computation time with two, three, four and ﬁve obstacles, respectively. The plots shows the change in cost with time plotted in log scale.

illustrates results for the two obstacle case, showing trajectories in all four different homology classes. Figure 3.8(e) shows how the cost of each generated trajectory changes as we keep searching – the corresponding trajectories have the same color as in Figure 3.8(a). It is obvious that the trajectory corresponding to the red curves in Figures 3.8(a), 3.8(e) is the global optimal one without topological constraints. So it terminates searching solution before the time limit. Note that we could not ﬁnd global optimal trajectories for all the homology classes within the time limit. Figure 3.8(e) however shows that a feasible solution was found relatively quickly. With additional computation time, we expect the optimizer to either ﬁnd the global optimal trajectories in each homology class or guarantee that the current solution is the global optimum.
Figure 3.8(b) shows the result of simulation with three obstacles. We ﬁnd suboptimal trajectories in all the eight homology classes. As shown in Figure 3.8(f), an initial feasible trajectory was found relatively quickly for all but one homology class. For the homology class corresponding to the black curve, the optimizer took over 1000 sec to ﬁnd a feasible trajectory.
For the four obstacle case shown in Figure 3.8(c), we found trajectories in nine homology classes, and could not ﬁnd trajectories in other seven homology classes within the time limit. The missing seven trajectories should pass obstacle 4 on left like one of the green plots in Figure 3.8(c).
Similarly, for the ﬁve obstacle case shown in Figure 3.8(d), we found trajectories in only ﬁve homology classes among 25 = 32 possible homology classes. As we found all eight trajectories passing between obstacle 4 and 5, like the trajectories in Figure 3.8(b), there are feasible trajectories in these homology classes which can be represented with our parametrization and can be found.
As illustrated by these simulations, although the optimizer quickly found initial feasible suboptimal trajectories in various homology classes, it could either not ﬁnd corresponding optimal solutions for all classes or not ﬁnd the trajectories in all the possible homology classes within the provided time. A few reasons for this are (a) insufﬁcient computation time for the optimizer, (b) insufﬁcient continuous-time variables for
23

I K

H

G

N

MJ L

F

RQ S WC

O

PV B

T

U

E

A

X

D

Figure 3.9: An example of a trajectory corresponding to the word TPUVWQLJHG.

parametrization of longer and winding trajectories in certain homology classes, and (c) fundamental limitation of using a general purpose solver such as CPLEX for this particular scenario. To address the issue of computation time, the algorithm can easily be run longer, but more importantly, the computation time can be improved signiﬁcantly by providing an initial guess for the optimization. Further, increasing the number of continuous-time variables will also help since Proposition 1 guarantees that there exists a feasible trajectory with a sufﬁciently large number of segments of trajectories.

3.3 Optimal Trajectory with Homotopy Class Constraints
In this section, we present a method to generate an optimal trajectory restricted to a particular homotopy class, which is speciﬁed by a given representative trajectory. We partition the conﬁguration space into nonoverlapping cells and model each cell in the partition with integer variables and inequality constraints. We associate with any sequence of integer variables a word, so that each trajectory can be mapped to a word. We then construct a set of all words that are homotopically equivalent to a given word. For each word, we ﬁx the integer variables of the MIQP to ﬁnd the optimal time distribution in each cell, by solving a QP for each iteration, to obtain the locally optimal trajectory in the speciﬁed homotopy class. We illustrate an example of minimum acceleration trajectory generation on a plane with different homotopy class constraints.
3.3.1 Algorithm Description
We have broken the problem of optimal trajectory generation into two parts. First we ﬁnd a word that is a coarse representation of the trajectory and use this to restrict the homotopy class of the trajectory, and next ﬁnd an optimal trajectory with this restriction. The following sections present the algorithm in more detail.

24

Cell and word
With feasibility constraints (3.1.1) and additional constraints (3.1.2), we can divide the work space with hyperplanes of obstacles by value of binary variables.
As a result, a set of connected cells is built, whose union is the feasible space, Q, and the intersection is only the extended lines of faces of the obstacles (see Figure 3.3.1). Each cell can be identiﬁed by a unique letter, representing the vector of binary variables with one binary variable for each face of each obstacle. Every point in a particular cell will have the same letter representation. It must be noted that not all binary vectors deﬁne valid cells, and hence letters. The collection of all possible valid letters is deﬁned as an alphabet.
Determining homotopy class of a trajectory is non-trivial. However, we use location information of intermediate key point, each represented by a letter in the alphabet. Assembling the sequence of letters corresponding to each key point of the trajectory and removing trivial repetitions will results in a word, which is a coarse representation of the trajectory. For example, the path shown in Figure 3.3.1 can be represented by the word T P U V W QLJHG. This can then be used to restrict trajectories to a homotopy class as will be seen in the following Section.

Finding Words in the same Homotopy Class
To ﬁnd an optimal trajectory satisfying a given homotopy class constraint, we ﬁrst construct Wh, the set of words of the same homotopy class with the required one. We construct Wh by starting with the word for the given initial trajectory; Wh = {w0}. Then we choose a word wc ∈ Wh and expand the chosen word as follows. For example let wc = T P U V W QLJHG as in Figure 3.3.1. We choose two letters, say T and U . If there is an alternative path, like T XU (the gray plot in Figure3.3.1), for the path T P U , we construct the closed loop by reversing the new path, and obtain T P U XT after removing duplicating letters. If the length of the closed loop is less than six, no obstacle lies in the closed loop (since we need to visit at least six cells to encircle a triangle). So we replace the path between the two chosen letters with the new path, and an expanded word representing the same homotopy class is achieved, w1 = T XU V W QLJHG. The new word is added into Wh. We repeat this expansion until there are no more new words.

Finding the Optimal Trajectory

For a given word, wc ∈ Wh, we parameterize the trajectory with Ns subtrajectories, where Ns is same as the length of wc. Each subtrajectory is restricted to be in a particular cell speciﬁed by the corresponding letter in the word. Thus, all the binary variables, bc, of the trajectory generation problem of (3.1.5) are ﬁxed by the given word wc, to reduce the optimization problem to

min cT Hc
c
s.t. Af c ≤ g˜f ,

Aeqc = 0,

(3.3.1)

which is obtained by substituting bc in (3.1.5) and g˜f = gf − Df bc. As the resulting problem (3.3.1) is a quadratic program, we can ﬁnd the global optimal trajectory for all words in Wh, which are in the given homotopy class.

25

J = 0.60234

J = 0.69267

J = 1.0091

J = 3.4522

J = 1.0612

(a)

(b)

(c)

(d)

(e)

Figure 3.10: (a) Optimal trajectory without homotopy constraints (b)-(e) Trajectories with four different homotopy class constraints. The thick black curve is the optimal trajectory in each homotopy class and thin gray curves are the suboptimal trajectories for each word. The cost (J) for each case is speciﬁed on the upper left corners of plots.

However, it is not trivial to ﬁnd the spending time in each cell to minimize the cost of the whole trajectory. To reﬁne the trajectory further, we can adjust the time spent in each cell. With the ﬁnal time, tf , ﬁxed, we can ﬁnd an optimal time distribution by solving

min min cT Hc

tj

c

s.t. Af c ≤ g˜f

Aeqc = 0

s.t. tj ≤ tj+1 for j = [0, ..., Ns − 1],

t0 = 0

tNs = tf .

(3.3.2)

As this problem is a nonlinear program, we cannot guarantee the global minimum. However, the trajec-

tory

is

iteratively

reﬁned

by

starting

with

∆tj

=

tj+1

− tj

=

tf nw

for

j

∈

[0, ..., Ns

−

1]

and

solving

(3.3.2)

by an interior-point method. Although we can ﬁnd an initial solution without iteration, a better trajectory

can be obtained by iterating the time distribution. Moreover, since the optimization cost reduces with more

iterations, this method can be considered as an anytime algorithm that produces better solutions with more

time.

3.3.2 Simulation Results
To illustrate how the suggested algorithm works, we performed some simulations to generate optimal trajectories with various homotopy classes. In this simulation, we ﬁx the ﬁnal time tf = 10 and ﬁnd optimal trajectories for four homotopy classes. To reduce the computation time, we limit the maximum length of word to twelve.
The plot of Figure 3.10(a) shows the result of solving (3.1.5) without homotopy class constraints, resulting in an optimal cost of 0.60234. The plots of Figure 3.10(b)-3.10(e) show the result of solving (3.3.2) with four different homotopy class constraints, resulting in optimal costs that are greater than the global optimal one. When we search for trajectories with the same homotopy as the optimal trajectory achieved without homotopy class constraints (Figure 3.10(a)), the obtained optimal trajectory (Figure 3.10(e)) is a local optimal
26

itr = 0 J = 2.3135

itr = 1 J = 1.2395

itr = 3 J = 0.82416

itr = 4 J = 0.75962

itr = 6 J = 0.69267

(a)

(b)

(c)

(d)

(e)

Figure 3.11: (a)-(e) Effect of varying the time distribution in each cell through iterations of the optimization (3.3.2). The number of iterations (itr) and cost are also speciﬁed on the upper left corner of each plot. Note that the cost converges to the local optimal cost of the case of Figure 3.10(b) in 6 iterations.

one with a larger cost. This disparity occurs due to restricting the trajectory to pass through certain cells and the fact that it is hard to ﬁnd global optimal time distribution in each cell. The most optimal trajectory with homotopy class constraints lies in a different homotopy class from the global optimal one (Figure 3.10(b)). However, this is due to the symmetric arrangement of initial/ﬁnal location of the trajectory and arrangement of obstacles.
With a ﬁxed time distribution for each cell, the optimization reduces to a quadratic program for each word, which can be solved efﬁciently. To see the effect of optimizing the time distribution, we begin with a trajectory in the particular homotopy class of Figure 3.10(b) with equal time distribution over all the cells and iteratively optimize time distribution. The plots of Figure 3.11(a)-3.11(e) illustrate the changes in the trajectory and the corresponding cost with each iteration. Although this nested optimization is computationally expensive, with each iteration we get closer to the local optimal solution, resulting in an algorithm with anytime properties.

3.4 Conclusion
In this chapter, we have presented a method to ﬁnd a smooth optimal trajectory subject to geometric and kinematic constraints, and restricted to a speciﬁc topology class. We used a MIQP to achieve global optimality. The homology constraint is considered by calculating the H-signature of the trajectory from its binary variables, which are a coarse representation of trajectory. The calculation of H-signature is quadratic in the binary variables but is reduced to a linear equation by introducing substitution binary variables. Then the resulting problem becomes a MIQP, which can be solved using an anytime numerical solver like CPLEX [52]. To ﬁnd an optimal trajectory restricted to a speciﬁc homotopy class, we suitably modiﬁed a MIQP to partition the conﬁguration space and by constructing a coarser representation of the trajectory in the form of a word to represent the homotopy class. The set of all words representing the same homotopy class is constructed, and a nested optimization is carried out to ﬁnd a locally optimal trajectory restricted to a homotopy class.
Clearly reducing the computation time is the most important issue for this problem for practical applications. One direction is to reduce the computational complexity of the method by reducing the number of binary variables or choosing proper number of intermediate points or number of subtrajectories. The other direction is to develop proper solver to solve this problem efﬁciently. General MIQP solver like CPLEX does not consider the structure of the problem and relax the binary variables to real number on [0, 1]. However, we can divide the MIQP into two parts. First, we ﬁnd the possible set of binary variables and solve QP
27

for the continuous variables. Or we can use numerical solvers with proper initial guess which is found by graph-search-based planner.
28

Chapter 4
Topological Exploration
In this chapter, we will present the mathematical framework and algorithms for multi-robot topological exploration of unknown environments in which the main goal is to identify the different topological classes of paths and thus efﬁciently distribute the task of exploration among different groups of robots. We consider two-dimensional conﬁguration spaces. At any point in time, the robots’ map consists of known, partiallymapped obstacles. The unknown, yet-to-be-explored area is mapped to a single point, thus giving us a quotient space. The topological classes on the quotient space allows us to deﬁne topological classes of paths connecting a robot pose to the unknown region in the original conﬁguration space. Robots explore this conﬁguration space choosing different homology classes when confronted by obstacles or walls. We illustrate the basic idea with simulations of small teams of robots. Experiments with a single robot illustrate the applicability of the method to robots that have small sensor footprints and limited computational resources. We also provide comparisons with a standard frontier-based algorithm. The work in this chapter was performed in close collaboration with Prof. Robert Ghrist and Dr. Subhrajit Bhattacharya. Much of this work was reported in [55].
4.1 Motivation
To motivate the approach in this chapter, consider the simple scenario in Figure 4.1(a) in which there is a group of robots at locations close to p equipped with sensors with a limited ﬁeld of view mapping an unknown environment. In the ﬁgure, the current map consists of the three obstacles (marked in black) and the free space colored in pale blue. The region, L, in pale yellow is not visible to any of the sensors and hence is unknown. An information gain maximization based approach as in [85] or [89] will essentially give an unique gradient descent direction at the location of the robots (if all the robots are roughly the same location, the control inputs will also be very similar) and make the robots move together. However, clearly there are three distinct topological classes in this environment that can lead the robots to the unknown region (indicated by the blue dashed arrows in the ﬁgure). We are interested in methods that will maximize the collection of information by naturally assigning robots to different topological classes of paths.
A frontier-based exploration as in [41] would ﬁnd three distinct paths or assignments in two steps [100]: i. Identify the boundary between the known and the unknown regions and segment it to obtain its con-
nected components (using an edge detection algorithm for example). 29

ii. Find optimal paths to each of the connected components (using Dijkstra’s search).
While this method would perform satisfactorily in the example of Figure 4.1(a), remarkable outperformance of a topology-based method as ours is observed in scenarios like that in Figures 4.1(b) or 4.1(c) – when the known region is not simply-connected. Moreover, in a frontier-based algorithm like in [100], the additional step of identiﬁcation of the connected components of the frontier may be expensive. When there are multiple robots, the standard frontier-based approach makes robot-frontier assignment by taking into consideration the size of the frontier [100]. In an indoor environment with lots of corridors and passages, possibly leading up to large open areas, the size of the frontier may not be the best indicator of information gain. Furthermore, when there are multiple groups of robots in different locations, performing distributed cooperative exploration, it is unclear how the groups can have a consistent way of referring to a particular frontier when communicating (without communicating the complete description of the frontier). Our topological approach, on the other hand, is completely free from the task of frontier identiﬁcation or representation, and instead uses single pass of search/planning to discover paths in different topological classes, each of which is represented by a topological invariant (H-signature) that is consistent over the different groups (Figure 4.3(b)).
Consider the scenario illustrated in Figure 4.1(b), where a group of robots are provided with a partial map of the environment. There is a single frontier, f . A frontier-based approach would ﬁnd a single shortest path to the frontier (either τ1 or τ2). However, there are two topological classes of paths in the plane punctured by the obstacle, O, that connect p to all points in L. As shown, τ1 and τ2 are two paths in different topological classes. Thus clearly, the number of frontiers do not correspond to the number of distinct non-looping topological classes when the explored/known free region is not simply connected. A similar example is shown in Figure 4.1(c), where O is the set of all obstacles that have been discovered. In particular, the group of robots have explored the perimeter of obstacle O1, thus resulting in a map that is not simply connected. In this case although there are two connected components of the frontier, there are three topological classes of paths and therefore three directions for exploration. Clearly, deployment of groups of robots in each of the distinct topological classes will result in more efﬁcient exploration.
Because our interest is in topological mapping, we will not concern ourselves with questions of localization, detection or mapping of obstacles or control. We will assume each robot is able to localize either using lasers and cameras or by using GPS, detect obstacles with a laser scanner, communicate with other robots, and avoid collisions with the environment. We implement our algorithm with nonholonomic robots in ROS, and demonstrate the multi robot exploration in simulation, along with comparisons with a frontier-based exploration algorithm. We also present experimental results with a single robot with a small ﬁeld-of-view laser and odometry to illustrate the basic ideas in a real world setting.
4.2 The Quotient Space and H-signature
As mentioned in Chapter 2, the H-signature of paths can be used for ﬁnding different homology classes of paths connecting two points. However, for exploration we are interested in the topological classes of paths that emanate from a start coordinate, with the goal being not a single point but rather a set L. To adapt to this situation, we collapse the set L to a single point via the construction of a quotient space [69].
To adapt the deﬁnition of the H-signature in this context, we will collapse the entire unknown region to
30

L
p

L

τ1

f O1 p OO21

∞

τ2

L f1 τ1

O3
p
O2

∞
f2 τ3 O1
τ2

(a) A group of robots, using their laser (b) In this partially known environment there (c) In this scenario the known region

range sensors, ﬁnds 3 topological classes is a single frontier (green dashed curve), but 2 is not simply-connected and there are 2

of paths leading to the unknown region, topological classes connecting the location of frontiers. But on R2 − O as well as

L. There are also 3 frontiers in this sce- the robots and frontier, f . Such scenarios are on (R2 − O)/L there are 3 non-looping

nario.

natural when the known free region, R2 −O − topological classes.

L, is not simply-connected.

Figure 4.1: Partially explored environments. The group of robots (red dots) need to be split and deployed for exploration of the unknown regions (pale yellow region marked as L). The ﬁgures illustrate the distinction between frontier-based and topology-based deployments.

τ1
R2 - O - L

τ2

O
L
R2

quotient map,
q

q(R2 - O - L)

q(τ1)

q(τ2)

q(O)

q(L)
R2 / L

Figure 4.2: A simple illustration of a quotient map. The set L is collapsed to a point, q(L). Here we consider the Euclidean plane, R2, with its subset L being the entire region outside a small disk on the plane. Collapsing L to a single point gives us the topological 2-sphere. All non-trivial 1-cycles (or closed loops)
that completely lie in L become trivial in the quotient space under the quotient map, q.

a single abstract point via a quotient map, q, so that the space under consideration becomes (R2 − O)/L (where O is the set of obstacles in the known region). The image of L under the quotient map, q, thus being a single point lets us use the notion of homology classes of paths connecting to this point from the image of the start coordinate on the quotient space (Figure 4.2). For a formal deﬁnition of quotient map see [69, 49].
The following proposition extends the homology class invariant function of H-signature to the quotient space (R2 − O)/L.
Proposition 4.2.1 (Homology invariant in quotient space [16]). Let O be the collection of obstacles in R2 with respect to which we compute the H-signature as described in Section 2, and let L ⊂ R2 − O. Let Q be the set of H-signatures of all closed loops (1-cycles) in (R2−O) contained entirely in L. Let τ1 and τ2 be two paths connecting two points, s, g ∈ (R2 − O). Now consider the quotient map q : (R2 − O) → (R2 − O)/L. The images of the paths τ1 and τ2 under the action of q are homologous in (R2−O)/L iff H(τ1)−H(τ2) ∈ Q.
Sketch of proof. First, note that the set Q is a countable set. Each element of Q corresponds to an element of the homology group H1(L; Z) [49]. The proof follows from the observation that by identifying L to a point under the quotient map, we essentially trivialize every closed loop (1-cycle) in L. This implies that the
31

loops that were non-trivial in L before applying the quotient map (i.e. whose H-signatures were not zero), need to be set to zero when we compute and compare the H-signatures in the quotient space. Thus, before applying the quotient map we would say that τ1 ≈ τ2 (i.e. belong to same homology class) iff H(τ1) − H(τ2) = 0. However, after applying the quotient map, each element of Q, containing the H-signatures of non-trivial loops in L, are to be considered equivalent to 0. Thus the new criteria becomes q(τ1) ≈ q(τ2) (i.e. the images of the paths belong to same homology class in the quotient space) iff H(τ1) − H(τ2) ∈ Q.
For a more formal algebraic proof and an illustration demonstrating the concept behind the proof, see Section 7 of [16].
4.3 The Algorithm
In this section we provide a complete description of the algorithm for topological exploration with multiple robots while respecting the present constraints on the available space. We assume that the reader is familiar with the construction of the H-augmented graph [15] and the process of performing search (using Dijkstra’s or A* algorithm) in it [25].
4.3.1 Representation
We discretize the environment (the subset of R2 that is of interest) into a uniform square grid and create a graph, G, by placing a vertex in each square cell and connecting a cell with its neighbors using directed edges. More complex forms of discretization (triangulation, unstructured or adaptive discretization) can also be used. But to focus on the main contribution of this thesis, we choose the simplest discretization scheme. We maintain a probability map by associating an occupancy probability with each cell. The initial probability for each cell in a completely unknown environment is set to 0.5, and the state of each cell is designated as ‘unknown’. As the laser sensor data are received, the probability map is updated. If the probability of a cell goes above a high threshold, Tobs, we designate the cell as an ‘obstacle’. Otherwise if it goes below Tfree, we designate it as a ‘free’ cell. This, at any instant of time, gives us an obstacle map (see Line 3 of Algorithm 1: ToplogicalExplore).
A candidate point (an arbitrarily chosen point) is placed inside each connected component of the unknown region (a point is chosen near the boundary of the region, and shifted, if possible, to create a padding). Like representative point, the exact location of a candidate point is not of signiﬁcance as long as it falls inside the desired region.
4.3.2 Multi-robot Exploration Algorithm
Suppose we start with N robots at a location, say p0, in the environment. At the beginning we have a single group of robots. The basic idea behind our algorithm is to split the group of robots based on the number of homology classes of paths discovered and deploy each newly-formed smaller group along those paths, and repeat this process for each subsequently formed group (Figure 4.3).
Discrete time is represented by t. The re-planning for paths does not happen in every time step, and instead happens at time steps t0, t1, · · · . The values at the subscript of these time steps are the planning cycle numbers, and are denoted by the variable, pl = 0, 1, 2, · · · .
32

g

τ1g

p0

τ2g

τ1g'

τ3g''

g' Ptg'

g
p0

τ2g'

τ4g''

τ3g'

τ1g''

g'' Ptg''

τ4g'

τ2g''

(a) At t = t0 = 0 a planning cycle starts. A single group of

N robots starts at p0. Thus Gt0 = {{1, 2, · · · , N }} =:

{g}. The group ﬁnds 2 topological classes of paths:

{τ

g 1

,

hg1

},

{τ

g 2

,

hg2

}

= F indP aths(p0, ∅). Thus the

group splits into two groups, each containing ∼ N/2 robots.

The new groups are g = {1, 2, · · · , N/2 } and g =

{ N/2 +1, · · · , N } (see ﬁgure on the right), and they follow

paths τ1g

:=

τ

g 1

and

τ1g

:=

τ

g 2

.

At

the

end

of

this

planning

cycle, we set t1 = t.

(b) At the beginning of the next planning cycle there are two

groups: Gt1 = {g , g }, when the condition in Line 4 of Algorithm ToplogicalExplore returns true. Thus, in this cycle

of planning the groups obtain the following paths respectively:

F indP aths(Pgt1 , τ1g )

=

{τ

g 1

,

ha},

{τ

g 2

,

hb

},

{τ

g 3

,

hc

},

{τ

g 4

, hd}

;

F indP aths(Pgt1 , τ1g )

=

{τ

g 1

,

hc},

{τ

g 2

,

hd

},

{τ

g 3

,

hb},

{τ

g 4

, ha}

.

Note the correspondence between the values of the H-

signatures.

Figure 4.3: Illustration of algorithm ToplogicalExplore.
At any instant, the groups formed by the robots are represented by a partition of the set of robot indices, {1, 2, 3, · · · , N }. We represent that partition (created after planning cycle, pl) by the ordered set Gpl =
{rp1l,1, rp1l,2, · · · }, {rp2l,1, · · · }, · · · . A group, g, is simply a partition element g ∈ Gpl, and variables giving attributes to the groups are indexed by g (e.g., τpgl). |Gpl| denotes the number of groups.
The planning cycle, pl, creates a set of paths, τpgl, g ∈ Gpl (with H-signature, hgpl, w.r.t. base-point p0 – see Section 4.3.2), that the groups need to follow. We will unambiguously (and without going into implementational details) refer to two obvious components of each such path: traversed part and the untraversed part.
Each group of robots, during their coordinated travel together as a group, has a representative location (a point in conﬁguration space), with respect to which all computations of paths are performed. This point, representing the position of the group g ∈ Gpl at time t (with tpl ≤ t < tpl+1), is denoted as Pgt . On the contrary, the positions of individual robots are denoted by prt , r ∈ {1, 2, · · · , N } (and thus at the individual level of robot r, the control objective will be to reach Pgt , where r ∈ g). We represent the path history of the gth group at the time instant t by Pg0:t.
At t = 0, pl = 0, we start with a single group, G0 = {{1, 2, · · · , N }}. After obtaining the ﬁrst few sets of laser sensor data and building the occupancy map in the neighborhood of the robot group, the algorithm ToplogicalExplore (Algorithm 1) is used to direct the exploration task. Figure 4.3 illustrates the working of the algorithm.
We use ‘∗’ in place of a index of a variable to denote the entire set of variables over all the possible indices (e.g., τp∗l = {τpgl | g ∈ Gpl}). An overline over a variable is used to emphasize that it is a temporary variable. Algorithm 1: Pseudocode for ToplogicalExplore:
1. |t = 0; pl = 0; tpl = 0; Gpl = {{1, 2, · · · , N }}
33

2. |while TRUE

3. |i. Update probability map based on laser sensor data.

|ii. Threshold probability map to generate obstacle map.

4. |if t == 0 OR map has changed signiﬁcantly

|

OR a group has reached its immediate goal

5. |i. Place representative points on newly discovered obstacles,

|ii. Place candidate points in connected components of

| unexplored regions.

6.

|for each g ∈ Gpl // Plan new paths

7.

|γg =

{τ

g 1

,

hg1

},

{τ

g 2

,

hg2

},

·

·

·

=

|

F indP aths(Pgt , Pg0:t)

8. |end for each

9.

|if γg = ∅, ∀g ∈ Gpl // No path found. All explored!

10.

|break while loop

11. |end if

12.

|Set Gpl+1 = Gpl // Copy groupings from previous plan cycle.

13.

|{Hg | g ∈ Gpl+1} =

|

AssignH

omologyC

lassesT

oGroups(c(τ

∗ ∗

),

h∗∗

,

h∗pl )

14.

|{Gpl+1, γ∗} =

| CheckN earbyGroupsF orRedistribution(P∗t , Gpl+1, H∗)

15.

|for each g ∈ Gpl+1

16.

|if |Hg| == 0 // Group not assigned any homology class.

17.

|{Gpl+1, H∗, γ∗} = RejoinW ithClosestGroup(g)

18.

|end if

19. |end for each

20.

|for each g ∈ Gpl+1

21.

|if |Hg| > 0 // Group assigned multiple homology classes.

22.

|{Gpl+1, H∗, γ∗} = SplitGroup(g)

23.

|end if

24. |end for each | // At this point each Hg, g ∈ Gpl+1 contains one H-signature.

| // The new group structure is present in Gpl+1.

25.

|for each g ∈ Gpl+1

26.

|τpgl+1

=

τ

g k

,

hgpl+1

=

hgk ,

k is such that hgk ∈ Hg

27. |end for each

28.

|tpl+1 = t; pl + +

29. |end if

30. |for each g ∈ Gpl

31.

|Choose the next point ((t − tpl)th point in τpgl), Pgt+1 ∈ τpgl.

32.

|Pg0:t+1 = Pg0:t Pgt+1

34

33. |for each r ∈ g

34.

|Move robot r towards Pgt+1 via the shortest path in the map.

| // Controller for making robot follow planned path.

35. |end for each

36. |end for each

37. |t + +

38. |end while

In Line 4 of the above algorithm, the condition for checking whether the ‘map has changed signiﬁcantly’ consists of two checks:

i. If any of the most recently planned paths (i.e., τpil, i ∈ Gt) has become invalid (blocked by newly discovered obstacles).

ii. The number of cells in the environment that have changed state (i.e. from ‘unknown’ to ‘free’ or ‘obstacle’) is greater than a threshold.

Below are brief descriptions of each of the remaining subroutines used in the algorithm.

FindPaths(P, τ )
(Refer to Figure 4.3) This subroutine is used to ﬁnd all paths emanating from P in the different topological classes. The subroutine also returns the H-signature of the planned path appended with the already traversed path, τ . This requires searching in the H-augmented graph, GH , as described in [15]. However, in the search algorithm we initiate the open set with the vertex {P, H(τ )} (i.e., instead of using 0 as the H-signature of the start vertex, we use H(τ ) – the H-signature of the traversed path, τ ). Consequently we expand the vertices in GH as usual. This ensures that we consider p0 as the base point of the space so that the value of the H-signature remains consistent over the different groups and over time (see Figure 4.3(b)). Vertices that lie in the explored region are expanded, and a path is stored every time a vertex connected to the unknown region is reached via a new homology class (identiﬁed by the sum of the H-signature of the expanded vertex and the H-signature of a path connecting that vertex with the candidate point in unknown region).
Note that according to Proposition 4.2.1, the way we determine whether H-signatures h and h represent the same homology class in the quotient space is to check if the elements of the difference, h − h (which, recall from the deﬁnition of H-signature, is a vector of complex numbers), are either i. all equal when the unknown region is not simply connected (i.e., the unknown region that extends to the boundary of the environment), or, ii. all zero when the unknown region is simply connected (for all other unknown regions). If none of these is true, they represent different homology classes. Using a method similar to [15], we do not allow path that loop around obstacles. Moreover we do not place representative points on obstacles smaller than a threshold radius, thus avoiding multiplicity of topological classes merely due to sensor noise.

AssignHomologyClassesToGroups
The number of paths returned by the ‘FindPaths’ procedure will be the same for each of the groups g ∈ Gpl (see Figure 4.3(b)). Since we used the same base-point, P0, for the searches for each group, we will obtain the same set of H-signatures for each group from the search in Line 7, although the paths will of course be different.
35

The purpose of this subroutine is to make the assignment of each of the homology classes to the different

groups

of

robots

based

on

the

cost

of

the

planned

paths,

c(τ

∗ ∗

),

their

H -signatures,

h∗∗,

and

the

H

-signature

of the paths assigned in the last plan cycle, h∗pl. The basic strategy for doing this is as follows:

i. If, for a group g, the H-signature of the last planned path, hgpl, that it has been following, is found in the result returned by FindPaths, that homology class is assigned to the group g (the H-signature comparison being made with respect to obstacles that are common to the time instants when the last plan was made and the current time). This ensures that a group (or one of its subgroups) keep following the homology class that it has been following.

ii. Whichever homology class remain unassigned after this is assigned to group for which the path corresponding to the class is shortest.
The H-signatures of the homology classes assigned to group g ∈ Gpl+1 is ﬁxed in Hg (i.e., it is a set of H-signatures, Hg = {ηg1, ηg2, · · · }).

CheckNearbyGroupsForRedistribution
If a group has been assigned homology classes more than the number of robots available in that group (i.e., |Hg| > |g|), then it is checked if there is another nearby group, g , such that c|Hg | < |g |, Pgt − Pgt < R (c > 1, R > 0 are parameters). If so, a re-shufﬂing of the groups is performed (with dome robots from g being transferred to g) and the new group arrangement is returned to Gpl+1. Since the content of each group gets changed, the indices of γ∗ are updated accordingly.

RejoinWithClosestGroup
This subroutine gets triggered when a group is not assigned any homology class. The reason for this is typically two-fold:
i. Sometimes a spurious homology class may be observed because of incorrect laser readings, which would soon turn out to be blocked as new sensor data arrives, thus resulting in some of the recently created group to be assigned no paths.
ii. A group can reach a dead-end in the environment (e.g., end of a corridor).
This requires that we rejoin those groups with other groups so that they don’t remain idle. We ﬁrst look for closest “cousin” groups (groups having common distant parent – group at an earlier plan cycle from which the current groups originated – see SplitGroup next) that are not more than D generations apart. This requires a traversal of D levels of the family tree (the sets Gpl, Gpl−1, Gpl−2, · · · , Gpl−D contain all the information required for this) and identiﬁcation of the closest cousin. If such a cousin cannot be found, the group is joined with the distance-wise closest group in the environment. The subroutine returns the new grouping (i.e. partition of the set {1, 2, · · · , N }) and the corresponding re-ordering that is required in H∗. Since γ∗ and H∗ are indexed by the groups, an update of their indices is also required (and removal of the elements corresponding to the joined, hence no-more existing, group).

36

SplitGroup If Hg contains more than one element (i.e. multiple homology classes assigned to a single group of robots), the group will be split into sub-groups of almost-equal sizes and at most one homology class will be assigned to each of the sub-groups. Thus, if there aren’t enough robots in the group (i.e. |Hg| > |g|), clearly a choice has to be made and some of the homology classes has to be left unattended for future exploration. Under such situations the unattended homology classes are removed from Hg. As before, the indices of γ∗ and H∗ are updated.
4.3.3 Distributed Implementation
It is to be noted that the algorithm ToplogicalExplore can be implemented in a distributed manner where the ith group performs its own computation for the robots in the group. In a distributed implementation the ‘for each’ loops starting at Lines 6, 15, 20, 25 and 30 would be replaced by computation for the respective group only in their respective threads. Each group would maintain its own probability map and update it based on the laser sensor readings. Each group also broadcasts the changes in its own map so that the other groups in the environment can update their maps (a communication protocol similar to that in [17]). Moreover, when one group decides that a re-planning of path is required (condition in Line 4 becomes true), all the groups are communicated the decision and they come to a consensus to re-plan. Since the procedure AssignHomologyClassesT oGroups requires a consensus, the groups communicate the cost of their respective planned paths as well.
4.4 Results
We implemented the ToplogicalExplore algorithm on ROS (Robot Operating System), that lets us accurately simulate robot dynamics, actuator noise and sensor noise. Although our current implementation is mostly centralized and runs on a single processor, the overall structure of the algorithm is perfectly suited for distributed implementation on multiple parallel processors as described in Section 4.3.3. Such an implementation is within the scope of future work.
We also provide extensive comparison with the frontier-based algorithm described in [100] (the implementation of which was also made in ROS, with identical models of robot dynamics, sensor and actuator). Section 4.4.1 illustrates, using a simple environment, why our algorithm logically outperforms a frontierbased algorithm. Section 4.4.2 demonstrates similar performance comparison for a more complex indoor environment.
All simulations were run on a dual core machine with processor clock speed of 2.6GHz and 4GB memory. Note that the run times reported involve the complete dynamic simulation of the non-holonomic robots.
4.4.1 Partially Known Environment
We consider a simple partially known environment that is 30m × 30m in size, discretized by 0.1m × 0.1m cells, with 4 robots exploring it. The environment has 3 rectangular obstacles, of which two fall inside the initially known elliptical region as shown in Figures 4.4(a) and 4.4(c). The initial known region, as clearly seen, is not simply-connected. Consequently, the number of topological classes do not correspond
37

to the number of frontiers. Thus, using a frontier-based algorithm (as described in [100]) the entire group of 4 robots are driven towards the single frontier as shown in Figure 4.4(a). However, using our topological exploration, the initial group of robots discover two topological classes of paths and hence split up into two sub-groups as seen in Figure 4.4(c). This, without surprise, results in more efﬁcient exploration of the environment. Our T opologicalExplore algorithm explores the entire environment in 1045 iterations (and actual run time of ∼ 35mins), while the frontier-based algorithm took 2359 iterations (and run time of ∼ 78mins).

(a) t = 3: A frontier-based (b) Using the frontier-based (c) t = 3: Our (d)

Using

exploration algorithm initially algorithm the robots explore T opologicalExplore

T opologicalExplore

ﬁnds a single frontier and plans the entire environment in t = algorithm ﬁnds 2 topological algorithm the robots explore

a path to drive all the robots to- 2359 iterations.

classes of paths and hence the entire environment in

wards it.

splits the group of robots into t = 1045 iterations.

two.

Figure 4.4: Comparison between the frontier-based exploration algorithm (top row) of [100] and our T opologicalExplore algorithm (bottom row) in a partially-known environment using 4 robots. The purple curves show parts of the planned paths, while black represents traversed paths. White is known/explored, while light yellow is the unknown region.
This example illustrates how a topological approach to exploration, as ours, visibly and structurally outperforms standard frontier-based approaches in cases when the known environment is not simply-connected.
4.4.2 Simulations of Multi-Robot Topological Exploration
Figure 4.6 shows an example with eight robots. The environment used is a part of the 4th ﬂoor of the Levine hall at the University of Pennsylvania (a 21.3m × 34.2m environment, discretized by 0.1m × 0.1m cells). In Figure 4.6(a) the single group of robots discovers two topological classes, and hence splits into two groups, each consisting of four robots (Figure 4.6(b)). In Figure 4.6(c) each of those groups get assigned two topological classes to discover, thus each splitting further into groups of two robots (Figure 4.6(d)). Further splitting of three of those groups happen in Figure 4.6(e). Following which, as some of the groups end up exploring the homology classes assigned to them, they rejoin the other groups to help explore whatever remains.
Figure 4.6(i) shows comparison with the ﬁnal result obtained using the frontier-based approach of [100]. Even in this case not only the number of iterations required using the frontier-based approach is higher, the actual time required for computation was also higher in case of the frontier-based exploration. The frontierbased approach took ∼ 100mins, while our algorithm took ∼ 69mins to completely explore this particular environment.
38

4.4.3 Experiment with a Single Robot

Laser Sensor

Radio

Bumper

Differential Drive Wheels

Figure 4.5: The SCARAB mobile robot platform [65]
To demonstrate practical applicability, we implemented our algorithm on a mobile robot platform developed in the GRASP laboratory and known as the SCARAB [65]. Figure 4.5 illustrates the various components of the experimental platform and a snapshot of the robot in action. To localize the robot we currently use an adaptive Monte Carlo localization [44] module that relies on laser sensor data. Having multiple robots in the environment would not only require an additional local collision check layer, but also an additional complexity for localization.
The overall ToplogicalExplore algorithm, even when there is a single robot, remains the same. The key feature during the execution, however, is that we always have a single group of robots consisting of a single robot (i.e., Gpl = {{1}}), and whenever the SplitGroup subroutine is called, the group/robot has to choose one of the paths.
We performed the single-robot experiment in the same indoor environment (the blue-print of which we used to perform the multi-robot simulations). However, we sealed the two entrances at lower left and lower right leading to the larger room at the bottom. Figure 4.7 shows the result. In Figure 4.7(a), the robot starts from the bottom left corner and explores the environment to initially ﬁnd three topological classes. The robot follows one of these paths that lead to the frontier 2 in Figure 4.7(a) (In the ﬁgures we number the frontiers for convenience of referencing. It should however be noted that at no point in our algorithm do we need to compute or identify the frontiers or its connected components). When the robot ﬁnds further branches, it keeps on following the path with the current H-signature (thus, for example, reaching frontier 2 in Figure 4.7(b)). When there are no more feasible paths with the current H-signature (e.g., the frontier 2 disappears in Figure 4.7(c)), the robot starts following the shortest path with a new H-signature to a new frontier (e.g., frontier 5 in Figure 4.7(c)). This process continues until there are no frontiers left, hence completing the process of building the map (Figure 4.7(e)).
4.5 Conclusion
In this chapter, we have presented an algorithm to explore an unknown or partially known environment by gradually building a topological description of the environment. Using the notion of quotient spaces,
39

(a) t = 4.

(b) t = 136.

(c) t = 186.

(d) t = 275.

(e) t = 580.

(f) t = 891.

(g) t = 1180.

(h) t = 1790 (explo- (i) Comparison: Final result (t = 2638 iterations)

ration complete).

using frontier-based approach of [100].

Figure 4.6: (a)-(h): Simulation result with 8 robots exploring an indoor ofﬁce-like environment. (i): Comparison of performance with frontier-based algorithm of [100] (in the same environment, with same number of robots and same initial conﬁgurations).

(a) t = 1.

(b) t = 310.

(c) t = 540.

(d) t = 900.

(e) t = 1226.

Figure 4.7: Experiment result with a single robot exploring an indoor ofﬁce-like environment.

40

optimal paths in different topological classes leading up to the unknown region were found by searching in the H-augmented graph. Groups of robots are split into subgroups with each subgroup being assigned to a different homology class to enable efﬁcient exploration of the environment. In contrast to previous work, the exploration is guided by topological and not metric information about the world and is ideally suited to obtaining a coarse topological map without detailed metric information. We demonstrated the performance of our algorithm in simulation using multiple robots, and in experiment using a single robot. We also provided a comparison of performance between our algorithm and a frontier-based approach.
41

Chapter 5
Manipulation with Cables

Cables are widely used to transport power or towing payload. Before we present the application how we can manipulate a number of obejcts with a single cable, we brieﬂy discuss another problem to manipulate or transport a heavy object or payload with multiple small robots and cables in this chapter. The work in Section 5.1.1 was performed in close collaboration with Dr. Peng Cheng and Dr. Jonathan Fink. Much of this work was reported in [24]. The work in Section 5.2 was performed in close collaboration with Dr. Jonathan Fink and Dr. Nathan Michael. Much of this work was reported in [67, 40].

5.1 Cooperative Towing With Multiple Ground Robots
In this section, we address the cooperative towing of a payload by a mobile robot that moves in the plane. Robot pulls via cable attached to an object or a pallet carrying a payload and coordinates its motion to manipulate the payload through a planar, warehouse-like environment. We formulate a quasi-static model for manipulation and derive equations of motion that yield the motion of the payload for a prescribed motion of the robot in the presence of dry friction and tension constraints. We derive conditions of stable equilibrium for a robot towing the payload.

5.1.1 The Quasi-Static Model for Cooperative Towing

Our task is to control a robot so it can tow or carry an object subject to gravity and frictional forces from

any initial part conﬁguration to a desired goal part conﬁguration. We want to achieve a speciﬁed degree of

precision in positioning and orienting the object at a desired ﬁnal position and orientation.

The different variables characterizing a robot towing a payload are shown in Figure 5.1. The position

and orientation of the payload is given by (X, Y, θ) in the world frame. The velocity of the payload is a twist (in the plane) in the body-ﬁxed frame, xb − yb, attached to the payload: ξ = [x˙ , y˙, θ˙]T . We will use this

body-ﬁxed frame representation for the twist throughout the chapter.

Let

Rj

denote

the

position

of

a

reference

point

on

robot

j.

There

are

m

robots,

each

of

which

is

attached −−−→

via an inextensible cable that connects the point Rj on robot j and the point Pj on the payload. If PjRj

equals the free length of the cable, then the dot product of the unit vector uj with the relative velocity of the

42

yb

S1 s1

β1

Rj VRj yw uj

Pj ρj

αj Ob (X,Y)

ow xw

S3

(a)

xb
S2 θ

λt,1 S1

λn,1

λt,3 S3

Ob

Pj λt,2S2

λc,j

λn,3 mg λn,2

(b)

Rj VRj

Figure 5.1: Quasi-static manipulation: The object is supported by three support points, Si, with normal forces (out of the plane), λn,i and tangential frictional forces, λt,i. It is pulled by m cables, each exerting a force λc,j. Note the robot Rj pulls by moving the object with a prescribed (given) velocity, VRj .
(This ﬁgure is taken from [24].)

point Pj to the point Rj is non negative, which can be written as unilateral kinematic constraints1:

Aξ ≥ b

(5.1.1)

where

 A1 

 b1 

A =  . . .  , b = . . .   

Am

bm

(5.1.2)

where Aj is a function of the unit vector uj, showing the direction of the cable j, and the position vector −−→
ρj = ObP j :

 uj · i 

ATj

=

 

uj · j

, 

(ρj × uj) · k

(5.1.3)

where i, j and k are respectively unit vectors along xb, yb, and zb axis, and bj is a function of uj and the velocity vR,j of the towing robot j:

bj = uTj vR,j .

(5.1.4)

Note that bj ∈ [ −vRmax, vRmax ] because the robot velocity vR,j is bounded by vRmax. The set of twists of freedom [62] is deﬁned with respect to the tuple (A, b) as follows:

Σ(A,b) = { ξ | Aξ ≥ b }.

(5.1.5)

Note that this set is determined by the towing conﬁguration of the robots and the payload, speciﬁed by
1The vector inequality denotes that each element of the vector satisﬁes the inequality.
43

the matrix A, and the velocities of the robots, given by the vector b. The kinematics-statics duality is evident in this problem. λc, the m-vector of cable tensions, is non
negative and is non zero only when the equality in (5.1.1) is satisﬁed. Thus we write complementarity constraints:

0 ≤ λc ⊥ Aξ − b ≥ 0,

(5.1.6)

where “⊥” implies λc,j(Aξ − b)j = 0. Since λc and Aξ − b are non negative, λTc (Aξ − b) = 0. In order to model the dry friction between the object and the support surface, we assume that the object is
supported by a ﬁnite number of frictional point contacts. For three non collinear support points, the support forces λn,i ≥ 0, i = 1, 2, 3 can be uniquely obtained from the following equation

 1 1 1  λn,1 mg

ys,1

ys,2

ys,3

 

λn,2

 

=

 

0

, 

xs,1 xs,2 xs,3 λn,3

0

(5.1.7)

where (xs,i, ys,i) for i = 1, 2, 3 are the coordinates of the support points in the body-ﬁxed frame. If the object undergoes quasi-static motion, the tensions associated with m cables and the frictional
forces (λt,i,x, λt,i,y) at each of the three support points (i = 1, 2, 3) must add to zero. Thus, we have the equilibrium equations:

BT λt + AT λc = 0, λc ≥ 0

(5.1.8)

where B is a full rank 6 × 3 matrix:

 1 0 1 0 1 0

BT = B1T

B2T

B3T

= 

0

1

0

1

0

1 

−ys,1 xs,1 −ys,2 xs,2 −ys,3 xs,3

with

1 Bi = 0

0 1

−ys,i xs,i

and λt is an unknown 6-vector with components in the body-ﬁxed frame:

λTt,1

λt

=

λTt,2

 

λTt,3

with

λt,i = λt,i,x . λt,i,y

(5.1.9)
(5.1.10) (5.1.11)

44

yb xb
Ob ϕ
θ

yb xb
Ob

Figure 5.2: (Left) Arbitrary initial conﬁguration. (Right) Stable equilibrium conﬁguration. (This ﬁgure is taken from [24].)

We use FCi to denote the friction cone at the ith support point deﬁned by Coulomb friction:

0 ≤ λt,i 2 = λ2t,i,x + λ2t,i,y ≤ µλn,i.

(5.1.12)

Note that F Ci is the friction cone with a known λn,i. For a given object twist, the velocity vector of the support point can be written in the body-ﬁxed frame:

vt,i = Bi ξ = 1 0 −ys,i ξ. 0 1 xs,i

(5.1.13)

From Coulomb’s law, the friction forces are equal to µλn,i and are opposite to the direction of slip, except if the slip is zero when the magnitude is indeterminate. This can be written explicitly as:

or in aggregate form,

λ t,i(ξ) ∈ argmin vt,i(ξ)T λ i,
λ i∈F Ci

λ t(ξ) ∈ argmin ξT BT λ.
λ i∈F Ci

(5.1.14)

It is not too hard to verify that this is equivalent to the Coulomb friction law [2]. The existence and uniqueness of solutions to (5.1.6), (5.1.8), and (5.1.14) have been prove in [23].

5.1.2 Equilibrium Analysis
In this section, we will study the equilibrium of the towing system, i.e., the system has an invariant state, when one or two robots move along straight lines.
One-robot towing case The single robot towing system will converge to an equilibrium in which the system exhibits pure translation and the cable, the robot, and the center of mass of the part will be aligned as shown in Figure 5.2. The result is stated in the following theorem.
45

Theorem 5.1.1. If a single robot tows the part with positive cable tension and moves in the invariant direction along a straight line, the angle φ will converge to zero.
Proof. Because the cable will have positive tension, the kinematic constraint will be an equality constraint and the part twist will be the result of the following optimization problem:

 x˙ (φ) 

ξ∗(φ) =  y˙(φ)  = argminξ





θ˙(φ)

s. t.

−ϕ(ξ) .
A(φ) = b

(5.1.15)

We will prove this by showing that
1) θ˙φ < 0.
2) θ˙ = 0 if φ = 0.
We will ﬁrst prove that ξ∗(φ) ( and therefore θ˙(φ)) is a continuous function of φ in Step 1. Second, we show that θ˙ = 0 if and only if φ = 0, −π, or π in Step 2. Finally, we can infer that θ˙ is negative when φ ∈ (0, π) and positive when φ ∈ (−π, 0) as a property of the continuous function.
Step 1: We will ﬁrst prove that ξ∗(φ) is well-deﬁned, and then is continuous. Because there is only one robot, the matrix A(φ) is full rank. It is easy to check that

∃ λc > 0, AT λc = 0

(5.1.16)

is not true because the unique solution to its equality is λc = 0 which does not satisfy the inequality. By Stiemke’s lemma, (5.1.16) is false implies that

∃ξ : A ξ > 0

(5.1.17)

is true. Therefore there must exist twists that satisfy the constraint (5.1.17). For any given b, if elements bj ≤ 0, (5.1.17) implies the constraint Ajξ ≥ bj is satisﬁed. If there are elements bj > 0, then we can always scale ξ with a positive scalar so that a feasible ξ that satisﬁes Ajξ ≥ bj can be found. Thus, Σ(A,b) is not empty. There always exists a unique part twist ξ for (5.1.6), (5.1.8), and (5.1.14)[23]. Therefore, ξ∗(φ)
is a well-deﬁned function and continuous. Step 2: When θ˙ = 0, the part has pure translation and does not rotate around any of the three support
points. Therefore, the objective function is differentiable at θ˙ = 0 and we can compute the following
necessary KKT conditions.

3
αi(x˙ − ys,iθ˙) − λ cos φ =0
i=1
3
αi(y˙ + xs,iθ˙) − λ sin φ =0
i=1
3
αi(−ys,i(x˙ − ys,iθ˙) + xs,i(y˙ + xs,iθ˙)) − λρ sin φ =0
i=1

(5.1.18) (5.1.19) (5.1.20)

46

ϕ2 yb
Ob xb

vb=(vb,x,vb,y) (px,py)
ϕ1

Figure 5.3: The equilibrium of two-robot towing. (This ﬁgure is taken from [24] and reproduced.)

in which

αi =

µλn,i

.

(x˙ − ys,iθ˙)2 + (y˙ + xs,iθ˙)2

(5.1.21)

Solving these equations, we can see that θ˙ = 0 if and only if φ = 0, π, or −π

Step 3:

It

can

also

be

checked

that

when

φ

>

0

(for

example,

π 2

)

the

resulting

θ˙

is

negative.

Similarly,

when

φ

<

0

(for

example,

−

π 2

),

the

resulting

θ˙

is

positive.

This

complete

the

proof.

2

Two-robot towing case

An equilibrium of two-robot towing is stated in the following theorem.

Theorem 5.1.2. When two robots tow the part by moving in the same direction and velocity (therefore maintaining ﬁxed relative positions), the part can have zero angular velocity if the line passing through the center of mass and the intersection point of two cables is parallel to the robot moving direction as shown in Fig. 5.3.

Proof. The position vector ρi = [ρi cos(αi), ρi sin(αi)]T in the body ﬁxed frame, in which ρi is the length of the vector ρi. Let φj to be the angle between the anchor point position vector and the cable direction. Then the direction of cable will be uj = [cos(αj + φj), sin(αj + φj)]T in the body ﬁxed frame.
Assuming both robots and the part have a pure translation with the velocity of vb = [vb,x, vb,y]T in the body ﬁxed frame, the wrench balance equation is

 cos(α1 + φ1)

 

sin(α1 + φ1)

ρ1 sin(φ1)

cos(α2 + φ2) 

sin(α2 + φ2)

 

ρ2 sin(φ2)

λc,1 λc,2



µmg

vb,x vb



= 

µmg

vb,y vb

, 

0

(5.1.22)

which is true only when

ρ2 sin(φ2) sin(α1 + φ1) − ρ1 sin(φ1) sin(α2 + φ2) = vb,y . ρ2 sin(φ2) cos(α1 + φ1) − ρ1 sin(φ1) cos(α2 + φ2) vb,x

(5.1.23)

It can be easily checked that (5.1.23) is true when the line of action of the ﬁrst cable, the line of action of

47

the second cable, and the line passing through the center of mass and parallel to the robot moving direction

intersect at a single point.

2

Exhaustive simulation and experimental results show that the two robot system converges to the equilib-

rium state shown in Figure 5.3, given by (5.1.22). However, we have not been able to prove this analytically.

Thus the result of a stable equilibrium under two-robot towing remains a conjecture.

5.2 Kinematics and Statics of Cooperative Multi-Robot Aerial Manipulation with Cables
This section addresses the forward and inverse kinematics of payloads carried by aerial robots. We address the cases with one or two aerial robots and derive the kinematics and conditions for stable static equilibrium with non-negative cable tensions. We can establish the maximum number of equilibrium positions. We also present the conditions of aerial robot conﬁgurations to achieve unique stable conﬁguration of payload. However, we can extend this result to the case of three aerial robots to ﬁnd sufﬁcient conditions.

5.2.1 Kinematics of Planar Manipulation Systems
Let n be the number of cables or aerial robots. For the planar case, we study the n = 1 and n = 2 cases. The n ≥ 3 cases in the plane are special conﬁgurations where n cables with positive tensions completely constrain (or over constrain) the manipulated object.

Model: n = 1
The planar case with a single cable or robot (n = 1) can be considered as a pendulum. An object is suspended by a massless cable with length l whose one end is ﬁxed at the origin of the ﬁxed frame and the other end is attach on the object. The conﬁguration of the part is constrained by the length of cable, which is modeled as

(x − r sin θ)2 + (y + r cos θ)2 = l2

(5.2.1)

where (x, y, θ) is the position and orientation of the body frame in ﬁxed frame and r is the distance from the center of mass to the attachment point.

Model: n = 2
The planar case with two cables or robots (n = 2) is modeled as a four-bar-linkage (as shown in Figure 5.4), with the payload as the coupler. We assume the lengths of both cables are equal (l) and the center of mass is at the midpoint of the coupler (payload) whose length is R. The well-known constraint equations for a four-bar linkage are:

f (θ, φ) =(l cos θ − l cos φ − a)2 + (l sin θ − l sin φ − b)2 − R2

=2l2 + a2 + b2 − R2 − 2l2 cos θ cos φ − 2l2 sin θ sin φ − 2al cos θ + 2al cos φ − 2bl sin θ + 2bl sin φ =2l2 + a2 + b2 − R2 − 2l2 cos(θ − φ) − 2al cos θ + 2al cos φ − 2bl sin θ + 2bl sin φ

=0

(5.2.2)

48

ϕ

(a,b)

θ

l

l

(xC,yC) R

λg

Figure 5.4: The planar system modeled as a four-bar-linkage. The suspended payload is the coupler with an assumed center of mass at the middle point of the coupler.

where a, b, θ, and φ are as shown in Figure 5.4.

Using

the tangent half-angle formulation (u

=

tan

θ 2

,

v

=

tan

φ 2

),

the constraint equation

may be

reduced to a 4th order polynomial of u and v,

f (u, v) = (b2 + a2 − R2)u2 − 4blu + a2 + b2 − 4al + 4l2 − R2 v2 + 4blu2 − 8l2u + 4bl v + (4l2 + 4al − R2 + a2 + b2)u2 − 4blu + b2 + a2 − R2

=0.

(5.2.3)

The center of mass, (xC, yC), must trace a couple curve and is deﬁned by the equation:

4x6 + 4y6 + 12x4y2 + 12x2y4 − 12ax5 − 12by5 − 12bx4y − 12axy4 − 24ax3y2 − 24bx2y3 + (13a2 + 5b2 + 8r2 − 8l2)x4 + (8r2 + 5a2 + 13b2 − 8l2)y4 + 16abx3y + (18b2 + 16r2 + 18a2 − 16l2)x2y2 + 16abxy3 + (−16r2a − 6a3 + 16l2a − 6ab2)x3 − (6a2b + 6b3 + 16br2 − 16bl2)y3 − (6a2b − 16bl2 + 6b3 + 16br2)x2y + (−16r2a − 6a3 + 16l2a − 6ab2)xy2 + (2b2r2 + a4 + b4 + 4l4 + 2a2b2 + 10a2r2 − 10a2l2 − 6b2l2 + 4r4 − 8r2l2)x2 + (+b4 − 10b2l2 + 4r4 + 2a2b2 − 8r2l2 + a4 + 4l4 − 6a2l2 + 2a2r2 + 10b2r2)y2 + (−2b2r2a + 2b2l2a − 2a3r2 + 8r2l2a − 4r4a − 4l4a + 2a3l2)x + (16abr2 − 8abl2)xy + (−2a2br2 − 4r4b + 2a2bl2 + 8r2bl2 + 2b3l2 − 2b3r2 − 4l4b)y + b2r4 − 2b2r2l2 + r4a2 + l4a2 − 2r2a2l2 + b2l4 = 0.

(5.2.4)

where

a

and

b

are

shown

in

Figure

5.4

and

we

set

r

=

R 2

,

x

=

xC ,

and

y

=

yC

for

simpliﬁcation.

It

is

well-

49

known that this curve is a tri-circular sextic with triple points at inﬁnity, x = ±iy, w = 0 with coordinates (x, y, w) in projective space [51].

5.2.2 Direct Problem
In this section, we address the direct problem to ﬁnd the conﬁguration of payload from given conﬁgurations of the aerial robots. Considering the aerial robots as a ﬁxed anchor points and the payload is hanging by cables connecting these point and anchor points on the payload. Then the sum of all the wrenches on the payload should be zero. And this condition is the First Order Necessary Condition of minimum gravity potential energy problem. In this section, let qi be the position of the aerial robot and pi be the position of the anchor point on the payload. And the center of mass of the payload is assumed to be the geometric center of pis.

5.2.3 Direct problem: n = 2
The conﬁguration of the payload is determined by the positions of anchor points, p1 and p2, which minimize the gravity potential energy. To numerical solve the direct problem of a planar case ,n = 2, we formulate the optimization problem:

min
pi

p1,y + p2,y

st ||p1 − q1||22 − l2 ≤ 0

||p2 − q2||22 − l2 ≤ 0

||p1 − p2||22 − R2 = 0

(5.2.5)

where we assume that y is the vertical axis and the length of the two cables are the same as l. And the length of the payload or the distance between the anchor points on the payload is R. However the last constraints in (5.2.5) is the quadratic equality constraint, which is non-convex. So, this optimization problem does not guarantee the unique solution. But we need to plan the trajectories of aerial robots, which guarantees the unique conﬁguration, to estimate the conﬁguration of payload for its position control. So we will ﬁnd the conditions of the position of the aerial robots to achieve unique solution of the direct problem (5.2.5).

Proposition 5.2.1 (Conditions for Unique Solutions to the Direct Problem of n = 2). The solution to the (5.2.5) is unique provided that if the distance between two robots are longer than the distance between anchor point on the payload:

||q1 − q2||2 ≥ R.

(5.2.6)

50

Proof. By relaxing the equality constraints in (5.2.5), we see that the program becomes convex.

min
pi

p1,y + p2,y

st ||p1 − q1||22 − l2 ≤ 0

||p2 − q2||22 − l2 ≤ 0

||p1 − p2||22 − R2 ≤ 0.

(5.2.7)

We begin by considering the SOCP in (5.2.7). The First Order Necessary Conditions (FONC) are:

with

(µ1 + µ3)p1,x − µ3p2,x − µ1q1,x = 0 1 2 + (µ1 + µ3)p1,y − µ3p2,y − µ1q1,y = 0
−µ3p1,x + (µ2 + µ3)p2,x − µ2q2,x = 0 1 2 − µ3p1,y + (µ2 + µ3)p2,y − µ2q2,y = 0

(5.2.8)

||p1 − q1||22 − l2 ≤0 ||p2 − q2||22 − l2 ≤0 ||p1 − p2||22 − R2 ≤0

µ1 ≥0 µ2 ≥0 µ3 ≥0

µ1(||p1 − q1||22 − l2) =0 µ2(||p2 − q2||22 − l2) =0 µ1(||p1 − p2||22 − R2) =0.

Here, assume that µ3 = 0, which leads to ||p1 − p2||22 − R2 < 0. Then the FONC (5.2.8) will be

µ1(p1,x − q1,x) = 0 1 2 + µ1(p1,y − q1,y) = 0
µ2(p2,x − q2,x) = 0 1 2 + µ2(p2,y − q2,y) = 0.

(5.2.9)

So the 2nd and 4th equations lead to mu1 = 0 and µ2 = 0, respectively. Then, 1st and 3rd equations lead to p1,x = q1,x and p2,x − q2,x, respectively. Then the optimal conﬁguration will be

p∗i = qi +

0 −l

for i = {1, 2}

(5.2.10)

whose optimal value is

q1,y +q2,y 2

− l.

However, as µ3

=

0 this solution should satisfy the inequality of

||p1 − p2||22 − R2 < 0:

||p∗1 − p∗2||22 − R2 = ||q1 − q2||22 − R2 < 0

(5.2.11)

which is contradiction with the assumption of (5.2.6). So the suggested condition (5.2.6) leads to the optimal solution with µ3 = 0, which means the optimal solution of (5.2.7), which is a convex problem, should
51

q2

p2-p1

p2-p3
Figure 5.5: A graphical depiction of the conditions presented in Proposition 5.2.2. (This ﬁgure is taken from [40].)
satisﬁes f1(pi) = ||p1 − p2||22 − R2 = 0. Then the Direct Problem is equivalent to this relaxed problem and will have a unique solution.

So, under the condition of (5.2.6), we can achieve the unique solution of the direct problem in case of n = 2.

5.2.4 Direct problem: n = 3
In the case of n = 3, we assume that the anchor points on the payload forms an equilateral triangle of edge length, R, and the center of mass is the geometric center of this equilateral triangle. Then the direct problem will be formulated as an optimization problem of

min
pi

p1,z + p2,z + p3,z

st ||p1 − q1||22 − l2 ≤ 0

||p2 − q2||22 − l2 ≤ 0

||p3 − q3||22 − l2 ≤ 0

||p1 − p2||22 − R2 = 0

||p2 − p3||22 − R2 = 0

||p3 − p1||22 − R2 = 0

(5.2.12)

where we assume that z is the vertical axis and the length of the three cables are the same as l. However, it is not trivial to extend the condition of (5.2.6) to three dimensional case of (5.2.12). So, we will propose a sufﬁcient condition to achieve the unique solution of (5.2.12).
52

Proposition 5.2.2 (Conditions for Unique Solutions to the Direct Problem of n = 3). The solution to the (5.2.12) is unique when the ith aerial robot, qi, lies strictly inside the convex cone originated at the corresponding anchor point on the payload, pi and formed by three vectors of {(pi − pj), (pi − pk), e3} for j = i, k = i, k = j and e = [0, 0, 1]T as shown in Figure 5.5, which is called cone constraints. And we assume that the conﬁguration of the payload satisﬁes that these three vectors are linearly independent.
Proof. By relaxing the equality constraints in (5.2.12), we see that the program becomes convex.

min
pi

p1,z + p2,z + p3,z

st ||p1 − q1||22 − l2 ≤ 0

||p2 − q2||22 − l2 ≤ 0

||p3 − q3||22 − l2 ≤ 0

||p1 − p2||22 − R2 ≤ 0

||p2 − p3||22 − R2 ≤ 0

||p3 − p1||22 − R2 ≤ 0.

(5.2.13)

Then the FONC of (5.2.13) is
1 µ1(p1 − q1) + µ4(p1 − p2) + µ6(p1 − p3) + 2 e3 = 0
1 µ2(p2 − q2) + µ4(p2 − p1) + µ5(p2 − p3) + 2 e3 = 0
1 µ3(p3 − q3) + µ5(p3 − p2) + µ6(p3 − p1) + 2 e3 = 0
||p1 − q1||22 − l2 ≤ 0 ⊥ µ1 ≥ 0 ||p2 − q2||22 − l2 ≤ 0 ⊥ µ2 ≥ 0 ||p3 − q3||22 − l2 ≤ 0 ⊥ µ3 ≥ 0 ||p1 − p2||22 − R2 ≤ 0 ⊥ µ4 ≥ 0 ||p2 − p3||22 − R2 ≤ 0 ⊥ µ5 ≥ 0 ||p3 − p1||22 − R2 ≤ 0 ⊥ µ6 ≥ 0.

(5.2.14)

Assume that if µ1 = 0, then the ﬁrst condition in (5.2.14) will be

1 µ4(p1 − p2) + µ6(p1 − p3) + 2 e3 = 0

(5.2.15)

which violates the assumption that the three vectors forming the convex cone for i = 1 are linearly independent. And the same arguments can be applied for µ2 and µ3. So, we have µi > 0 for all i = {1, 2, 3}. Then

53

the ﬁrst three equations of (5.2.14) can be presented as

q1

−

p1

=

µ4 µ1

(p1

−

p2)

+

µ6 µ1

(p1

−

p3)

+

1 2µ1

e3

=

0

q2

−

p2

=

µ4 µ2

(p2

−

p1)

+

µ5 µ2

(p2

−

p3)

+

1 2µ2

e3

=

0

q3

−

p3

=

µ5 µ3

(p3

−

p2)

+

µ6 µ2

(p3

−

p1)

+

1 2µ3

e3

=

0.

(5.2.16)

From our assumption that the position vector qi − pi should lie strictly inside the convex cone of {(pi −

pj), (pi − pk), e3}, the coefﬁcients of the above equations in (5.2.16) should be all strictly positive,

µj µi

>0

for all i = {1, 2, 3} and j = {4, 5, 6}. Then it is obvious that µj > 0 for all j = {4, 5, 6}, which leads to

||p1 − p2||22 − R2 =0 ||p2 − p3||22 − R2 =0 ||p3 − p1||22 − R2 =0,

which means the optimal solution of (5.2.13), which is a convex problem, should satisﬁes ||pj −pk||22 −R2 = 0 for all j = {1, 2, 3}, k = {1, 2, 3} and j = k. Then the Direct Problem is equivalent to this relaxed problem and will have a unique solution.

However, the suggested condition works only when we know the desired conﬁguration of the payload, pis. But it is enough for path planning for aerial robots [40]. To ﬁnd a condition only depending on qis are remained as one of the future works.

5.2.5 Stability
In Sections 5.2.1, we developed the kinematic formulation of the n = {1, 2} cases. We now consider the stability of these systems. We begin by presenting the trivial case of n = 1 in order to provide an intuition to the approach we use in the analysis of the n = 2 system.
To study the stability of the system, we are interested in considering the potential energy of the payload assuming the ﬁxed position(s) of the robot(s). We also assume in this analysis that all cables are in tension.

Analysis: n = 1 From Section 5.2.1, we see that the wrench balance equation is

x − r sin θ

0

λ

y + r cos θ = mg 1 .

l

 

0

x

(5.2.17)

Therefore, the condition for static equilibrium is met when x = 0 and sin θ = 0, or (x, y) =

54

(0, −l − r), (0, −l + r), (0, l − r), (0, l + r). Computing the Hessian of the potential energy, V = mgy,

H(x, θ) =mg

∂2y ∂x2 ∂2y ∂x∂θ

∂2y ∂x∂θ ∂2y ∂θ2

mg =
l + 2r

1 r

r .
r(l + r)

(5.2.18)

A positive-deﬁnite H indicates the stability of a conﬁguration, leading us to conclude that (x, y) = (0, −l − r) is the only stable conﬁguration.
While the n = 1 analysis is trivial, we present it to elucidate the approach to studying the stability of the next system.

Analysis: n = 2

We begin by considering the equilibrium conﬁgurations, which correspond to the geometric point of intersection between the line of gravity and two cable forces. This condition is expressed as

1 det 1
 0

tan θ tan φ
1

0 b − a tan φ = 0.
 −xc

(5.2.19)

The potential energy of the system is

mg V (θ) = mgyc = 2 (l sin θ + l sin φ + b) ,

(5.2.20)

where φ is related to θ through (5.2.2). Clearly, the equilibrium points correspond to conﬁgurations in which V is stationary. Considering the ﬁrst and second derivatives,

dV mgl

dφ

=

cos θ + cos φ

dθ 2

dθ

d2V mgl

dφ 2

d2φ

dθ2 = 2

− sin θ − sin φ dθ

+ cos φ dθ2 ,

(5.2.21) (5.2.22)

we

conclude

that

we

must

ﬁnd

points

along

the

coupler

curve

which

correspond

to

dV dθ

=

0

and

d2 V dθ2

> 0.

The lines of tangency to the coupler curve may be thought of as a tangent line from inﬁnity whose class

determines the number of tangency points [36]. The class of the coupler curve (5.2.4) is twelve. A review of

various coupler curves for a four-bar-linkage is provided in [51]. Figure 5.6 depicts an example of a linkage

for which we can easily visualize the twelve horizontal tangents to the coupler curve and the corresponding

equilibrium points. As the coupler curve is a closed curve (with one or two branches), the number of local

maxima and minima are the same, and therefore six unstable and six stable equilibrium points (ignoring

tension constraints, λi > 0). Figure 5.7 depicts these stable conﬁgurations.

5.3 Conclusion
In this chapter, we discussed the classical method of suing cables to tow payload with multiple ground or aerial robots. First, we studied the mechanics of planar, multi-robot towing a planar payload subject to fric-
55

5

4

3

2

1

0

-1

-2

-3

-4

-5

-1

0

1

2

3

4

5

Figure 5.6: A coupler curve with twelve equilibrium conﬁgurations. The stable and unstable conﬁgurations are denoted by ﬁlled or open red diamonds. The stable conﬁgurations are shown in Figure 5.7. Note that tension constraints are ignored.

5

5

5

1

1

1

4

4

4

0

0

0

3

3

3

-1

-1

-1

2

2

2

-2

-2

-2

1

1

1

-3

-3

-3

0

0

0

-4

-4

-4

-1 -1

0

1

2

3

4

-1

5

-1

0

1

2

3

4

-1

5

-1

0

1

2

3

4

-5

5

-1

0

1

2

3

4

-5

5

-1

0

1

2

3

4

-5

5

-1

0

1

2

3

4

5

(a)

(b)

(c)

(d)

(e)

(f)

Figure 5.7: The six equilibrium conﬁgurations of Figure 5.6. Clearly Figures. 5.7(a)-5.7(c) are infeasible when considering tension constraints.
tion. The problem formulation incorporates complementarity constraints which are necessary to allow for cables becoming slack during a towing maneuver. We showed that a payload towed by one robot driving along a straight line, or two robots driving along parallel straight lines, converges to an equilibrium conﬁguration independent of the uncertainty in the support force distribution. This result suggest a robust primitive motion of planar towing problem. However, ﬁnding another robust primitive motion, rotating about a point with ﬁnite radius, is a remaining problem.
We also address the kinematics of payloads carried by aerial robots. We address the cases with one and two aerial robots and derive the kinematics and conditions for stable static equilibrium with non-negative cable tensions. We can establish the maximum number of equilibrium positions. We derived the conditions of aerial robot conﬁgurations to achieve a unique solution of direct problem with two or three aerial robots.

56

Chapter 6
Manipulation of A Set Of Objects
In this chapter, we study the problem of manipulating and transporting multiple objects on the plane using a cable attached at each end to a mobile robot. This problem is motivated by the use of boats with booms in skimming operations for cleaning oil spills or removing debris on the surface of the water. Because the cable is ﬂexible, the shape of the cable must be explicitly modeled in the problem. Further, the robots must cooperatively plan motions to achieve the required cable shape and gross position/orientation to separate the objects of interest and then transport them as speciﬁed. We ﬁrst derive the necessary topological conditions for achieving the desired separation of objects. We then propose a distributed search-based planning technique for ﬁnding optimal robot paths for separation and transportation. We demonstrate the applicability of this method using a dynamic simulation platform with explicit models of the cable dynamics, the contact between the cable and one or more objects, and the surface drag on the cable and on the objects. The work in Section 6.1-6.5 was performed in close collaboration with Dr. Subhrajit Bhattacharya, Hordur Heidarsson and Prof. Gaurav Sukhatme, much of which was reported in [56, 57].
6.1 Introduction
Object manipulation is an important problem in robotics. Certainly conventional approaches to manipulation using robot arms with grippers has received considerable attention and is well understood [104, 30]. In contrast, we are interested in the use of mobile robots to contact and manipulate objects without special purpose effectors. This allows more versatility but leads to many challenges. One approach relies on caging an object using multiple mobile robots. This problem has been studied for planar objects [39]. However, the ratio between the number of objects manipulated at a time, and the number of robots required for doing that is small, thus making such an approach highly inefﬁcient for manipulating a large number of objects and for separating objects in a ﬁeld with obstacles. In contrast, we propose a framework for manipulating a large number of objects with only a pair of robots.
The advantages of using ropes with robots for manipulation were demonstrated by Donald et al [34]. An interesting problem that arises in these settings is the modeling of the shape of the cable and the motion planning for the robots to control the position and shape of the cable. Motion planning for manipulation of rope-like ﬂexible objects is discussed in [82]. The problem of entangling and disentangling knots and the motion planning for this problem has been addressed in [60]. Our goal, however, is the motion planning that
57

∂W W
s e

s
∂W2

b-4

r1
-

ζ4
+
ζ1

b5 - - r2
+ +
ζ2
–C ζ5

r3- -b6
+ +
ζ3
–
ζ6

∂W1
e

(a) The initial conﬁguration of the cable and the two robots in the workspace W with boundary ∂W . Red and blue circles are objects to be separated. Two green boxes are the robots. Grey curve is the cable.

(b) ζi are representative points inside the objects, R1, R2, R3, B4, B5, B6 (in that order), and ri, i = 1, 2, 3 and bj , j = 4, 5, 6 are rays emanating from the respective
points. Using the bump forms, (2.2.3), corresponding to the
rays in deﬁning the H-signature, H(C) = [1, 1, 1, 0, 0, 0]. And, h(C) = “r1+b+5 r2+r3+b−5 ”.

Figure 6.1: The problem of separating the two types of objects.

s
∂W2

∂W1

C

e

∂W

τ2

s

Cf

R2

B1

s

e

R3

e

τ1
R1

Ci

B2

B3

(a) A separating conﬁguration of the cable, C, that separates the two types of objects.

(b) A possible set of paths that take the cable from the initial conﬁguration, Ci, to a conﬁguration homotopic to the separating conﬁguration, Cf .

Figure 6.2: An example of separating conﬁguration and a set of paths to the separating conﬁguration.

is required to manipulate objects on the plane and we are less interested in the speciﬁc conﬁguration of the cable. The use of robots to tow objects using cables is discussed in [53, 23] and in the previous Chapter 5. An extension of these ideas leads to using a cable with its ends tied to robots to cage and tow objects. Indeed this method is widely used in skimming operations on water surfaces [81, 54]. A description of the dynamics of such systems and an analysis of the problem of cooperative skimming are provided in [12, 4]. However, this work does not explicitly address the manipulation of objects.
In this chapter, we discuss the planning and control of the motions of two robots, each of which is tied to one end of a ﬂexible cable, with the goals of (a) separating a speciﬁed set of objects from other objects; and (b) to transport the speciﬁed objects to a destination. The ﬁrst step, as one might expect, is to navigate the robots around the objects so that the cable separates the objects of interest from the ones that are not of interest. The problem of ﬁnding a hypersurface separating two types of objects is studied as part of
58

C3
s B1

∂W
C1

R2

R3

e

C2

R1

B2

B3

s

B1

s

R2 e

τ2

R3

e

τ'1 R1

B2

B3

τ1

τ'2

(a) Three possible cable conﬁgurations separating the two types of objects. C1 and C2 are homotopic. But C3 belongs to a different homotopy class. See the curve C in Figure 6.1(b) for yet another cable conﬁguration that separates the two types of objects.

(b) The robot paths (up to homotopy) that can take the cable
to a desired separating conﬁguration (up to homotopy) are not
unique. In this ﬁgure, τ1 and τ1 are not homotopic, neither are τ2 and τ2. But either of the sets of paths, {τ1, τ2} or {τ1, τ2}, take the cable to the homotopy class shown in Figure 6.2(a).

Figure 6.3: The solutions of object separating problem is not unique.

statistical classiﬁcation problems [18, 93]. However such methods are susceptible to ﬁnding curves that can have disjoint components, do not have guarantees on optimality, and are statistical in nature. Moreover, the problem of ﬁnding a separating cable conﬁguration (the curve) that separates the objects does not give us a necessary means of ﬁnding the paths of the robots that achieve that conﬁguration. The ﬁrst key contribution of this chapter is a topological description of the problem of separating two sets of objects and the algebraic formulation of the separation problem. The second contribution is a complete motion planning algorithm that relies on graph search [25] to drive the robots in order to achieve separation and then transport the objects to speciﬁed destinations. We also derive a decoupled algorithm that has the advantage of only requiring to plan in the individual robot’s conﬁguration space instead of the joint state-space.

6.2 Problem Description
We consider the scenario where there are two classes of objects present in a ﬂat enclosed region, W . For convenience we will refer to the two classes as ‘blue’ and ‘red’. Without loss of generality, one of these classes of objects will be considered to be of interest (i.e., those need to be manipulated and transported), while the other consists of obstacles or objects that are not of interest. Let O = R1 ∪ R2 ∪ · · · ∪ Rr ∪ Br+1 ∪ Br+2 ∪ · · · ∪ Br+b ⊆ W , where R1, R2, · · · , Rr are r counts of red objects, and Br+1, Br+2, · · · , Br+b are b counts of blue objects. Each object, Ri or Bj, is assumed to be connected and arbitrarily shaped.
A ﬂexible cable is attached, at its two ends, to two robots that are capable of navigating on the ﬂat surface. Given an initial conﬁguration of the cable and the robots (Figure 6.1(a)), we need to ﬁrst make the robots follow paths to the boundary of the enclosed region, ∂W , such that the ﬁnal cable conﬁguration ‘separates’ the blue objects from the red, which we call the separating conﬁguration (Figure 6.2(b)). Once that is achieved, the robots can move along ∂W to enclose one type of objects and “pull” them out, thus separating and transporting those objects.
Suppose e and s are the points on the boundary reached by the robots so that they split ∂W into ∂W1
59

and ∂W2 as in Figure 6.2(a). It is clear that the robot paths and cable conﬁgurations that describe the problem and achieve the desired objective are sufﬁciently described up to homotopy. That is, if C1 and C2 are two cable conﬁgurations that are in the same homotopy class [15], then, “C1 separates the two types of objects” ⇐⇒ “C2 separates the two types of objects” (Figure 6.3(a)). Likewise, if a particular set of robot paths, {τ1, τ2}, carry the cable from the initial conﬁguration to the desired separating conﬁguration (up to homotopy), another set of paths, {τ1, τ2}, that are homotopic to the ﬁrst set (i.e. τ1 ∼ τ1 and τ2 ∼ τ2) will achieve the same objective.
In addition to this, it should also be noted that the homotopy class of the cable conﬁguration that achieves the separation of the two types of objects is not unique either. For example, in Figure 6.3(a), the conﬁguration C3 is in a different homotopy class from C1 or C2, but still separates the two types of objects. C in Figure 6.1(b) is another example. Furthermore, for a given desired separating conﬁguration of the cable (up to homotopy), the homotopy classes of the robot paths that can carry the cable from its initial conﬁguration to the separating conﬁguration, are not unique either (Figure 6.3(b)).
Thus, it is useful to develop a notion of optimality to more precisely deﬁne the problem objectives. It is natural to use length of the robot paths to the optimization criteria.
For the theoretical foundation and for setting up the optimization problem, we will make the following assumptions:
i. The objects are assumed to be stationary rigid bodies – that is, the cable cannot ‘pass through’ any of the objects, and that on contact of the cable with the objects the objects do not move. In the implementation (Section 6.5.2) we will however relax the conditions that the objects need to be stationary.
ii. The cable is ﬂexible, and there is no restriction on the length of the cable (i.e. the cable will not fall short and tug on the robots). We assume that the cable can either be spooled out as required from a cable reel residing on the robots, or may stretch as in an elastic band.
One simple and intuitive strategy to solve this problem is to drive all the robot on one (left) boundary of the workspace and ﬁx one robot. Then the other robot travels from this (left) boundary of the workspace to the opposite (right) boundary while passing one (red) object above it and the other (blue) object under it as shown in Figure 6.4(a). It is a simple and intuitive algorithm to ﬁnd and drive to a separating conﬁguration. However, this algorithm requires that all the obejcts should have different value of X coordinates. And this algorithm does not guarantee the shortest traveling distance. In the same environment, the cable conﬁguration or the path of a robot shown in Figure 6.4(b) is shorter than the one in Figure 6.4(a). The path can be shorter if we allow the robot to go backward to minimize the overall traveling distance. Also, we should allow the robot to go backward if the objects are not size less points like this case. For example, we cannot ﬁnd a path with this strategy in the environment of Figure 6.1(b). Also, this algorithm does not guarantee the shortest path of robot from the initial conﬁguration and we need another procedure to drive the robot to a speciﬁc part of the boundary of workspace.
In this work, we divide and solve this manipulation and transportation problem into two steps. The ﬁrst step is to ﬁnd a separating conﬁgurations, which works as initial conﬁguration of the simple controller for transportation, which will be discussed in Section 6.3. And the second problem is to navigate the robots to a separating conﬁgurations.
60

C
s

e

s

C'

e

(a) A separating conﬁguration achieved by intuitive planning. (b) A separating conﬁguration with less travel distance.
Figure 6.4: An example of separating conﬁgurations achieve by intuition when considering point objects.

Figure 6.5: An example of separating conﬁgurations which requires smart controller for transporting.
6.3 Separating Conﬁgurations
As the separating conﬁguration is the initial conﬁguration of the planner or controller of transporting, we assume a simple planner/controller for transporting and there should be a feasible path or control input from this separating conﬁguration to the ﬁnal goal. Consider the example in Figure 6.5, which shows a separating conﬁguration that satisﬁes the following Proposition 6.3.1. Considering that this conﬁguration is inﬁnitely long, the system could be stuck by pulling the cable side to side. And such conﬁguration to cause balance between internal forces is also possible for noncircular objects, too. However, it depends on the boundary condition of this contexture conﬁguration. If the objects at the end of the structure is free, we can decompose this contexture conﬁguration from its ends, by driving robots or the ends of the cable up and down. If we pin nails on the proper points on the boundary of the objects on the boundary to replace the constraints forces by imaginary objects next to it, we can make this contexture conﬁguration as a right body. (One obvious case is to pin two nails on the tangent points for the next two imaginary objects to it.) Or we can achieve such force balances by a wall tangent to the boundary object and pulling the cable with proper direction. However, we assume free workspace except the objects to manipulate, and we will not discuss about this interesting case further in this work.
As the feasible separating conﬁguration should be a separating conﬁguration that the given or designed controller for transporting can drive the cable-robot system to the goal. So, in this section, we propose a condition of separating conﬁguration that does not represent all possible separating conﬁgurations but a set of separating conﬁgurations which can be a proper initial conﬁguration for simple transporting controllers.
Proposition 6.3.1. Suppose C is an embedded cable conﬁguration such that C(0), C(1) ∈ ∂W (i.e. the 61

cable ends lie on the boundary of the environment). Say the end points of C splits ∂W into two parts: ∂W1 and ∂W2 (which themselves are curves in (W − O)). We assign orientation to ∂W1 and ∂W2 such that C ∂W1 and C ∂W2 are closed loops (Figure 6.2(a)). Then, C separates the two types of objects (i.e., it is a separating conﬁguration) iff one of the following holds for the vector H(C ∂W1):
i. The ﬁrst r components are all 1 or all −1, and the last b components are all 0.
ii. The last b components are all 1 or all −1, and the ﬁrst r components are all 0.
Note that from the deﬁnition of H-signature, H(C ∂W1) = H(C)+H(∂W1). Also, in these conditions the choice of ∂W1 over ∂W2 is made without loss of generality. The conditions could have been stated in terms of ∂W2 as well.
Sketch of Proof: The proof follows from the very deﬁnition of homology (see Figure 6.3(a)). First we note that C ∂W1 is a Jordan curve [43] inside W (since C is embedded). Hence there is a simply-connected region in W (not considering the objects) enclosed by C ∂W1. The objects (and their representative points) that this region will contain will manifest as a ±1 in the corresponding components of the vector H(C ∂W1). Since C ∂W1 is Jordan, it will wind around each of the enclosed points in the same direction (all clockwise or all anti-clockwise), thus making the corresponding components of the vectors either all +1 or all −1. All the other components will be 0. The statement of the lemma simply states that the enclosed representative points will be ones corresponding to the red objects or the blue objects, while the ones not enclosed will be ones corresponding to objects of the other color.
At this point it is instructive to illustrate why, in the above Proposition, we used the homology invariant instead of homotopy invariant. Consider the curve C in Figure 6.1(b), which clearly separates the red objects from blue. However we previously saw that the reduced word for (C ∂W1) is, h(C) h(∂W1) = “r1+b+5 r2+r3+b−5 b−6 r3−r2−b−5 r1−b−4 ”. Likewise the reduced word h(C) h(∂W2) = “r1+b+5 r2+r3+b−5 ”. Neither of these words are helpful in identifying the fact that C separates the blue objects from the red. However, H(C) + H(∂W1) = [0, 0, 0, −1, −1, −1]T , and H(C) + H(∂W2) = [1, 1, 1, 0, 0, 0]T – both satisfying the condition of Proposition 6.3.1 (note that the ﬁrst 3 components of the vector correspond to R1, R2 & R3, while the last 3 correspond to B4, B5 & B6), thus indicating that C indeed separates the blue from the red objects.
It is obvious that there could be separating conﬁgurations that do not satisfying Proposition 6.3.1 like examples in Figure 6.6. The conﬁguration in Figure 6.6(a) winds one red object twice and we can separate the red objects by pulling the two robots or the cable downward or −y direction. But we cannot separate the blue objects by pulling this cable upward or +y direction.Also, the conﬁguration in Figure 6.6(b) winds the red objects in different directions and we can separate only red objects by pulling cable downward. In both examples, we cannot separate the blue objects and need careful planning and control to release the red object after transporting to the destination. So, we do not consider such conﬁgurations as our separating conﬁguration and it is obvious by Proposition 6.3.1.
Proposition 6.3.2. (Refer to Figure 6.2(b)) Let C be a starting cable conﬁguration (which has an orientation from robot ‘2’ to robot 1’, as shown in Figure 6.1(a)) and C be a ﬁnal cable conﬁguration (which may or may not be a separating conﬁguration). Then the paths τ1 and τ2 for the two robots carry the cable from initial conﬁguration to the separating conﬁguration (up to homotopy) if and only if the closed loop
62

s
∂W2

b-4

r1
-

ζ4
+
ζ1

b5 - - r2
+ +
ζ2
–C ζ5

r3- +b6

+

+

+ +

ζ3

– –

ζ6

∂W1
e

s
∂W2

b-4

r1
-

ζ4
+
ζ1

b5 - - r2
––
ζ2
+C

r3- -b6
––
ζ3
+

∂W1
e

ζ5

ζ6

(a) A separating conﬁguration which winds the same object (b) A separating conﬁguration which winds red objects in dif-

twice. H(C) = [1, 1, 2, 0, 0, 0]T .

ferent direction. H(C) = [1, −1, −1, 0, 0, 0].

Figure 6.6: Examples of separating conﬁgurations which do not satisfy Proposition 6.3.1.

q2(0)

Figure 6.7: Illustration for Proof of Proposition 6.3.2.
(C τ2 −C −τ1) is null homotopic [49], i.e. h(C τ2 −C −τ1) = h(C) h(τ2) h(C )−1 h(τ1)−1 = “ ”, is the empty word (identity element).
Sketch of Proof: We note that unlike in Proposition 6.3.2 we don’t have the luxury of assuming that (C τ2 −C −τ1) will be Jordan (see, for example, Figure 6.2(b)). First, suppose paths τ1 and τ2 carries the cable from conﬁguration C to ﬁnal conﬁguration C . We choose two arbitrary points, p1 and p2, on the paths τ1 and τ2 respectively, as shown in Figure 6.7. Next consider the sequence of cable conﬁgurations from C to C as the robots carry it. We can thus construct a continuous function (a homotopy), C : [0, 1] × [0, 1] → (W − O), such that C(0, ·) ≡ C(·) and C(1, ·) ≡ C (·), and C(t) is a general intermediate cable conﬁguration. Such a curve, C(t), has its end points q1(t) ∈ τ1 and q2(t) ∈ τ2 (Figure 6.7). We consider the curve connecting q1(t) to p1 and lying on τ1 (call it q1(t)p1), and the one connecting q2(t) to p2 and lying on τ2 (call it q2(t)p2). Thus, the sequence of curves, D(t) := −(q1(t)p1) C(t) (q2(t)p2) , deﬁnes a homotopy between curves connecting p1 and p2. Thus, D(0) −D(1) is null-homotopic. That is, −(q1(0)p1) C(0) (q2(0)p2) − −(q1(1)p1) C(1) (q2(1)p2) ≡ (C τ2 −C −τ1), is null-homotopic.
Conversely, if (C τ2 −C −τ1) is null-homotopic, one can construct a homotopy, D, as before, and hence construct a sequence of curves C, that takes the cable from C to C .
63

b4 r1 b5

r2 r3 b6

s

ζ2

ζ4

s

e ζ3

e

Ci

ζ1

ζ5

ζ6

Cf

∂W2

(a) The rectangular environment with the goal of the robots being the left (cyan line) and right (magenta line) boundaries. ∂W2 does not intersect any of the rays (all of which point in the positive Y direction).

u1 u'1
h
h' ~ ~
u2 u'2
(b) Robots 1 and 2 navigating on copies of graph, G, formed by uniform discretization of conﬁguration space. Change in the h-signature of the cable due to transitions within the graph is also illustrated.

... ...

Figure 6.8: The environment and its discretization.
6.4 Implementation
For simplicity, we assume that the environment, W , is a rectangular region (x ∈ [xl, xr], y ∈ [yb, bt]), and all the rays, rj, j = 1, 2, · · · , r and bj, j = r + 1, r + 2, · · · , r + b, are parallel, pointing along the positive Y axis. Furthermore, we restrict the ﬁnal goals of the robots to the left and right boundaries of the environment (∂Wl at x = xl and ∂Wr at x = xr respectively), but they need to reach the opposite edges. Thus a part of the boundary, ∂W2, will never intersect any of the rays (Figure 6.8(a)), and hence H(∂W2) = [0, 0, · · · , 0]T and h(∂W2) =“ ”. This simpliﬁes the computation of H(Cf ∂W2) for Proposition 6.3.1 to the computation of H(Cf ).
We use a discrete representation of the environment, and construct a graph, G, by placing a vertex in every discrete cell and by establishing an edge between the vertices of adjacent cells. From such a graph we can construct an H-augmented graph, GH (for keeping track of the homology invariants), or an h-augmented graph, Gh (for keeping track of the homotopy invariants), as described in [15].
While the graph, G, itself can be quite arbitrary, for simplicity we used a uniform 8-connected discrete representation (see Figure 6.8(b)) of the environment for all our simulations and experiments.
6.4.1 Planning in Joint State-space
The problem under consideration is to plan optimal paths that would take a given initial cable conﬁguration, Ci, to a separating cable conﬁguration, and the robot 1 reaches the left (or right) edge of W , while robot 2 reaches the right (or left) edge. In the ﬁrst approach we plan paths in the joint state-space of the two robots. A graph, J = G × G, is deﬁned as the graph Cartesian product of two copies of G. Thus, for every pair of vertices, u1, u2 ∈ V (G), a vertex in V (J ) is of the form (u1, u2). We are given an initial vertex in the joint state-space, (ui1, ui2), and an initial conﬁguration of the cable (up to homotopy) in form of the h-signature
64

of the cable, hi (which, as deﬁned earlier, is a reduced word).

We deﬁne an augmented graph, Jh, such that a vertex in this graph contains the additional information

of the h-signature of the cable that is being carried by the robots. This, in essence, is similar to the H-

augmented graph construction detailed in [15]. Thus the initial vertex in the graph is vi = (ui1, ui2, hi),

which contain the information about the initial positions of the robots and the h-signature of the initial cable

conﬁguration, hi = h(Ci). A transition of the robots from (u1, u2, h) to (u1, u2, h ) will mean (due to

Proposition 6.3.2) that the h-signature of the resultant cable conﬁguration is equal to h = h(−τ2) h h(τ1)

(recall, ‘ ’ is concatenation, followed by reduction), where τ1 and τ2 are paths taken by the robots for the

transition

(see

Figure

6.8(b)).

Thus, for each −−−→

edg−−e−[→(u1, u2)

;

(u1, u2)]

∈

E(J ),

the

vertex

(u1, u2, h)

is

connected to neighbors (u1, u2, h(u−2→u2)

h

h(u1u1))

(where,

[a

;

b]

is

used

to

indicate

an edge −→

in

edge

set, E(G), from vertex a to b, and ab is the curve/line segment that constitutes the edge. ba is the same

curve but with opposite orientation).

We choose the optimization objective to be the sum of the length of the robot paths. Thus, the cost of the −−−→ −−−→
edge [(u1, u2, h);(u1, u2, h h(u1u1) h(u2u2))] ∈ E(Jh) is chosen to be the sum of the lengths of the edges [u1;u1] and [u2 ; u2] in E(G). For this cost and with the left and right boundaries as goal, an admissible heuristic function is f (u1, u2, h) = min ((u1,x − xl) + (xr − u2,x), (u2,x − xl) + (xr − u1,x)), which is a lower bound on the cost to reach a goal from (u1, u2, h) (where, uj,x is the X coordinate at a

vertex uj). Starting at (ui1, ui2, hi) we thus keep expanding the vertices in the graph, Jh, using a search algorithm
(we use Dijkstra’s [29] or A* [48] since they are complete, optimal and deterministic). A vertex (u1, u2, h) is deemed as goal if u1 ∈ ∂Wl and u2 ∈ ∂Wr (or vice-versa), and if h∗(h) + H(∂W2) (= h∗(h)) satisﬁes

the condition of Proposition 6.3.1 (i.e., it is a separating cable conﬁguration).

Planning in the joint state-space gives the ﬂexibility of easily incorporating additional constraints like

inter-robot collision avoidance, communication constraints, etc.

6.4.2 Decoupled Planning: A Distributed Approach

While the approach of planning in joint state-space is complete and optimal, it suffers from the obvious

drawback of being slow and inefﬁcient since the graph, J , is very large and is of high degree, being a

discrete representation of a 4-dimensional space. However, it is possible to decouple the searches for the two

robots in two copies of Gh (the h-augmented graph of G, described next), and run those searches in parallel

(parallel threads in our C++ implementation), comparing the solutions obtained from each parallel process

as they progress, and being able to conclude when the optimal solution is found, and thus halting the threads.

The h-augmented graph, Gh, is very similar to the concept of the H-signature augmented graph, GH

described in [15], only with the homology invariants being replaced by the homotopy invariants. Corre-

sponding to a given u ∈ V (G), there exists discrete number of the augmented states, (u, h) ∈ V (Gh), for

each homotopy class of paths (with h-signature h) from an initial vertex, ui, to the vertex u. Edges em-

−−→

anating

from

(u, h)

are

thus

of

the

form

[(u, h)

;

(u

,h

+

h(uu

))]

∈

E(Gh),

corresponding −−→

to

every

[u ; u ] ∈ E(G). The cost of such an edge is chosen to be the Euclidean length of uu . An admissible

heuristic function for this choice of cost, and with goal as ∂Wl ∪ ∂Wr, is f (u, h) = min(ux − xl, xr − ux). Thus, we start with two copies of the augmented graph, Gh,1 and Gh,2, in two parallel threads (that branch
off from a main thread), for robots 1 and 2. In robot j’s copy of the graph, we start expanding the vertices

65

... ... ...

(v2●, g2●) . . .
(v1a, g1a) (v12, g12)

(v2b, g2b)

. . .
1 (v11, g11)

. . .2
Ci

(v21, g21)

(a) Optimal paths in different homotopy classes corresponding to goal vertices (vj1, g1j ), (vj2, g2j ), · · · ∈ Gh,j are found in parallel threads for robot j = 1 (yel-
low) and robot j = 2 (green).

(b) A compatible combination of paths (with end vertices (v1a, ga1 ) and (v2b, gb2)) is such that the end points, v1a & v2a, lie on the opposite edges of W , and h∗((gb2)−1 h(Ci) ga1 ) satisﬁes the condition of Proposition 6.3.1.

Figure 6.9: Decoupled and distributed planning: Optimal paths with different h-signatures found for the two robots in parallel threads, and costs of compatible pairs are compared to ﬁnd the optimal compatible pair.

from (i.e., initiate the open set with) the vertex (uij, “ ”) ∈ Gh,j, j = 1, 2. We keep expanding the vertices in the respective graphs, and keep storing a path every time ∂Wl or ∂Wr is reached via a new homotopy class for the robot (i.e. if (v, g) is expanded, with v ∈ ∂Wl ∪ ∂Wr, then the vertex is bookmarked if the homotopy class g is not same for any of the previously bookmarked vertices for the robot). It is important to note that for each of the robots such optimal paths with different h-signatures are found in the order of their costs since we use an optimal search algorithm (Dikjstra’s/A* [48]). Suppose for robot ‘j’ such goal vertices are {(vj1, g1j ), (vj2, g2j ), (vj3, g3j ), · · · } with costs of the respective optimal paths c1j ≤ c2j ≤ c3j ≤ · · · , for j = 1, 2.
We deﬁne a partial order [90], , on R2, to compare the cost of pairs of paths of robots 1 and 2. One obvious choice is to compare the sum of the path costs: (α1, α2) (β1, β2) ⇔ α1 + α2 ≤ β1 + β2. However, one would desire that the task of carrying the cable is evenly distributed among the two robots, and not one of the robots end up traveling the most of the distance while the other travels very little. For this, we choose to minimize the maximum of the costs of the two paths (rather than their sum). Thus, we deﬁne the partial order to be

(α1, α2) (β1, β2) ⇐⇒ max(α1, α2) < max(β1, β2) or

(6.4.1)

max(α1, α2) = max(β1, β2) and min(α1, α2) ≤ min(β1, β2)

which we call the sorted lexicographic order. Thus, as the main thread of the program receives the two sequences of optimal paths to the left/right
66

boundaries with different h-signatures from the two different threads, it keeps checking them in pairs. A pair, (v1a, ga1) and (v2b, gb2), is deemed ‘compatible’ (Figure 6.9(b)) if the corresponding ﬁnal cable conﬁguration (whose h-signature, by Proposition 6.3.2, is equal to (gb2)−1 h(Ci) ga1) is a separating conﬁguration. That is, due to Proposition 6.3.1, a pair is compatible if h∗((gb2)−1 h(Ci) ga1) + H(∂W2) is a vector with ﬁrst r components ±1 and rest zeros, or last b components ±1 and rest zeros. We keep record of the most optimal compatible pair (i.e., one with lowest (ca1, cb2), where comparisons are made using ‘ ’).
Say at an instant the most optimal pair has cost (c∗1, c∗2). Since the optimal paths with different hsignatures are found in order of there costs, if robot j ﬁnds a path such that its cost is greater than current value of max(c∗1, c∗2) (or, if we were using the sum of the pairs in deﬁning the partial order, then c∗1 + c∗2), we can say for sure that none of the paths to be discovered for robot j after that point can be part of a more
optimal pair. Hence we stop the search for robot j. When the searches for both the robots end, the current
optimal pair is the global optimal one.

6.4.3 Sequential Planning
While the approach of decoupled planning in the previous Section is efﬁcient method for large map, it requires large memory and heavy computation with large number of objects. For example, in Figure 6.9(a), the planner of robot j = 1 ﬁnds the path to (v11, g11) ﬁrst, because it is the minimum cost path to the boundary of the workspace. Then keep ﬁnding paths to the left vertices on the left boundary in the homotopy class of g11 then it will ﬁnd the optimal path in different homotopy class of (v12, g21). But, we need only one optimal path in each homotopy class. So, this decoupled planning can be and should be improved.
We divide this problem into two steps. The ﬁrst step is ﬁnd proper combination of homotopy class. Here we do not allow to wind the same object twice. In other word, we do not allow that rk+ or rk− (k = 1, 2, . . . , r) appears in gkj more than once. If we have n = r +b objects the upper bound of possible number of homotopy class is

N ≤1 + 2n + 2n(2n − 2) + 2n(2n − 2)(2n − 3) + 2n(2n − 2)(2n − 3)(2n − 4) + · · ·

2n−1

k

2n−1

=1 + 2n + 2n (2n − k)) + 2n (2n − k))

k=2 m=1

m=1

(6.4.2) (6.4.3)

where the ﬁrst 1 is for empty word or the word with length 0. For word of length 1 we can choose arbitrary reference ray in any direction. So the number of possible words is 2n. For the kth letter, it cannot be the k −1 letters which are already appeared and the letter of different sign with k −1th letter. As, the 2nth letter has no choice, number of possible word of length 2n is the same with 2n − 1. However, in this computation, we did not consider the case that the letter of different sign with the previous, (k − 1)th, letter is already appeared. So, the Equation (6.4.2) can give us upper bound but not exact number of possible words. However, it is obvious that the possible homotopy class is ﬁnite and we can ﬁnd the corresponding word to each homotopy class.
The decoupled planning works with heuristic function which gives the minimum cost to the boundary while not considering the homotopy class of the path. This function is a proper heuristic function for decoupled planning because there is no desired homotopy class in decoupled planning. However, we have desired homotopy class of the path in sequential planning, we need a heuristic function which consider the goal homotopy class. The basic concept of this heuristic function is that the robot should visit the reference ray
67

b4 r1 b5 r2 r3 b6 ∂W

ζ2

ζ4

ζ3

ζ1

ζ5

ζ6

Figure 6.10: An example of heuristic cost(the sum of the length of green lines) of the path start from the green circle to the boundary while the desired homotopy class is hd = “r2+r3+”. In this example, we ignore
the feasibility of the path with respect to objects.

in order described in the given word or h-signature to ﬁnd the path in the desired homotopy class. While traveling between reference rays, other reference ray will work like obstacle to be avoided not to change the h-signature of the path. In Figure 6.10, the heuristic cost from given point, the green circle, to the boundary while the desired homotopy class is given by hd = “r2+r3+” will be the sum of the length of green lines. As we ignore the feasibility with respect to the objects, the cost will be the sum of each length of path between start conﬁguration to the ﬁrst reference ray, paths between reference rays; and the path between the last reference ray and the boundary of the workspace while considering other reference rays as obstacles. Also, we do not consider the cost between segments of paths, it is underestimation and an admissible heuristic function. We add some detailed example in Appendix A.
The sequential planning we deﬁne a vertex as

ca,b = (ga1, gb2, ca1, cb2, realcosta1, realcostb2)

(6.4.4)

where is gaj is the homotopy class of thejth robot, caj is the cost to the corresponding path, realcostaj is boolean variable if corresponding cost caj is the real cost or heuristic cost. Then the following algorithm
describe the sequential planning Algorithm 1: Pseudocode for Sequential Planning:

1. |Find all possible homotopy class for each robot.

2. |Build the set of all possible combinations ca,b ∈ C satisﬁes the condition of Proposition 6.3.1.

3. |for all ca,b ∈ C

4. |Calculate heuristic cost and update ca1 and cb2. Set realcosta1 = f alse and realcostb2 = f alse. 5. |end for

6. |while TRUE

7. |Sort C and ﬁnd the combination of minimum cost, ca,b ∈ C

8. |if realcosta1 &realcostb2 9. |break

10. |else

11.

|if notrealcosta1

68

12.

|Find optimal path of the ﬁrst robot in homotopy class of ga1

13.

|Update ca1 . Set realcosta1 = true.

14. |end if

15.

|if notrealcostb2

16.

|Find optimal path of the second robot in homotopy class of gb2

17.

|Update cb2. Set realcostb2 = true.

18. |end if

19. |end while 20. |return ca,b

Then the result combination is the optimal one. The unexpanded vertices cannot be better because the estimated cost is underestimation. We need to ﬁnd optimal paths in each homotopy class to update the cost with real value. However, we do not need to non-optimal paths in each homotopy class to reduce the memory requirements and computation power.

6.5 Result
In this section, we demonstrate the performance of the algorithm and implementation in the previous section by various ways.
6.5.1 Simulation Results
We implemented the search in the joint state-space as well as the decoupled search in C++ programming language with ROS integration, and used A* search algorithm. All computations were performed on a system with dual-core processor with clock speed 2.6 MHz and 4 Gb memory. Throughout this thesis we consider an uniform discretization of the environment for simplicity. However, the techniques developed in this thesis is not restricted to any speciﬁc discretization scheme or even a speciﬁc search algorithm. A more detailed discussion on the generality of the technique can be found in [15].
Joint State-space Plan
The search in this 4-dimensional environment is prohibitively expensive for large environments. Figure 6.11(a) shows the result in a simple environment, 30 × 30 discretized, and with 3 objects of each type. The search took about 4250 s and expanded 1484999 vertices in Jh. Figure 6.11(b) shows the result obtained for same problem, but using the decoupled planning (and using sum of the cost of the paths for deﬁning the partial order, , for being consistent). The result has the same optimal cost as the joint state-space planning, but took less than 1 s with 19144 and 19593 vertices being expanded in Gh,1 and Gh,2. All objects were inﬂated to avoid collision.
Decoupled Planning
In this section we present results obtained using the decoupled, distributed implementation. The sorted lexicographic order was used for ‘ ’. Figure 6.12(a) show the plans obtained for two robots in a 100 × 100 discretized environment. The planning took about 1.3 s, and expanded 39764 and 40066 vertices in
69

(a) Planning in the joint state-space took 4250s. The sum (b) The distributed decoupled planning gives result with

of the costs of two paths is 65.598 discretization units.

the same optimal cost, but takes about 2s to run.

Figure 6.11: A simple 30 × 30 environment with r = b = 3. The green & yellow are the paths of the robots. The rays emanating from ζj are also shown. The dark gray segment indicates the initial cable conﬁguration.

(a) The planned paths in a 100 × 100 discretized envi- (b) The planned paths in a 400 × 400 discretized envi-

ronment.

ronment.

Figure 6.12: Decoupled, distributed plans. Initial cable is shown in gray/black. Paths are in green and yellow.

70

Figure 6.13: Sequential plan. Initial cable is shown in gray/black. Paths are in green and yellow.
the graphs of the two robots. Figure 6.12(b) shows the result in a much larger (400 × 400 discretized) environment. The planning time for this case was 490 s, with 1086182 and 1079670 vertices being expanded.
Sequential Planning In this section we present results obtained using the sequential planning implementation. The decoupled algorithm shows fast computation with several examples. However. the decoupled algorithm failed to ﬁnd optimal paths in the case of eleven objects in Figure 6.13 because of lack of memory. The sequential planner ﬁnd this optimal path in 350 s.
6.5.2 Dynamic Simulation and Fast Re-planning
So far we have planned the paths with the assumptions that the object remain stationary as the robots follow the planned paths. However, in a practical implementation, where the objects will be free to move on the surface, the interaction between the cable and the objects will change the conﬁguration of the environment. Consequently there comes the need for re-planning.
Dynamic Simulation For the purpose of testing this scenario we build an accurate real-time dynamic simulation platform for the cable (modeled as a serial chain) and freely ﬂoating disk-shaped objects on a ﬂuid. Using Lagrangian mechanics we developed the equations of motion with realistic modeling of drag forces [12], and modeled the contacts using linear complementarity conditions [1]. We use a simple feedback (PD) controller to make each robot follow the paths generated by the planner.
In this section, we extend the dynamics simulation platform proposed in [12]. We adopt the discrete dynamic model of the ﬁxed-length cable by modeling the cable as a series of n rigid cylindrical segments connected by revolute joints. The ith segment is modeled as an uniform cylinder of length Li, and its
71

(xL,yL)
w1 w2

wn

(ox,1,oy,1)

wn-1

(ox,2,oy,2)

wi θi
wi-1

Figure 6.14: The dynamic model showing a discrete model of the cable consisting of n rigid segments and two rigid circular objects.

diameter, di, is assumed to be much smaller than its length. This model of the cable has n + 2 degrees of freedom.
We also consider the dynamics of no count of objects freely ﬂoating on the water. Although it is straightforward to extend them to non circular objects, for simplicity, the objects are modeled as uniform disks of radius Rj, j = 1, 2, · · · , no. Each disk-shaped object is assumed to have only two degrees of freedom – the x and y coordinates of their centers. The objects’ rotational degree of freedom are ignored due to symmetry of the disk shapes, and due to the assumption that the coefﬁcient of friction on the surface of the objects are zero, thus allowing only normal forces to be imparted on the objects.
Thus the system has (2 + n) + 2no degrees of freedom. We choose the generalized coordinates to be q = [xL, yL, θ1, . . . , θn, o1,x, . . . , ono,x, o1,y, . . . , ono,y]T , where w0 := [xL, yL]T is the coordinates of the point at which the cable is attached to the left boat, θi is the angles made by the ith cylindrical segment with respect to positive X axis of the global inertial frame of reference, and oj = [oj,x, oj,y]T are the coordinates of the center of the jth object (see Figure 6.14).
Using Lagrangian mechanics, the equations of motion for the system can be written as,

d ∂K ∂K dt ∂q˙l − ∂ql − Qql = 0 ∀ql ∈ {xL, yL, θ1, . . . , θn, o1,x, . . . , ono,x, o1,y, . . . , ono,y}

(6.5.1)

72

where, K, the kinetic energy of the system, is given by,

n
K=

1 2 mi

(p˙ i

·

p˙ i)

+

1 2

miL2i 12

θ˙i2

no 1 + 2 Mj (o˙ j · o˙ j)

i=1

j=1

(6.5.2)

where pi is the center of mass of the ith segment of the cable, mi is the mass of the ith segment of the cable, and Mj is the mass of the jth object. Since we assume frictionless contact with the disk-shaped objects, the kinetic energy due to rotation of the objects will remain unchanged (i.e. derivatives w.r.t. the coordinates and time will be zero), and hence not considered as part of the expression for kinetic energy in the Lagrange equations.
The generalized forces are

n

QxL =fLx + fRx + Fj,x

j=1

n

QyL =fLy + fRy + Fj,y

j=1

Qθi

=fRxLi

sin θi

+

fRy Li

cos θi

+

τi

+

n
Fk
k=1

·

∂pk ∂θi

Qoj,x = − cj o˙j,x

Qoj,y = − cj o˙j,y

∀i ∈ {1, 2, . . . , n}

(6.5.3)
(6.5.4)
(6.5.5) (6.5.6) (6.5.7)

where [fLx, fLy]T and [fRx, fRy]T are the input forces on the left and right ends of the cable respectively;

Fi :=

Fi,x Fi,y

Li /2

=−

cV vi (s) + cSvi⊥(s) ds

−Li /2

Li /2

τi := −

ri(s) × cV vi (s) + cSvi⊥(s) ds

−Li /2

(6.5.8) (6.5.9)

are the forces and torques due to drags on the cylindrical segments of the cable, where cV and cS are constants that are functions of ﬂuid properties and Reynolds number [42] and ri is the moment arm with respect to the left end of cylindrical segment. For these constants we use the same values suggested in [12]. In writing the above equations for the forces and torques, the relative ﬂow velocity along each segment has been decomposed into two components – one parallel to the axis (vi ), other perpendicular to the axis (vi⊥), which, using a parameter, s, along the length of the segments, are given by,

vi (s) = vi⊥(s) =

cos θi sin θi

· r˙ i(s)

− sin θi · r˙ i(s) cos θi

cos θi sin θi
− sin θi cos θi

(6.5.10) (6.5.11)

under the assumption that the ﬂuid is stationary. Also, the generalized forces on the jth object due to the drag (Equation (6.5.6) and (6.5.7)) are assumed to be proportional to the speed of the ﬂow at low Reynold’s

73

oj

wi

wi-1 θi

oj wi wi-1 θi

oj oi

(a) The ﬁrst type of contact.

(b) The second type of contact.

(c) The third type of contact.

Figure 6.15: The three types of contacts considered in the model.

number. For a 3-dimensional sphere moving through a ﬂuid, Stokes’ law give a drag equal to FD,sphere = 3πµU d where U and d are speed and diameter of the sphere respectively [101], the direction of which is opposite to the direction of motion of the sphere. We assume that each object is a sphere of radius Rj, the bottom half of which is under the water surface. Thus, the drag on each object being half of that on the sphere,

−3πµUd

FD,j = 2

= −3πµRjo˙ j.

(6.5.12)

Thus, cj = 3πµRj in Equations (6.5.6) and (6.5.7), where the kinematic viscosity of seawater is µ = 1.07 × 10−3kg/(m · s) at 20 ◦C [101].
Using ﬁrst order approximation of the acceleration in the equations of motion, Equation (6.5.1), we can write at the kth time instant,

M

(qk )

q˙ k+1 − ∆tk

q˙ k

− V(q˙ k, qk)

−

Qk

=

0

(6.5.13)

where V(q˙ k, qk) ∈ Rn+2no+2 and Qk = Qq1 , . . . , Qqn+2no+2 T ∈ Rn+2no+2 is the vector of generalized forces. Thus, using Euler integration, we can ﬁnd the generalized states and velocities at the (k + 1)th time step.
We next consider the contact between cable and objects. Since we assume frictionless contacts between the rigid bodies, we adopt a time-stepping algorithms to solve Linear Complementarity Problem at every step [1, 3, 91]. In order to account for noninterpenetration between the rigid bodies with smooth distance function, we assume that all the objects are disk-shaped, and that the thickness of cable segments are negligible, which is consistent with our earlier assumptions. In our model we consider three different cases of contacts or noninterpenetration conditions.
The ﬁrst case (Figure 6.15(a)) is the tangential contact between the segments of the cable and the diskshaped object. For this, we need to consider the distance between the ith segment and the jth disk-shaped object only when the center of the object lies in the strip perpendicular to the segment and containing the segment (the yellow region in Figure 6.16). If the ith segment and the jth disk-shaped object do not satisfy the both conditions, we do not need to consider contact between them.

74

o1 wi-1

cos θi sin θi
θi

wi o2

Figure 6.16: When the center of an object lies in the yellow region, we need to check for contact between the ith segment of the cable and the object. The boundary of yellow region (i.e. the green lines) are perpendicular to (wi − wi−1). In this example, we need to check for contact between ith segment and o1, but not o2.

The inequalities that need to be satisﬁed for that to happen are,

cos θi sin θi

· (oj − wi−1) ≥0

−

cos θi sin θi

· (oj − wi) ≥0

(6.5.14) (6.5.15)

where wi is the coordinate of the right end of the ith segment:

wi = wi−1 + Li cos θi sin θi

(6.5.16)

with w0 = [xL, yL]T being the left end of the cable. Then the distance between the ith segment and jth object is

DLO,ij =

cos θi × (oj − wi−1) − Rj. sin θi

(6.5.17)

The second case (Figure 6.15(b)) is the non-tangent contact between an end of a segment and an object. Such a case can arise when at least one of the Equation (6.5.14) and (6.5.15) is not satisﬁed. Then the distance function is

DP O,ij = wi − oj − Rj

(6.5.18)

for ∀i ∈ {0, 1, . . . , n} and ∀j ∈ {1, . . . , no}. The last case (Figure 6.15(c)) is the contact between two objects. The distance function in this case is

DOO,ij = oi − oj − Ri − Rj 75

(6.5.19)

for ∀i, j ∈ {1, . . . , no}. At a given state, qk, at time tk, we assume all the distances are nonnegative. We select and stack up
all the distance functions whose values are less than some threshold, δ, (say m of them) into a vector, f (qk) = f1(qk), . . . , fm(qk) T , i.e. fp(qk) < δ for p = 1, 2, . . . , m. Then our goal is to ﬁnd the state in
the next step which satisﬁes,

fp(qk+1) ≥ 0

(6.5.20)

which results in a nonlinear problem. We thus linearize the distance functions around qk using a ﬁrst order approximation as follows [1, 3, 91],

fp(qk+1)

fp(qk) + ∆tk∇qfp(qk)q˙ k+1

(6.5.21)

which is linear with respect to the generalized velocity of the next time step. Now we add the impulse due to contact into the generalized force term of Equation (6.5.13), and thus
construct the equations of motion which satisfy the noninterpenetration constraints

M kq˙ k+1 =M kq˙ k + ∆tk Vk + Qk + ∇qf (qk)T λk =M kq˙ ku + ∇qf (qk)T λk

(6.5.22)

where M k = M (qk), Vk = V(q˙ k, qk), Qk = Q(qk) and λk = λk1, . . . , λkm T is a vector of nonnegative components (since the impulse due contact of two rigid bodies should be in a direction such that the distance functions increase). To simplify the notation, we deﬁne q˙ ku to be the generalized velocity of the next time step when there is no impulse due to noninterpenetration constraints, which satisﬁes the Equation (6.5.13).
Then we substitute this equation into the noninterpenetration constraints to achieve a linear inequality,

f (qk) + ∆tk∇qf (qk) M k −1 M kq˙ ku + ∇qf (qk)T λk =f (qk) + ∆tk∇qf (qk)q˙ ku + ∆tk∇qf (qk) M k −1 ∇qf (qk)T λk =bk + Akλk ≥ 0

(6.5.23)

where bk = f (qk) + ∆tk∇qf (qk)q˙ ku ∈ Rm and Ak = ∆tk∇qf (qk) M k −1 ∇qf (qk)T ∈ Rm×m are known, given by the current generalized state and velocity, qk and q˙ k. Hence we need to solve a linear
complementarity problem (LCP),

bk + Akλk ≥ 0 λk ≥ 0
λk · bk + Akλk = 0

(6.5.24)

at each time step. We can solve this LCP efﬁciently with Lemke’s method [26, 38]. We then substitute the solution of λk into the following equation (derived from Equation (6.5.22)) to ﬁnd the generalized state and

76

velocity for the next time step.

q˙ k+1 =q˙ ku + M k −1 ∇qf (qk)T λk qk+1 =qk + ∆tkq˙ k+1

(6.5.25) (6.5.26)

Re-planning

Throughout the Section 6.4, we presented algorithms to solve this path planning problem more fast in large envirnoment with objects. However, the simulation results in the previous Section 6.5.1 showed that it is hard to implement real-time planner in large envirnoment. However, in the dynamics environment, when the objects are fre to move, we need real-time re-planning for successful manipulation. So in this section, we will brieﬂy present a real-time replanning algorithm for real-time simulation or experiments in dynamic environments. Instead of solving the path planning problem to adapt the change of the environment, we ﬁnd the optimal paths of the robots which lead to the same homotopy class of the initial path.
Instead of solving the entire problem every time whenever the environment changes, we invoke a replanning algorithm whenever we need replanning:

• Any two objects exchange the order of the X coordinates of their representative points (i.e., the rays emanating from ζj cross each other)

• One of the planned paths becomes invalid (due to an object moving on top of it).

Let gsc = (gb2)−1 h(Ci) ga1 be the h-signature of the separating conﬁguration of the iniatial path planning, which can be generated by any algorithm described in the previous Section 6.4. Assume we keep track-

ing the cable conﬁguration and its homotopy class, gc = h(C). If the trigger was caused due to switching

of the X coordinates of two representative points, we interchange the positions of the corresponding letters

in the words (gsc and gc) wherever they appear side-by-side. Then the goal h-signature of the paths of two

robots

should

be

determined

so

that

gsc

=

(gb2

−1
)

gc

ga1 . We can simply split the h-signature of the separat-

ing conﬁguration as gsc = gfsc gbsc and the number of possible conﬁgurations of (gfsc, gbsc) is length(gsc)+1.

And we can split the h-signature of the current cable conﬁguration as gc = gfc gbc in the same manner to ﬁnd

length(gc) + 1 combinations. Then we will achieve (length(gsc) + 1) × (length(gsc) + 1) combiniations

of

ga1 =(gbc)−1 gbsc

gb2 =(gfsc

(gfc

−1 −1
))

=

gfc

(gfsc)−1

(6.5.27)

which will drive the cable-robot system to the same separating conﬁguration of the initial path:

(gb2

−1
)

gc

ga1 =(gfc

(gfsc)−1

−1
)

gfc gbc

(gbc)−1 gbsc

=gfsc (gfc )−1 gfc gbc (gbc)−1 gbsc = gfsc gbsc = gsc.

(6.5.28)

As we have ﬁnite number of possible combinations of h-signatures of pthas of robots, we ﬁnd the optimal paths of the robots from current positions by using the same algorithm used in the sequential planning

77

t = 0.000000

t = 58.060000

t = 178.345000

t = 298.645000

t = 479.095000

50

50

50

50

50

40

40

40

40

40

30

30

30

30

30

20

20

20

20

20

10

10

10

10

10

0

0

0

0

0

0

10 20 30 40 50 0

10 20 30 40 50 0

10 20 30 40 50 0

10 20 30 40 50 0

10 20 30 40 50

(a) t = 0.00 s

(b) t = 58.06 s

(c) t = 178.35 s

(d) t = 298.65 s

(e) t = 479.10 s

Figure 6.17: Dynamic simulation for separation of objects. The gray curve is the cable, with black dots marking robots at its ends. Green curves are the planned paths. Magenta curves are the robot footprints. Red & blue disks are the rigid freely-ﬂoating objects. See http://youtu.be/GyCn-8yDzO0 for video.

Figure 6.18: Experiments with Autonomous Boats conducted by H. K. Heidarsson, University of Southern California [56]. Red and blue circles are Buoys (objects). Thin gray curve is the planned paths of two ASVs. The Black curve is the current cable conﬁguration. See http://youtu.be/vGgca2w2UdA for video.
described in 6.4.3, which ﬁnds the optimal combination of h−-signatures and paths of the robots. The only difference is how we build the set of combinations, C.
Figure 6.17 shows the simulation result. Figure 6.17(a) shows the initial conﬁguration of the system. As the objects move and the map change, the planned paths of robot are re-computed (shown by green curves in Figures 6.17(b)-(e)). We are able to successfully separate the red objects from the blue ones.
6.5.3 Experiment Results
To demonstrate the performance of the suggested algorithm, the ﬁeld experiments were conducted in Puddingstone Lake, San Dimas, CA. The experiment was performed by Hordur Kristinn Heidarsson under the supervision of Prof. Gaurav Sukhatme of University of Southern California [56].
The two Autonomous Surface Vessels (ASV) are identical, each around 2 m long and 0.8 m wide, capable of speeds up to 1.6 m/s, using two electric thrusters and a rudder for control. Both are equipped with a GPS, an IMU with integrated compass and an onboard computer for control.
The two ASVs have a 40 m long ﬂoating rope attached between them with periodically spaced markers 78

W δ δ

δ y
x

δ
δ Δ

Figure 6.19: A large problem. Red and blue dots are object. Green curves are cable-robot teams. Light blue and red boxes are the baskets to bring objects. The dashed line is a smallest box to enclose all objects to be manipulated. Gray box is the workspace of the problem. The yellow boxes are the workspace of each cable-robot team.
on it for increased visibility and to use as ﬁxed sampling points. Buoys (the objects to be separated) are placed in the water and anchored in place in an area 50 m × 50 m, and their approximate locations recorded using GPS.
To record the experiment, particularly the position and shape of the rope, a camera, in an adjustable tilt mount, was mounted on top of a 30 ft mast which stood on shore close to the experiment area, overlooking it. Figure 6.18 shows a snapshot of the experimental. The video of experiment is available at http://youtu.be/vGgca2w2UdA.
The experiment result showed that the planned paths were feasible and the ASVs followed the planned paths successfully.
6.6 Sequential Manipulation of Large Number of Objects
We presented various implementation to decrease the computation time and solve this planning problem with more number of objects in larger environments in Section 6.4. However, it is practically impossible to ﬁnd a solution with a large number of objects due to heavy computation. Also, as the size of the workspace and number of objects increases, we need longer cable and more powerful actuator on robots to manipulate and transport obejcts. So, it is not practical to manipulate and transprt a large number of objects with the
79

same strategy described in the previous sections. In this section, we will consider the problem to manipulate and transport a large number of objects with multiple cable-robot teams (see Figure 6.19). There are a large number of red and blue objects. Each cable-robot team will sequentially manipulate and transport the objects to the corresponding baskets. To simplify the algorithm, we assume that the number of cable-robot team is equal to the number of pairs of red/blue baskets. And each cable-robot team is assigned to its own pair of baskets.

6.6.1 Algorithm
In this section, we will describe how we can sequentially manipulate and transport objects to basket efﬁciently and successfully. As the size of the planning problem become enormous comparing to the problem of single cable-robot team, it is practically impossible to ﬁnd paths of all the cable-robot team in a single planner; the dimension of the search space will be too large for real-time planning. So, we will reduce the size of the problem by splitting the large planning problem into a planning problem of single cable-robot team like the previous problem. We need to decentralize the planning so that each cable-robot team ﬁnds its own path.

Workspace of each cable-robot team
As there are other cable-robot teams, each cable-robot team should consider the conﬁgurations and paths of other cable-robot teams to avoid collisions and cable entanglements. As the conﬁgurations and paths of other cable-robot teams keep changing and the manipulation will happen only in a part of whole workspace, it is not an efﬁcient way to ﬁnd path of cable-robot team in the whole workspace. So, we assign the workspace, Wj ⊂ W , as a subset of the whole workspace for the jth cable-robot team. To determine the workspace of each robot, we will explain with the robot on the bottom of Figure 6.19. For other robot will work with the same manner by proper transformation(rotation) of the coordinates. In Figure 6.19, the dashed lines are the boundary of the smallest rectangle including all the red and blue object to be manipulate while its edge are parallel to x or y axis. Then the workspace W = {(x, y)|xl ≤ x ≤ xr, yb ≤ y ≤ yt} will have δ margins from this box. Then the workspace of the jth cable robot team whose cable length is Lj is a square box of

Wj = {(x, y)|xj ≤ x ≤ xj + lj,x, yb ≤ y ≤ yb + lj,y}

(6.6.1)

√

√

where lj is the length of the edge while 2lj,x ≤ Lj and 2lj,y ≤ Lj, which will guarantee that the maxi-

mum distance between two robots will be less than the cable length while navigating inside the workspace,

Wj. Also, we reduce lj,x and lj,y properly to avoid overlapping with workspace of other cable-robot teams.

And xj is the left boundary of the workspace Wj which is determined by the minimum value of x coordinate

of the objects in W whose y coordinate lies between yb and yb + lj. If we assume there is alway certain dis-

tances between objects so that the robots can travel, we can always ﬁnd paths that can separate this objects.

And we can manipulate at least one object for each manipulation and can separate all the objects.

Coarse grid and search
To reduce the computation time, we will adapt a coarse grid map for our search algorithm (see Figure 6.20). The workspace is divided into set of cells by the rays from the reference points inside each objects, ζj in four
80

b4 r1 b5

r2 r3 b6 W

ζ2

ζ4

ζ3

gl ζ1

ζ5
s

ζ6
gr

Figure 6.20: An example of coarse grid. the given workspace is split into set of cells whose boundaries are the reference rays, the cyan lines, and the grey lines. the topology class of path does not change when crossing the grey lines.

81

directions, (+x, −x, +y, −y). And we consider 4-way connected map; the cell is connected to the neighbor cells who share edges, not a vertex. The topology class of path does not change when move to the neighbor cell through grey lines. And the topology class of the cell changes only when passing to the neighbor cell through reference rays, the cyan lines in Figure 6.20. So, we can track the change of topology of the path.
Then we drive the two robots to the cell in the middle of bottom, which is marked as s in Figure 6.20. This cell is the initial node of search. The goal of each robot will be the cells on the left and right bottom corners, gl and gr in Figure 6.20.

Efﬁcient sequential manipulation

We will sequentially manipulate and transport the objects. We will ﬁnd paths of two robot for each cablerobot team inside its own workspace, Wj. However, we cannot guarantee that there is always a solution that satisﬁes the Proposition 6.3.1. Eventhough such a path exists, it could no be optimal in some other point of view. For example, if only one object is on the upper left corner and all others are on the right bottom, it will be efﬁcient to remain the one on the left corner for other cable-robot team or next manipulation. So, we will follow the decoupled planning algorithm described in the previous section to ﬁnd the set of paths for each robot {τj1, τj2, τj3, . . . } for j ∈ {l, r} where taukj start from the cells and reach the goal cell gj. Then hkj = h(τjk) is the homotopy class of corresponding path of the robots. Then we will ﬁnd the optimal combination of the paths that maximize the efﬁciency of each manipulation:

max
a,b

sum(H(−τla τlb)) max(cal , cbr) + 2∆

(6.6.2)

where ∆ is the underestimated cost between the basket and the workspace as shown in Figure 6.19. Also, this pair of paths should be embed. And the components of H(−τla τlb) should be 1 or 0 or one kind of object (for example red) and should be 0 for the other kind (for example blue). Then sum(H(−τla τlb) is the number of objects (for example red) we can manipulate and transport by pulling the cable in −y direction to
the basket. And these objects have the same color or are the same kind. By maximizing the Equation (6.6.2),
we can maximize the number of objects, numerator, to separate with respect to the cost of the manipulation,
denominator.

6.6.2 Simulation Result
For the simulation for this large problem, we extend the dynamics simulator described in Section 6.5.2 to consider a large number of objects with multiple cable-robot teams. To reduce the computation time, we do not consider the cable-cable contacts. As each cable team will work in there own workspace, there is little possibility that cable-cable contact occurs. So we demonstrate the suggested algorithm with simulation of 100 objects (50 red objects and 50 blue objects).
The Figure 6.21 shows the simulation result with 4 cable-robot teams. Each cable robot team separates and transports the objects to its own baskets. The size of the workspace for each cable-robot team is properly reduced to avoid overlapping like Figure 6.21(i).

82

(a)

(b)

(c)

(d)

(e)

(f)

(g)

(h)

(i)

(j)

Figure 6.21: Dynamic simulation for separation of a large number of objects with multiple cable-robot teams via sequential manipulation. The red and blue dots are the objects. The green curves are the cables. The red and blue ’s are the baskets. Yellow boxes are the workspace of each cable-robot team. Magenta curves are the paths of the robots. See http://youtu.be/ZHrEIo8dGDA for video.
6.7 Conclusion
In this chapter, we present a formal mathematical description of the problem of planning and control for a ﬂexible cable towed by two robots so as to separate two types of objects in a planar environment. We develop a graph search-based implementation, and distribute the computation for efﬁciency. We demonstrate the working of the algorithms through simulations, and the practical applicability of the method using a complete dynamic simulation. We also extend this problem to separate a large number of objects with multiple cable-robot team via sequential manipulation and transportation. We presented various algorithms to reduce the computation time but still the algorithm is not real-time. We build the graph from ﬁne grid of the environment. However, we can adapt other graphs like visibility graph or Voronoi tessellation to reduce the size of search space. We need to choose one which is easy and fast to build while the topology of its edges can be easily calculated. Also, to manipulate large number of objects more efﬁciently, we need to ﬁnd more systematical method to assign workspace of each cable-robot team. Also, in real debris clean-up or oil skimming with ﬁxed obstacles like rocks, we need to develop proper planner and controller for transporting procedure to avoid obstacles while not losing objects or oil.

83

Chapter 7
Conclusion
7.1 Summary
In this thesis, we have presented different trajectory generation or path planning problems considering topology classes. In Chapter 3, we presented a method to ﬁnd a smooth optimal trajectory subject to geometric and kinematic constraints, and restricted to a speciﬁc topology class. In Chapter 4, we proposed an algorithm to explore an unknown or partially known environment by gradually building a topological description of the environment. Using the notion of quotient spaces, optimal paths in different topological classes leading up to the unknown region were found by searching in the H-augmented graph. We also addressed the forward and inverse kinematics of payloads carried by aerial robots. In Chapter 6, we presented a formal mathematical description of the problem of planning and control for a ﬂexible cable towed by two robots so as to separate two types of objects in a planar environment. We also extended this problem to separate a large number of objects with multiple cable-robot team via sequential manipulation and transportation.
7.2 Main Contributions
There are three key contributions in this thesis. The ﬁrst contribution is to present optimal control problem to generate optimal trajectories under topol-
ogy class constraints. As the H-signature is a homology class invariant function, the gradient would be zero almost everywhere. So, it is not a proper constraints for optimal trajectory generation problem formulated as optimal control problem. Because it is practically impossible to ﬁnd analytical solution of the optimal control problems and we depends on numerical solvers to ﬁnd solution. Most of the numerical solvers depends on gradients of cost function and constraints function to improve the solution. So, we cannot expect to ﬁnd a solution if the gradients are zero in infeasible region of the search space. In this work, we introduced a H-signature calculated from integer variables corresponding to the intermediate point on the trajectory. To our knowledge, it is the ﬁrst work to deﬁne homology class invariant function, from coarse information of the trajectory, whose gradient is not zero. By adapting this new H-signature, we formulate the optimal trajectory generation under homology class constraints as MIQP to guarantee the global optimal solution.
We also presented optimal control problem to generate optimal trajectories under homotopy class constraints. As the integer variables in MIQP provide the coarse representation of the trajectory, we can build
84

a set of integer variables which correspond to the trajectories in the same homotopy class. By ﬁnding the integer variables in the given homotopy class, we can ﬁnd optimal trajectory under the given homotopy class constraints by solving QP while adjusting time distribution.
The second contribution of this thesis deals with how the topological constraints can be used to solve practical problems. We suggest the topological exploration algorithm based on H-signature as the alternative method of frontier-based planning.
Most of the exploration algorithms with multiple robots depend on frontier-based planning to maximize the information gain. However, we can deploy the group of robots into different paths by comparing the H-signature of paths instead of the goal frontiers. As the calculation time of H-signature is negligible and we do not need preprocessing of ﬁnding frontiers, this algorithm can work fast and efﬁcient.
Finally, the last contribution is the manipulation using cable. The cables are widely used in robotic or mechanical systems to transport powers. However, we can also use cables to tow payload with single or multiple robots. In this thesis, we presented a stable motion primitive of straight line motion to two a payload with single or two mobile robot. Also, we discussed the kinematics of payload and aerial robots connected by cables. The unique conﬁguration of payload can be achieved if the aerial robots satisfy the suggested conditions.
As the cable is a curve in plane or three dimensional space, it has inﬁnite dimensions and it is practically impossible to control the cable conﬁguration with ﬁnite number of robots. In this work, instead of control the conﬁguration of the cable, we plan and control the homotopy class of the cable with only two robots, which are attach both ends of the cable, to manipulate and transport a set of objects.
First, we deﬁne the separating conﬁguration as the topological constraints of the cable to manipulate and transport only one kind of objects. Then we implemented different algorithms to navigate the robots to reach the separating conﬁguration from the initial conﬁguration while minimizing the travel distance.
We also extend this manipulation problem to consider a large number of objects with multiple cablerobot team via sequential manipulation and transportation. We deﬁned the efﬁciency of each manipulation to increase the performance of whole manipulation problem.
7.3 Future Work
There are many directions for future work. One direction of the future work is to increase the performance of the suggested algorithm. And the other direction is to extend the algorithm to solve more complicated problems.
The suggested algorithms to ﬁnd optimal trajectories under topological constraints can generate anytime solution or guarantee the global optimal solution. But in practical implementation, the size of the problem is too large to ﬁnd solution in real-time. So, it is important to reduce the size of the problem to reduce the computation load to make this approach practical. This improvement is one of the key direction of the future works.
In addition, we plan to extend the this optimal trajectory generation problem to three-dimensional space. We introduced the topological exploration algorithm as an alternative criteria of Frontier-based planning. However, the current implementation is centralized and necessitates the integration and sharing of all the sensor information of all the robots. If we implement this exploration algorithm in decentralized manner, it would be robust to the failure or loss of a groups or robot, or temporary disconnection of communications.
85

For decentralized algorithm, we need properly sharing the map between groups of robots when they are inside the communication range. Developing proper communication protocol to share topological information is remained for future research. Also, we need to verify the decentralized algorithm with by conducting experiments with more than one robot.
One of the most intriguing direction of future work is to solve the problem of clean up surface oil or debris in the presence of ﬁxed obstacles. In this work, we assume a simple feedback control for transportation process. However, in the presence of ﬁxed obstacle, which cannot be removed by the skimming operation, the ﬁxed obstacles should be avoided in the transportation process and both robots and cable should avoid these obstacles by considering the topology of the paths of the robots. Also, the robots should maintain proper distance inside the cable length not to leak any objects to transport. Finally, we need to reduce the dimension of the search space for fast planning.
The ﬁrst direction of future work in this section discuss about ﬁnding optimal trajectories faster for practical problem. The heavy computation of the optimal control problem prevents us to apply this algorithm to more complicated problems. For example, we used graph-search-based planning for the topological exploration and manipulation problems in Chapter 4 and 6 to simplify the problem and reduce the computation time. So, one of the direction of future work is to implement the algorithm for these applications as optimal control problems. For real-time implementation, we need to reduce the size the optimization problem. One way to reduce the problem size it to adapt model predictive control. For example, we ﬁnd the coarse path, or the integer variables, from graph-search-based planner and ﬁnd smooth optimal trajectories for ﬁnite horizon.
Another direction of future work is to extend the suggested algorithm to dynamic environments. In the manipulation of a set objects, we consider all the objects are stationary. However, some objects could move actively to avoid our robots or randomly by external forces. In this work, we proposed a fast-replanning algorithm but there could be better strategy to consider dynamic environments. One good example of planning and control dynamic environments is elastic band [78], strips [22] and roadmaps [103]. Merging the suggested topological constraints into these algorithm is one of obvious and trivial ways to extend this problem with moving objects. However, when the objects are moving, we need to sense the cable conﬁguration or estimate the homotopy class of the cable. As the objects can pass the previously executed paths of robots, we cannot just estimate the homotopy class of the cable from current object conﬁgurations and the previously executed paths of robots. Even though, the robots are stationary, the homotopy class of the cable can be changed by the movements of objects. As we estimate the homotopy class of cable only from paths of robots, it is an interesting problem to consider moving objects or change of reference rays.
One obvious and intriguing direction of future work is to manipulate and transport a set of objects with a net, a surface in three dimensional space. To extend the suggested algorithm to this three-dimentional problem, we need some mathematical framework. First, we need a topological, or any coarse, representation of a surface like homotopy or homology of cable. Then we need to deﬁne the separating conﬁguration based on this topological, or coarse, representation as we described in this work. And the last part of this problem is to ﬁnd the relation between the topology class, or coarse presentation, of surface and paths/trajectories of robots like Proposition 6.3.2. Also, we need to consider what is the minimum number of robots to control the topology class, or coarse representation, of the surface.
The last direction of future work is ﬁnd and solve novel and practical problems by considering topology of robot systems. It is obvious that topology class is the coarse representation of the path/trajectory or
86

cable. So, we can add some abstract constraints into our path planning problems in the form of topological constraints. For example, wireless communication allows us to share information between robots without physical contact but requres the robots to stay inside certain range. However, the wireless communication will not work in extreme conditions like mission under the nuclear pollution or communication jam by other agents. In such circumstances, we need wired communication between robot-robot or robot-user for stable and robust communication. another issue is the power supply of robots. The battery is the most commner source of power for mobile or aerial robots. And the capacity of the battery keeps increasing and the size or weight of battery keeps decreasing. However, the limitation of actuation and the size of the robot prevent to install arbitrary size or number of batteries on the robot. And the wired power supply is the most reliable source of energy. So, the mission in extreme environments, it is necessary to consider the conﬁguration of cable connecting robot-robot or robot-user in planning and control. In this case, the reachable region does not simply depend on the length of the cable but the history of the paths of robots. So, we need to plan the paths of robots considering the topology of the previously executed paths and build the map of reachable region.
87

