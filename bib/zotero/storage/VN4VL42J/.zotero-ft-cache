2015 IEEE International Conference on Robotics and Automation (ICRA) Washington State Convention Center Seattle, Washington, May 26-30, 2015
Batch Informed Trees (BIT*): Sampling-based Optimal Planning via the Heuristically Guided Search of Implicit Random Geometric Graphs
Jonathan D. Gammell1, Siddhartha S. Srinivasa2, and Timothy D. Barfoot1

Abstract— In this paper, we present Batch Informed Trees (BIT*), a planning algorithm based on unifying graph- and sampling-based planning techniques. By recognizing that a set of samples describes an implicit random geometric graph (RGG), we are able to combine the efﬁcient ordered nature of graph-based techniques, such as A*, with the anytime scalability of sampling-based algorithms, such as Rapidly-exploring Random Trees (RRT).
BIT* uses a heuristic to efﬁciently search a series of increasingly dense implicit RGGs while reusing previous information. It can be viewed as an extension of incremental graphsearch techniques, such as Lifelong Planning A* (LPA*), to continuous problem domains as well as a generalization of existing sampling-based optimal planners. It is shown that it is probabilistically complete and asymptotically optimal.
We demonstrate the utility of BIT* on simulated random worlds in R2 and R8 and manipulation problems on CMU’s HERB, a 14-DOF two-armed robot. On these problems, BIT* ﬁnds better solutions faster than RRT, RRT*, Informed RRT*, and Fast Marching Trees (FMT*) with faster anytime convergence towards the optimum, especially in high dimensions.
I. INTRODUCTION
Graph-search and sampling-based methods are two popular techniques for path planning in robotics. Graph-based searches, such as Dijkstra’s algorithm [1] and A* [2], use dynamic programming [3] to exactly solve a discrete approximation of a problem. These algorithms are not only resolution complete but also resolution optimal, always ﬁnding the optimal solution to the given problem at the chosen discretization, if one exists. A* does this efﬁciently by using a heuristic to estimate the total cost of a solution constrained to pass through a state. The result is an algorithm that searches in order of decreasing solution quality and is optimally efﬁcient. Any other optimal algorithm using the same heuristic will expand at least as many vertices as A* [2].
The quality of the continuous solution found by these graph-search techniques depends heavily on the discretization of the problem. Finer discretization increases the quality of the solution [4], but also increases the computational effort necessary to ﬁnd it. This becomes a signiﬁcant problem in high-dimensional spaces, such as for manipulation planning (Fig. 1), as the size of the discrete state space grows exponentially with the number of dimensions. Bellman [5] referred to this problem as the curse of dimensionality. Graphsearch techniques have still been successful as planning algorithms [6] on a variety of graph types [7], [8], including
1 J. D. Gammell and T. D. Barfoot are with the Autonomous Space Robotics Lab at the University of Toronto, Toronto, Ontario, Canada. Email: {jon.gammell, tim.barfoot}@utoronto.ca
2 S. S. Srinivasa is with The Personal Robotics Lab at Carnegie Mellon University, Pittsburgh, Pennsylvania, USA. Email: siddh@cs.cmu.edu

Fig. 1. A composite ﬁgure of a trajectory generated by BIT* for a difﬁcult 14-DOF two-arm manipulation planning problem on HERB. In the trial pictured, BIT* found a solution in 4 seconds and spent 2.5 minutes reﬁning it. Over 25 trials with 2.5 minutes of computational time, BIT* had a median solution cost of 17.4 and success rate of 68%, while Informed RRT* and FMT* had median costs of 25.3 and 17.2 and success rates of 8% and 36%, respectively. Nonoptimal planners, RRT and RRT-Connect, had median costs of 31.1 and 22.1 and success rates of 8% and 100%, respectively.
for nonholonomoic robots [9], [10], kinodynamic planning [11], [12], and manipulation planning [13].
Graph search has also been extended to anytime and incremental search. Anytime techniques [14]–[16] quickly ﬁnd a suboptimal path before completing the search for the optimum, while incremental techniques [15]–[19] handle changes in a graph efﬁciently by reusing information.
Sampling-based planners, such as Probabilistic Roadmaps (PRM) [20], Rapidly-exploring Random Trees (RRT) [21], and Expansive Space Trees (EST) [22], avoid the discretization problems of graph-search techniques by randomly sampling the continuous planning domain. This scales more effectively to high-dimensional problems, but makes their search probabilistic. They are probabilistically complete, having a probability of ﬁnding a solution, if one exists, that goes to one as the number of samples goes to inﬁnity. Anytime algorithms, such as RRT and EST, also have anytime resolution, a growing representation of the problem domain that becomes increasingly accurate as the number of iterations increases. Optimal variants, such as RRT* and PRM* [23], are also asymptotically optimal, converging asymptotically to the optimal solution with probability one as the number of samples goes to inﬁnity (almost sure asymptotic convergence). While solutions improve with computational time, this does not guarantee a reasonable rate of convergence as the random sampling is inherently unordered.
There is a long history of adding graph-search concepts to sampling-based planners. Algorithms have used heuristics to reﬁne the RRT search, including by biasing the sampling procedure [24], and to deﬁne a series of subplanning problems given the current solution [25]. Similarly, focusing techniques

978-1-4799-6923-4/15/$31.00 ©2015 IEEE

3067

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 23,2022 at 14:59:40 UTC from IEEE Xplore. Restrictions apply.

have also been used to limit the search of RRT* once it ﬁnds a solution [26]–[28]. While these techniques can improve the initial solution and/or the convergence rate to the optimum, their RRT-based search is still unordered.
Other algorithms order the search at the expense of anytime resolution. Fast Marching Trees (FMT*) [29] uses a marching method to process a single set of samples. The resulting search is ordered on cost-to-come but must be restarted if a higher resolution is needed. The Motion Planning Using Lower Bounds (MPLB) algorithm [30] extends FMT* to quasi-anytime resolution and an ordering given by estimating the cost of solutions constrained to pass through each state. The quasi-anytime resolution is achieved by solving a series of independent problems with an increasing number of samples. It is stated that this can be done efﬁciently by reusing information, but no speciﬁc methods are presented.
Still other algorithms attempt to extend graph-search directly to continuous planning problems. In Randomized A* (RA*) [31] and Sampling-based A* (SBA*) [32] a tree is grown towards solutions by sampling near heuristically selected vertices. This biases the growth of the tree towards good solutions but requires methods to avoid local minima. RA* deﬁnes a minimum-allowed distance between vertices, limiting the number of times a vertex can be expanded but also limiting the ﬁnal resolution. SBA* includes a measure of local sample density in the vertex expansion heuristic. This decreases the priority of sampling near frequently expanded vertices, but requires methods to estimate local sample density.
In this paper, we present Batch Informed Trees (BIT*), a planning algorithm that balances the beneﬁts of graphsearch and sampling-based techniques. It uses batches of samples to perform an ordered search on a continuous planning domain while maintaining anytime performance. By processing samples in batches, its search can be ordered around the minimum solution proposed by a heuristic, as in A* [2]. By processing multiple batches of samples, it converges asymptotically towards the global optimum with anytime resolution, as in RRT* [23]. This is done efﬁciently by using incremental search techniques to incorporate the new samples into the existing search, as in Lifelong Planning A* (LPA*) [17]. The multiple batches also allow subsequent searches to be focused on the subproblem that could contain a better solution, as in Informed RRT* [28].
The performance of BIT* is demonstrated both on random experiments in R2 and R8 and manipulation problems on the CMU Personal Robotic Lab’s Home Exploring Robot Butler (HERB) [33]. The results show that BIT* consistently outperformed both nonasymptotically and asymptotitcally optimal planners (RRT, RRT*, Informed RRT*, and FMT*). It was more likely to have found a solution at a given computational time and converged towards the optimum faster. The same held in difﬁcult planning problems on HERB, where collision checking is expensive. BIT* was nearly twice as likely to ﬁnd a solution to a difﬁcult two-arm problem (Fig. 1) and found better solutions on easier one-arm problems (Fig. 6). The only planner tested that found solutions faster was RRTConnect, which does not converge towards the optimum.

Sampling-based optimal planners

trees

graphs

m batches 1 sample/batch

PRM* et al. 1 batch m samples/batch

RRT*

batches m samples/batch

FMT*

BIT*
Fig. 2. A simpliﬁed taxonomy of sampling-based optimal planners demonstrating the relationship between RRT*, FMT*, and BIT*.
The remainder of this paper is organized as follows. Section II presents further background and Section III presents a description of the algorithm. Section IV presents an initial theoretical analysis of BIT*, while Section V presents the experimental results in detail. Finally, Section VI presents a discussion on the algorithm and related future work and Section VII provides a conclusion.
II. BACKGROUND
We deﬁne the optimal planning problem similarly to [23]. Problem Deﬁnition 1 (Optimal Planning): Let X ⊆ Rn be the state space of the planning problem, Xobs ⊂ X be the states in collision with obstacles, and Xfree = X \ Xobs be the resulting set of permissible states. Let xstart ∈ Xfree be the initial state and Xgoal ⊂ Xfree be the set of desired ﬁnal states. Let σ : [0, 1] → X be a sequence of states (a path) and Σ be the set of all nontrivial paths. The optimal solution is the path, σ∗, that minimizes a chosen cost function, s : Σ → R≥0, while connecting xstart to any xgoal ∈ Xgoal through free space,
σ∗ = arg min {s (σ) | σ(0) = xstart, σ(1) ∈ xgoal,
σ∈Σ
∀t ∈ [0, 1] , σ (t) ∈ Xfree} ,
where R≥0 is the set of non-negative real numbers. We denote the cost of this optimal path as s∗.
A discrete set of states in this state space, Xsamples ⊂ X, can be viewed as a graph whose edges are given algorithmically by a transition function (an implicit graph). When these states are sampled randomly, Xsamples = {x ∼ U (X)}, the properties of the graph can be described by a probabilistic model known as a random geometric graph (RGG) [34].
In an RGG, the connections (edges) between states (vertices) depend on their relative geometric position. Common RGGs have edges to a speciﬁc number of each state’s nearest neighbours (a k-nearest graph [35]) or to all neighbours within a speciﬁc distance (an r-disc graph [36]). RGG theory provides probabilistic relationships between the number and distribution of samples, the k or r deﬁning the graph, and speciﬁc graph properties such as connectivity or relative cost through the graph [23], [29], [34], [37].
Sampling-based planners can therefore be viewed as algorithms to construct an implicit RGG and an explicit spanning tree in the free space of the planning problem. Much

3068

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 23,2022 at 14:59:40 UTC from IEEE Xplore. Restrictions apply.

During each batch, the search expands outwards around the minimum solution using a heuristic.

When a solution is found, the batch ﬁnishes and the expansion stops.

A new batch of samples is then added and the search restarts.

The process repeats indeﬁnitely, restarting each time an improved solution is found.

(a)

(b)

(c)

(d)

Fig. 3. An illustration of the informed search procedure used by BIT*. The start and goal states are shown as green and red, respectively. The current solution is highlighted in magenta. The subproblem that contains any better solutions is shown as a black dashed line, while the progress of the current batch is shown as a grey dashed line. Fig. (a) shows the growing search of the ﬁrst batch of samples, and (b) shows the ﬁrst search ending when a solution is found. After pruning and adding a second batch of samples, Fig. (c) shows the search restarting on a denser graph while (d) shows the second search ending when an improved solution is found. An animated illustration is available in the attached video.

like graph-search techniques, the performance of an algorithm will depend on the quality of the RGG representation and the efﬁciency of the search.
Karaman and Frazzoli [23] use RGG theory in RRT* to limit graph complexity while maintaining probabilistic bounds on the representation, but the graph is constructed and searched simultaneously, resulting in a randomly ordered anytime search. Janson and Pavone [29] similarly use RGG theory in FMT*, but for a constant number of samples, resulting in an ordered but nonanytime (in solution or resolution) search. Recently, Salzman and Halperin [30] have given FMT* quasi-anytime performance by independently solving increasingly dense RGGs in their MPLB algorithm. Heuristics order and focus the search, but solutions are only returned when an RGG is completely searched.
In contrast, BIT* uses incremental search techniques on increasingly dense RGGs. This balances the beneﬁts of heuristically ordered search with anytime performance and asymptotic optimality. The tuning parameters are the choice of the heuristic, an RGG constant, and the number of samples per batch. BIT* can be viewed as an extension of LPA* [17] to continuous problems and as a generalization of existing sampling-based optimal planners (Fig. 2). With batches of one sample, it is a version of Informed RRT* [28], and with a single batch and the zero heuristic, a version of FMT*.
III. BATCH INFORMED TREES (BIT*)
Informally, BIT* works as follows. An initial RGG with implicit edges is deﬁned by uniformly distributed random samples from the free space and the start and goal. The RGG parameter (r or k) is chosen to reduce graph complexity while maintaining asymptotic optimality requirements as a function of the number of samples [23], [29]. An explicit tree is then built outwards from the start towards the goal by a heuristic search (Fig. 3a). This tree includes only collision-free edges and its construction stops when a solution is found or it can no longer be expanded (Fig. 3b). This concludes a batch.
To start a new batch, a denser implicit RGG is constructed by adding more samples and updating r (or k). If a solution has been found, these samples are limited to the subproblem that could contain a better solution (e.g., an ellipse for path length [28]). The tree is then updated using LPA*-style

incremental search techniques that reuse existing information (Fig. 3c). As before, the construction of the tree stops when the solution cannot be improved or when there are no more collision-free edges to traverse (Fig. 3d). The process continues with new batches as time allows.
A. Notation
The functions g (x) and h (x) represent admissible estimates of the cost-to-come to a state, x ∈ X, from the start and the cost-to-go from a state to the goal, respectively (i.e., they bound the true costs from below). The function, f (x), represents an admissible estimate of the cost of a path from xstart to Xgoal constrained to pass through x, i.e., f (x) := g (x) + h (x). This estimate deﬁnes a subset of
states, Xf := x ∈ X f (x) ≤ cbest , that could provide a solution better than the current best solution cost, cbest.
Let T := (V, E) be an explicit tree with a set of vertices, V ⊂ Xfree, and edges, E = {(v, w)} for some v, w ∈ V . The function gT (x) represents the cost-to-come to a state x ∈ X from the start vertex given the current tree, T . We assume a state not in the tree, or otherwise unreachable from the start, has a cost-to-come of inﬁnity. It is important to recognize that these two functions will always bound the unknown true optimal cost to a state, g (·), i.e., ∀x ∈ X, g (x) ≤ g (x) ≤ gT (x).
The functions c (x, y) and c (x, y) represent an admissible estimate of the cost of an edge and the true cost of an edge between states x, y ∈ X, respectively. We assume that edges that intersect the obstacle set have a cost of inﬁnity, and therefore ∀x, y ∈ X, c (x, y) ≤ c (x, y) ≤ ∞. It is important to recognize that calculating c (x, y) can be expensive (e.g., collision detection, differential constraints, etc.) and using a heuristic estimate for edge cost has the effect of delaying this calculation until necessary.
The function λ (·) represents the Lebesgue measure of a set (e.g., the volume), and ζn represent the Lebesgue measure of an n-dimensional unit ball. The cardinality of a set is denoted by |·|. We use the notation X ←−+ {x} and X ←− − {x} to compactly represent the compounding operations X ← X ∪ {x} and X ← X \ {x}, respectively. As is customary, we take the minimum of an empty set to be inﬁnity.

3069

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 23,2022 at 14:59:40 UTC from IEEE Xplore. Restrictions apply.

Algorithm 1: BIT* xstart ∈ Xfree, xgoal ∈ Xgoal

1 V ← {xstart} ; E ← ∅; Xsamples ← xgoal ; 2 QE ← ∅; QV ← ∅; r ← ∞;

3 repeat

4

if QE ≡ ∅ and QV ≡ ∅ then

5

Prune gT xgoal ;

6

Xsamples ←+− Sample m, gT xgoal ;

7

Vold ← V ;

8

QV ← V ;

9

r ← radius |V | + Xsamples ;

10

while BestQueueValue (QV ) ≤ BestQueueValue (QE ) do

11

ExpandVertex (BestInQueue (QV ));

12

(vm, xm) ← BestInQueue (QE );

13

QE ←−− {(vm, xm)};

14

if gT (vm) + c (vm, xm) + h (xm) < gT xgoal then

15

if g (vm) + c (vm, xm) + h (xm) < gT xgoal then

16

if gT (vm) + c (vm, xm) < gT (xm) then

17

if xm ∈ V then

18

E ←−− {(v, xm) ∈ E};

19

else

20

Xsamples ←−− {xm};

21

V ←+− {xm} ; QV ←+− {xm};

22

E ←+− {(vm, xm)};

23

QE ←−− {(v, xm) ∈ QE |

gT (v) + c (v, xm) ≥ gT (xm)};

24

else

25

QE ← ∅; QV ← ∅;

26 until STOP; 27 return T ;

B. Algorithm

BIT* is presented in Algs. 1–3. For simplicity, we limit

our discussion to a search from the start to a single goal

state using an r-disc RGG, but the formulation is similar

for searches from a goal state, with a goal set, or with a

k-nearest RGG. The algorithm starts with a given initial state,

xstart, in the tree, T , and the goal state, xgoal, in the set of unconnected samples, Xsamples (Alg. 1, Line 1). The tree is grown towards xgoal from xstart by processing a queue of RGG edges, QE. This edge queue is populated by a vertex expansion queue, QV (Alg. 1, Line 2).

1) Batch creation (Alg. 1, Lines 4–9): A new batch begins

when the queues are empty. The samples and spanning tree

are pruned of states that cannot improve the solution (Alg. 1,

Line 5; Alg. 3). A new set of m samples is then added to

the RGG from the subproblem containing a better solution

(Alg. 1, Line 6). This can be accomplished by rejection

sampling or, for some cost functions, direct sampling [28].

The vertices in the tree are labelled so that only connections

to new states will be considered (Alg. 1, Line 7) and requeued

for expansion (Alg. 1, Line 8). The radius of the underlying

r-disc RGG is updated to reﬂect its size, q, (Alg. 1, Line 9),

radius (q) := 2η

1

+

1 n

1 n

1
λ(Xf ) n
ζn

1

log(q) q

n,

(1)

where η ≥ 1 is a tuning parameter [23].

2) Edge selection (Alg. 1, Lines 10–13): The tree is built by processing the queue of edges, QE, in order of increasing estimated cost of a solution constrained to pass through the

Algorithm 2: ExpandVertex(v ∈ QV ⊆ V )

1 QV ←−− {v}; 2 Xnear ← x ∈ Xsamples ||x − v||2 ≤ r ; 3 QE ←+− (v, x) ∈ V × Xnear

g (v) + c (v, x) + h (x) < gT xgoal ;

4 if v ∈ Vold then

5

Vnear ← w ∈ V ||w − v||2 ≤ r ;

6

QE ←+− (v, w) ∈ V × Vnear (v, w) ∈ E,

g (v) + c (v, w) + h (w) < gT xgoal , gT (v) + c (v, w) < gT (w) ;

Algorithm 3: Prune c ∈ R≥0

1 Xsamples ←−− x ∈ Xsamples 2 V ←−− v ∈ V f (v) > c ;

f (x) ≥ c ;

3 E ←−− (v, w) ∈ E f (v) > c, or f (w) > c ;

4 Xsamples ←+− {v ∈ V | gT (v) ≡ ∞}; 5 V ←−− {v ∈ V | gT (v) ≡ ∞};

edge, (v, x), given the current tree, gT (v) + c (v, x) + h (x). Ties are broken in favour of the edge with the lowest current cost-to-come to the source vertex, gT (v). The function BestInQueue (QE) returns the best edge in the queue given this ordering. The function BestQueueValue (QE) returns the estimated solution cost of the best edge in the queue.
The cost of creating the edge queue is delayed by using a vertex expansion queue, QV . This vertex queue is ordered on the estimated cost of a solution constrained to pass through the vertex given the current tree, gT (v) + h (v). This value is a lower bound estimate of the edge-queue values from a vertex; therefore, vertices only need to be expanded into the edge queue when their vertex-queue value is less than the best edge-queue value. The function BestInQueue (QV ) returns the best vertex in the vertex queue given this ordering. The function BestQueueValue (QV ) returns the estimated solution cost of the best vertex in the queue.
Before selecting the next edge in the queue to process, any vertices that could have a better outgoing edge (Alg. 1, Line 10) are expanded (Alg. 1, Line 11; Alg. 2). The best edge in the queue, (vm, xm), is then removed for processing (Alg. 1, Lines 12–13). As edges are only added to the edge queue by expanding their source vertex, and each vertex is only expanded once per batch, each edge is guaranteed to only be processed once per batch.

3) Edge processing (Alg. 1, Lines 14–25): Heuristics are used to accelerate the processing of edges and delay the calculation of the true edge cost. The edge being processed, (vm, xm), is ﬁrst checked to see if it can improve the current solution given the current tree (Alg. 1, Line 14). If it cannot, then by construction no other edges in the queue can and both queues are cleared to start a new batch (Alg. 1, Line 25).
The true edge cost is then calculated by performing collision checks and solving any differential constraints. This may be expensive, so the edge is processed if it could ever improve the current solution, regardless of the current state of the tree (Alg. 1, Line 15). If it cannot, than it is discarded.

3070

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 23,2022 at 14:59:40 UTC from IEEE Xplore. Restrictions apply.

RRT*

FMT*

Informed RRT*

BIT*

t = 0.487s

t = 0.141s

t = 0.144s

t = 0.072s

Fig. 4. An example of RRT*, Informed RRT*, FMT* (m = 2500), and BIT* run on a random R2 world. Each algorithm was run until it found a equivalent solution to FMT* (c = 1.39) regardless of homotopy class. BIT*’s use of heuristics allows it to ﬁnd such a solution faster (t = 0.072s) than RRT* (t = 0.487s), FMT* (t = 0.141s) and Informed RRT* (t = 0.144s) by performing its search in a principled manner that initially investigates
low-cost solutions and focuses the search for improvements. Animated results are available in the attached video.

Finally, the edge is checked to see if it improves the costto-come of its target vertex (Alg. 1, Line 16), noting that disconnected vertices have an inﬁnite cost. If it does, it is added to the tree.
If the target vertex, xm, is in the tree (Alg. 1, Line 17), then the edge represents a rewiring, otherwise it is an expansion. Rewirings require removing the edge to the target vertex from the tree (Alg. 1, Line 18). Expansions require moving the target vertex from the set of unconnected samples to the set of vertices and queueing it for expansion (Alg. 1, Lines 20–21).
The new edge is then added to the tree (Alg. 1, Line 22) and the edge queue is pruned to remove edges that cannot improve the cost-to-come of the vertex (Alg. 1, Line 23).
4) Vertex Expansion (Alg. 2): The function, ExpandVertex (v), removes a vertex, v ∈ QV ⊆ V , from the vertex queue (Alg. 2, Line 1) and adds outgoing edges from the vertex to the edge queue.
In the RGG, a vertex is connected to all states within a radius, r. Edges to unconnected states (Alg. 2, Line 2) are always added to edge queue if they could be part of a better solution (Alg. 2, Line 3). Edges to connected states are only added if the source vertex was added to the tree during this batch (Alg. 2, Line 4). This prevents repeatedly checking edges between vertices in the tree. These rewiring edges (Alg. 2, Line 5) are added to the edge queue if, in addition to possibly providing a better solution, they are not already in the tree and could improve the path to the target vertex given the current tree (Alg. 2, Line 6).
5) Graph Pruning (Alg. 3): The function, Prune (c), removes states that cannot provide a solution better than the given cost, c ∈ R≥0. Unconnected samples are removed (Alg. 3, Line 1), while vertices in the tree are removed and disconnected (Alg. 3, Lines 2–3). To maintain uniform sample density in the subproblem being searched, disconnected descendents that could still provide a better solution are returned to the unconnected sample set (Alg. 3, Lines 4–5).
C. Practical Considerations
Algs. 1–3 describe BIT* without considering implementation, leaving room for practical improvements. Pruning (Alg. 1, Line 5) is expensive and should only occur when a new solution has been found. It can even be limited to

signiﬁcant changes in solution cost without altering behaviour. Searches (e.g., Alg. 1, Line 18; Alg. 2, Line 2; Alg. 3,
Line 3; etc.) can be implemented efﬁciently with appropriate datastructures, e.g., k-d trees or indexed containers, that do not require an exhaustive global search.
Ordered containers provide an efﬁcient edge queue (Alg. 1, Lines 12–13). While rewirings will change the order of some elements, we found little experimental difference between an approximately sorted and a strictly sorted queue.

IV. ANALYSIS

For brevity, we only present a proof of almost sure

asymptotic optimality (Theorem 1) and note that this implies

probabilistic completeness. We also present a discussion on

the relationship between BIT*’s edge queue and LPA*’s

vertex queue (Remark 1).

Theorem 1 (Asymptotic Optimality): BIT* asymptotically

converges almost surely to the optimal solution to Prob. 1, if

a solution exists, as the total number of samples, q, goes to

inﬁnity, i.e.,

P

lim

sup

cBIT∗
best,q

=

s∗

= 1,

q→∞

where

cBIT∗
best,q

is

the

cost

of

the

best

solution

found

by

BIT*

from q samples.

Proof: The proof extends directly from the work in

[23]. In Appendix G, Karaman and Frazzoli show that for q

uniformly distributed random samples and a speciﬁc constant

rq, the solution found by RRT* almost surely converges asymptotically to the optimal solution as q goes to inﬁnity, i.e.,

P

lim

sup

cRRT∗
best,q

=

s∗

= 1.

q→∞

RRT* processes the sequence of q samples individually. For

any sample, it considers all edges involving samples earlier in

the sequence that are less than length rq. BIT* processes the

sequence of samples in batches. For any sample in a batch,

it considers all edges involving samples from the same or

earlier batches that are less than length rq. This will contain

all the edges considered by RRT* for the same sequence

and rq. As BIT* maintains uniform sample density in the

subproblem that contains all better solutions and (1) meets

the requirements for almost sure asymptotic optimality given

in [23], BIT* is almost surely asymptotically optimal.

3071

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 23,2022 at 14:59:40 UTC from IEEE Xplore. Restrictions apply.

100

100

Success [%]

Success [%]

50

50

0

10−2

10−1

100

Computation time [s]

(a) R2: Runs solved vs. time

0 10−2

10−1

100

101

Computation time [s]

(b) R8: Runs solved vs. time

Median solution cost

Median solution cost

2.6

2.4

2.2

2.0

1.8

1.6

1.4

10−2

10−1

100

Computation time [s]

(c) R2: Median solution cost vs. time

5.0 4.5 4.0 3.5 3.0
10−2

10−1

100

101

Computation time [s]

(d) R8: Median solution cost vs. time

RRT

RRT-Connect

FMT*

RRT*

Informed RRT*

BIT*

Fig. 5. The results from representative worlds in R2 and R8 for RRT, RRT-Connect, RRT*, Informed RRT*, BIT* with a batch size of 100 samples, and FMT* of various sample sizes (R2: 500, 1000, 2500, 5000, 10000, 25000, and 50000; R8: 100, 500, 1000, 2500, 5000, and 7500). For the chosen random worlds, (a) and (b) show the percentage of trials solved versus run time for the 50 different trials, while (c) and (d) show the median solution cost versus run time. Dots represent the median initial solution. For algorithms that asymptotically converge towards the optimum, the dashed lines represent a median calculated from 50%–100% success rate and may increase as new trials are included. The solid lines represent the median when all trials have a solution, with error bars denote a non-parametric 95% conﬁdence interval on median solution cost and time. Note that for some algorithms the conﬁdence intervals are smaller than the median line and are not visible and that RRT and RRT-Connect are not asymptotically optimal planners.

Remark 1 (Equivalence to LPA* vertex queue): BIT*’s edge queue is an extension of LPA*’s vertex queue [17] to include a heuristic estimate of edge cost.
Explanation: LPA* uses a queue of vertices ordered lexicographically ﬁrst on the solution cost constrained to go through the vertex and then the cost-to-come to the vertex. Both these terms are calculated for a vertex, v ∈ V , considering all the incoming edges (rhs-value in LPA*), i.e.,

min {gT (u) + c (u, v)} ,

(2)

(u,v)∈E

where E is the set of edges.

This minimum requires the calculation of the true edge

cost between a vertex and all of its possible parents. This

calculation is expensive in sampling-based planning (e.g.,

collision checking, differential constraints, etc.), and reducing

its calculation is desirable. This can be done by using an

admissible heuristic estimate of edge cost and calculating (2)

incrementally. A running minimum is calculated by processing

edges in order of increasing estimated cost. The process

ﬁnishes, and the true minimum is found, when the estimated

cost through the next edge is higher than the current value.

BIT* combines these individual minima calculations into

a single edge queue. In doing so, it simultaneously calculates

the minimum cost-to-come for each vertex while expanding

vertices in order of increasing estimated solution cost.

V. EXPERIMENTAL RESULTS

BIT* was tested against existing algorithms in both
simulated random worlds (Section V-A) and real-world
manipulation problems (Section V-B) using publicly available
Open Motion Planning Library (OMPL) [38] implementations. All tests and algorithms used an RGG constant (e.g., η in (1)) of 1.1 and approximated λ (Xfree) with λ (X). RRT-based algorithms used a goal bias of 5%. BIT* used 100 samples per batch, Euclidean distance between states for heuristics,

and direct informed sampling [28]. Graph pruning was limited to changes in the solution cost greater than 1% and we used an approximately sorted queue.
A. Simulated Random Worlds
BIT* was compared to existing sampling-based algorithms on random problems minimizing path length in R2 and R8. The problems consisted of a (hyper)cube of width 2 populated with random axis-aligned (hyper)rectangular obstacles such
that at most one third of the environment was obstructed.
The initial state was in the centre of the world and the goal was (0.9, 0.9, . . . , 0.9) away (Fig. 4). BIT* was compared to the OMPL implementations of RRT, RRT-Connect [39],
RRT*, Informed RRT*, and FMT*. The RRT-based planners used a maximum edge length of 0.2 and 1.25 in R2 and R8, respectively. All algorithm parameters were chosen in good
faith to maximize performance on a separate training set of
random worlds. For each state dimension, 10 different random worlds were
generated and the planners were tested with 50 different pseudo-random seeds on each. The solution cost of each planner was recorded every 1 millisecond by a separate thread1. For each world, median solution cost was calculated
for a planner by interpolating each trial at a period of 1 millisecond. As the true optima for these problems are different and unknown, there is no meaningful way to
compare the results across problems. Instead, results from
a representative problem are presented in Fig. 5, where the
percent of trials solved and the median solution cost are
plotted versus computational time. These experiments show that in both R2 (Figs. 5a, 5c)
and R8 (Figs. 5b, 5d), BIT* generally ﬁnds better solutions faster than other sampling-based optimal planners and RRT.
1Simulations were run on a MacBook Pro with 4 GB of RAM and an Intel i7-620M processor running a 64-bit version of Ubuntu 12.04.

3072

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 23,2022 at 14:59:40 UTC from IEEE Xplore. Restrictions apply.

It has a higher likelihood of having found a solution at a given computational time than these planners, and converges faster towards the optimum. The only planner tested that found solutions faster than BIT* was RRT-Connect, a nonasymptotically optimal planner.
B. Motion Planning for Manipulation
To evaluate the performance of BIT* on real-world highdimensional problems, it was tested on HERB [33]. Experiments consisted of both dual-arm and one-arm planning problems for manipulation with a goal of minimizing the path length through conﬁguration space. Parameter values for BIT* and RRT-based planners were chosen from the results of Section V-A, and the number of FMT* samples was chosen to use the majority of the available computational time. Once again, BIT* outperformed all planners other than RRT-Connect.
For the dual-arm planning problem, HERB started with both arms extended under a table from the elbow onward. The task was to plan a trajectory for both arms to place the hands in position to open a bottle (Fig. 1). HERB’s proximity to the table and starting position created a narrow passage for the arms around the table. Coupled with the 14-degree-of-freedom (DOF) conﬁguration space, this made for a challenging problem.
Given 2.5 minutes2 of planning time, BIT* was almost twice as likely to ﬁnd a solution than RRT, Informed RRT*, or FMT*. Over 25 trials, BIT* was 68% successful with a median solution cost of 17.4. RRT-Connect was 100% successful, but had a median solution cost of 22.1. RRT was 8% successful with a median solution cost of 31.1 and Informed RRT* was 8% successful with a median solution cost of 25.3. FMT* with m = 500 was 36% successful with a median solution cost of 17.2. All RRT-based planners used a maximum edge length of 3.
An easier one-arm planning problem was also tested. HERB started with its left arm folded at the elbow and held at approximately the table level of a table. The task was to plan a trajectory to place the left hand in position to grasp a box (Fig. 6). The smaller conﬁguration space, 7 DOF, and a starting position partially clear of the table made this an easier planning problem. In the given 5 seconds of computational time, both BIT* and RRT-Connect found a solution in all 25 trials. BIT* had a median solution cost of 6.8 while RRT-Connect had a median solution cost of 10.6. RRT was 88% successful with a median solution cost of 11.2 and Informed RRT* was 88% successful with a median solution cost of 10.6. FMT* with m = 50 was 52% successful with a median solution cost of 9.0. All RRT-based planners used a a maximum edge length of 1.25.
VI. DISCUSSION & FUTURE WORK
BIT* demonstrates that anytime sampling-based planners can be designed by combining incremental graph-search techniques with RGG theory. We hope that this work will motivate further uniﬁcation of these two planning paradigms.
2HERB experiments were run on a Dell T3500 with 12 GB of RAM and an Intel W3565 processor running a 64-bit version of Ubuntu 12.04.

Fig. 6. A composite ﬁgure of a one-arm trajectory on HERB found by BIT*. Over 25 trials with 5 seconds of computational time, BIT* had a median solution cost of 6.8 and success rate of 100%, while Informed RRT* and FMT* had median costs of 10.6 and 9.0 and success rates of 88% and 52%, respectively. Nonoptimal planners, RRT and RRT-Connect, had median costs of 11.2 and 10.6 and success rates of 88% and 100%, respectively.
A fundamental component of BIT* is the application of heuristic estimates to all aspects of path cost. Doing so allows the algorithm to account for future graph improvements (costto-come), avoid unnecessary collision checks and boundaryvalue problems (edge cost), and order and focus the search (solution cost). As always, the beneﬁt of these heuristics will depend on their suitability for the speciﬁc problem, but we feel that they are an important tool to reduce the curse of dimensionality. Note that while direct sampling of the subproblem is possible for some cost functions [28], rejection sampling is applicable. Also note that, as with other heuristically guided searches (e.g., A*), BIT* works with the trivial zero heuristic (e.g., Dijkstra’s algorithm); however, more conservative heuristics provide less beneﬁt to the search.
In describing BIT* as an extension of LPA* to continuous planning problems, it is important to note a key difference in how they reuse information. In LPA*, updating the cost-tocome of a vertex requires reconsidering the cost-to-come of all possibly descendent vertices. This is a step that becomes prohibitively expensive in anytime resolution planners as graph size increases quickly. The results of RRT* demonstrate that this is unnecessary for the planner to almost surely converge asymptotically to the optimum as the number of samples approaches inﬁnity.
While the efﬁciency of graph-search techniques is well understood, this area remains understudied for sampling-based planners. We are actively investigating whether BIT*’s use of graph-search techniques and RGG theory can be used to probabilistically evaluate its efﬁciency.
Also of interest are possible improvements to BIT*, including the fact that BIT* does not remove samples when connection attempts fail. This is a requirement of the uniform sample distribution used in RGG theory, but leaves edges in the implicit RGG that are known to be unusable.
Finding an efﬁcient method to avoid these edges would improve BIT*, and there are multiple potential ways to accomplish this. Failed edges could be tracked and prevented from reentering the queue, but initial attempts have proven

3073

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 23,2022 at 14:59:40 UTC from IEEE Xplore. Restrictions apply.

too computational expensive. Samples that fail multiple connection attempts could be removed, but doing so will require RGG theory for nonuniform distributions. Our current focus is on the adaptively varying batch size to increase the rate at which these edges are removed from the RGG.
We are also interested in more general extensions to BIT*. Its expanding search is well suited for large or unbounded planning problems, and we have had initial success with a version that generates samples as needed and avoids the a priori deﬁnition of state space limits. Its relationship to incremental search techniques also suggests it may be well suited for planning problems in changing environments. We are also investigating the use of other graph-search techniques, including anytime [14]–[16] or bidirectional [40], [41] searches to decrease the time required to ﬁnd an initial solution. Finally, we are investigating combining BIT*’s global search with local searches, such as path-smoothing.
VII. CONCLUSION
In this paper, we attempt to unify graph-search and sampling-based planning techniques through RGG theory. By recognizing that a set of samples deﬁnes an implicit RGG and using incremental-search techniques, we are able to combine the efﬁcient search of algorithms such as A*, with the anytime scalability of sampling-based algorithms such as RRT*. The resulting algorithm, BIT*, uses heuristics for all aspects of path cost in order to prioritize the search of high-quality paths and focus the search for improvements.
As demonstrated on both simulated and real-world experiments, BIT* outperforms existing sampling-based optimal planners and RRT, especially in high dimensions. For a given computational time, BIT* has a higher likelihood of ﬁnding a solution and generally ﬁnds solutions of equivalent quality sooner. It also converges towards the optimum faster than other asymptotic optimal planners, and has recently been shown to perform well on problems with differential constraints [42]. Information on the OMPL implementation of BIT* is available at http://asrl.utias.utoronto.ca/code.
ACKNOWLEDGMENT
We would like to thank Christopher Dellin, Michael Koval, and Rachel Holladay for their comments on drafts of this work and Jennifer King for her help with experiments on HERB. This research was funded by contributions from the Natural Sciences and Engineering Research Council of Canada (NSERC) through the NSERC Canadian Field Robotics Network (NCFRN), the Ontario Ministry of Research and Innovation’s Early Researcher Award Program, and the Ofﬁce of Naval Research (ONR) Young Investigator Program.
REFERENCES
[1] E. W. Dijkstra, “A note on two problems in connexion with graphs,” Numerische Mathematik, 1(1): 269–271, 1959.
[2] P. E. Hart, N. J. Nilsson, and B. Raphael, “A formal basis for the heuristic determination of minimum cost paths,” TSSC, 4(2): 100–107, Jul. 1968
[3] R. E. Bellman, “The theory of dynamic programming,” Bull. of the AMS, 60(6): 503–516, 1954.
[4] D. P. Bertsekas, “Convergence of discretization procedures in dynamic programming,” TAC, 20(3): 415–419, Jun. 1975.
[5] R. E. Bellman, Dynamic Programming. Princeton Uni. Press, 1957. [6] T. Lozano-Pe´rez and M. A. Wesley, “An algorithm for planning
collision-free paths among polyhedral obstacles,” CACM, 22(10): 560– 570, Oct. 1979.

[7] P. C. Chen and Y. K. Hwang, “SANDROS: a motion planner with performance proportional to task difﬁculty,” in ICRA, 3: 2346–2353, May 1992.
[8] C. S. Sallaberger and G. M. D’Eleuterio, “Optimal robotic path planning using dynamic programming and randomization,” Acta Astronautica, 35(2–3): 143–156, 1995.
[9] J. Barraquand and J.-C. Latombe, “Nonholonomic multibody mobile robots: controllability and motion planning in the presence of obstacles,” in ICRA, 3: 2328–2335, Apr. 1991.
[10] K. M. Lynch and M. T. Mason, “Stable pushing: Mechanics, controllability, and planning,” IJRR, 15(6): 533–556, 1996.
[11] M. Cherif, “Kinodynamic motion planning for all-terrain wheeled vehicles,” in ICRA, 1: 317–322, 1999.
[12] B. Donald, P. Xavier, J. Canny, and J. Reif, “Kinodynamic motion planning,” JACM, 40(5): 1048–1066, Nov. 1993.
[13] K. Kondo, “Motion planning with six degrees of freedom by multistrategic bidirectional heuristic free-space enumeration,” TRA, 7(3): 267–277, Jun. 1991.
[14] M. Likhachev, D. Ferguson, G. Gordon, A. Stentz, and S. Thrun, “Anytime dynamic A*: An anytime, replanning algorithm,” in ICAPS, Jun. 2005.
[15] D. Ferguson and A. Stentz, “The delayed D* algorithm for efﬁcient path replanning,” in ICRA, 2045–2050, Apr. 2005.
[16] M. Likhachev, D. Ferguson, G. Gordon, A. Stentz, and S. Thrun, “Anytime search in dynamic graphs,” Art. Intel., 172(14): 1613–1643, 2008.
[17] S. Koenig, M. Likhachev, and D. Furcy, “Lifelong planning A*,” Art. Intel., 155(1–2): 93–146, 2004.
[18] A. Stentz, “The focussed D* algorithm for real-time replanning,” in IJCAI 1652–1659, 1995.
[19] S. Koenig and M. Likhachev, “Fast replanning for navigation in unknown terrain,” TRO, 21(3): 354–363, Jun. 2005.
[20] L. E. Kavraki, P. Sˇ vestka, J.-C. Latombe, and M. H. Overmars, “Probabilistic roadmaps for path planning in high-dimensional conﬁguration spaces,” TRA, 12(4): 566–580, 1996.
[21] S. M. LaValle and J. J. Kuffner Jr., “Randomized kinodynamic planning,” IJRR, 20(5): 378–400, 2001.
[22] D. Hsu, R. Kindel, J.-C. Latombe, and S. Rock, “Randomized kinodynamic motion planning with moving obstacles,” IJRR, 21(3): 233–255, 2002.
[23] S. Karaman and E. Frazzoli, “Sampling-based algorithms for optimal motion planning,” IJRR, 30(7): 846–894, 2011.
[24] C. Urmson and R. Simmons, “Approaches for heuristically biasing RRT growth,” IROS, 2: 1178–1183, 2003.
[25] D. Ferguson and A. Stentz, “Anytime RRTs,” IROS, 5369–5375, 2006. [26] B. Akgun and M. Stilman, “Sampling heuristics for optimal motion
planning in high dimensions,” IROS, 2640–2645, 2011. [27] M. Otte and N. Correll, “C-FOREST: Parallel shortest path planning
with superlinear speedup,” TRO, 29(3): 798–806, Jun. 2013 [28] J. D. Gammell, S. S. Srinivasa, and T. D. Barfoot, “Informed RRT*:
Optimal sampling-based path planning focused via direct sampling of an admissible ellipsoidal heuristic,” in IROS, 2997–3004, 2014. [29] L. Janson and M. Pavone, “Fast marching trees: a fast marching sampling-based method for optimal motion planning in many dimensions,” in ISRR, Dec. 2013. [30] O. Salzman and D. Halperin, “Asymptotically-optimal motion planning using lower bounds on cost,” in ICRA, 2015. [31] R. Diankov and J. J. Kuffner Jr., “Randomized statistical path planning,” in IROS, 2007. [32] S. M. Persson and I. Sharf, “Sampling-based A* algorithm for robot path-planning,” IJRR, 33(13): 1683–1798, 2014. [33] S. Srinivasa, D. Berenson, M. Cakmak, A. Collet Romea, M. Dogar, A. Dragan, R. A. Knepper, T. D. Niemueller, K. Strabala, J. M. Vandeweghe, and J. Ziegler, “HERB 2.0: Lessons learned from developing a mobile manipulator for the home,” Proc. IEEE, 100(8): 1–19, Jul. 2012. [34] M. Penrose, Random Geometric Graphs, ser. Oxford Studies in Probability, L. C. G. Rogers, Ed. Oxford Uni. Press, 5: 2003. [35] F. Xue and P. R. Kumar, “The number of neighbors needed for connectivity of wireless networks,” Wireless Networks, 10(2): 169– 181, 2004. [36] E. N. Gilbert, “Random plane networks,” SIAM, 9(4): 533–543, 1961. [37] S. Muthukrishnan and G. Pandurangan, “The bin-covering technique for thresholding random geometric graph properties,” in SODA, 989–998, 2005. [38] I. A. S¸ ucan, M. Moll, and L. E. Kavraki, “The Open Motion Planning Library,” IEEE R&A Mag., 19(4): 72–82, Dec. 2012. [39] J. J. Kuffner Jr. and S. M. LaValle, “RRT-Connect: An efﬁcient approach to single-query path planning,” in ICRA, 995–1001, 2000. [40] I. Pohl, “Bi-directional search,” Mach. Intel., 6: 127–140, 1971. [41] L. Sint and D. de Champeaux, “An improved bidirectional heuristic search algorithm,” JACM, 24(2): 177–191, Apr. 1977. [42] C. Xie, J. van den Berg, S. Patil, and P. Abbeel, “Toward asymptotically optimal motion planning for kinodynamic systems using a two-point boundary value problem solver,” in ICRA, 2015.

3074

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on August 23,2022 at 14:59:40 UTC from IEEE Xplore. Restrictions apply.

