IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Loading [MathJax]/jax/element/mml/optable/BasicLatin.js

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

    Cart 
    Create Account
    Personal Sign In

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Journals & Magazines > IEEE Robotics and Automation ... > Volume: 2 Issue: 3
Planning Dynamically Feasible Trajectories for Quadrotors Using Safe Flight Corridors in 3-D Complex Environments
Publisher: IEEE
Cite This
PDF
  << Results   
Sikang Liu ; Michael Watterson ; Kartik Mohta ; Ke Sun ; Subhrajit Bhattacharya ; Camillo J. Taylor ; Vijay Kumar
All Authors
View Document
152
Paper
Citations
6148
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Technical Approach
    III.
    Analysis
    IV.
    Experimental Results
    V.
    Conclusion

Authors
Figures
References
Citations
Keywords
Metrics
More Like This

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: There is extensive literature on using convex optimization to derive piece-wise polynomial trajectories for controlling differential flat systems with applications to thr... View more
Metadata
Abstract:
There is extensive literature on using convex optimization to derive piece-wise polynomial trajectories for controlling differential flat systems with applications to three-dimensional flight for Micro Aerial Vehicles. In this work, we propose a method to formulate trajectory generation as a quadratic program (QP) using the concept of a Safe Flight Corridor (SFC). The SFC is a collection of convex overlapping polyhedra that models free space and provides a connected path from the robot to the goal position. We derive an efficient convex decomposition method that builds the SFC from a piece-wise linear skeleton obtained using a fast graph search technique. The SFC provides a set of linear inequality constraints in the QP allowing real-time motion planning. Because the range and field of view of the robot's sensors are limited, we develop a framework of Receding Horizon Planning , which plans trajectories within a finite footprint in the local map, continuously updating the trajectory through a re-planning process. The re-planning process takes between 50 to 300 ms for a large and cluttered map. We show the feasibility of our approach, its completeness and performance, with applications to high-speed flight in both simulated and physical experiments using quadrotors.
Published in: IEEE Robotics and Automation Letters ( Volume: 2 , Issue: 3 , July 2017 )
Page(s): 1688 - 1695
Date of Publication: 02 February 2017
ISSN Information:
INSPEC Accession Number: 16870950
DOI: 10.1109/LRA.2017.2663526
Publisher: IEEE
Funding Agency:
Contents
SECTION I.
Introduction

Navigation of a Micro Aerial Vehicle (MAV) in an obstacle-cluttered environment is a challenging problem which requires the MAV not only to detect obstacles, but also plan and execute collision-free and dynamically feasible trajectories. In this letter, we propose an algorithm that efficiently generates these safe and smooth trajectories in real time. We use this algorithm as a foundation for a fast and safe navigation system for a quadrotor ( Fig. 1 ).
Fig. 1. - Our experimental quadrotor equipped with a Velodyne VLP-16, a stereo camera and an Intel NUC computer navigating an unknown environment with obstacles.
Fig. 1.

Our experimental quadrotor equipped with a Velodyne VLP-16, a stereo camera and an Intel NUC computer navigating an unknown environment with obstacles.

Show All

It has been shown that the trajectory generation problem, for differentially flat systems, can be formulated as a Quadratic Programming (QP)  [1] . The trajectory can be parameterized as an k -th order polynomial in time  [2] . Generating a collision-free trajectory has been solved with Mixed Integer methods in [3] – [5] . Since solving MILP/MIQP takes seconds to minutes  [3] – [5] , other approaches have been developed to remove the integer variables and solve the QP instead which is much faster  [6] – [9] . A trajectory can be solved in closed form  [6] , but it requires many iterations to generate a collision-free trajectory especially when the map is complicated.  [7] requires an OctoMap  [10] representation and produces a sequences of axes-aligned cubes in free space to generate trajectories. This formulation of convex free space is not generic and is efficient only when obstacles are rectangular parallelopipeds. In  [11] , the author analyzes the high speed navigation through a obstacle field, but they fail to consider non-trivial robot dynamics and their results may not applicable for MAVs. The framework in  [12] corrects trajectories based on a prior path, but it requires an accurate prior map which is a limitation for practical navagation in unkown environments.

We adopt some ideas from these related works and propose a robust and efficient solution based on our previous work  [13] ,  [9] to generate trajectories in real time. Our pipeline uses a linear piece-wise path from a fast graph search algorithm to guide the convex decomposition of the map to find a Safe Flight Corridor (SFC). The SFC is a collection of convex connected polyhedra that models free space in a map and can be treated as linear inequality constraints in the QP for trajectory optimization. Inspired by  [14] , we developed a novel convex decomposition method to construct the SFC using ellipsoids. The total time for trajectory generation using this pipeline is sufficiently small such that we use it with a Receding Horizon Planning (RHP) framework to build our navigation system with mapping and state estimation. We assume the robot is able to follow our generated trajectories through a non-linear controller  [15] . We verify the system's robustness for collision avoidance in partially sensed complex environments through both simulation and real world experiments.

In order to guarantee safety, the stopping policy  [13] is used. The three main distinguishing advantages of our algorithm can be summarized as:

    Fast computation

    High speed trajectory generation

    Safety and completeness

Compared with our previous work in  [9] , we improve the planning speed, propose a more generic and effective decomposition method and test the pipeline with much larger traveling distance and higher flight speed. The outline of this letter is as follows: in Section II , we describe the technical approach for trajectory generation; in Section III , we analyze the computational expense and efficiency of our algorithm; experimental results are shown in Section IV ; insights and conclusion follow in Section V .
SECTION II.
Technical Approach

The overall architecture of our autonomous system is shown in Fig. 2 . In this section, we mainly discuss the top four components through which we derive the desired trajectory for controlling the MAV to reach the goal. The source code for fast Path Planning and convex decomposition can be found in https://github.com/sikang/JPS3D.git and https://github.com/sikang/DecompUtil.git .
Fig. 2. - Block diagram of our autonomous system. We first find a valid path in a grid map toward a goal $g$, based on which we construct the Safe Flight Corridor (SFC) through convex decomposition. The trajectory inside the SFC is achieved from solving a optimization problem. And in the end we are able to get the desired control commands for navigating the quadrotor.
Fig. 2.

Block diagram of our autonomous system. We first find a valid path in a grid map toward a goal g , based on which we construct the Safe Flight Corridor (SFC) through convex decomposition. The trajectory inside the SFC is achieved from solving a optimization problem. And in the end we are able to get the desired control commands for navigating the quadrotor.

Show All
A. Path Planning

The environment is represented as an occupancy grid that can be constructed from sensor data such as laser range finder, stereo cameras or RGB-D sensors. A valid collision-free path can then be found in the grid using a graph search algorithm. Randomized methods like RRT * and PRM are probabilistically complete, which means there is no guarantee on the time it takes to find a optimal path if there exist one. Also, their random behavior make the performance of the algorithm unpredictable when we need to re-plan frequently. Search-based algorithms like Dijkstra and A * , on the other hand, are resolution complete, but their computation time for finding an optimal path is a limitation when used with large maps. Jump Point Search (JPS)  [16] solves this problem by planning in uniform-cost grid maps. Since we are using 3-D grid maps with uniform voxels, JPS can be applied to our problem. JPS prunes the neighbors of a node being searched and potentially reduces the running time of A * by an order of magnitude. In order to use JPS with 3-D voxel maps, we extend the 2-D algorithm proposed in  [16] to 3-D. We propose pruning rules for 3-D voxel grids as presented in Figs. 3 and  4 . As defined in  [16] , the natural neighbors refer to the set of nodes that remain after pruning. For those neighbors which cannot be pruned due to obstacles, we call them forced neighbors .
Fig. 3. - Neighbor Pruning. We draw a $3\times 3\times 3$ voxel grid as three $3\times 3$ 2-D layers – bottom (-1), middle (0), top (+1). The center node indicated by the blue arrow is currently being expanded. The natural neighbors of the current node are marked white. The pruned neighbors are marked grey. The blue arrow also shows the direction of travel from its parent which includes three cases: (1). straight, (2). 2-D diagonal and (3). 3-D diagonal.
Fig. 3.

Neighbor Pruning. We draw a 3 × 3 × 3 voxel grid as three 3 × 3 2-D layers – bottom (-1), middle (0), top (+1). The center node indicated by the blue arrow is currently being expanded. The natural neighbors of the current node are marked white. The pruned neighbors are marked grey. The blue arrow also shows the direction of travel from its parent which includes three cases: (1). straight, (2). 2-D diagonal and (3). 3-D diagonal.

Show All
Fig. 4. - Forced Neighbors. When the current node is adjacent to an obstacle (black), the highlighted forced neighbors (pink) cannot be pruned. The red arrow indicates the pair of an obstacle and its corresponding forced neighbor: if the tail voxel is occupied, its head voxel is a forced neighbor. For example, in Case 1, if the voxel $(0, 1, 0)$ is occupied, $(1, 1, 0)$ is a forced neighbor. In Case 2, the occupied voxel $(0, 0, 1)$ results in three forced neighbors and similarly in Case 3. For clarity of figures, we omit drawing the symmetric situations wit respect to the blue arrow.
Fig. 4.

Forced Neighbors. When the current node is adjacent to an obstacle (black), the highlighted forced neighbors (pink) cannot be pruned. The red arrow indicates the pair of an obstacle and its corresponding forced neighbor : if the tail voxel is occupied, its head voxel is a forced neighbor . For example, in Case 1, if the voxel ( 0 , 1 , 0 ) is occupied, ( 1 , 1 , 0 ) is a forced neighbor . In Case 2, the occupied voxel ( 0 , 0 , 1 ) results in three forced neighbors and similarly in Case 3. For clarity of figures, we omit drawing the symmetric situations wit respect to the blue arrow.

Show All

The details of the recursive pruning and jump processes can be found in  [16] . The proposed pruning in Fig. 4 is a compromise between checking all the situations and maintaining simplicity of the algorithm: we add more neighbors than required (three forced neighbors case) but it is easier to check (i.e. more efficient). JPS provides the same completeness and optimality guarantees as A *   [16] , with the only limitation being the assumption of uniform-cost grid which holds for our case. Our 3-D JPS significantly speeds up the running time of planning (column 6 in Table I ) which makes it possible to run the trajectory generation within our RHP framework.
TABLE I Trajectory Generation Run Time (sec)
Table I- Trajectory Generation Run Time (sec)
B. Safe Flight Corridor Construction

The set of points that constitute the obstacles (the occupied voxels in the 3D grid map representation of the environment) are represented as O . A piece-wise linear path P from start to goal in the free space is denoted as P = ⟨ p 0 → p 1 → ⋯ → p n ⟩ , where p i are points in the free space and p i → p i + 1 are directed line segments in the free space. We generate a convex polyhedron around each line segment in P to construct a valid SFC. The i t h line segment is represented as L i = ⟨ p i → p i + 1 ⟩ . Denote the generated convex polyhedron from each L i as C i . The space covered by these convex polyhedra constitutes the Safe Flight Corridor . We denote the collection of these convex polyhedra as SFC ( P ) = { C i | i = 0 , 1 , … , n − 1 } . Fig. 5 shows a typical example of a path P and corresponding SFC ( P ) . One criterion for the construction of the SFC is that two consecutive polyhedra, C i and C i + 1 , need to intersect in a non-empty set containing p i + 1 . This ensures continuity in the SFC.
Fig. 5. - Generate a Safe flight corridor (blue region) from a given path $P = \langle \mathbf {p}_0 \rightarrow \dots \rightarrow \mathbf {p}_4\rangle$ . Left: find the collision-free ellipsoid for each line segment. Right: dilate each individual ellipsoid to find a convex polyhedron.
Fig. 5.

Generate a Safe flight corridor (blue region) from a given path P = ⟨ p 0 → ⋯ → p 4 ⟩ . Left: find the collision-free ellipsoid for each line segment. Right: dilate each individual ellipsoid to find a convex polyhedron.

Show All

To generate the convex polyhedron C i from L i , we describe two procedures: (1) “Find Ellipsoid”, that first fits an ellipsoid around L i , and, (2) “Find Polyhedron”, that constructs the polyhedron C i from tangent planes to a sequence of dilated ellipsoids. In order to reduce the computation time, we add a bounding box to confine the space around L i in which we consider obstacles. In addition, we propose a shrinking process to guarantee that a non-point robot is collision-free. In the following subsections we introduce the details on these procedures. For simplicity, we remove the subscripts “ i ” and simply use L , C to denote the corresponding line segment and polyhedron.
1) Step 1 – Find Ellipsoid

In this step we find an ellipsoid which includes the line segment L and does not contain any obstacle points from O . An ellipsoid is described as
ξ ( E , d ) = { p = E p ¯ + d   |   ∥ p ¯ ∥ ≤ 1 } (1)
View Source Right-click on figure for MathML and additional features. \begin{equation} \xi (\mathbf {E}, \mathbf {d}) = \lbrace \mathbf {p} = \mathbf {E}\bar{\mathbf {p}} + \mathbf {d}\ |\ \Vert \bar{\mathbf {p}}\Vert \leq 1\rbrace \end{equation}

For an ellipsoid in R 3 , E is a 3 × 3 symmetric positive definite matrix that represents a deformation of a sphere ( ∥ p ¯ ∥ ≤ 1 ). E can be decomposed as E = R T S R where R is the rotation matrix aligning the ellipsoid axes with map axes and S = diag ( a , b , c ) is the diagonal scale matrix whose diagonal elements stand for the corresponding lengths of ellipsoid semi-axes. d indicates the center of the ellipsoid. Without loss of generality, we assume a ≥ b , a ≥ c . Our goal is to find E , d given the line segment L and obstacles O .

This ellipsoid is computed in two steps: first, we shrink an initial sphere to derive the maximal spheroid (an ellipsoid with two axes of equal length); second, we “stretch” this spheroid along the third axis to obtain the final ellipsoid. In the first step, the initial ellipsoid is a sphere centered at the mid point of L and with diameter equals to the length of L . Assume the length of ellipsoid's x ~ -axis is fixed and aligned with L , we reduce the length of other two axes until the spheroid contains no obstacles. This is done by searching for the closest obstacle in O from the center of ξ . Fig. 6 shows the shrinking process from a 2-D perspective.
Fig. 6. - Shrink ellipsoid $\xi$. The bold line segment is $L$, gray region indicates obstacle while the white region is free space. Left: start with a sphere, we find the closest point $\mathbf {p}^\star$ to the center of $L$ and adjust the length of short axes such that the dashed ellipsoid touches this $\mathbf {p}^\star$. Middle: repeat the same procedure, find a new closest point $\mathbf {p}^\star$ and the new ellipsoid. Right: no obstacle is inside the ellipsoid, current ellipsoid is the max spheroid. Several iterations are required to ensure the final spheroid excludes all the obstacles.
Fig. 6.

Shrink ellipsoid ξ . The bold line segment is L , gray region indicates obstacle while the white region is free space. Left: start with a sphere, we find the closest point p ⋆ to the center of L and adjust the length of short axes such that the dashed ellipsoid touches this p ⋆ . Middle: repeat the same procedure, find a new closest point p ⋆ and the new ellipsoid. Right: no obstacle is inside the ellipsoid, current ellipsoid is the max spheroid. Several iterations are required to ensure the final spheroid excludes all the obstacles.

Show All

The maximal spheroid touches an obstacle at p ⋆ which, along with the line segment L , defines the plane of x ~ - y ~ axes of the spheroid. Following
Algorithm 1: Given ξ 0 ( E , d ) , find the C ( A , b ) . The set of obstacle points is denoted as O .

function Find Polyhedron ( ξ 0 , O )

O r e m a i n ← O

j ← 0

while O r e m a i n ≠ ∅ do

p c j ← ClosestPoint ( ξ 0 , O r e m a i n )

ξ j ← DilateEllipsoid ( ξ 0 , p c j )

a j ← 2 E − 1 E − T ( p c j − d )

b j ← a T j p c j

O r e m a i n ← RemovePoints ( a j , b j , O r e m a i n )

j = j + 1

end while

C : A T ← ⎡ ⎣ ⎢ ⎢ a T 0 a T 1 ⋮ ⎤ ⎦ ⎥ ⎥ , b ← ⎡ ⎣ ⎢ ⎢ b 0 b 1 ⋮ ⎤ ⎦ ⎥ ⎥

return C ( A , b )

end function
that, we stretch the length of the z ~ -axis of the spheroid to make it equal to a to form a new initial ellipsoid. The actual value of c can be determined through finding another closest point using the similar process as shown in Fig. 6 .

2) Step 2 – Find Polyhedron

Denote the ellipsoid found in the previous step as ξ 0 , which touches an obstacle point at p c 0 = p ∗ . The tangent plane to the ellipsoid at this point creates a half space H 0 = { p | a T 0 p < b 0 } , containing the ellipsoid. After computing H 0 , we remove all the obstacles in O that lie outside H 0 (call this the set of remaining obstacles, O r e m a i n ), and “dilate” the ellipsoid (keeping its aspect ratio constant) until it is in contact with another obstacle point, p c 1 , at which point the new ellipsoid is called ξ 1 and the new tangent hyperplane creates a new half-space H 1 . This process is continued to obtain a sequence of half-spaces, H 0 , H 1 , ⋯ , H m . The intersection of these m + 1 halfspaces gives the convex polyhedron, C = ⋂ m j = 0 H j = { p | A T p < b } , where a j and b j are the j -th column of matrix A and element of vector b respectively.

Fig. 7 shows an example of ellipsoid dilation. In each dilate iteration, the ellipsoid ξ j touches an obstacle at a point p c j . Algorithm  1 shows the pseudo-code. The hyperplane defining the j -th half-space, H j , is the tangent to ξ j at p c j , and is computed as
a j b j = d ξ r d p ∣ ∣ ∣ p = p c j = 2 E − 1 E − T ( p c j − d ) = a T j p c j (2)
View Source Right-click on figure for MathML and additional features. \begin{equation} \begin{aligned} \mathbf {a}_j & = \left.\frac{d\xi _{r}}{d\mathbf {p}}\right|_{\mathbf {p} = \mathbf {p}^c_j} = 2\mathbf {E}^{-1}\mathbf {E}^{-T}(\mathbf {p}^c_j - \mathbf {d}) \\ b_j & = \mathbf {a}_j^T \mathbf {p}^c_j \end{aligned} \end{equation}

Fig. 7. - Dilate ellipsoid $\xi ^0$ to find halfspaces. Left: find the first intersection point $\mathbf {p}^c_0$ for $\xi ^0$ and hyperplane (red line), the obstacle points outside corresponding halfspace $H_0$ are removed (shadowed). Middle: find the next intersection point $\mathbf {p}^c_1$ (dashed ellipsoid shows the original ellipsoid $\xi ^0$ and the solid ellipoid shows the new ellipsoid $\xi ^1$), keep removing obstacle points from the map that are outside the new halfspace. Right: keep dilating until no obstacle remains in the current map, the convex space $C$ (blue region) is defined by the intersection of the halfplanes.
Fig. 7.

Dilate ellipsoid ξ 0 to find halfspaces. Left: find the first intersection point p c 0 for ξ 0 and hyperplane (red line), the obstacle points outside corresponding halfspace H 0 are removed (shadowed). Middle: find the next intersection point p c 1 (dashed ellipsoid shows the original ellipsoid ξ 0 and the solid ellipoid shows the new ellipsoid ξ 1 ), keep removing obstacle points from the map that are outside the new halfspace. Right: keep dilating until no obstacle remains in the current map, the convex space C (blue region) is defined by the intersection of the halfplanes.

Show All

So far, we are able to generate the polyhedron C for L , given the obstacles O . We apply this method on each individual line segment of the path P to get the Safe Flight Corridor as SFC ( P ) = { C i | i = 0 , 1 , … , n − 1 } ( Fig. 5 ). Since the original ellipsoid is inside the corresponding polyhedron, we have a guarantee that the line segment L is also inside the polyhedron. Thus the whole path P is guaranteed to be inside SFC ( P ) .
3) Bounding Box

The algorithm, as presented, needs to search through all the points in O at least twice to check for the intersection with the inflated ellipsoid when constructing the polyhedron C for each line segment L . This is an expensive process. We decrease the number of points to be checked for by adding a bounding box around L , and thus only searching for the obstacle points inside it. This process saves a large amount of computation time and also prevents the trajectory from going too far away from the original path. The bounding box for L is composed of 6 rectangles such that the axis of the bounding box is aligned with L and the minimum distance from each face to L is r_s . If the maximum speed and acceleration of the MAV is v_{\text{max}}, a_{\text{max}} , the condition imposed on the safety radius is r_s \geq \frac{v_{\text{max}}^2}{2a_{\text{max}}} . Fig. 8 shows the typical result from applying the bounding box. The generated SFC contains similar halfspaces as shown in Fig. 5 .
Fig. 8. - Left: apply bounding box on each line segment with safety radius $r_s$. Right: inflate individual line segment to find the convex polyhedron. We only process the obstacles inside corresponding bounding box comparing to Fig. 5 .
Fig. 8.

Left: apply bounding box on each line segment with safety radius r_s . Right: inflate individual line segment to find the convex polyhedron. We only process the obstacles inside corresponding bounding box comparing to Fig. 5 .

Show All
4) Shrink

We model the robot as a sphere with radius r_r and expand occupied voxels in the original map M to generate the configuration space M_e such that we are able to treat the robot as a single point for planning. When constructing the SFC for path P planned in M_e , using M_e could generate narrow ellipsoids and polyhera [ Fig. 9(a) and (b) ]. In order to avoid such kind of bad SFC, we use the original map M to generate the SFC and shrink the SFC by the robot radius r_r in order to guarantee safety. The shrinking process is applied by pushing every support hyperplane along its normal by r_r . This process ensures the safety of the shrunken SFC as we increase the distance between obstacles and each hyperplane by r_r , but may also exclude some portion of the path [ Fig. 9(d) ] which may cause discontinuity of the Safe Flight Corridor . To guarantee the continuity, we have to make sure the line segment L is inside the shrunken polyhedron C^{\prime } . For this, we modify the Algorithm  1 : for any halfspace H_j \in C ( C is the raw polyhedron), we check the minimum distance d(L, H_j) from L to the hyperplane of H_j . If d(L, H_j) < r_r , we adjust the normal of the hyperplane such that d(L, H_j^{\prime }) = r_r ( H_j^{\prime } is the adjusted halfspace). The hyperplane of the new halfspace H_j^{\prime } also passes through the intersection point of H_j with the dilated ellipsoid [ Fig. 9(e) ].
Fig. 9. - Constructing the SFC($P$) through the shrinking process. For clarity, we draw the contour of the expanded map $M_e$ using black bold lines. The contours of the SFC are indicated by blue boundaries while the shrunken SFCs are drawn as blue regions inside. The SFC in (a) and (b) is derived using $M_e$ without shrinking. Several ellipsoids and corresponding polyhedra are quite narrow. In (c) and (d), the SFC is generated using the original map $M$ such that the corridor is “wider” compared to (a) and (b). Since this SFC also penetrates obstalces in the expanded map, we shrink it by the robot radius $r_r$ to derive the “safe” SFC. However, this shrinking process may cause discontinuities in the SFC, for example $\mathbf {p}_2$ (circled) is outside of the shrunken polyhedron generated from line segment $\mathbf {p}_1 \rightarrow \mathbf {p}_2$ in (d). In (e), the green hyperplane is adjusted such that $\mathbf {p}_2$ is still inside the shrunken polyhedron.
Fig. 9.

Constructing the SFC( P ) through the shrinking process. For clarity, we draw the contour of the expanded map M_e using black bold lines. The contours of the SFC are indicated by blue boundaries while the shrunken SFCs are drawn as blue regions inside. The SFC in (a) and (b) is derived using M_e without shrinking. Several ellipsoids and corresponding polyhedra are quite narrow. In (c) and (d), the SFC is generated using the original map M such that the corridor is “wider” compared to (a) and (b). Since this SFC also penetrates obstalces in the expanded map, we shrink it by the robot radius r_r to derive the “safe” SFC. However, this shrinking process may cause discontinuities in the SFC, for example \mathbf {p}_2 (circled) is outside of the shrunken polyhedron generated from line segment \mathbf {p}_1 \rightarrow \mathbf {p}_2 in (d). In (e), the green hyperplane is adjusted such that \mathbf {p}_2 is still inside the shrunken polyhedron.

Show All
C. Trajectory Optimization

In this section, we introduce the approach to generate minimum snap trajectories using the generated SFC. We adopt the similar formulation of trajectory optimization in our previous work  [9] . Assume the SFC contains n convex polyhedra, the whole trajectory is composed of n polynomials and the i -th polynomial is inside the i -th polyhedron C_i . Thus, the convex optimization for minimum snap trajectories can be formed as a QP with constraints for the robot's starting and ending states as \begin{align} \arg \min \limits _{\Phi }\ J &= \sum \limits _{i=0}^{n-1} \int \nolimits _0^{\Delta t_i} \left||\frac{d^4}{dt^4} \Phi _i(t)\right||^2dt \nonumber\\ s.t\ \ \frac{d^k}{dt^k} \Phi _i(\Delta t_i) & = \frac{d^k}{dt^k} \Phi _{i+1}(0), \;\;k = 0\dots 4 \nonumber\\ \mathbf {A}^T_i \Phi _i(t) &< \mathbf {b}_i \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \arg \min \limits _{\Phi }\ J &= \sum \limits _{i=0}^{n-1} \int \nolimits _0^{\Delta t_i} \left||\frac{d^4}{dt^4} \Phi _i(t)\right||^2dt \nonumber\\ s.t\ \ \frac{d^k}{dt^k} \Phi _i(\Delta t_i) & = \frac{d^k}{dt^k} \Phi _{i+1}(0), \;\;k = 0\dots 4 \nonumber\\ \mathbf {A}^T_i \Phi _i(t) &< \mathbf {b}_i \end{align}

Here the matrices \mathbf {A}_i, \mathbf {b}_i correspond to the i -th polyhedron C_i . And the trajectory \Phi (t) is composed as \begin{align} \Phi (t) =\left\lbrace \begin{array}{ll}\Phi _0(t-t_0)\ \ &t_0 \leq t < t_1\\ \Phi _1(t-t_1)\ \ &t_1 \leq t < t_2\\ \vdots \\ \Phi _{n-1}(t-t_{n-1})\ \ &t_{n-1} \leq t < t_{n} \end{array} \right. \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \Phi (t) =\left\lbrace \begin{array}{ll}\Phi _0(t-t_0)\ \ &t_0 \leq t < t_1\\ \Phi _1(t-t_1)\ \ &t_1 \leq t < t_2\\ \vdots \\ \Phi _{n-1}(t-t_{n-1})\ \ &t_{n-1} \leq t < t_{n} \end{array} \right. \end{align}

Here we use piece-wise polynomials as  [17] to describe the trajectory \Phi (t) . Thus, \Phi _i(t), \frac{d}{dt} \Phi _i(t), \frac{d^2}{dt^2} \Phi _i(t), \frac{d^3}{dt^3} \Phi _i(t) indicate the desired position, velocity, acceleration and jerk at time t , which are the input for the non-linear controller  [15] to calculate desired force and momentum for controlling the quadrotor. \Delta t_i in above equations refers to time of each polynomial as \Delta t_i = t_{i+1} - t_i . Fig. 10 shows an example of piece-wise polynomial trajectory that is confined by the SFC.
Fig. 10. - Example trajectory has three polyhedra $C_i$ and each segment $\Phi _i$ is confined to be inside its corresponding polyhedron. The red start and end points are confined to be at those locations and the yellow knot points are only constrained to be continuous and are allowed to vary within the intersection of adjacent pairs of polyhedra.
Fig. 10.

Example trajectory has three polyhedra C_i and each segment \Phi _i is confined to be inside its corresponding polyhedron. The red start and end points are confined to be at those locations and the yellow knot points are only constrained to be continuous and are allowed to vary within the intersection of adjacent pairs of polyhedra.

Show All

The estimation of \Delta t_i or Time Allocation significantly affects the resulting trajectories. As every SFC contains a valid path P , the naive Time Allocation method is to map this P into time domain using trapezoid velocity profile. Solving (3) with initial Time Allocation may result in trajectories with large velocity, acceleration or jerk that exceed the maximum thresholds of the MAV. Similar to  [6] , we modify \Delta t_i according to the (5) to adjust the Time Allocation such that the final trajectory generated using \Delta t_i^{\prime } can be followed by the robot. Denote the maximum velocity, acceleration and jerk of the generated trajectory as v_{\text{max}}, a_{\text{max}}, j_{\text{max}} and the corresponding thresholds as \bar{v}_{\text{max}}, \bar{a}_{\text{max}}, \bar{j}_{\text{max}} . The unit 1 is used to prevent modifying a proper Time Allocation . \begin{equation} \Delta t_i^{\prime } = \text{max}\left\lbrace 1,\bigg(\frac{v_{\text{max}}}{\bar{v}_{\text{max}}}\bigg), \bigg(\frac{a_{\text{max}}}{\bar{a}_{\text{max}}}\bigg)^\frac{1}{2}, \bigg(\frac{j_{\text{max}}}{\bar{j}_{\text{max}}}\bigg)^\frac{1}{3}\right\rbrace \Delta t_i \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \Delta t_i^{\prime } = \text{max}\left\lbrace 1,\bigg(\frac{v_{\text{max}}}{\bar{v}_{\text{max}}}\bigg), \bigg(\frac{a_{\text{max}}}{\bar{a}_{\text{max}}}\bigg)^\frac{1}{2}, \bigg(\frac{j_{\text{max}}}{\bar{j}_{\text{max}}}\bigg)^\frac{1}{3}\right\rbrace \Delta t_i \end{equation}

In our optimization process, we use a sample-based method to confine each polynomial, the details for which can be found in  [2] . Also, we always assume a static end state with zero velocity, acceleration and jerk to ensure the flight safety.
D. Receding Horizon Planning

For navigation of the MAV in an unknown environment with local sensing, we use Receding Horizon Planning (RHP) to continuously generate trajectories until the robot reaches the final goal. As mentioned in the Section.  I , the RHP is a variant of Receding Horizon Control where people solve a optimal control problem over a fixed future time interval  [18] ,  [19] . Instead of solving for a fixed time interval, we define the planning horizon to be the longest distance d_r that is restricted by sensing range in our receding horizon framework. Once we plan a path from start to goal, we only use a portion of this path with radius d_r of the robot to generate the trajectory \Phi . The robot only executes \Phi for a short period which we call the execution horizon T_e and thus the starting state for trajectory generation in next re-planning epoch is determined by \Phi (T_e) . We select T_e such that the time for generating a trajectory is guaranteed to be less than T_e so that the robot is able to follow a new trajectory once it finishes executing the current trajectory \Phi . In other words, we start generating the trajectory for the next epoch when the robot is executing the trajectory at the current epoch. Since the execution time T_e is bigger than the time it takes for generating a trajectory, the robot is always able to transit to track a new trajectory when it finishes executing the current one. Fig. 11 shows the example of RHP.
Fig. 11. - Receding Horizon Planning. The planned path $P$ goes to the goal (red diamond) directly. However, for generating trajectory $\Phi$, we only plan to the boundary point according to the planning horizon $d_r$ . The execution trajectory $\Phi (T_e)$ is bounded in the red circle according to the execution horizon $T_e$.
Fig. 11.

Receding Horizon Planning . The planned path P goes to the goal (red diamond) directly. However, for generating trajectory \Phi , we only plan to the boundary point according to the planning horizon d_r . The execution trajectory \Phi (T_e) is bounded in the red circle according to the execution horizon T_e .

Show All

In certain cases, if the planner is not able to find a path or the trajectory optimization fails due to a bad Time Allocation , the trajectory in the next re-planning epoch is not achievable. We utilize the stopping policy as described in  [13] to make the robot come to a stop if the failure happens and after the robot stabilizes itself, we continue searching for a new trajectory using the same trajectory generation pipeline. We are able to plan trajectories in either a global or local map but for our experiments we use a local map. A local map is built using the last few sensor readings while a global map requires a full SLAM solution to correct for drift in state estimation. Compared to the global map, a local map is easier to achieve and is sufficient for obstacle avoidance, but the lack of global information makes the planner globally incomplete and susceptible to dead-end like environments.
SECTION III.
Analysis
A. Comparison with IRIS

The existing algorithms for generating the collision-free convex region  [5] ,  [14] requires a proper selection of seeds and a geometric representation of obstacles which is hard to get from real sensor data. In their process (IRIS), solving the maximum ellipsoid through convex optimization takes a long time. For the map shown in Fig. 12 , the IRIS algorithm takes around 110 ms while our algorithm only requires 4.8 ms. In fact, the selection of seeds for growing ellipsoids in IRIS is non-trivial, which also makes it harder to run IRIS for decomposition in real-time.
Fig. 12. - Comparing our convex decomposition approach with IRIS. Red stars point out the start and goal. The generated trajectories are very similar, even though using two different Safe Flight Corridors. The light blue short lines that are perpendicular to the trajectory show the speeds at corresponding positions. (a) IRIS. (b) SFC.
Fig. 12.

Comparing our convex decomposition approach with IRIS. Red stars point out the start and goal. The generated trajectories are very similar, even though using two different Safe Flight Corridors . The light blue short lines that are perpendicular to the trajectory show the speeds at corresponding positions. (a) IRIS. (b) SFC.

Show All
B. Run Time Analysis

We use four different maps to test the run time of our algorithm by generating hundreds of trajectories through them. The four maps are named as ‘Random Blocks’, ‘Multiple Floors’, ‘The Forest’ and ‘Outdoor Buildings’. We sample goals at certain density in each map and manually select a start. Fig. 13 shows these maps and generated results. These maps are selected because they are typical for different environments encountered in the real world (namely 2.5-D, fully 3-D, randomly scattered complex obstacles and real-world data).
Fig. 13. - Generate trajectories from a start (big red ball) to sampled goals (small red balls) in different maps. The blue curves are generated trajectories, cyan region is the overlapped SFC. (a) Random blocks. (b) Multiple floors. (c) The forest. (d) Outdoor buildings.
Fig. 13.

Generate trajectories from a start (big red ball) to sampled goals (small red balls) in different maps. The blue curves are generated trajectories, cyan region is the overlapped SFC. (a) Random blocks. (b) Multiple floors. (c) The forest. (d) Outdoor buildings.

Show All

To evaluate the computational expense of our algorithm, we split the whole trajectory generation into three parts: path planning, convex decomposition and trajectory optimization. Table I indicates the time cost for each component when generating trajectories as shown in Fig. 13 on an i7-4800MQ processor. For path planning, we compared two different methods: A * and JPS to show the impact on run time by using JPS. As can be seen from the results, we are able to generate trajectory under a few hundred milliseconds which is sufficient fast for re-planning at 2–3 Hz.
C. Completeness

In this subsection, we discuss the algorithmic completeness within the local map: whether a trajectory will be found if one exists up to the resolution of the map. Since construction of SFC starts with line segments, it will at least produce a set of convex regions that includes those line segments. In this case, the feasible set of the optimization always contains the solution where the trajectory \Phi is polynomial with static starting and ending states. For other cases where the initial non-static dynamics cause the failure of the trajectory optimization, the vehicle will either follow the existing collision-free trajectory or execute a stopping policy. Eventually, the vehicle will stop in a hover mode and from that static state we can always generate a trajectory if there exists a path to the final goal. In sum, our algorithm is complete since the path planning algorithm we use is complete. When using the global map (for example, Fig. 13 ), the completeness is guaranteed. However, if we only have local maps, the global completeness is impossible to achieve and the robot may get trapped in dead-end.
D. Flight Speed

In this section, we analysis the speed of the autonomous flight through non-dimensional parameters. We describe an MAV model by the maximum acceleration \bar{a}_{\text{max}} (constrained by the vehicle thrust to weight ratio) and the maximum velocity \bar{v}_\text{max} (bounded by air drag). These two parameters reflect how fast an quadrotor can travel. For different platforms, we usually have different \bar{a}_{\text{max}}, \bar{v}_{\text{max}} values due to their various hardware configurations. The planning horizon d_r (limited by the sensing range) and execution horizon T_e (limited by the on-board computation power) are two independent variables that affect the flight speed of the vehicle in RHP. They can be non-dimensionalized through normalization as: \begin{equation} \begin{aligned} l = \frac{2\bar{a}_\text{max}}{\bar{v}^2_\text{max}}d_r, \ \ \tau _e = \frac{\bar{a}_\text{max}}{\bar{v}_\text{max}}T_e \end{aligned} \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \begin{aligned} l = \frac{2\bar{a}_\text{max}}{\bar{v}^2_\text{max}}d_r, \ \ \tau _e = \frac{\bar{a}_\text{max}}{\bar{v}_\text{max}}T_e \end{aligned} \end{equation}

The flight speed can be evaluated using two parameters: total time for reaching a goal T and the max speed v_\text{max} . Suppose the total distance is d_\text{goal} , we are able to evaluate the nominal flight time and maximum speed using the notation as: \begin{equation} \begin{aligned} \tau = \frac{\bar{v}_\text{max}}{d_\text{goal}}T,\ \ u = \frac{v_\text{max}}{\bar{v}_\text{max}} \end{aligned} \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \begin{aligned} \tau = \frac{\bar{v}_\text{max}}{d_\text{goal}}T,\ \ u = \frac{v_\text{max}}{\bar{v}_\text{max}} \end{aligned} \end{equation} We plot the test results from using three different robots in simulation using these non-dimensional parameters ( Fig. 14 ). We can conclude that fast flight can be achieved through setting a large planning horizon. However, in the actual experiments, the planning horizon is limited by the sensing range and won’t increase the flight speed after a certain threshold. The execution horizon is also limited by the on-board computation, for example in Table I the max time cost for re-plan takes up to 0.47\text{s} which places a lower bound on T_e .

Fig. 14. - Non-dimensional analysis for 3 different quadrotors while keeping $t_e$ fixed at 0.1 and changing $l$: for robot 1, $\bar{v}_\text{max} = 20\,{\rm m/s}, \bar{a}_\text{max} = 10\,{\rm m/s}^2$; for robot 2, $\bar{v}_\text{max} = 10\,{\rm m/s}, \bar{a}_\text{max} = 5\,{\rm m/s}^2$ ; for robot 3, $\bar{v}_\text{max} = 5\,{\rm m/s}, \bar{a}_\text{max} = 5\,{\rm m/s}^2$. The total time for reaching the goal $\tau$ and the maximum speed $u$ goes to 1.1 with increasing $l$ (due to sample-based method we use for trajectory optimization, the maximum speed will exceed the actual bound by a small amount), which means the longer planning horizon leads to a faster flight.
Fig. 14.

Non-dimensional analysis for 3 different quadrotors while keeping t_e fixed at 0.1 and changing l : for robot 1, \bar{v}_\text{max} = 20\,{\rm m/s}, \bar{a}_\text{max} = 10\,{\rm m/s}^2 ; for robot 2, \bar{v}_\text{max} = 10\,{\rm m/s}, \bar{a}_\text{max} = 5\,{\rm m/s}^2 ; for robot 3, \bar{v}_\text{max} = 5\,{\rm m/s}, \bar{a}_\text{max} = 5\,{\rm m/s}^2 . The total time for reaching the goal \tau and the maximum speed u goes to 1.1 with increasing l (due to sample-based method we use for trajectory optimization, the maximum speed will exceed the actual bound by a small amount), which means the longer planning horizon leads to a faster flight.

Show All

To test high speed obstacle avoidance, we simulate environments by randomly scattering N convex obstacles inside a region. A typical environment is shown in Fig. 15 . With a simulated Velodyne Puck VLP-16 of 40\text{m} sensing range, the robot is able to achieve a max speed of 19.2\;{\rm m/s} in this forest and reach the goal 200\text{m} away in 14.3\text{s} .
Fig. 15. - 400 trees are randomly placed onto a $200\times 40\;\text{m}$ square. The RHP planning horizon is $50\;\text{m}$, execution horizon is $1\;\text{s}$. Blue curves show the robot trajectory from one end to the other. Green dot show the start position of each re-plan.
Fig. 15.

400 trees are randomly placed onto a 200\times 40\;\text{m} square. The RHP planning horizon is 50\;\text{m} , execution horizon is 1\;\text{s} . Blue curves show the robot trajectory from one end to the other. Green dot show the start position of each re-plan.

Show All
SECTION IV.
Experimental Results

We apply the proposed navigation pipeline on the quadrotor platform shown in Fig. 1 . We use a stereo version of the MSCKF algorthm  [20] for state estimation and a Velodyne VLP-16 to build a local map. All the computation is performed on an on-board Intel NUC computer (dual-core i7). Fig. 17 shows several experiments in the outdoor scenario where the robot has zero prior knowledge about the environment. Given a goal with respect to initial robot position, our system can successfully reach the goal and come back without hitting any obstacle. The vehicle travels at speeds up to 5 \;{\rm m/s} for the runs shown in Fig. 17 . In test 1, the robot successfully avoids trees and bushes with complicated 3-D geometries. In test 2, since the forest is dense the robot decides to fly around it instead of flying through it. In test 3, the robot avoids trees, forests and buildings, the total distance traveled by the robot is around 1\;\text{km} . Our trajectories are smooth and constrained by thresholds on velocity, acceleration and jerk which helps to decrease the error in vision-based state estimation: the general drift in position after coming back to the start position is less than 1\% .

As we set the maximum acceleration to be relatively small ( 3\;{\rm m/s}^2 ), the robot is able to closely track the generated trajectories. Fig. 16 shows the performance of the controller during test 1 and we can see that the errors are smaller than 0.2\;\text{m} in position.
Fig. 16. - State estimation vs desired command for test 1. The actual robot state is marked blue, while the desired command is marked black.
Fig. 16.

State estimation vs desired command for test 1. The actual robot state is marked blue, while the desired command is marked black.

Show All
Fig. 17. - Outdoor experiments. The grid cell size is $10\;\text{m} \times 10\;\text{m}$. The maximum speed is set to be $5\,{\rm m/s}$ while we also limit the maximum acceleration as $3\,{\rm m/s}^2$. The 2-D axes shows the direction of $x-y$ axes, the origin is located at the start point marked as a read star denoted by S. (a) Test 1. Goal ($-$ 155, 39). (b) Test 2. Goal (46, $-$ 184). (c) Test 3. Goal (25, 384).
Fig. 17.

Outdoor experiments. The grid cell size is 10\;\text{m} \times 10\;\text{m} . The maximum speed is set to be 5\,{\rm m/s} while we also limit the maximum acceleration as 3\,{\rm m/s}^2 . The 2-D axes shows the direction of x-y axes, the origin is located at the start point marked as a read star denoted by S. (a) Test 1. Goal ( - 155, 39). (b) Test 2. Goal (46, - 184). (c) Test 3. Goal (25, 384).

Show All
SECTION V.
Conclusion

High-speed autonomous navigation is a challenge for MAVs because of (a) the constraints on dynamics that have to be incorporated into motion planning; (b) the limited computational resources for planning; (c) the limited sensor sensing range because of which the robot only has access to a local map of the world. In this letter, we described a trajectory generation algorithm that derives dynamically-feasible, collision-free trajectories in real time based only on on-board sensing and computation, and updates these trajectories in real time as fresh information becomes available from its sensors under the framework of Receding Horizon Planning . We studied the trade-offs between speed and safety and the effects of such parameters as (a) T_e , the execution horizon , (b) l , the sensor sensing range in the environment for different quadrotors. The study of the whole system and balance between the subsystems will identify the limiting factors hindering the speed of navigation and guide future research towards mediating these factors.

Authors
Figures
References
Citations
Keywords
Metrics
   Back to Results   
More Like This
A comparative study of robust attitude synchronization controllers for multiple 3-DOF helicopters

2015 American Control Conference (ACC)

Published: 2015
Real-time trajectory optimization under input constraints for a flatness-controlled laboratory helicopter

2009 European Control Conference (ECC)

Published: 2009
Show More
References
1.
M. J. Van Nieuwstadt and R. M. Murray, "Real time trajectory generation for differentially flat systems", 1997.
Show in Context Google Scholar
2.
D. Mellinger and V. Kumar, "Minimum snap trajectory generation and control for quadrotors", Proc. 2011 IEEE Int. Conf. Robot. Autom. , 2011.
Show in Context View Article
Google Scholar
3.
D. Mellinger, A. Kushleyev and V. Kumar, "Mixed-integer quadratic program trajectory generation for heterogeneous quadrotor teams", Proc. 2012 IEEE Int. Conf. Robot. Autom. , 2012.
View Article
Google Scholar
4.
K. F. Culligan, "Online trajectory planning for UAVs using mixed integer linear programming", 2006.
Google Scholar
5.
R. Deits and R. Tedrake, "Efficient mixed-integer planning for UAVs in cluttered environments", Proc. 2015 IEEE Int. Conf. Robot. Autom. , 2015.
Show in Context CrossRef Google Scholar
6.
C. Richter, A. Bry and N. Roy, "Polynomial trajectory planning for aggressive quadrotor flight in dense indoor environments", Proc. Int. Symp. Robot. Res. , 2013.
Show in Context CrossRef Google Scholar
7.
J. Chen, T. Liu and S. Shen, "Online generation of collision-free trajectories for quadrotor flight in unknown cluttered environments", Proc. 2016 IEEE Int. Conf. Robot. Autom , pp. 1476-1483, 2016.
Show in Context Google Scholar
8.
F. Gao and S. Shen, "Online quadrotor trajectory generation and autonomous navigation on point clouds", Proc. 2016 IEEE Int. Symp. Safety Security Rescue Robot. , pp. 139-146, Oct. 2016.
CrossRef Google Scholar
9.
S. Liu, M. Watterson, S. Tang and V. Kumar, "High speed navigation for quadrotors with limited onboard sensing", Proc. 2016 IEEE Int. Conf. Robot. Autom , pp. 1484-1491, 2016.
Show in Context Google Scholar
10.
A. Hornung, K. M. Wurm, M. Bennewitz, C. Stachniss and W. Burgard, "Octomap: An efficient probabilistic 3D mapping framework based on octrees", Auton. Robots , 2013.
Show in Context CrossRef Google Scholar
11.
S. Karaman and E. Frazzoli, "High-speed flight in an ergodic forest", Proc. 2012 IEEE Int. Conf. Robot. Autom. IEEE , pp. 2899-2906, 2012.
Show in Context View Article
Google Scholar
12.
K. M. Seiler, S. P. Singh, S. Sukkarieh and H. Durrant-Whyte, "Using lie group symmetries for fast corrective motion planning", The Int. J. Robot. Res. , vol. 31, pp. 151-166, 2011.
Show in Context CrossRef Google Scholar
13.
M. Watterson and V. Kumar, "Safe receding horizon control for aggressive MAV flight with limited range sensing", Proc. 2015 IEEE/RSJ Int. Conf. Intell. Robots Syst. , 2015.
Show in Context View Article
Google Scholar
14.
R. Deits and R. Tedrake, "Computing large convex regions of obstacle-free space through semidefinite programming" in Algorithmic Foundations of Robotics XI, Berlin, Germany:Springer, pp. 109-124, 2015.
Show in Context Google Scholar
15.
T. Lee, M. Leoky and N. H. McClamroch, "Geometric tracking control of a quadrotor UAV on SE (3)", Proc. 49th IEEE Conf. Decis. Control , pp. 5420-5425, 2010.
Show in Context CrossRef Google Scholar
16.
D. D. Harabor et al., "Online graph pruning for pathfinding on grid maps", Proc. 25th AAAI Conf. Artif. Intell. , 2011.
Show in Context Google Scholar
17.
D. W. Mellinger, "Trajectory generation and control for quadrotors", 2012.
Show in Context Google Scholar
18.
J. Bellingham, A. Richards and J. P. How, "Receding horizon control of autonomous aerial vehicles", Proc. 2002 Am. Control Conf. , vol. 5, pp. 3741-3746, 2002.
Show in Context CrossRef Google Scholar
19.
T. Schouwenaars, É. Féron and J. How, "Safe receding horizon path planning for autonomous vehicles", Proc. Annu. Allerton Conf. Commun. Control Comput. , vol. 40, no. 1, 2002.
Show in Context Google Scholar
20.
A. I. Mourikis and S. I. Roumeliotis, "A multi-state constraint Kalman filter for vision-aided inertial navigation", Proc. 2007 IEEE Int. Conf. Robot. Autom , pp. 3565-3572, 2007.
Show in Context Google Scholar
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
