PATH PLANNING WITH HOMOTOPIC CONSTRAINTS FOR AUTONOMOUS UNDERWATER
VEHICLES
Emili HERNÀNDEZ BES
Dipòsit legal: GI. 1193-2012
http://hdl.handle.net/10803/83568
ADVERTIMENT. L'accés als continguts d'aquesta tesi doctoral i la seva utilització ha de respectar els drets de la persona autora. Pot ser utilitzada per a consulta o estudi personal, així com en activitats o materials d'investigació i docència en els termes establerts a l'art. 32 del Text Refós de la Llei de Propietat Intel·lectual (RDL 1/1996). Per altres utilitzacions es requereix l'autorització prèvia i expressa de la persona autora. En qualsevol cas, en la utilització dels seus continguts caldrà indicar de forma clara el nom i cognoms de la persona autora i el títol de la tesi doctoral. No s'autoritza la seva reproducció o altres formes d'explotació efectuades amb finalitats de lucre ni la seva comunicació pública des d'un lloc aliè al servei TDX. Tampoc s'autoritza la presentació del seu contingut en una finestra o marc aliè a TDX (framing). Aquesta reserva de drets afecta tant als continguts de la tesi com als seus resums i índexs.
ADVERTENCIA. El acceso a los contenidos de esta tesis doctoral y su utilización debe respetar los derechos de la persona autora. Puede ser utilizada para consulta o estudio personal, así como en actividades o materiales de investigación y docencia en los términos establecidos en el art. 32 del Texto Refundido de la Ley de Propiedad Intelectual (RDL 1/1996). Para otros usos se requiere la autorización previa y expresa de la persona autora. En cualquier caso, en la utilización de sus contenidos se deberá indicar de forma clara el nombre y apellidos de la persona autora y el título de la tesis doctoral. No se autoriza su reproducción u otras formas de explotación efectuadas con fines lucrativos ni su comunicación pública desde un sitio ajeno al servicio TDR. Tampoco se autoriza la presentación de su contenido en una ventana o marco ajeno a TDR (framing). Esta reserva de derechos afecta tanto al contenido de la tesis como a sus resúmenes e índices.
WARNING. Access to the contents of this doctoral thesis and its use must respect the rights of the author. It can be used for reference or private study, as well as research and learning activities or materials in the terms established by the 32nd article of the Spanish Consolidated Copyright Act (RDL 1/1996). Express and previous authorization of the author is required for any other uses. In any case, when using its content, full name of the author and title of the thesis must be clearly indicated. Reproduction or other forms of for profit use or public communication from outside TDX service is not allowed. Presentation of its content in a window or frame external to TDX (framing) is not authorized either. These rights affect both the content of the thesis and its abstracts and indexes.

Ph.D. thesis PATH PLANNING WITH HOMOTOPIC CONSTRAINTS FOR AUTONOMOUS UNDERWATER
VEHICLES
emili hernàndez bes
2012

Ph.D. thesis PATH PLANNING WITH HOMOTOPIC CONSTRAINTS FOR AUTONOMOUS UNDERWATER
VEHICLES emili hernàndez bes
2012 Doctoral Programme in Technology
Supervisors Dr. Pere Ridao Rodríguez and Dr. Marc Carreras Pérez Work submitted to the University of Girona in fulﬁlment of the
requirements for the degree of Doctor of Philosophy

Emili Hernàndez Bes: Path Planning with Homotopic Constraints for Autonomous Underwater Vehicles, © 2012

Dedicated to my family and especially to Sara.

ACKNOWLEDGMENTS
I would like to express my gratitude to those who helped me during the development of this thesis. First of all, I would like to thank my supervisors Marc Carreras and Pere Ridao for believing in me and encouraging me to realize this research work. Without their advices and optimism in those moments when things did not work, this work would not have been possible.
I also thank the members of the Underwater Robotics Lab. for the help whenever it was necessary. I want to thank my colleagues Narcís, David, Andrés, Aggelos, Tali, Lluís, Enric, Arnau, Chee Sing, Simone and Carles for always being there. I would also like to extend my gratitude to the rest of the members of the Computer Vision and Robotics Group of the Department of Computer Engineering, in particular to Xevi, Jordi, Xavi, Rafa, Miki, Quintana, Tudor, Sergio, Sik, Quim and Aulinas.
I am also grateful to the people in the Systems, Robotics & Vision Group at the Mathematics and Computer Science Department of the University of the Balearic Islands for their warm reception and hospitality during my stay. I especially want to thank Javier Antich for his useful advices and those interesting discussions, and Alberto Ortiz for his help during the stay. Thank you Francesc, Toni, Biel, Julian, Oscar and Xisco for making me feel like a member of the group.
I also wish to extend my gratitude to all my friends, in particular to Ivan for his enormous patience and those wonderful dives that helped me to break with the routine of the last period of the Ph.D.
I give my special gratitude to my parents, Rosa and Emili and my brother Edu. They deserve special gratitude for their comprehension and support of my decision to start a Ph.D. Thank you Joan for helping me with those obstacle’s panels. Thank you Maribel, Adriana and Carla for being there.
Finally, I want to express my gratitude to Sara for her love, patience and comprehension at every moment.
vii

ABSTRACT
The work presented in this thesis addresses the path planning problem for Autonomous Underwater Vehicles (AUVs). Our method proposes the utilization of homotopy classes to provide topological information on how paths avoid obstacles. Looking for a path within a homotopy class constrains the search into a speciﬁc area of the search space, speeding up the computation of the path. The method starts by generating the homotopy classes that connect the starting point with the ending point in a workspace with obstacles. Those classes which most probably contain lower cost solutions are determined by means of a lower bound criterion before computing a path. Finally, a path planner uses the topological information of homotopy classes to generate a few probable good solutions very quickly. Three path planners from different approaches have been proposed to generate paths for the homotopy classes obtained. The ﬁrst is the Homotopic A* (HA*), a graph-search based algorithm that computes the shortest homotopic path according to an input homotopy class. The second is a probabilistic sampled-based approach called Homotopic RRT (HRRT). The last is the Homotopic Bug (HBug), a Bug-based algorithm that combines following the lower bound path with the surroundings of the obstacle boundaries.
This thesis also proposes a local map building approach to generate Occupancy Grid Maps (OGMs) where path planning is performed. The method ﬁrst improves the dead-reckoning navigation of an AUV through a sonar scan matching technique to generate a more feasible OGM according to the information provided by the onboard sensors.
The local map building approach has been tested in a dataset gathered with an AUV. Results of our path planning approach in synthetic environments have shown that the HA* should be used when generating optimal solutions at the expense of low performance is required, whereas the HBug is suitable for applications where the time to perform the path planning is highly constrained. The map building approach and the path planning method have been tested together in real experimentation with the Sparus AUV in a controlled unknown environment.
ix

RESUM
Aquesta tesi aborda el problema de la planiﬁcació de camins per a Vehicles Submarins Autònoms (AUVs). El nostre mètode proposa la utilització de classes d’homotopia per a proporcionar informació topològica de com els camins eviten els obstacles. Calcular un camí dins d’una classe d’homotopia permet limitar l’espai de cerca accelerant-ne el càlcul de la solució. El mètode proposat comença amb la generació de les classes d’homotopia que connecten el punt inicial amb el punt ﬁnal d’un workspace amb obstacles. Aquelles classes que probablement contenen les solucions de menor cost s’identiﬁquen per mitjà d’un criteri de lower bound sense haver de calcular el camí al workspace. Finalment, un planiﬁcador de camins utilitza la informació topològica de les classes d’homotopia per generar solucions segons les classes seleccionades molt ràpidament. Els camins de les diferents classes d’homotopia obtingudes es generen per mitjà de tres planiﬁcadors de camins que segueixen propostes ben diferenciades. El primer és l’Homotopic A* (HA*), un algoritme de cerca en grafs que calcula el camí òptim per a una classe d’homotopia utilitzada com a paràmetre d’entrada. El segon és un algoritme probabilístic basat en la generació de mostres aleatòries anomenat Homotopic RRT (HRRT). L’últim és l’Homotopic Bug (HBug), un algoritme Bug que combina el seguiment del lower bound amb el seguiment del contorn dels obstacles.
En aquesta tesi també es proposa un mètode per generar mapes locals basats en Occupancy Grid Maps (OGMs), on posteriorment es realitza la planiﬁcació de camins. El mètode primer millora la navegació basada en dead-reckoning de l’AUV mitjançant una tècnica de scan matching que permet generar OGMs més ﬁdedignes d’acord amb la informació proporcionada pels sensors a bord del vehicle.
La proposta presentada per a la construcció de mapes locals s’ha provat en un dataset adquirit amb un AUV. Els resultats obtinguts amb el mètode de planiﬁcació de camins en escenaris sintètics han posat de manifest que l’HA* s’hauria d’utilitzar quan es requereix generar solucions òptimes sempre i quan es pugui assumir els seus alts temps d’execució, mentre que l’HBug és un bon candidat per aplicacions on el temps per a planiﬁcar camins està altament restringit. La proposta de construcció de mapes i el mètode de planiﬁcació de camins s’han testejat conjuntament en un experiment real utilitzant el Sparus AUV en un entorn desconegut i controlat.
xi

RESUMEN
El trabajo de esta tesis aborda el problema de la planiﬁcación de caminos en Vehículos Submarinos Autónomos (AUVs). Nuestro método propone la utilización de clases de homotopía para proporcionar información topológica de cómo los caminos evitan los obstáculos. Realizar una búsqueda del camino siguiendo una clase de homotopía especíﬁca permite limitar el espacio de búsqueda, acelerando el cálculo de la solución. El primer paso del método presentado genera las clases de homotopía que conectan el punto inicial con el punto ﬁnal en un workspace con obstáculos. Aquellas clases que probablemente contienen las soluciones de menor coste son identiﬁcadas mediante un criterio de lower bound sin necesidad de calcular ningún camino en el workspace. Por último, un planiﬁcador de caminos utiliza la información topológica de las clases de homotopía con el ﬁn de generar soluciones para las clases seleccionadas muy rápidamente. Para generar los caminos de las diferentes clases de homotopía obtenidas, se ha propuesto tres planiﬁcadores de caminos que siguen estrategias bien diferenciadas. El primero es el Homotopic A* (HA*), un algoritmo de búsqueda en grafos que calcula el camino óptimo según la clase de homotopía seleccionada como parámetro de entrada. El segundo es un algoritmo probabilista basado en la generación de muestras aleatorias llamado Homotopic RRT (HRRT). El último es el Homotopic Bug (HBug), un algoritmo Bug que alterna el seguimiento del lower bound con el del contorno de los obstáculos.
En esta tesis también se presenta un propuesta de un método para generar mapas locales basado en Occupancy Grid Maps (OGMs) donde posteriormente se realiza la planiﬁcación de caminos. El método primero mejora la navegación basada en dead-reckoning del AUV mediante una técnica de scan matching que permite generar OGMs más ﬁdedignos según la información proporcionada por los sensores a bordo del vehículo.
El método propuesto para la construcción de mapas locales ha sido testeado con un dataset adquirido con un AUV. Los resultados obtenidos con el método de planiﬁcación de caminos en escenarios sintéticos han puesto de maniﬁesto que el HA* debería de ser utilizado cuando se requiere generar soluciones óptimas en aplicaciones donde sus altos tiempos de ejecución no sean un problema. Por el contrario, el HBug es un buen candidato para aplicaciones donde el tiempo para obtener los caminos debe ser muy reducido. La propuesta presentada para la construcción del mapa y el método de planiﬁcación de caminos han sido probados conjuntamente en un experimento real utilizando el Sparus AUV en un escenario desconocido y controlado.
xiii

CONTENTS
1 introduction 1 1.1 Motivations 2 1.2 Goal of the Thesis 3 1.2.1 Objectives 4 1.3 Outline of the Thesis 6
2 state of the art 9 2.1 The Path Planning Problem 9 2.1.1 Overview 9 2.2 Graph-based Search Path Planning 10 2.2.1 Heuristic Functions Overview 11 2.2.2 The A* algorithm 12 2.2.3 Replanning Algorithms 13 2.3 Probabilistic sample-based Path Planning 15 2.3.1 The Rapidly-exploring Random Tree Approach 16 2.4 Bug-based Path Planning 18 2.5 Anytime Path Planning 23 2.5.1 The Deterministic Anytime Approach 24 2.5.2 The Probabilistic Anytime Approach 26 2.6 Topological Path Planning 28 2.7 Homotopy Classes 29 2.7.1 The Shortest Homotopic Path Problem 31 2.7.2 Homotopy Classes Generation Approaches 35 2.7.3 Constraining Path Search Topologically 36 2.7.4 Summary 39 2.8 Path planning for AUVs 40 2.9 Discussion 41
3 path planning with homotopy class constraints 45 3.1 Overview 45 3.1.1 Applicability to the Path Planning Problem 47 3.2 Homotopy Classes Generation 49 3.2.1 Reference Frame 49 3.2.2 Computation of the Canonical Sequence 50 3.2.3 Topological Graph 51 3.2.4 Systematic Homotopy Classes Computation 52 3.3 Lower Bound Estimator 54 3.4 Homotopic Path Planning Algorithms 55 3.4.1 Homotopic A* 56 3.4.2 Homotopic Rapidly-exploring Random Tree 58 3.4.3 Homotopic Bug 61 3.5 Summary 66
4 local map building 67 4.1 Scan Matching 67
xv

xvi contents
4.1.1 Problem Deﬁnition 68 4.1.2 Related Work 69 4.1.3 Scans Generation using an MSIS 72 4.1.4 The MSISpIC algorithm 81 4.2 Occupancy Grid Mapping 81 4.2.1 Problem Deﬁnition 82 4.2.2 Inverse Sensor Model 84 4.3 summary 86
5 experimental platform 87
5.1 Vehicle Experimental Platforms 87 5.1.1 Ictineu AUV 87 5.1.2 Sparus AUV 89
5.2 Map Building Hardware 91 5.2.1 Doppler Velocity Log 91 5.2.2 Motion Reference Unit 92 5.2.3 Mechanical Scanned Imaging Sonar 93 5.2.4 Multibeam Proﬁling Sonar 93
5.3 COLA2 Architecture 94 5.3.1 Reactive Layer 95 5.3.2 Execution Layer 96 5.3.3 Mission Layer 97
6 results 99
6.1 Map building in a Man-made Marina Environment 99 6.1.1 Scan Matching 100 6.1.2 Occupancy Grid Mapping 101
6.2 Path planning with Homotopy Class Constraints 103 6.2.1 Cluttered Scenario 105 6.2.2 Large Scenario 109 6.2.3 Discussion 117
6.3 A Water Tank Environment Test 117 6.3.1 Map Building 118 6.3.2 Path Planning with Homotopy Constraints 119
6.4 Experiment in the Formigues Islands 120 6.5 Summary 125
7 conclusions 129
7.1 Summary 129 7.2 Contributions 131 7.3 Future Work 132 7.4 Research Framework 133 7.5 Related Publications 134
a an example of homotopy classes generation 137
b transformations in 2d 139
b.1 Composition 139 b.2 Point features 139
bibliography 141

LIST OF FIGURES

Figure 1 Figure 2
Figure 3
Figure 4
Figure 5
Figure 6 Figure 7 Figure 8 Figure 9 Figure 10 Figure 11 Figure 12 Figure 13 Figure 14 Figure 15 Figure 16 Figure 17

Two discrete motion models. 10 A* execution example. a), b) and c) depict the environment exploration at three different moments. d) Shows the shortest path computed with backtracking from the goal once it has been found. 14 Graphical comparison of graph-based search algorithms. A* (A8 connectivity) only assumes the cost of the centre of the discrete cells. Field-D associates costs with cell corners and allows linear paths between cells. HybridA* associates a continuous state with each cell. Image extracted from (Dolgov et al., 2010). 15 The RRT uses the qstart as the root node of a tree until the goal conﬁguration qgoal is reached. At each step, a conﬁguration qrand is selected using a random sampling distribution. Then, the nearest node in the tree to qrand is labeled as qnearest. Finally, a new node qnew is added to the tree at a certain distance from qnearest towards qrand. 17 Example of an RRT execution in a simple environment: a) Exploration tree with no biased sampling; b) Exploration tree making 5% of the samples coincident with the goal. 18 Improving a sampled-based path with the greedy approach. 18 An example of the execution of the Bug1 algorithm in a simple scenario. 19 Example of execution of Bug2 algorithm in a simple scenario. 20 Bug2 path in a scenario with a complex obstacle. 20 Interval of continuities found by the range sensor at a ﬁxed position. 21 A Tangent Bug algorithm execution. 22 Completeness of Bug1 and Bug2 algorithms. 22 An ARA* search. Images extracted from (Likhachev et al., 2004) 25 An ARRT example. 27 Example of computing the shortest path using a visibility graph. 29 Computing the shortest path using a Voronoi diagram in a scenario with 12 sites. 30 Example of homotopic paths. 30

xvii

xviii List of Figures

Figure 18 Figure 19 Figure 20
Figure 21 Figure 22 Figure 23

Different moments during the computation of the shortest path using the funnel algorithm. The dashed blue lines represent the interior edges of the channel. 32 According to (Cheng et al., 2010), the input path (dashed line) is encoded according to the edges traversed on the triangulated environment differentiating whether an edge is crossed to the left or right: ← e−1−e→2← e−2−e→2−e→3← e−4−e→4← e−4−e→5. Then, it is possible to obtain its canonical representation ←e−1−e→2−e→3←e−4−e→5 which shortens the path (solid line). The next step would expand the triangulation to improve the path while keeping the canonical sequence of the homotopy class. 33 Computing the shortest homotopic paths: a) Input paths p1 and p2 with their respective terminal points (t1 and t2 for p1, and t3 and t4 for p2). b) Minimum necessary shortcuts s1 and s2 to obtain x-monotone paths. c) Monotone pieces after applying shortcuts: p1 is divided into 3 monotone pieces: µ1 from t1 to t3, µ2 from t3 to t4, and µ3 from t4 to t2; p2 is represented by one monotone piece µ4. µ2 and µ4 belong to the same bundle since they are homotopic because they share terminal points and there are no more terminal points between them. d) Paths after computing the shortest path for each bundle: σ1 and σ2 are the shortest homotopic paths of p1 and p2 respectively. Figure extracted from (Efrat et al., 2002). 34 A (Jenkins, 1991) and (Cuerington, 1991) example: a) In the reference frame, the obstacles are represented as single points bk and a path p is described topologically according to the semi-rays traversed . b) The homotopic shortest path of p crosses the semi-rays of the reference frame in the same manner. 36 Schmitzberger et al. places a minimum number of x points that cover the whole C-Space with their ﬁelds of view (a), and others support points y in order to build a redundant PRM (b), which is simpliﬁed in c). The ﬁnal PRM allows performing a suboptimal motion planning with any homotopy class. Images extracted from (Schmitzberger et al., 2002). 37 The original graph G is expanded by the L-value to generate the GL graph. In the example, trajectories τ1 and τ2 are obtained from the start point in the complex domain zs with an L-value of 0+0i, to the goal zg which has an L-value Λ or Λ¯ depending on the state of GL. Image extracted from (Bhattacharya et al., 2010). 38

Figure 24 Figure 25 Figure 26
Figure 27 Figure 28
Figure 29 Figure 30 Figure 31 Figure 32 Figure 33 Figure 34 Figure 35 Figure 36 Figure 37 Figure 38 Figure 39 Figure 40
Figure 41 Figure 42 Figure 43 Figure 44
Figure 45

List of Figures xix

A topological path represented in the reference frame as

p = β1α2α2α2 with the transitions labeled. 46

Path p = β1α2α2α2 represented in the topological graph

with bold arrows. 47

Example of a valid homotopy class (β1α2) in the ref-

erence frame (a) and in the topological graph (b) that

cannot be followed in the workspace (c) because at least

one line (l1 or l2) in the reference frame intersects more

than one obstacle. 49

Topological path represented in the reference frame as

p = β11 α10 α20 α10 α20 α20 α10 α1−1

50

A possible path in the reference frame of the canonical

sequence p = β11α10α20α1−1 obtained with the sequence

β11 α10 α20 α10 α20 α20 α10 α1−1 .

51

The path β11α10α20α1−1 represented in the topological

graph. 52

A simple wrap in path βk1αk0βk1. 53 A wrap in path αm0 αk0 βk2 αk1 . 53 Self-crossing in path βk1 βm1 αm0 βk2 . 53 The channel and lower bound path for the homotopy

class β11 α10 α20 α1−1 . 55 An HA* execution example in a simple workspace with

two obstacles for homotopy class β11β21. 57 A path computed with the HRRT path planner for the

homotopy class β11 α10 α20 α1−1 . 61 Perpendicular dot product. 62

Path computed with the HBug path planner for the ho-

motopy class β11 α10 α20 α1−1 . 63 Two ways to check completeness with HBug algorithm

for the homotopy class αk0. 65 The scan matching problem. 69

pIC correspondence computation. The large ellipse con-

tains all the statistically compatible points and the squared

point represents the correspondence with its uncertainty

(small ellipse). 71

Generation of an acoustic beam. Extracted from (Ribas

et al., 2010) 73

Interpretation of a polar image gathered with an MSIS.

The current beam is detailed. 74

A peaks detector for an MSIS beam. 74

The distortion produced by the displacement of the robot

in the scenario in Figure 42 while acquiring data can be

corrected using the relative localization system. 75

A scan forming process: any beam k of the scan is rep-

resented with respect to the pose of the robot when the

ﬁrst beam I was gathered. 80

xx List of Figures

Figure 46 Figure 47
Figure 48 Figure 49 Figure 50 Figure 51 Figure 52 Figure 53 Figure 54 Figure 55 Figure 56 Figure 57 Figure 58 Figure 59 Figure 60 Figure 61 Figure 62
Figure 63
Figure 64
Figure 65
Figure 66
Figure 67
Figure 68

Initially each beam is gathered at different vehicle positions. 80 The scan grabbing process references all the beams of the scan at the position of the robot when the ﬁrst beam was gathered. The uncertainty of the motion has been propagated to the scan points. 80 A proﬁler sonar inverse sensor model. 84 Imaging sonar inverse sensor model. 85 The Ictineu AUV. 88 The Sparus AUV. 90 DVLs used in this research project. 92 Xsens MTi MRU. 92 Models of the MSISs used in this research project. 93 Imagenex Multibeam. 94 COLA2 architecture 95 The Ictineu AUV with a surface buoy equipped with a DGPS. 100 DGPS trajectory with range data plotted on the orthophotomap. 101 Dead-reckoning trajectory (in red) with range data plotted on the orthophotomap. 102 The MSISpIC trajectory (in cyan) with range data plotted on the orthophotomap. 102 Dead-reckoning and MSISpIC trajectories absolute error with respect to the DGPS. 103 OGMs based on DGPS, dead-reckoning and MSISpIC trajectories. Each trajectory is represented using a proﬁler sonar model and an imaging sonar model. 104 Paths generated with the HA*, HRRT and HBug algorithms for the four homotopy classes with the smaller lower bound in the cluttered environment. 107 Cost of the paths computed with the HA*, HRRT and HBug algorithms for each homotopy class in Table 6 sorted according their lower bound. 108 Accumulated computation time of the paths using the HA*, HRRT and HBug algorithms for each homotopy class in Table 6 sorted according their lower bound. 108 Paths of the ﬁve homotopy classes with the smaller lower bound computed with the HA*. The class associated to the index can be found in Table 7. 110 Normalized cost, normalized lower bound and computation time for paths generated with the HA* for each homotopy class. 111 Paths of the ﬁve homotopy classes with the smaller lower bound computed with the HRRT. The class associated to the index can be found in Table 7. 112

Figure 69
Figure 70
Figure 71
Figure 72
Figure 73 Figure 74 Figure 75 Figure 76
Figure 77 Figure 78
Figure 79 Figure 80 Figure 81
Figure 82
Figure 83
Figure 84

Normalized cost, normalized lower bound and computation time for paths generated with the HRRT for each homotopy class. 112 Paths of the ﬁve homotopy classes with the smaller lower bound computed with the HBug. The class associated to the index can be found in Table 7. 113 Normalized cost, normalized lower bound and computation time for paths generated with the HBug for each homotopy class. 114 Comparison of the HA*, HRRT and HBug paths of the ﬁve homotopy classes with the smaller lower bound vs A*, RRT, ARA*, ARRT and Bug2 algorithms. 115 The HRRT and HBug paths cost with respect to the HA* cost for each homotopy class. 117 Water tank environment set up. 118 A dead-reckoning trajectory with range data. 119 A trajectory estimated with scan matching against deadreckoning. The range data is plotted according to the MSISpIC trajectory. 120 An 18x16m OGM with 0.1m resolution used as a C-space and its topological graph. 121 Paths generated with the HA*, the HRRT and the HBug algorithms for each homotopy class generated in the Underwater Robotics Lab. environment. 122 Girona 500 I-AUV 123 Bathymetric map obtained in the Formigues Islands. 124 The paths of the ﬁve homotopy classes with the smaller lower bound. The class associated to the index can be found in Table 10. 125 Normalized cost, normalized lower bound and computation time for paths generated with the HA* for the 45 homotopy classes in Figure 81. 126 The paths of the ﬁve homotopy classes with the smaller lower bound. The class associated to the index can be found in Table 11. 126 Normalized cost, normalized lower bound and computation time for paths generated with the HA* for the 75 homotopy classes in Figure 83. 126

xxi

Figure 85

The reference frame of a simple scenario with two obstacles with its correspondent topological graph. 137

LIST OF TABLES

Table 1 Table 2 Table 3 Table 4 Table 5 Table 6
Table 7 Table 8 Table 9
Table 10 Table 11 Table 12

Summary of selected methods that explicitly deal with homotopy classes. 42 A systematic generation of homotopy class candidates with the BFS algorithm. 48 Homotopy classes with their index of generation obtained with the topological graph in Figure 25. 48 Homotopy classes obtained with the extension of the Jenkins method we propose. The ﬁrst column shows their index of generation. 54 Lower bounds for each homotopy class normalized according to the cost of the A* solution. 55 Homotopy classes of the cluttered environment sorted by their lower bound with the cost of the paths computed using the HA*, HRRT and HBug algorithms. Costs in bold show the paths that would be computed when operating under realtime constraints. 106 The ﬁve homotopy classes of the large environment with the smaller lower bound and their generation index. 109 Homotopy classes generated for the Underwater Robotics Lab. environment with their length sorted according to the lower bound. 120 Homotopy classes generated for the Underwater Robotics Lab. environment with their computation time using the homotopic path planners. The homotopy classes have been sorted according to their lower bound. 121 The ﬁve homotopy classes with the smaller lower bound in Figure 81 scenario. 125 The ﬁve homotopy classes with the smaller lower bound in Figure 83 scenario. 127 Modiﬁed BFS execution. 138

xxii

Table 13

Glossary xxiii Homotopy classes obtained for the example. 138

LIST OF ACRONYMS

AAC AD* ADRRT AHRS AI ARA* ARRT ASC ASEKF AUV

Architecture Abstraction Component. Anytime Dynamic A*. Anytime Dynamic RRT. Attitude and Heading Reference System. Artiﬁcial Intelligence. Anytime Repairing A*. Anytime-RRT. Autonomous Surface Craft. Augmented State EKF. Autonomous Underwater Vehicle.

BFS

Breadth-First Search.

C-space CCD CL COLA2

Conﬁguration Space. Charge Coupled Device. Component Labeling. Component Oriented Layer-based Architecture for Autonomy.

DES DFS DGPS DoF DSTL DVL

Discrete Event System. Depth-First Search. Differential Global Positioning System. Degree of Freedom. Defence Science and Technology Lab. Doppler Velocity Log.

EKF ENU EST

Extended Kalman Filter. East-North-Up. Expansive-Space Tree.

FM

Fast Marching.

xxiv Glossary

GPS GVD

Global Positioning System. Generalized Voronoi Diagram.

HA* HBug HIL HRRT

Homotopic A*. Homotopic Bug. Hardware In the Loop. Homotopic RRT.

I-AUV ICP IFoG IGC

Intervention-Autonomous Underwater Vehicle. Iterative Closest Point. Intelligent Fiber-optic Gyro. Intelligent Gyro Compass.

MCL MCS MPS MRU MSIS

Mission Control Language. Mission Control System. Multibeam Proﬁling Sonar. Motion Reference Unit. Mechanical Scanned Imaging Sonar.

O2CA2 OGM

Object Oriented Control Architecture for Autonomy.
Occupancy Grid Map.

pIC PID PNP PRM

Probabilistic Iterative Correspondance. Proportional Integral Derivative. Petri Net Player. Probabilistic RoadMap.

r.g.v RL ROV RRT

random Gaussian variable. Reinforcement Learning. Remotely Operated Vehicle. Rapidly-exploring Random Tree.

SAUC-E
SBL SLAM SVS

Student Autonomous Underwater ChallengeEurope. Single-query Bi-directional Lazy collision-checking. Simultaneous Localization And Mapping. Sound Velocity System.

TAM

Thruster Allocation Matrix.

ULV USBL UUV

Ultra Low Voltage. Ultra-Short BaseLine. Unmanned Underwater Vehicle.

VICOROB Computer Vision and Robotics.

Glossary xxv

INTRODUCTION

1

Despite covering almost three quarters of the Earth’s surface, seas and oceans represent some of the least known areas of the planet due to the technological challenges that underwater research implies. Unmanned Underwater Vehicles (UUVs) are useful devices to perform exploration, inspection and intervention operations in oceans and internal waters. The development of Remotely Operated Vehicles (ROVs) during the 80s has had a huge impact in various application areas such as the oceanographic ﬁeld, where ROVs have reduced the need for manned submersibles, increasing the observation time from a few hours to a few days. These robots have also played an important role in industrial ﬁeld applications for the inspection of submerged structures like cables, pipes or dams, allowing intervention capabilities as well as rescue operations.
In order to overcome the limitations imposed by ROVs’tether cable, which highly restricts the working area of the vehicles, and to increase their autonomy and reduce the human intervention for operating the vehicles, Autonomous Underwater Vehicles (AUVs) have been developed. These vehicles are built with autonomous capabilities in mind. They cover a wide range of potential applications from data sampling to structure inspection. There are several AUV applications being explored by various organizations around the world (Davis, 1996): environmental monitoring, oceanographic research and maintenance/monitoring of underwater structures are just a few examples. AUVs are attractive for use in these areas because of their size and their non-reliance on human operators. Recently, some research institutions have started to develop a new generation of AUVs with one or more manipulators called InterventionAutonomous Underwater Vehicles (I-AUVs). Their main advantage is the low operational cost, since there is no need for large intervention ships (or oceanographic ships) with dynamic positioning capabilities. I-AUVs are designed to be operated very close to the seabed or in close proximity to industrial structures like those used by offshore industries. Given the potential applications and advantages of AUVs and I-AUVs, academic and commercial organizations around the world are conducting research using these vehicles.
This thesis explores the path planning capabilities of a navigation, mapping and guidance system for an AUV, whose main goal is to achieve a safe guidance of the vehicle in complex scenarios where intervention and surveilling applications are being carried out. After studying the main path planning approaches applied to robotics, this work has focused on generating topological information which is used to constraint the path generation. Consequently, the necessity of developing path planning algorithms that take into account topological constraints arises. In order to demonstrate the feasibility of our

1

2 introduction
proposal, it has been a priority to carry out experiments with real data from AUVs.
This introduction continues with the main aspects which have conditioned this thesis. First, some background information on the motivations and applicability is provided. Then, a description of the objectives of this thesis and an outline of this document are given.
1.1 motivations
The research presented in this thesis was carried out in the Underwater Robotics Laboratory of the Computer Vision and Robotics (VICOROB) group of the University of Girona. This group has been doing research in underwater robotics since 1992, supported by several National and European programs. The main contribution over the past few years has been the development of several ROV and AUV prototypes. The most recent vehicles, all operative at the present date, are the Ictineu AUV, the Sparus AUV and the Girona 500 I-AUV.
The Ictineu AUV is a small form factor with remarkable sensorial capabilities and easy maintenance which makes it a perfect research platform for testing in both laboratory and real application environments. The Sparus AUV was designed as a small, simple torpedo-shaped vehicle with hovering capabilities, which increases the vehicle’s autonomy with respect to the Ictineu AUV when traveling long distances. Both prototypes where conceived to participate in the 2006 and 2010 editions respectively of the Student Autonomous Underwater Challenge-Europe (SAUC-E) competition, but keeping in mind their later use in a wide range of applications such as the inspection of hydroelectric dams, mosaicking of areas with biological interest, harbors, underwater cables and pipes.
In the context of a National program, the lab’s latest prototype, the Girona 500, a reconﬁgurable I-AUV designed for a maximum operating depth of up to 500m was developed. The vehicle is composed of a frame supporting three torpedo-shaped hulls providing a good hydrodynamic performance and a large space for housing equipment while maintaining a compact size which allows the operation of the vehicle from small boats. Concerning the basic conﬁguration, the vehicle is equipped with navigation sensors and basic survey equipment. Moreover, the vehicle has a reserved space for a mission-speciﬁc payload such as a stereo imaging system or an electric arm for manipulation tasks.
The research efforts in the Underwater Robotics Laboratory have been oriented to the development of the diverse disciplines related with the operation of autonomous vehicles. An example can be found in the work done in control architectures, which has lead to the creation of the Object Oriented Control Architecture for Autonomy (O2CA2) control architecture (Carreras et al., 2001), recently substituted by a new layer-based control architecture named Component Oriented Layer-based Architecture for Autonomy (COLA2) implemented in the three operative prototypes. As the complexity of the autonomous mis-

1.2 goal of the thesis 3
sions increased, advances were made towards the development of a Mission Control System (MCS) (Palomeras, 2011). Also Artiﬁcial Intelligence (AI) capabilities have been studied by using Reinforcement Learning (RL) techniques (El-Fakdi, 2011) for automatic behavior learning.
Navigation has been addressed putting special efforts into vehicle localization since it constitutes a major underwater problem. Different approaches are currently being explored in the lab. The ﬁrst is by means of Simultaneous Localization And Mapping (SLAM) techniques (Ribas et al., 2010; Ridao et al., 2011), which require neither previous knowledge of the scenario nor the use of absolute positioning systems. Relative localization techniques based on scan matching, which improve the localization of the vehicle by overlapping successive sonar range scans provided by the sensors onboard the vehicle (Hernández et al., 2009b), have also been studied. Recent achievements rely on the combination of scan matching and SLAM in order to obtain the high quality results of SLAM with the low computation time of scan matching (Mallios et al., 2009, 2010a, 2011).
The principle motivation of this thesis is to expand the autonomous navigation and guidance capabilities of AUVs in inspection, intervention and surveilling applications. This kind of mission usually requires guiding the vehicle at a close distance to the seaﬂoor or to the surface to explore, which makes the robot to carry on the mission in complex scenarios. Following the studies carried out in mobile robotics (Mínguez et al., 2004), developing a navigation and guidance system capable of generating safe trajectories between known positions is required. The vehicle must be able to sense the environment and build a local map of the surroundings to compute a safe path towards the goal. After that, a path following algorithm has to guide the vehicle along the computed path with a simple reactive obstacle avoidance behavior which ensures the safety of the AUV in case of imminent collision.
This thesis focuses on the path planning capabilities of a navigation and guidance system for an AUV. In inspection and surveilling missions, the vehicle is not only required to compute a safe path between a start and a goal position, it must generate paths that avoid obstacles in a speciﬁc manner. This dissertation goes a step further and surveys most of the path planning approaches that have offered important advances in robotic applications, paying special attention to those which use homotopy classes since they provide a topological description of how paths avoid obstacles with respect to a set of obstacles and can be used to constrain the path search.
1.2 goal of the thesis
As stated earlier, the goal of this thesis is to explore the path planning capabilities in the context of a navigation and guidance system for an AUV. Path planning is a discipline that has been widely studied. However, a small number of algorithms have been applied to underwater robotics since most of the missions are carried out in the open ocean or along the coast where the

4 introduction
presence of obstacles is relatively low and the common strategy to avoid them is to keep a safe distance from the seaﬂoor.
The purpose of the work presented in this thesis is to provide trajectories for other types of missions, such as surveys and/or search tasks where the robot is required to navigate at a ﬁxed altitude in bottom-following mode while acquiring opto-acoustic imagery. For this purpose, the robot has to navigate in environments where high deliberative capabilities are required since the number of obstacles and the complexity of the environment increase. This is the case in applications like benthic habitat mapping, underwater archeology and cable or pipe inspection. Although path planning for AUVs is naturally formulated in 3D, under exposed conditions it can be considered that the robot is only required to generate a 2D map parallel to the sea ﬂoor, where any area with a slope greater than a certain threshold behaves as a 2D obstacle. This thesis has considered this fact and the 3D formulation of the problem is beyond its scope.
AUVs are usually designed to maximize their autonomy. Because of this, most of these vehicles have limited computational capabilities, which are commonly shared with online data processing for map building and/or obstacle avoidance purposes. For this reason, it is necessary to keep the computational load for path planning tasks relatively low. Moreover, the applications listed before usually require the generation of safe paths from two known positions that avoid obstacles in a speciﬁc manner, allowing the robot to navigate through regions of interest as well as avoiding potentially dangerous zones. In this dissertation both objectives are studied through the utilization of topological description of paths provided by homotopy classes, and how to use them for path planning purposes. Topological information provides information of how paths would avoid obstacles before generating any paths at all. Furthermore, with this information, it is possible to know in which areas of the scenario the solution path will be generated. Thus, path planning algorithms can take advantage of this topological description to accelerate the path generation process. Once a path has been found, the real time guidance of the vehicle is assumed to achieve it, conveniently merging a path following algorithm with a simple reactive obstacle avoidance technique. This system is not within the scope of this dissertation.
1.2.1 Objectives
After reviewing the research motivations and describing the problem, the goal of this thesis is stated here as:
Development of path planning techniques for autonomous underwater vehicles on sonar maps built with their onboard sensors.
The objective of this dissertation has been oriented to the autonomous navigation and guidance of AUVs in this lab. The main goal is to develop a method to automatically extract high-level topological knowledge of a given environment by means of homotopy classes and use this information in path

1.2 goal of the thesis 5
planning algorithms. This dissertation reviews the main path planning approaches and focuses specially on those which use topological information to constrain the path search, which are usually not taken into account by the robotics community.
In most autonomous navigation and guidance applications, the AUV is deployed with limited or no previous information about the environment. Therefore, the vehicle has to be able to generate an internal representation of the scenario where path planning is then performed. For this reason and taking into account the previous work done in the Underwater Robotics Lab., it is also an objective of this thesis to develop a local map building system to improve the dead-reckoning navigation of the vehicles in realtime in order to increase the feasibility of the map.
Although it is necessary to specify the theoretical properties of the algorithms proposed, it is also very important to show their applicability in real conditions. For this reason, carrying out experiments with real data from AUVs in order to demonstrate the achieved research advances has been a priority.
The goal of this thesis can be divided into the following more speciﬁc objectives:
topologically constrained path planning. To study the most relevant path planning approaches putting special attention into those techniques that constrain the path search topologically using homotopy classes. The objective is to constrain the generation of paths that avoid obstacles in different manners, which are best suited for surveilling purposes or to avoid certain undesirable zones.
path planning for auvs. Once the topological information of how paths avoid obstacles between the start and goal positions is provided by means of homotopy classes, a path planning algorithm has to generate a feasible path to be followed by a robot. The objective is to develop several algorithms based on different approaches since it is a subject of study to highlight the advantages and disadvantages of each proposal in order to specify what type of solution best ﬁts in each context.
local map building. The applicability of our path planning method is tested on maps generated with the AUV’s onboard sonar sensors. The accurateness of the map depends on the localization estimation itself and on the precision of the sensor readings. Although it is not the main goal of this research work, different sensor models are studied and developed in order capture all the information provided by the sensors on our vehicles into the map.
scan matching navigation. In order to generate more feasible maps of the navigated area where the path planning has to be performed, a suitable scan matching technique developed for mobile robots is adapted to work with the sonar sensors which AUVs are commonly equipped with.

6 introduction
test and results. The evaluation of path planning methods, either in synthetic or in real environments. The goal is to compare the proposed algorithms and extract their strong and weak points. In this work, we put special emphasis on real experimentation. Given an unknown scenario, it is expected that the robot is capable of building an internal representation of the environment, improved with scan matching techniques. The ﬁnal map is used by the AUV to generate paths according to the set of homotopy classes that allow avoidance of obstacles in different manners.
1.3 outline of the thesis
This thesis can be divided into three different parts. The ﬁrst part consists of an state of the art about path planning techniques, paying special attention to those methods that use homotopy classes to constrain the path search (Chapter 2). Based on the methods studied, Chapter 3 presents a new path planning method that uses homotopy classes to constrain the search for the path. The method provides general rules to generate homotopy classes in any 2D workspace that can then be accomplished by path planners. The second part of the thesis focuses on a map building approach for navigation purposes (Chapter 4) which improves the dead-reckoning navigation of AUVs through scan matching techniques to generate more feasible maps with an Occupancy Grid Map (OGM) algorithm. The resultant maps are used to perform path planning with the method developed in part one. Finally, the third part of this dissertation (Chapter 5) details the experimental platforms which are compounded by the Ictineu AUV and the Sparus AUV. The experimental results with the map building and path planning approaches are shown in Chapter 6, whereas Chapter 7 summarizes the contributions and future work. A brief description of each chapter is presented next.
chapter 2 State of the Art. This chapter reviews the main path planning techniques for robotic applications. Its main goal is to provide an insight into the different techniques studied. Because of this, a description of the main features of each approach with some representative algorithms shown in detail is provided. The chapter starts with a description of the graph-based search, probabilistic sampled-based algorithms and bugbased algorithms. An insight into anytime path planning techniques is also provided. Further, topological path planning approaches are presented, paying special attention to those techniques based on homotopy classes. Finally, the chapter shows some path planning solutions adopted for AUVs.
chapter 3 Path Planning with Homotopy Class Constraints. This chapter describes our proposal to generate homotopy classes whose paths can be followed in any 2D workspace. Then, it describes a heuristic estimator used as a lower bound criterion to set up a preference order when looking for paths of the homotopy classes. The path for each homotopy class can be generated with three different proposals; the ﬁrst is a graph-based

1.3 outline of the thesis 7
search algorithm, the second exploits the capabilities of the probabilistic random sampling, and the third focuses the search according to the strategies of the bug-like algorithms. The theoretical properties of each algorithm are also detailed.
chapter 4 Local Map Building. This chapter describes a map building approach to generate an internal representation of the environment where the path planning is performed. The chapter is divided into two main parts. The ﬁrst one focuses on improving the navigation of the AUV through a scan matching technique designed to deal with the noisy data and motion induced distortion introduced by sonar sensors with rotation heads. The second part of the chapter details the utilization of the improved navigation to generate more reliable maps with an OGM technique.
chapter 5 Experimental Platforms. This chapter introduces the Ictineu AUV and the Sparus AUV, the two vehicles used in the experimental phase of this research project. Details of the main sensors used for map building and the control architecture that operates the vehicles are also provided.
chapter 6 Results. This chapter presents the experimental results of this thesis, which are divided into four main sections. The ﬁrst shows the results obtained with the map building procedure described in Chapter 4 applied to a dataset gathered in a man-made marina environment. Then, the capabilities of the path planners constrained with homotopy classes proposed in Chapter 3 are shown in different synthetic environments. A comparison of well known path planners is also included. In the third section, the map building procedure and the path planning method are merged into one single experiment performed with the Sparus AUV. Finally, at the end of the chapter, the applicability of our path planning method on a bathymetric map is shown.
chapter 7 Conclusions. This chapter concludes the thesis with a summary of all the work done, pointing out contributions and future work. It also comments on the research evolution and the publications accomplished during this research project.

STATE OF THE ART

2

The work presented in this thesis concerns a system for an AUV that ﬁrst builds an internal map according to sonar sensor readings. This map is then used to perform deliberative path planning to generate safe and feasible paths towards a goal position. Since most of the work has been focused on the path planner, this chapter contains a survey of different path planning techniques that have been studied in the development of our proposal.
After an introduction that brieﬂy describes the path planning problem in Section 2.1, the survey explores graph search-based, probabilistic sample-based and bug-based path planning approaches in sections 2.2, 2.3 and 2.4 respectively. Then, Section 2.5 exposes anytime path planning techniques, which assume that in real world applications, robots have a limited time in which to operate. Section 2.6 introduces topological path planning and Section 2.7 focuses on solutions that explicitly take into account homotopy classes. Section 2.8 reports path planning solutions for AUVs. Finally, a discussion of the survey is given in Section 2.9.
2.1 the path planning problem
In robotics, the path planning problem consists of computing a safe path in the workspace that can be followed by a vehicle without collisions. Computing the path directly in the workspace is a very complex task since it requires taking into account the speciﬁc constraints of the robot such as size, shape and Degrees of Freedom (DoFs). Because of this, path planning is performed on the Conﬁguration Space (C-space), where the robot is represented as a single reference point called conﬁguration q. Every conﬁguration is a vector of all the parameters that represent the robot in the environment in a given position, orientation, energy, etc. The dimension of the C-space is determined by the number of parameters of the conﬁguration.
2.1.1 Overview
The set of conﬁgurations q of a C-space Q that are free of obstacles is the free conﬁguration space Qfree and the conﬁguration space obstacles Qobst groups all the conﬁgurations occupied by obstacles in the workspace.

Qfree = Q\ Qobst
Then, the path planning problem looks for a continuous mapping p in the Qfree

9

10 state of the art

a) A4 connectivity

b) A8 connectivity

Figure 1: Two discrete motion models.

p : [0, 1] → Qfree
where [0, 1] is the parametrization interval, p(0) corresponds to the start conﬁguration qstart and p(1) to the goal conﬁguration qgoal.
A path planning algorithm is said to be optimal when it computes a path that minimizes a set of constrains such as distance, time or energy. A path planner is also called complete when the algorithm ﬁnds a path from the start conﬁguration to the goal conﬁguration when there is a solution and reports no solution when there is not.
2.2 graph-based search path planning
The graph-based search is one of the most popular ways to perform path planning since it is theoretically well-grounded, has been extensively studied and has been applied in many different domains. A graph can be organized as a grid, where the nodes, usually called cells in this conﬁguration, and the edges are distributed regularly. In robotics, grids are widely used to represent environments where the robots have to perform path planning. Every cell of the grid corresponds to a physical region of the scenario. The value of a cell can represent, for instance, whether the cell is occupied by an obstacle or not (see Chapter 4 for further explanation). When the C-space is represented by a Cartesian grid, graph search algorithms commonly use an A4 or A8 connectivity discrete motion model of the robot, see Figure 1.
The Depth-First Search (DFS) and the Breadth-First Search (BFS) are two well-known algorithms to perform graph exploration. The DFS carries out an uninformed search based on the expansion of the ﬁrst child node, which then directs the search towards deeper nodes. When there are no more children nodes to explore, the search backtracks, returning to the most recent node that has not been explored and repeats the procedure until the goal is reached. On the other hand, the BFS expands and examines all nodes of the graph by systematically searching through every possible solution. The algorithm performs an exhaustive search throughout the entire graph or sequence of nodes without considering the goal until it ﬁnds it.

2.2 graph-based search path planning 11
The Wavefront algorithm (Barraquand et al., 1992), also called NF1, is a particular implementation of the BFS that can only be applied to grid environments. The algorithm explores the C-space from the start according to the selected connectivity which follows a wave pattern. Once the goal is reached by the wave, the path is computed with a gradient descent technique. The NF1 has been applied in many situations with success. For instance, (Mínguez, 2002) uses it in a sensor-based motion system for a mobile robot to avoid trap situations that could arise using only an obstacle avoidance algorithm. (Parker et al., 2003) implement a dual wavefront path planner in a mobile robot to intercept targets in an indoor environment using information from a distributed acoustic sensor network.
Dijkstra’s algorithm (Dijkstra, 1959) is an efﬁcient search algorithm for ﬁnding the optimal path in a graph when no other information besides the graph is given. Every time a node is explored, it is updated with the cost to reach the node from the start. Once the goal is found, the least-cost solution can be obtained with backtracking. The A* algorithm (Hart et al., 1968; Nilsson, 1982) uses a BFS to ﬁnd the least-cost path from an initial node to one goal node. It extends the Dijkstra’s algorithm by incorporating a heuristic to the cost estimation of paths from each node of the graph to the goal.
2.2.1 Heuristic Functions Overview
Path planning algorithms often use heuristic functions in order to estimate the path cost from a speciﬁc node to the goal before computing it. This information is commonly used together with the cost of traversing the graph from start to the speciﬁc node to set up a preference order when choosing the candidate node to be explored.
A heuristic is called optimistic (or admissible) when it returns a value that is less or equal to the cost of the shortest path from the current node to the goal. Formally, given a heuristic function for the a node n to the goal node ngoal, h(n, ngoal) and a function c(n, ngoal) that returns the cost of the shortest path from n to the goal node ngoal an optimistic heuristic accomplishes:
∀n, h(n, ngoal) c(n, ngoal)
In this case the heuristic search is efﬁcient. On the other hand, using a pessimistic heuristic, a path is also found but it takes more time than probably required and there is the possibility of ﬁnding a suboptimal solution. A heuristic function is also consistent (or monotonic) when the search approaches the solution incrementally without any backtracking, which improves the performance. Formally, for every node n and every successor of n, n , the estimated cost of reaching the goal from n is no less than or equal to the step cost of getting to n plus the estimated cost of reaching the goal from n :
∀n, h(n, ngoal) c(n, n ) + h(n , ngoal)

12 state of the art
and
h(ngoal, ngoal) = 0
2.2.2 The A* algorithm
As stated before, the A* extends the Dijkstra’s algorithm by incorporating a heuristic to the cost estimation of paths from each node of the graph to the goal. Each node is ordered according to the sum of its current path cost from the start and a heuristic estimation of its path cost to the goal. The node with the minimum value is evaluated ﬁrst, since it is the most promising to belong to an optimal path from the start node to the goal node. When applied to path planning, the algorithm uses an optimistic heuristic to ensure that the shortest path is found. Usually, the heuristic function is also consistent to improve the search by ignoring those nodes already explored. However, some recent research (Zhang et al., 2009) points out that using inconsistent heuristics can improve the performance of A* and similar algorithms.
During the computation of the path, the A* generates a search tree which has no cycles. In a bounded world, the number of nodes is limited, which means the number of acyclic paths that can be generated is bounded. In the worst possible case, the A* has to explore all the possible acyclic paths to ﬁnd the solution, which means the algorithm will always ﬁnish. Therefore, the A* is complete.
The A* is written in pseudocode in Algorithm 1. The nodes of the algorithm are conﬁgurations of the robot q and processed according to their position in the OPEN priority queue. Each node in this queue is ordered according to the sum of its current path cost from the start, g(n), and a heuristic estimation of its path cost to the goal, h(n, ngoal). The node with the smallest sum is at the top of the priority queue. Assuming that the heuristic function is consistent, once a node is processed, it is added to the CLOSED set.
The algorithm receives as input the start conﬁguration qstart and the goal conﬁguration qgoal, which, inside the algorithm, are equivalent to start and goal nodes (nstart and ngoal) respectively. It starts by adding nstart into the OPEN queue. While node n with the minimum g(n) + h(n, ngoal) is different from the cost to reach the goal node g(ngoal), the algorithm pops n to the top of the queue and puts it in the CLOSED set. For all the nodes n reachable from n that are not in the CLOSED set, the algorithm checks whether they are in the OPEN queue or not. If not, n is added to the priority queue with a priority g(n ) plus the heuristic h(n , qgoal) (line 12). If it is, and the cost g(n) plus the cost of traversing from n to n , c(n, n ) is less than its current cost (line 13), g(n ) is set to this new lower value. This process is repeated until the ngoal is found or OPEN has no more nodes to be expanded.
Figure 2 depicts an example of an A* execution in a grid cell environment using A4 connectivity and Manhattan distance as a heuristic estimator. The neighbor cells are explored clockwise starting with the upper neighbor. Black cells represent obstacles and cannot be traversed. The numbers on each cell represent their priority value in the OPEN queue, which is the sum of the

2.2 graph-based search path planning 13

Algorithm 1 The A* algorithm

A∗(qstart, qgoal)

1: nstart ← qstart; ngoal ← qgoal 2: g(nstart) ← 0; g(ngoal) ← ∞

3: OPEN ← ∅; CLOSED ← ∅

4: OPEN.push(qstart)

5: while minn∈OPEN(g(n) + h(n, ngoal)) = g(ngoal)) do 6: n ← OPEN.top()

7: OPEN.pop()

8: CLOSED ← CLOSED ∪ n

9: for all n ∈ Succ(n)\n ∈/ CLOSED do

10:

if n ∈/ OPEN then

11:

g(n ) ← g(n) + c(n, n )

12:

OPEN.push(n ) with g(n ) + h(n , ngoal)

13:

else if g(n ) > g(n) + c(n, n ) then

14:

g(n ) ← g(n) + c(n, n )

15:

end if

16: end for

17: end while

18: if minn∈OPEN(g(n) + h(n, ngoal)) = g(ngoal)) then

19: publish solution

20: end if

cost to reach the cell from the start node and its heuristic value toward the goal. Black dots represent nodes already considered. Those nodes with priority values that do not have a dot depicted are stored in the OPEN queue. Figures 2.a,b,c depict different moments during the execution. Figure 2.d shows the ﬁnal path obtained with backtracking from the goal to the start.
2.2.3 Replanning Algorithms
In real world applications, robots do not have complete knowledge of the environment and usually carry onboard sensors that provide updated information while navigating. Therefore, the graph that models the environment may change as new information arrives, which can make a computed solution suboptimal or unreachable.
In order to avoid recomputing the solution from scratch, the D* (Stentz, 1995) and D* Lite (Koening and Lickhachev, 2002) algorithms extend the A* by taking into account the changes in the environment in order to update the computed solution. In robot path planning, these algorithms are used in grids to compute discrete paths which are unnatural and constrain the robot’s movement. (Ferguson and Stentz, 2005) propose the Field D* algorithm to generate a smooth solution which not only uses the center of the cells for generating the paths, but the edges as well. The E* algorithm, developed by (Philippsen and Siegwart, 2005), computes continuous cost paths by using a Fast Marching (FM) method (Sethian, 1996), which generates a set of continuous propagation curves from the start that are traversed by a gradient descent method. (Dolgov et al., 2010) propose the Hybrid-state A* to perform path

14 state of the art

ab c de f

ab c de f

0+8 1+7
0 qstart

0+8 1+7
0 qstart

1 1+7

1 1+7 2+6

8+4

2+6

7+3 8+2

2

2

3+5 4+4 5+3 6+2

3

3

qgoal

qgoal

OPEN = {b0, a1}

OPEN = {e2, d1}

a b
0+8 1+7
0 qstart
1 1+7 2+6

a)
c de f
8+4 9+3 10+2

a b
0+8 1+7
0
qstart
1 1+7 2+6

b)
c de f
8+4 9+3 10+2

2+6
2

7+3 8+2 9+1

2+6
2

7+3 8+2 9+1

3+5 4+4 5+3 6+2
3
OPEN = {d1, e1, f 1} c)

10+0 qgoal

3+5
3

4+4 5+3 6+2 OPEN = {d1, e1, f 1}

d)

10+0 qgoal

Figure 2: A* execution example. a), b) and c) depict the environment exploration at three different moments. d) Shows the shortest path computed with backtracking from the goal once it has been found.

2.3 probabilistic sample-based path planning 15

a) A*

b) Field-D

c) Hybrid-A*

Figure 3: Graphical comparison of graph-based search algorithms. A* (A8 connectivity) only assumes the cost of the centre of the discrete cells. Field-D associates costs with cell corners and allows linear paths between cells. Hybrid-A* associates a continuous state with each cell. Image extracted from (Dolgov et al., 2010).

planning for autonomous vehicles in unknown semi-structured environments represented by grid cells. Essentially, it is an extension of the A*, similar to the Field D*, that expands every state with several continuous steering actions computed by a kinematic model. Although its global optimality is not ensured, the algorithm generates continuous paths that can be achieved by the vehicles. Figure 3 depicts a graphical comparison of the solutions obtained with the A*, Field D* and Hybrid A* algorithms.
2.3 probabilistic sample-based path planning
Probabilistic sampling-based path planners include multiple-query and singlequery methods. Both strategies generate samples of the free space which connect the start to the goal by means of a graph or a tree data structure. Every sample is a node that represents a conﬁguration of the robot. These nodes are connected with edges which represent free paths through which the robot can navigate.
Probabilistic RoadMap (PRM) methods (Kavraki et al., 1996; Svestka and Overmars, 1998) were originally presented as multiple-query planners: the goal was to create a roadmap that captures the connectivity of the free space and then answer multiple user-deﬁned queries very quickly. Although the connectivity of the free space is usually performed before any path planning query, both phases can be done at the same time.
On the other hand, single-query path planners attempt to solve a query as fast as possible and do not focus on the exploration of the entire free space. The Expansive-Space Tree (EST) (Hsu, 2000; Hsu et al., 2002) and the Rapidlyexploring Random Tree (RRT) (LaValle, 2006) build a tree rooted at qstart that grows towards qgoal. The EST generates new samples in the free space around a conﬁguration selected in a low density sampled area, whereas the RRT attempts to expand the sampling into the regions of the free space away from the tree. In both algorithms, the growing of the tree is highly dependant

16 state of the art
on the sampling method. For geometric problems, it is possible to bias the conﬁguration sampling by using a bi-directional strategy, which is maintaining two trees, rooted at qstart and qgoal respectively, and making them grow toward each other until they are merged into a single one. Another singlequery path planner is the Single-query Bi-directional Lazy collision-checking (SBL) (Sanchez and Latombe, 2002), a bi-directional EST that improves the performance of the original bi-directional EST by using a lazy evaluation in the node connection strategy which performs the collision checking between nodes only when it is absolutely necessary.
2.3.1 The Rapidly-exploring Random Tree Approach
The RRT (LaValle, 2006) has become the most popular single-query planner. It has been shown to be effective for solving path planning tasks in many kinds of problems (Kim and Ostrowski, 2003; Alcázar et al., 2011), even with a lot of DoFs (Kuffner and LaValle, 2000; Yang and Sacks, 2006). Algorithm 2 shows the pseudocode of the RRT. It begins with the initial robot conﬁguration qstart as the root node and incrementally grows a tree T until the goal conﬁguration qgoal is reached. To grow the tree, ﬁrst a target conﬁguration qrand is randomly selected from the C-space using the function RandomConfiguration. Then, a NearestNeighbor (line 2) function selects the node qnearest in the tree closest to qrand. Finally, a new node qnew is created by growing the tree some distance from qnearest towards qrand. If extending the tree towards qrand requires growing through an obstacle, no extension occurs. This process is repeated until the tree grows to within some distT hreshold from the goal (line 7). Figure 4 depicts this process and Figure 5.a depicts an RRT in a simple scenario. A property that follows from this method of construction is that the tree growth is strongly biased towards unexplored areas of the C-space. Consequently, exploration occurs very quickly.
Algorithm 2 Rapidly-exploring Random Tree Extend(T , qgoal) 1: qrand ← RandomConfiguration() 2: qnearest ← NearestNeighbor(T , qrand) 3: qnew ← ComputeQNew(qnearest, qrand) 4: T .Add(qnew) 5: return qnew
RRT(qstart, qgoal) 5: qnew ← qstart 6: T .Add(qnew) 7: while Distance(qnew, qgoal) > distT hreshold do 8: qnew ← Extend(T , qgoal) 9: end while
Although RRTs offer very good performance, it is a common practice to use a biased sampling towards the goal which makes a certain percentage of random samples coincident with the goal, making the tree expand in that direction

2.3 probabilistic sample-based path planning 17
qrand

qstart

qnew qnearest

Figure 4: The RRT uses the qstart as the root node of a tree until the goal conﬁguration qgoal is reached. At each step, a conﬁguration qrand is selected using a random sampling distribution. Then, the nearest node in the tree to qrand is labeled as qnearest. Finally, a new node qnew is added to the tree at a certain distance from qnearest towards qrand.

(Frazzoli et al., 2000; Hsu et al., 2003; Kuwata et al., 2008) (see Figure 5.b). (Branicky et al., 2001; Lacevic and Rocco, 2010; Thomas and Iser, 2010) improve the original RRT by using a quasi-random sampling distribution such as a Halton sequence or a Hammersley sequence since they offer lower discrepancy1 than random distributions, which means that the samples perform a coverage of the space more uniformly.
There are other strategies to improve RRTs. For instance, (Kuwata et al., 2008; Borrajo and Veloso, 2012) incorporate a heuristic estimator in the building tree process in order to obtain better solutions at the expense of reducing the performance. As stated before, it is possible to use a bi-directional strategy (Kuffner and LaValle, 2000) which generates two trees, one from the start and other from the goal. Both explore the respective space around them and advance towards each other by using a simple greedy heuristic. The path is found when both trees are merged after a collision between them is detected. (Ferguson et al., 2006) present a replanning algorithm for repairing RRTs when changes are made on the C-space. In such a situation, those parts of the search tree that become invalid are pruned and the remaining tree is then grown to the goal conﬁguration again.
Sampling-based path planners are probabilistically complete (LaValle, 2001), because the probability of ﬁnding a solution increases as more samples are used. However, in practical situations, these methods may not ﬁnd a solution in a ﬁnite time. A narrow passage is a typical problem where sampling-based path planners can get stuck. In this situation, a common practice is to ﬁx the number of times the tree can be expanded. If then no solution has been found, it is assumed the goal is not reachable.
Although many authors incorporate kinematic and dynamic constraints in the C-space (Kuwata et al., 2008; Shkolnik et al., 2009) to generate feasible paths and trajectories for real robots, sampling-based path planners do not compute optimal solutions. Thus, a common practice is to post-process the path in order to improve the solution (Kuffner and LaValle, 2000; Thomas
1 Discrepancy: A measure of how uniformly points are distributed over the space.

18 state of the art
q
start

qstart

qgoal

qgoal

a) RRT

b) Goal-biased RRT

Figure 5: Example of an RRT execution in a simple environment: a) Exploration tree with no biased sampling; b) Exploration tree making 5% of the samples coincident with the goal.

qgoal
qstart
Figure 6: Improving a sampled-based path with the greedy approach.
and Iser, 2010). For instance, a greedy approach starts by trying to connect qstart directly with qgoal. If this step fails, it starts from the conﬁguration after qstart and tries again. This process is repeated until a conﬁguration q can be connected to qgoal. Next, the target is set to q and the process begins again. Figure 6 illustrates this process, which can also be applied backwards. Notice that using postprocessing steps to improve the path can impose a signiﬁcant overhead on the absolute computation time of the path.
2.4 bug-based path planning
Bug-based algorithms were one of the ﬁrst planners developed. Although they are reactive algorithms designed for online robot navigation that can be applied to robots with low computational capabilities, it is possible to use

2.4 bug-based path planning 19

ql1

qh2

O2

O1

qgoal ql2

qh1 qstart Figure 7: An example of the execution of the Bug1 algorithm in a simple scenario.

them to perform deliberative path planning on a C-space, which is the main goal of this dissertation.
Bug-based path planners assume the robot is a point with a contact sensor or a zero-range sensor to detect obstacles. Essentially, the Bug-like algorithms are compounded of two different behaviors: go straight and follow the obstacle boundary. Bug1 and Bug2 (Lumelsky and Stepanov, 1987) are two well known path planners that have been used in many applications (Chien and Xue, 1992; Sarid et al., 2007; Mastrogiovanni et al., 2009; Zhu et al., 2010). These path planning algorithms try to go from the start conﬁguration qstart to the goal conﬁguration qgoal in a straight line until they ﬁnd an obstacle. In such case, they surround the boundary of the obstacle until a condition is satisﬁed.
The Bug1 represents the most basic idea when looking for the goal while surrounding obstacles. The algorithm tries to follow an imaginary line, called the m-line, which connects the qstart with the qgoal until an obstacle is found. The contact point with the obstacle is marked as a hit point qh. Then, the robot completely surrounds the obstacle reaching the qh again, which allows the computation of the leave point ql. That is the closest point of the obstacle’s boundary coinciding with the new m-line which goes from ql to qgoal and does not intersect with the surrounded obstacle. Next, the robot has to reach the leave point in order to leave the obstacle. This procedure is repeated until qgoal is reached. Figure 7 depicts an example of the generated path in a simple scenario.
In a worst case scenario, the robot has to navigate half of the perimeter of the current ith obstacle pi. Assuming this situation can arise for all the n obstacles of the environment encountered, the upper bound of a Bug1 is deﬁned as

UBBug1

n
dist(qstart, qgoal) + 1.5 pi
i=1

(2.1)

where dist(qstart, qgoal) is de distance between the qstart and qgoal. The Bug2 algorithm tries to improve the Bug1 by ﬁxing the m-line from qstart to qgoal at the beginning. The robot starts by following the m-line until the ﬁrst hit point qh1 is reached. Then, the boundary following behavior surrounds the obstacle until it reaches a point in the m-line which is closer

20 state of the art

qgoal ql2

O2

O1

ql1

qh2

qh1 qstart Figure 8: Example of execution of Bug2 algorithm in a simple scenario.

q q start

h1

ql1 qh2

q q l2

goal

O1
Figure 9: Bug2 path in a scenario with a complex obstacle.
to the goal than the previous hit point, thus becoming the ﬁrst leave point ql1. The same process is repeated until qgoal is found. Figure 8 depicts a path generated by the Bug2 algorithm. Note that the direction to circumnavigate the obstacles can be ﬁxed at the beginning of the execution or chosen randomly.
Although the Bug2 algorithm is designed to avoid the complete circumnavigation of the obstacle, depending on the obstacle’s shape, this is not always the case. Figure 9 shows the path generated by the Bug2 algorithm in a scenario with a complex obstacle. The Bug2 m-line intersects with O1 obstacle several times. Assuming that the circumnavigation direction does not change for the whole obstacle, the algorithm generates a longer solution than the one computed with the Bug1.
Formally, the ith obstacle is intersected by the m-line ni times, which means there are ni leave points. However, half of these points are not valid since they lie on the side of the obstacle that moving towards the goal would generate a collision. As reported in (Choset et al., 2005), in the worst case, the robot

2.4 bug-based path planning 21

c

c1 8

O 1

O 3

c 2

x

c

3

c

7

c

4

cc

6

5

O 2

Figure 10: Interval of continuities found by the range sensor at a ﬁxed position.

would traverse nearly the entire perimeter of the obstacle for each leave point. Therefore, the upper bound of the algorithm is

UBBug2

n
dist(qstart, qgoal) + 0.5 nipi
i=1

(2.2)

In order to improve the Bug2 algorithm, (Kamon et al., 1998) developed the Tangent Bug. This algorithm supposes the robot has a ﬁnite range sensor used to detect the obstacles in the workspace. It is assumed that the sensor is able to detect the continuous boundary of the obstacles within its range, which are called intervals of continuity. As depicted in Figure 10, every time that a discontinuity appears in the boundaries gathered by the sensor, an endpoint ci tangent to the obstacle arises.
Figure 11 depicts an execution of the Tangent Bug. Like the other Bug algorithms, the robot initially goes in a straight line towards the goal until hit point qh1, where it senses the ﬁrst obstacle O1 in the goal direction. At that point, an interval of continuity limited by two endpoints C = {c1, c2} is created. Notice that the interval of continuity intersects with the segment between the robot and the goal. Then the robot moves to the right since c2 minimizes a heuristic distance such as dist(x, ci) + dist(ci, qgoal), where x represents the robot’s position. At ql1 the updated interval of continuity C = {c1 , c2 } no longer intersects with the line from the robot to the goal, therefore, the robot moves towards the goal following a straight line. At qh2 obstacle O2 is detected and the robot moves to the left since the heuristics decreases until qm2, where point m2 that minimizes the heuristic distance is located. At this point, the algorithm follows the boundary of the obstacle until its next leave point ql2, which is set when the distance from c3 to qgoal is smaller than

22 state of the art

ql2
c c 4'' 3''

qstart

c1 c2
qh1

O1
c2' c1'
ql1

c3'

O2

qm2

m2
c4'

c3

qh2 c4

Figure 11: A Tangent Bug algorithm execution.
ql1

qgoal

qgoal
O1 qh1

qgoal
O1 q q h1
l1

qstart a) Bug1 algorithm execution

qstart b) Bug2 algorithm execution

Figure 12: Completeness of Bug1 and Bug2 algorithms.

the distance between m2 and qgoal. Finally, the robot moves straight towards qgoal.
Bug algorithms are complete regardless of the strategy followed because they ﬁnd a path from the start to the goal when there is a solution, and report when there is not. For instance, Bug1 reports that there is no solution after the robot reaches the leave point and intersects with an obstacle when trying to navigate towards the goal (Figure 12.a). On the other hand, Bug2 reports that there is no solution when it circumnavigates the entire obstacle, which means that a leave point has not been found (Figure 12.b). The Tangent Bug also navigates through the whole obstacle perimeter before reporting there is no solution.
There are many recent Bug algorithms that try to improve the performance or the quality of the solution or both (Ng and Braunl, 2007). For instance, (Lumelsky and Skewis, 1990) propose an improvement of the Bug2 incorporating range sensor information. The algorithm, called VisBug, enhances the

2.5 anytime path planning 23
condition that the robot uses to stop surrounding an obstacle and resumes the movement to the goal, which results in short cuts in the path. A similar idea is used with the DistBug (Kamon and Rivlin, 1997), which proposes another alteration in the leaving condition that allows the robot to abandon obstacle boundaries as soon as global convergence is guaranteed. The K-Bug (Langer et al., 2007) changes the paradigm of contouring all the obstacles towards the goal to the idea of contouring only the essential ones to reach the destiny point. (Antich and Ortiz, 2009) propose the Bug2+, an improved version of the Bug2 algorithm, which only takes into account the valid leave points when the m-line intersects a number of times with the same obstacle. However, to the best of the author’s knowledge, none of the Bug-based algorithms are optimal since following the boundary of the obstacles encountered does not generate the shortest path to the goal.
2.5 anytime path planning
In real world applications, robots have to perform path planning in a limited amount of time with the computers they carry onboard. Algorithms that look for the optimal solution are not usually feasible due to their computation time. Instead, the path planner has to ﬁnd the best solution within a limited time. Therefore, anytime path planners (Ferguson et al., 2005; Likhachev et al., 2008) are the most suitable as they ﬁnd a ﬁrst solution, possibly highly suboptimal, very quickly and then reﬁne it until time runs out.
Most of the anytime path planning literature is about deterministic approaches. They all share the strategy of using a multiplication factor to inﬂate the heuristics (Likhachev et al., 2004), which is usually referred to as weighted heuristic search. As a result, the nodes of the C-space to be explored ﬁrst are those which are closer to the goal (Ferguson and Stentz, 2007), generating solutions very quickly at expense of their quality. On the other hand, there are also some probabilistic anytime proposals, the vast majority of them based on RRTs (Ferguson and Stentz, 2006). These algorithms generate an initial RRT solution and, within the time allotted, a new RRT that improves the previous one is computed. Essentially, this new solution is generated by an enhanced sampling strategy and using a heuristics that only lets the tree expand into those areas of the C-space that would possibly improve the solution. Further details on deterministic and probabilistic anytime approaches are given in the next sections.
Although it is not common, there is also an anytime approach inspired by bug algorithms (Antich et al., 2009). This algorithm assumes that the scenario is known. Every time the path that follows the m-line hits an obstacle, an improved version of the Bug2 computes left and right boundaries of the obstacle until the m-line is reached again. Each hit point of the path with the obstacles is stored in the nodes of a binary search tree which is explored using the A* algorithm with an inﬂated heuristic to speed up the path search. Once computed, the path is post processed in order to obtain the optimal solution while maintaining the manner in which the path avoids the obstacles.

24 state of the art
2.5.1 The Deterministic Anytime Approach
As stated before, most of the deterministic anytime path planning algorithms use a weighted heuristic search to speed up the path search (Ferguson and Stentz, 2007). The weight value ( 1) is a multiplication factor used to control the cost of the generated solution. Some algorithms compute different solutions using the same (Hansen et al., 1997; Zhou and Hansen, 2002; Hansen and Zhou, 2007). Other approaches use a decrement factor in order to decrease the value at each iteration until = 1, if the time does not expire before (Likhachev et al., 2005). For instance, the Anytime Repairing A* (ARA*) proposed by (Likhachev et al., 2004) is a reference within the class of deterministic/heuristic based anytime path planners. It inﬂates the heuristic function using the value to guide the search towards those states closer to the solution whose ﬁnal cost is ensured not to be more than times the cost of the optimal path (Pearl, 1984).
Algorithm 3 shows a simpliﬁed version of the ARA*. This algorithm starts by doing an A* search (line 24) with an inﬂation factor expanding each node just once. As in the A*, the nodes in OPEN are processed according to their priority, which in this case is the sum of its cost g(n) and its inﬂated heuristic value
· h(n, ngoal). CLOSED contains the nodes already expanded in the current search. Once expanded, if a node becomes inconsistent during the search (g(n) = minn ∈Pred(n)(g(n ) + c(n , n))) due to a cost change associated with a neighboring node, it is inserted into the INCONS list (line 14), which contains all inconsistent nodes already expanded. When the current path search is ﬁnished, the nodes in the INCONS list are moved into the OPEN queue with the priorities updated according to the new inﬂation factor (lines 28– 29) which is going to be used in the next search.
Figure 13 shows three consecutive iterations of an ARA* execution in a simple grid scenario. In this example, an A8 connectivity grid is used with black cells representing obstacles. The cost of moving from one cell to its neighbor is one. The heuristic is the largest of the x and y distances from the cell to the goal. Expanded cells are shown in grey and those which are inconsistent at the end of each iteration are shown with an asterisk. The initial solution is computed with an inﬂation factor of 2.5 expanding 13 cells. The next iteration computes the solution using = 1.5 and requires only one cell to be expand. Finally, the third iteration generates the path using = 1.5 which computes the optimal solution by expanding 9 cells. The total number of cells expanded in this example are 22.
Although at each iteration the solution is intended to be improved by decreasing , the generation of a new/better path is not ensured (the same path as in the previous iteration of the algorithm can be obtained), which means a waste of computation time in a critical context where the time to perform the path planning is very limited. The algorithm also proposes the reutilization of the inconsistent states between iterations, updating only the heuristic values of these states with the new inﬂation factor, which can only be used if the current path search passes through the previously visited states.

2.5 anytime path planning 25

Algorithm 3 The Anytime Repairing A* Key(n) 1: return g(n) + · h(n, ngoal)

ImprovePath()

2: while minn∈OPEN(Key(n)) < Key(ngoal) do

3: n ← OPEN.top(); OPEN.pop()

4: CLOSED ← CLOSED ∪ n

5: for all n ∈ Succ(n) do

6:

if n was not visited then

7:

g(n ) ← ∞

8:

end if

9:

if g(n ) > g(n) + c(n, n ) then

10:

g(n ) ← g(n) + c(n, n )

11:

if n ∈ CLOSED then

12:

OPEN.push(n ) with Key(n )

13:

else

14:

INCOS ← INCONS ∪ n

15:

end if

16:

end if

17: end for

18: end while

ARA∗(qstart, qgoal)

19: OPEN ← ∅; CLOSED ← ∅; INCONS ← ∅

20: nstart ← qstart; ngoal ← qgoal 21: g(nstart) ← 0; g(ngoal) ← ∞ 22: OPEN.push(nstart)

23: repeat

24: ImprovePath()

25: publish solution

26: decrease

27: if > 1 then

28:

OPEN ← INCONS; INCONS ← ∅

29:

∀n ∈ OPEN update priorities with Key(n)

30:

CLOSED ← ∅

31: end if

32: until > 1

s **
* *

s
* *
*
g

* *

s
* *
g

* **
g

a) = 2.5

b) = 1.5

c) = 1

Figure 13: An ARA* search. Images extracted from (Likhachev et al., 2004)

26 state of the art
Otherwise, no reutilization can be done, which means that in some scenarios the total number of states explored during the execution can be larger than using the standard A*. Generally, and the decrement factor values are critical depending on the complexity of the scenario. However, authors do not provide a general rule to set them, hence the setting of these parameters strongly depends on the expertise of the user.
There are anytime approaches that instead of increasing the weight of the heuristics, select a number of the most promising nodes during the search for further expansion while the remaining nodes are pruned (Zhou and Hansen, 2005; Furcy, 2006; Aine et al., 2007). Other algorithms, such as Anytime Dynamic A* (AD*) (Likhachev et al., 2005) combine anytime performance with replanning capabilities.
2.5.2 The Probabilistic Anytime Approach
There are some probabilistic anytime path planners. For instance, (Belghith et al., 2006) is based on the PRM approach. This algorithm applies the AD* to the PRMs generated with an improved sample strategy. However, most of these approaches are based on RRTs since they offer very good performance. The Anytime-RRT (ARRT) developed by (Ferguson and Stentz, 2006) is a wellknown anytime sampling-based planner that works by generating a series of RRTs where each new tree reuses the cost information from the previous tree to control its growth and thus improve the quality of the resultant path. Unlike the ARA*, the ARRT scarcely reutilizes data between iterations at all because each new tree is almost built from scratch.
Algorithm 4 shows a simpliﬁed version of the ARRT. Essentially, the algorithm computes a set of solutions based on RRTs while the time does not expire. Like the RRT, each solution is obtained by expanding a tree T (with the function ExpandRRT ) until the tree grows to within some distT hreshold. At each iteration, the cost of the tree is ensured to be less than or equal to (1 − f) times the previous cost of the tree, where f ∈ [0..1) is a ﬁxed improvement factor (line 27),
The extension of the tree starts with function ComputeQRand which generates a sample qrand. This function improves the sampling process by introducing a bias towards the goal (line 1) and constraining it into those areas of the C-space where the heuristics from qstart to qgoal through qrand are lower than an upper bound (line 6). Then, the kNearestNeigbor function computes the k nearest nodes in tree T to the sample qrand and sorts them according to their cost in order to obtain the cheaper solutions (Urmson and Simmons, 2003). Next, the ﬁrst qnear node from Qnear is selected to compute a set of extensions (line 11). The one with the lowest cost is chosen as the qnew. If the cost of the tree from qstart to qnew through the selected qnear (line 13) is lower than the upper bound (line 14), the extension of the tree is performed and the function returns. Otherwise, the process is repeated for the next qnear. Figure 14 depicts a simple example of an execution.

2.5 anytime path planning 27

Algorithm 4 The Anytime RRT
ComputeQRand(qgoal)
1: if RandomReal([0.0, 1.0]) < probT hreshold then 2: return qgoal 3: end if 4: repeat 5: qrand ← RandomConfiguration() 6: until h(qstart, qnew) + h(qnew, qgoal) T .cs 7: return qrand

ExtendRRT(T , qgoal)

8: qrand ← ComputeQRand() 9: Qnear ← kNearestNeighbor(T , qrand, k) 10: for all qnear ∈ Qnear do

11: Qext ← GenerateExtension(qnear, qrand) 12: qnew ← argminq∈Qext c(qnear, q) 13: T .cnew ← c(qstart, qnear) + c(qnear, qnew)

14: if T .cnew + h(qnew, qgoal) < T .cs then

15:

T .add(qnew)

16:

return {qnew, T .cnew}

17: end if

18: end for

ARRT(qstart, qgoal)

19: while there is time do

20: T ← ∅; T .cnew ← ∞ 21: qnew ← qstart 22: T .Add(qnew)

23: while Distance(qnew, qgoal) > distT hreshold do

24:

{qnew, T .cnew} ← ExtendRRT (T , qgoal)

25: end while

26: publish solution

27: T .cs ← (1 − f) · T .cnew 28: end while

g

g

g

s
a) Initial RRT solution

s
b) k-iteration

Figure 14: An ARRT example.

s
c) Final solution

28 state of the art
The Anytime Dynamic RRT (ADRRT) (Ferguson and Stentz, 2007) improves the ARRT by adding repairing capabilities. This algorithm generates a solution that is continually improved while the time does not expire, as ARRT does, and, at the same time, repairs the solution when changes that invalidate it are detected in the C-space. Some other proposals, like (Abbasi-Yadkori et al., 2010; Karaman et al., 2011), improve the ARRT with RRT-based algorithms that apart from generating initial solutions very quickly and improving them continuously while there is time, they also compute ﬁnal solutions close to the optimal.
2.6 topological path planning
Topological approaches are another way to tackle the path planning problem. This kind of solution works with an abstraction of the C-space, a topologicalbased map usually represented by a graph. These graphs represent the structure of the free space in the C-space in terms of the basic topological notions of connectivity and adjacency (Fabrizi and Safﬁotti, 2000), which represents the environment with a reduced number of potential states (Dudek et al., 1991).
Topological-based maps are quite robust with respect to sensor noise and small environmental changes. Moreover, graph representation yields the possibility of exploring them with graph-search algorithms. Visibility maps (Latombe, 1991) is a well-known topological-based technique widely used in robotics. The simplest visibility map, called visibility graph, consists of a set of nodes in the free C-space that are within the line of sight of at least one node of the visibility graph. Although it has been generalized to be used with curved obstacles (Liu and Arimoto, 1992), the original version was intended to work in polygonal C-spaces, where each edge of the obstacles is a node in the graph. Assuming that the start and goal conﬁgurations are also nodes in the graph, the visibility graph is built by trying to connect each node with all the other nodes with a straight line. The connection is performed only when the line does not intersect with an obstacle. Once the graph is generated, it is traversed with a graph-based search algorithm to compute the shortest path according to the graph (Hans and Rohnert, 1986). Figure 15.a depicts an example.
In order to improve the search in the shortest-path problem, it is a common practice to work with a reduced visibility graph which performs the connection between two nodes only when the line that connects them is tangent to the two obstacles they belong to (see Figure 15.b).
Using the Voronoi diagram to perform topological path planning is another technique widely extended (Takahashi and Schilling, 1989; Acar et al., 2006). Essentially, the Voronoi diagram is deﬁned for a set of points called sites (Aurenhammer, 1991). Then, the Voronoi diagram is a set of points equidistant to the two closest sites at the same time. Figure 16 depicts an example of a Voronoi diagram for a low number of sites. When applied to path planning, the sites are the centre of the obstacles to be avoided and the edges of the diagram deﬁne the possible channels that maximize the distance to the obstacles. When

2.7 homotopy classes 29

qstart

qstart

qgoal

qgoal

a) Visibility grah

b) Reduced visibility graph

Figure 15: Example of computing the shortest path using a visibility graph.

applied to motion planning, it is a common practice to use the Generalized Voronoi Diagram (GVD) since it assumes than obstacles are more complex than single points, allowing the computation of a diagram which is closer to reality (Bhattacharya and Gavrilova, 2007). Nevertheless, both options allow the computation of safe paths according to the distance to obstacles.
Another way to perform path planning with topological information is by means of homotopy classes, which are detailed in the following section.
2.7 homotopy classes
Homotopy is a topological concept related with path deformation with respect to a set of obstacles (Munkres, 1974; Seifert et al., 1980). A homotopy class is the set of all possible trajectories from a start to an end point that avoid obstacles in the same manner. Given two paths, they are said to be homotopic if one can be deformed into the other without encroaching any obstacle. Figure 17.a shows an example where p1 and p2 are homotopic and hence, belong to the same homotopy class. Figure 17.b depicts two paths that do not belong to the same homotopy class since they encroach on O1 when p1 is deformed to be coincident with p2.
Path homotopy is an equivalence relation, which means that it is possible to identify a homotopy class by giving a representative path, whatever the deﬁnition chosen to represent a path is. It is common practice to use the canonical representation to describe a homotopy class since it is the simplest representation of a class without changing its topology. Moreover, two paths belong the same homotopy class if they have the same canonical sequence (Cabello et al., 2002).
The homotopy concept has applications in many different areas such as VLSI routing (Leiserson and Maley, 1985; Gao et al., 1988; Yang, 1997) or image analysis (Kalitzin et al., 2001). In robotics, homotopy classes are intrinsically taken into account; for instance, into the map discovering problem with multiple vehicles (Williams et al., 2002), for surveillance purposes (Tang and Ozguner, 2005) or for locally optimal navigation in unknown scenarios (Tovar et al.,

30 state of the art

1

0.9

0.8
qgoal
0.7

0.6

0.5

0.4

0.3

0.2

0.1
qstart

0

0

0.2

0.4

0.6

0.8

1

Figure 16: Computing the shortest path using a Voronoi diagram in a scenario with 12 sites.

g

g

O2

p1

p2

O2

p1

p2

O1

O1

s

s

a) p1 and p2 are homotopic b) p1 and p2 are not homotopic

Figure 17: Example of homotopic paths.

2.7 homotopy classes 31
2007). Focusing on path planning, (Antich et al., 2009) use homotopy classes to classify all the different paths that can be generated for a scenario to ensure that their topology is not affected after an optimization process. Along the same line, (Laumond et al., 1994) use homotopy classes to maintain the topology when optimizing trajectories for a non-holonomic mobile robot. (Asama et al., 1991; Bourgault et al., 2002) address the motion planning for multiple vehicles keeping communication between them, which means that the vehicles are constrained to certain homotopy classes. (Fenwick and Estivill-Castro, 2005) compute the optimal paths in the mutually visible path problem assuming that agents are represented by points which move and pause along the paths to achieve the goal.
In this dissertation the application of homotopy classes from the path planning point of view is studied, since they provide topological information about how paths are generated with respect to a set of obstacles. The following sections present an overview of the most relevant contributions related with homotopy classes that can be applied to path planning. The aim of this overview is not to be an exhaustive enumeration of all the publications, but a description detailed enough to provide an insight into understanding the proposals which have been grouped according to the problem they try to solve.
2.7.1 The Shortest Homotopic Path Problem
This section describes proposals that address the computation of the shortest path when the homotopy is already speciﬁed, usually with an input path or with a constrained area through which the path has to go. This is a computational geometry problem that has direct application to VLSI, network routing, gaming or path optimization.
2.7.1.1 Triangulated environments
(Chazelle, 1982) proposed the funnel algorithm to compute the shortest path within a simple polygon called channel. A channel is assumed to be triangulated and hence the shortest path has to cross all the interior edges of the polygon. Notice that the start and goal points belong to the set of vertices of the channel. Although it was not explicitly designed to be used with homotopy classes, the funnel algorithm intrinsically constrains the path to a speciﬁc homotopy class described by the channel. Figure 18.a depicts a polygon with the interior edges to be traversed by the shortest path. The algorithm considers a path as the sequence of line segments that belong to the shortest path known within the channel at some point of the execution of the algorithm. There is a structure called funnel, which consists of two series of segments that represent the area where all shortest paths can be found. The two line series of the funnel are connected by a point called apex.
The algorithm starts by placing the initial apex at the start point. The funnel is constructed as the segments connect the start point with the ﬁrst interior edge. At each step, the algorithm checks whether the vertices of the new interior edge are inside the funnel or not. If they are, the funnel is updated

32 state of the art

apex

funnel

apex

funnel

path

path

g

g

s

s

a) Narrowing the funnel

b) Cannot update funnel

apex path s

funnel

path g
s

funnel apex
g

c) New apex required

d) New apex added

Figure 18: Different moments during the computation of the shortest path using the funnel algorithm. The dashed blue lines represent the interior edges of the channel.

and narrowed (see Figure 18.a). There are two situations that do no allow the funnel to narrow. The ﬁrst is when the vertex of the next interior edge is outside the current funnel (Figure 18.b). The second is when adding the vertex of the new interior edge makes the current line segments of the funnel go over to its opposite line segments. In such case a new apex is set to the vertex that belongs to the opposite line segments that avoids such a situation (see Figure 18.c and Figure 18.d). The segment line between the current apex and the old apex is ensured to belong to the shortest path, and hence, is added to the path. This procedure is repeated until the channel has been completely explored.
Following the same line, (Hershberger and Snoeyink, 1991) compute the shortest path while keeping the homotopy of an input path in a simple polygonal environment. This method can be applied to more complex paths such as closed curves and does not require a channel to constrain the search. Essentially, it triangulates the environment and splits it into simpliﬁed subpolygons. Each one of these subpolygons contains a part of the input path, which is then optimized with a funnel algorithm (Chazelle, 1982) before being compounded back to generate the global optimal path.
(Cheng et al., 2010) propose a method to compute an approximate shortest homotopic path in a polygonal triangulated environment, where each region has a speciﬁc weight. Obstacles are represented by simple polygons. The method is aimed at encoding the homotopy class of a given input path according to the crossed edges of a spanning tree of obstacles. The tree checks whether an edge is crossed to the left or right obtaining the ﬁrst representation

2.7 homotopy classes 33

e1

s

e2 e3

e4 e5 g

Figure 19: According to (Cheng et al., 2010), the input path (dashed line) is encoded

according to the edges traversed on the triangulated environment differen-

tiating whether an Then, it is possible

edge is crossed to the to obtain its canonical

lreefpt roersreingthatt:io← e−n1−e→← e−21← e−e→−22−e→−e→23−e→← e−34← e−e→−45−e→w4← e−h4i−e→c5h.

shortens the path (solid line). The next step would expand the triangulation

to improve the path while keeping the canonical sequence of the homotopy

class.

of the path, which is then improved until its canonical representation (see Figure 19). A graph that expands the triangulations of the tree is computed to generate a shorter path without changing its homotopy.
2.7.1.2 Non-triangulated environments
(Efrat et al., 2002) propose an algorithm that efﬁciently computes the shortest homotopic path for a set of input paths. The algorithm considers the start and goal points of each path and the obstacles as terminal points. It begins by applying vertical shortcuts to reduce each input path to a sequence of essential x-monotone path sections. A vertical shortcut is a vertical line segment that joins a path p at two or more points with the property that the subpath of p which follows the segment is homotopic to the line segment. The algorithm applies the maximum number of vertical shortcuts ensuring that, at each step, the length of the subpath is not increased. The second step of the algorithm bundles the essential x-monotone paths obtained in the previous step according to their homotopy class and chooses a representative path. Notice that if the paths in each bundle are homotopic, they have the same shortest path. Two xmonotone paths are homotopic if they share the same start and goal points and there are no other terminals between them. For each bundle of x-monotonic paths, the shortest homotopic path is computed using an improved funnel

34 state of the art

p1

t1

t2

t3

p2

p1

t1

t2

t3

p2

t4

t4

s1

s2

a)

b)

µ1

t
1
µ3

t

t 3

2

µ4

t

σ1

t 2

1

t 3

σ2

t 4 µ2
c)

t 4 d)

Figure 20: Computing the shortest homotopic paths: a) Input paths p1 and p2 with their respective terminal points (t1 and t2 for p1, and t3 and t4 for p2). b) Minimum necessary shortcuts s1 and s2 to obtain x-monotone paths. c) Monotone pieces after applying shortcuts: p1 is divided into 3 monotone pieces: µ1 from t1 to t3, µ2 from t3 to t4, and µ3 from t4 to t2; p2 is represented by one monotone piece µ4. µ2 and µ4 belong to the same bundle since they are homotopic because they share terminal points and there are no more terminal points between them. d) Paths after computing the shortest path for each bundle: σ1 and σ2 are the shortest homotopic paths of p1 and p2 respectively. Figure extracted from (Efrat et al., 2002).

technique (Chazelle, 1982) that reuses the information gained when each path is computed. Finally, the paths are unbundled to recover ﬁnal paths. Figure 20 illustrates this process and Algorithm 5 summarizes the steps of the algorithm.
(Bespamyatnikh, 2003) uses a similar idea to Efrat et al. by ﬁrst turning the paths into a set of x-monotone subpaths. Then, the subpaths that belong to the same homotopy class are bundled. For each bundle, the shortest path is found with a technique that assumes that the path is bound into a simpliﬁed polygon, which allows the efﬁciency of the method to be improved. Bespamyatnikh also extends the Efrat et al. proposal by allowing paths that self-intersect to be used as an input .
In the same vein, (Grigoriev and Slissenko, 1998) propose a method to construct the shortest path for a given homotopy class that does not intersect in a scenario with semi-algebraic obstacles. For each obstacle in the scenario a representative point is selected. From this point a curve called a cut is launched

Algorithm 5 Efrat’s homotopic shortest path
1: Shortcut Paths 2: Bundle homotopically equivalent pieces 3: Compute the shortest path for each bundle 4: Recover ﬁnal paths

2.7 homotopy classes 35

and goes to inﬁnity. Then, assigning a letter to each cut and differentiating whether the cut is crossed clockwise or counterclockwise (e.g. α and α1 respectively), any path can be represented by a word generated with its consecutive intersections with the cuts. The computation of the shortest path for any path consists of reducing the number of cuts –and the word– until the canonical sequence is found.
Given a set of input paths and rectangular obstacles, (Speckmann and Verbeek, 2010) compute the non-crossing thick minimum-link rectilinear homotopic paths. This is a two step process. The ﬁrst consists of computing the shortest homotopic paths for the input paths using a modiﬁed version of the algorithm proposed by (Efrat et al., 2002). Then the paths are untangled according to the length of their shortest version while ensuring that the number of links is no more than doubled. Although this solution is strongly focused on VLSI routing, it is also interesting for path planning purposes since the thickness of the path is a constraint that can make the solution unfeasible and this algorithm is capable of detecting it, adapting the path, and, if it is not possible, reporting that there is no solution.
2.7.2 Homotopy Classes Generation Approaches
There are some approaches that do not require speciﬁng the homotopy of the path to compute. Usually, these are two step methods that ﬁrst generate the homotopy classes according to data structures that characterize the topology of the environment and then compute a path for each class.
For instance, (Jenkins, 1991) proposes a method to generate homotopy classes for any 2D workspace with obstacles. Assuming that any obstacle can be represented by a single point, the method ﬁrst constructs a reference frame which is a geometric structure compounded of a set of semi-ﬁnite rays that establish the topological relationships between the obstacles in the metric space. The reference frame allows the description of any path in the workspace as a topological sequence according to the semi-rays traversed. Then, a topological graph, whose construction is based on the reference frame, allows the systematic generation of homotopy classes using graph-search algorithms. Once generated, (Cuerington, 1991) proposes a method to compute the shortest path in the workspace for each homotopy class with circular obstacles. Essentially, the algorithm looks for the direct straight path in the workspace that follows the homotopy class. If it does not exist, it is computed by following the tangent lines of the corresponding obstacles that accomplish the input homotopy class. The lines can be connected with the boundary of the obstacles to obtain the homotopic shortest path. Figure 21 depicts a simple

36 state of the art
g β1
b1

g β2 β1

b2

b1

β2 b2

pc

α2

s

α1

pc

α2

s

α1

a) A path p in a reference frame

b) The shortest homotopic path of p

Figure 21: A (Jenkins, 1991) and (Cuerington, 1991) example: a) In the reference frame, the obstacles are represented as single points bk and a path p is described topologically according to the semi-rays traversed . b) The homotopic shortest path of p crosses the semi-rays of the reference frame in the same manner.

example of a homotopy class in the reference frame and its corresponding shortest path. Since the method proposed in this thesis is based on the Jenkins approach, more details are given in Chapter 3.
An example applied to robotics is proposed by (Milgram and Kaufman, 2000), who characterize topologically ﬁxed routes such as energized wires embedded in a factory ﬂoor that are traversed by automatically guided vehicles. The goal is to avoid collisions between the vehicles while maintaining the homotopy of their original paths.
(Schmitzberger et al., 2002) propose to perform motion planning on a PRM which takes into account topological constraints. The method assumes the coverage of the C-space by a set of visibility domains. A visibility domain is the ﬁeld of view of a point placed in the C-space. Figure 22.a depicts a scenario with tree points and the ﬁeld of view of x3. Then, a set of points that belong to at least two different visibility domains are added in order to generate a PRM that covers the full exploration of the C-space (see Figure 22.b). The added points may generate redundant loops that can be identiﬁed since the paths belong to the same homotopy class and therefore do not encroach on any obstacles. The ﬁnal step consists of removing those points that generate redundant loops. The ﬁnal result is a reduced PRM that allows the generation of trajectories which avoid obstacles in all possible manners (see Figure 22.c). However, the trajectories generated are far from optimal and postprocessing is required to achieve better results.
2.7.3 Constraining Path Search Topologically
This section groups a set of representative algorithms that starts by computing an initial path whose homotopy class is then obtained in order to prevent the algorithm from generating another path with the same topology. This

2.7 homotopy classes 37

x

y6

y2

1

x1

y6

y2

x1

x 2

x2

y4

y3

x2

y4

y3

y7

y7

y1

y1

x 3

y5

x3

y5

x3

a) Field of view of x3

b) Redundant PRM

c) PRM without redundant loops

Figure 22: Schmitzberger et al. places a minimum number of x points that cover the whole C-Space with their ﬁelds of view (a), and others support points y in order to build a redundant PRM (b), which is simpliﬁed in c). The ﬁnal PRM allows performing a suboptimal motion planning with any homotopy class. Images extracted from (Schmitzberger et al., 2002).

methodology achieves the generation of a path for different homotopy classes by blocking the ones previously explored.
(Fujita et al., 2003) propose a two step method to compute local minimum paths for homotopy classes that do not cross. Given a start and goal conﬁguration in a C-space represented as a graph, the ﬁrst step consists of computing, for each node, the shortest path between the start and the goal that passes through that node. This is done by running the Dijkstra’s algorithm from the start to all the nodes in the graph, and running it again from the goal to all the other nodes. The cost of both searches is added to create a cost map, which is used to obtain the shortest path that traverses every node in the graph. Hence, the number of computed paths is the same as the number of nodes in the graph. The second step consists of pruning the number of paths in order to obtain the shortest path for each homotopy class. The procedure explores all the nodes in the graph in increasing order according to their value in the cost map. For each node, the shortest path that passes through that node is generated, and the nodes of the corresponding path are labeled. When the shortest path for the next node according to the cost map is generated, two possible situations can arise: when all path nodes adjoin at least one labeled node, the path has the same topology as a path previously computed and is discarded; otherwise, when the path has a node that does not adjoin any labeled node from the previous paths, it belongs to a different homotopy class. The process is repeated for all the computed paths. (Shiller et al., 2004) improve the second step of this method by identifying the homotopy classes according to their canonical sequence as (Cabello et al., 2002) propose. Therefore, the shortest path for each node of the cost map does not have to be completely traversed to look for a node with no junction with previous paths. Only the computation of the canonical sequence of the path is required to check whether it has been already found.
(Banerjee and Chandrasekaran, 2006) propose to perform path planning for military applications. Essentially, it generates a Voronoi diagram assuming the enemy zones to be avoided are the sites in the diagram. Based on the Voronoi diagram, a graph that keeps the homotopy is then constructed. The

38 state of the art
Figure 23: The original graph G is expanded by the L-value to generate the GL graph. In the example, trajectories τ1 and τ2 are obtained from the start point in the complex domain zs with an L-value of 0+0i, to the goal zg which has an L-value Λ or Λ¯ depending on the state of GL. Image extracted from (Bhattacharya et al., 2010).
graph is traversed with graph-search algorithms based on the DFS which compute paths that have a direct equivalence to the Voronoi diagram. Notice that this method does not compute optimal paths since it focuses on avoiding undesirable zones.
(Bhattacharya et al., 2010) propose a method to perform path planning with homotopy class constraints using graph-search algorithms. The graph that represents the environment is expanded with Complex Analysis values to characterize homotopy classes while computing the path. Assuming that each obstacle is represented by a single point, Bhattacharya et al. deﬁne a function in the complex domain that allows the characterization of any node in the search space according to its relative position with respect to the obstacles. Since any trajectory is a sequence of nodes traversed in order, the line integration of the function generates a value that represents the trajectory according to its relative position between the obstacles. This value is called L-value and is used to identify the homotopy classes. Therefore, two trajectories that share the same start and end points with an equal L-value belong to the same homotopy class, whereas different L-values means that the two trajectories do not share the same homotopy class. In order to perform search-based path planning with homotopy class constrains, the search space is expanded with L-values while computing the path. Once the ﬁrst path is computed, its homotopy class is identiﬁed through the L-value. Then, to obtain the path for a different homotopy class, the previous L-value is used to constrain the search. Figure 23 depicts a simple example. However, it is difﬁcult to conﬁgure the path planner to follow a speciﬁc homotopy class without ﬁnding its path and hence, its L-value.

2.7 homotopy classes 39
2.7.4 Summary
Computing the shortest homotopic path for an input path/homotopy class is a problem that has been studied since the 80’s. Therefore, there is a large set of proposals that performs the computation efﬁciently for any possible path. However, when there is no input homotopy class or path, the problem becomes intractable for these solutions making it difﬁcult to apply them to robot path planning. On the other hand, some of these algorithms are suitable for the optimization process, when a path has been already generated by a path planner.
There is also a group of methods that compute the shortest path and then identify its homotopy class. This process can be done during the path search or once the whole path has been computed. Then, the topology of the path is encoded in order to restrict the next path search, which ensures that the new shortest path will have a different topology and hence, belong to another homotopy class. By repeating this process, it is possible to obtain the k-shortest paths of k-homotopy classes. These methods have the clear advantage of starting with the computation of the global shortest path. However, if we are interested in the solution of the k path, computing all the previous paths is required.
On the other hand, there is a minor group of methods that ﬁrst compute the homotopy classes and then search for a path that follows them. In order to generate the homotopy classes, a data structure able to codify the topology of the environment as a graph is required. Then, the homotopy classes can be systematically generated by exploring the graph with a graph-search algorithm. These methods offer the ﬂexibility of computing a path that does not belong to the homotopy class of the global optimal path without having to compute any previous paths. However, generating the homotopy classes systematically can make the problem intractable depending on the number of classes generated. This problem can be overcome by using some restriction criteria during the generation of the classes such as allowing the generation of homotopy classes in their canonical form, and avoiding those classes that self-cross or repeat cycles.
A summary of the reviewed methods that takes into account the homotopy of the paths can be seen in Table 1. The outlined features are:
• A short description of the problem to be solved.
• The dimensionality of the problem.
• The required input when it is necessary to specify the homotopy class of the solution.
• The types of obstacles the methods are able to deal with.
• The additional data structure required to name the homotopy classes.
• The homotopy class representation.
• Whether the method can deal with paths that self-cross.

40 state of the art
2.8 path planning for auvs
Although the literature on path planning applied to AUVs is not extensive, several proposals that follow a wide range of different approaches have been reported. (Warren, 1990) presents an algorithm that uses artiﬁcial potential ﬁelds to aid in the path planning. It is ﬁrst required to generate a trial path and then modify the entire path under the inﬂuence of the potential ﬁelds. A path is a set of connected straight line segments, only those endpoints of the segments that remain at the start and end positions are ﬁxed, while the others are modiﬁed according to the potential ﬁeld in order to generate a safe path. (Carroll et al., 1992) apply the A* algorithm in a graph-based environment built according to a previously gathered bathymetry, water currents and exclusion zones. The A* has also been adopted by (Garau et al., 2005) to compute optimal paths in terms of energy cost in underwater environments with eddies. Recently, (Fernandez-Perdomo et al., 2011) have adapted the A* to perform a constant time surfacing algorithm that computes suitable trajectories to be followed by a Glider.
(Vasudevan and Ganesan, 1994) propose to perform path planning with a case-based algorithm which is part of a larger planning system. For a given set of routes to be followed, the planner relies on past experience to adapt the old routes to achieve the goal. Further, it can also build new routes by adopting the same strategies for those cases that approximately match the current situation such as connecting a new segment of a route with a previously existing one. (Petillot et al., 2001) propose a path planning strategy based on nonlinear programming techniques using acoustic images gathered with a multi-beam forward looking sonar in an obstacle avoidance system for a ROV
(Alvarez et al., 2004) use a genetic algorithm to perform path planning for an AUV in an ocean environment characterized by strong currents, minimizing the energy cost. (Kruger et al., 2007) proposes a technique to perform path planning in rivers based on analytic models, which enables an AUV to plan optimally exploiting useful currents, avoiding adverse currents, maximizing speed, minimizing energy and avoiding obstacles. Water currents are also taken into account by (Petres et al., 2007), who developed a path planning algorithm called E* that computes a continuous path from a discrete representation of the environment based on the FM approach.
Some authors tackle the coverage path planning problem for AUVs, since this kind of survey has a wide range of applications such as map building purposes, mosaicking and target localization. For instance, (Maki et al., 2009) propose a path planning method that generates a set of waypoints for an AUV to follow the surface of the target at a constant distance, based on the previously given information about the conﬁgurations of both the target and the vehicle. The target application is the support leg inspection of on-water platforms consisting of cylindrical rods. The method starts by turning the 3D workspace into a set of 2D slices at different depths parallel to the surface. The result is a set of 2D workspaces with cylindrical obstacles where paths are generated following their boundaries at a safe distance. (Williams, 2010)

2.9 discussion 41
addressed the problem of designing the optimal survey route for an AUV in mine countermeasure operations according to the area perceived by its sonar sensors. (Paull et al., 2010) propose an adaptive path planning method that modiﬁes a global precomputed path according to the AUV’s measurements of the environment with side-looking sensors to achieve complete coverage of a speciﬁc area.
Over the last few years, data collection using AUVs has been increasing in importance within the oceanographic research community. For this purpose, (Binney et al., 2010) adapt an informative path planner based on a recursive greedy algorithm focused on collecting data within a certain area using Gliders. The algorithm uses previous knowledge of the environment gathered before releasing the robot to compute the path. Despite receiving updated information from the onboard sensors, the algorithm only uses it as a complement to the previous data, but not to improve the path. On the other hand, (Smith et al., 2010) present an algorithm designed to generate paths for AUVs to high-value location for data acquisition. The algorithm focuses on tracking dynamic ocean features according to ocean model predictions and predicted current velocities. Hence, the predeﬁned path has to be modiﬁed according to the features of interest perceived.
2.9 discussion
In this survey we have explored a set of different proposals to perform path planning. The graph-based search algorithms look for the global shortest path in the C-space, which is obtained with an exhaustive exploration of the search space. Most of these algorithms use a heuristic function in order to speed up the exploration process by ﬁrst selecting the most promising states according to the heuristics. On the other hand, probabilistic sample-based path planners, most of them based on the RRT, perform the exploration by growing a tree incrementally until the goal is reached. These algorithms do not perform an exhaustive exploration in C-space, therefore, they provide a solution very quickly at the expense of its quality. Because of this, it is a common practice to improve the computed path with a post-processing step.
Anytime approaches have been shown suitable to be used with robots that have a limited amount of time to perform path planning. These algorithms compute an initial solution highly suboptimal very quickly and improve it until time runs out. They speed up the path generation by inﬂating the heuristics to force the exploration of those conﬁgurations that are closer to the goal according to their heuristics. During successive iterations, the inﬂation factor is decreased in order to generate better solutions. However, it is difﬁcult to set up the correct inﬂation value since it is highly dependent on the complexity of the scenario. Moreover, even with decreasing the heuristics inﬂation, the generation of a better path is not ensured.
In the survey, Bug-based approaches, initially developed to perform motion planning, have also been considered for path planning purposes since their navigation strategies are suitable to generate paths in a C-space. These

Cite
Chazelle (1982)
Hershberger and Snoeyink (1991) Cheng et al. (2010) Grigoriev and Slissenko (1998)
Efrat et al. (2002) Bespamyatnikh (2003) Speckmann and Verbeek (2010) Jenkins (1991)
Cuerington (1991) Milgram and Kaufman (2000) Schmitzberger et al. (2002) Fujita et al. (2003) Shiller et al. (2004) Banerjee and Chandrasekaran (2006) Bhattacharya et al. (2010)

Description
Shortest path
Shortest homotopic path Approximate shortest homotopic path Shortest homotopic path
Shortest homotopic path Shortest homotopic path Rectilinear homotopic thick path Homotopy classes computation
Shortest homotopic path Topological environment characterization Motion planning with homotopy classes Shortest path with homotopy constraints Shortest path for each homotopy class N-shortest paths Shortest path with homotopy constraints

Dimension
2D
2D 2D 2D
2D 2D 2D 2D
2D 2D 2D 2D 2D 2D 2D

Input
Triangulated simple polygon Path Path Hc/ Path Path Path Paths –
Hc Paths – – – – –

Obstacles type –
Polygonal Polygonal Semi-algebraic
Points Points Rectangular Any kind (points) Circles – Geometric Any kind Any kind Points Any kind

Add. data structure –
– Spanning tree Labeled curves – – – Reference frame Topological graph Reference frame – – – – Voronoi diagram Expanded graph

Homotopy class representation Triangulated simple polygon Edge sequence Edge label seq. Word (label seq.) Edge sequence Edge sequence Edge seq Edge label seq.
Edge label seq. Seq. nodes Edge sequence Point sequence Point sequence Seq. traversed edges Complex number

Self-crossing allowed No
Yes Yes No
No Yes No –
Yes Yes Yes No No Yes Yes

42 state of the art

Table 1: Summary of selected methods that explicitly deal with homotopy classes.

2.9 discussion 43
algorithms look for a path to the goal by following a straight line until an obstacle on the path is detected. At this point, the obstacle is surrounded until a stopping criterion makes the path go straight towards the goal again. Therefore, only the search space around the boundary of the obstacles towards the goal have to be explored.
The topological approaches described in this survey mainly focus on homotopy classes, which provide information on how paths avoid obstacles. In order to perform path planning for an AUV, methods that compute the shortest homotopic path are not suitable because it is ﬁrst necessary to generate a path. Neither are the methods that restrict the path search according to the topology of the paths previously computed. Hence, if the path we are interested in does not belong to the homotopy class of the global optimal solution, it is required to compute a path for each homotopy class that has a shorter path. Finally, those methods that ﬁrst generate the homotopy classes are the most suitable to achieve success in our path planning for an AUV, since they allow us to look for a path that accomplishes other criteria than its shortest length, such as surveilling an area or avoiding dangerous zones.
Despite the range of the solutions surveyed to perform path planning for AUVs, most of which are highly speciﬁc to the problem they want to solve and hence, are difﬁcult to apply in a different context. Some of these solutions take into account water currents, which implies previous knowledge of the scenario that is not provided in our target applications. Further, none of them take into account the homotopy classes of the generated paths. Because of this, our proposal focuses on the topological approach presented by (Jenkins, 1991), which is a generic method to compute the homotopy classes independently from the path planning approach selected to compute the ﬁnal path in the C-space. However, it is necessary to establish a set of restriction criteria in order to generate only those homotopy classes that are interesting for the problem we need to solve.

PATH PLANNING WITH HOMOTOPY CLASS CONSTRAINTS

3

This chapter concerns the path planning method developed for this research project. It is assumed that the computation of the path has to be performed on a local map built for navigation purposes with data provided by the onboard sonar sensors of the vehicle. In order to achieve the realtime requirements of the robot, the computation of the path has to be done in a short time.
Our method proposes the utilization of homotopy classes in order to constrain the path generation topologically. As pointed out in Chapter 2, a homotopy class of a set of trajectories from the start to the end point describes how these trajectories avoid obstacles. From the different approaches that deal with homotopy classes, those methods that ﬁrst generate the classes neither compute previous path to obtain its class nor require giving any input homotopy class speciﬁed by the user. Therefore, they are suitable for the automatic generation of homotopy classes for surveilling or zone avoiding purposes, since they may not follow the homotopy class of the global optimal path. However, these methods require establishing a set of restriction criteria in order to allow the generation of only those homotopy classes that are interesting for the problem to be solved.
Given any 2D environment, our method ﬁrst generates the set of all the homotopy classes that connect the start point with the end point with an extension of the (Jenkins, 1991) proposal we have developed. Using the topological information, path planners do not have to explore the whole space but the space conﬁned in a homotopy class. Then, using a lower bound criterion that estimates the cost of the homotopy classes in the workspace, it is possible to set up a preference order when choosing a homotopy class to generate its path. Finally, three different path planning algorithms have been developed in order to compute paths in the C-space that accomplish the homotopy classes.
Section 3.1 gives an overview of the method to generate homotopy classes proposed by (Jenkins, 1991). In Section 3.2 we propose an extension of the method that allows the generation of homotopy classes that can be followed in any 2D workspace. Section 3.3 shows the heuristic estimator used as a lower bound criterion to set up a preference order when looking for paths of the homotopy classes. Section 3.4 describes three different path planning algorithms designed to follow the homotopy classes previously computed. Finally, in Section 3.5 a summary is provided.
3.1 overview
The method to generate homotopy classes that we propose is based on the (Jenkins, 1991) approach. Given a 2D workspace, this method ﬁrst constructs a

45

46 path planning with homotopy class constraints

g

β2

α1

b2

c

b1

β1 l1

s

α
l2

2

Figure 24: A topological path represented in the reference frame as p = β1α2α2α2 with the transitions labeled.

reference frame that allows the representation of any path in the workspace as a topological sequence. The reference frame is also used to build a topological graph which is explored with graph-search algorithms to generate topological sequences that represent homotopy classes.
More in detail, the reference frame determines, in the metric space, the topological relationships between obstacles and is used to name the homotopy classes. In a workspace with n obstacles, construction starts by representing each obstacle with a single point bk, where k = 1..n. Then, a central point c is selected. This point cannot be inside an obstacle nor inside the n(n − 1)/2 lines determined by the pairwise choices of distinct bk. Finally, the n lines lk joining c with each bk are constructed. Each line is partitioned into two directed semiﬁnite rays: the ray emanating from bk and away from c is labeled βk and the ray from bk that contains c is labeled αk. Figure 24 shows an example of a reference frame in a scenario with two obstacles with a path described by the rays of the reference frame it crosses.
The topological graph, whose construction is based on the reference frame, provides a model to describe the topological relationships between regions of the metric space. The reference frame divides the metric space into regions called wedges. Each wedge represents a node in the graph which is connected to its neighbors through labeled edges according to the semiﬁnite rays shared with its contiguous wedges in the reference frame.
Figure 24 depicts an example of a reference frame of a simple workspace with two obstacles and Figure 25 shows its correspondent topological graph. In the reference frame, lines l1 and l2 split the workspace into four different wedges, hence, the topological graph has four nodes. The wedges in the reference frame and their corresponding nodes in the topological graph are labeled in increasing order in a counter clockwise direction. As stated earlier, nodes of the topological graph are connected with their neighbors according to the segments shared between wedges in the reference frame. For instance, wedges 1 and 2 share a single semiﬁnite ray α2 in the reference frame, thus, their nodes in the topological graph are connected with the edge labeled α2.

3.1 overview 47

g

β2

3

α2

2 34
4

α1
2

α1

α2

β1 1
1

s

Figure 25: Path p = β1α2α2α2 represented in the topological graph with bold arrows.

The wedges of nodes 1 and 4 share the α1 and β1 rays, so they are connected with the two edges with these labels. In the reference frame, a path is deﬁned according to the segments it crosses, whereas, in the topological graph, it turns into traversing the graph from the start node to the end node. Start and end nodes are those wedges in the reference frame, nodes in the topological graph, where the start and end points are located.
Once the topological graph is constructed, Jenkins proposes traversing it using a modiﬁed version of the BFS. The algorithm begins at the start node and new homotopy class candidates are systematically generated according to the edges traversed. In order to reduce the potential number of classes generated, the author provides a set of restriction criteria to avoid the generation of the homotopy classes that self-cross or are duplicated according to their canonical sequences. The algorithm does not stop when the goal node has been reached, it continues generating potential solutions until all the homotopy classes have been computed or the last candidate homotopy class generated is larger than a given threshold. Table 2 shows a small part of the execution of the BFS algorithm and Table 3 summarizes the homotopy classes generated with the method proposed by Jenkins. It is worth noting that this method achieves the generation of homotopy classes in any 2D workspace assuming that obstacles are represented by single points. Despite that it can be applied to any kind of obstacle, depending on their shape/size, resultant classes might not be followed back in the workspace with the original obstacles. The next section details this problem.

3.1.1 Applicability to the Path Planning Problem
Our work proposes using the Jenkins method to guide a path planning algorithm following a topological path. Thus, the topological information of the homotopy classes has to be turned into metric paths in the workspace by using the reference frame as a link between the topological graph and the workspace. In order to ﬁnd a path in the workspace that follows a speciﬁc homotopy class,

48 path planning with homotopy class constraints
Homotopy class α1 β1 α2 α1β1 α1α2 α1β2 β1α1 β1α2 β1β2 α2α1 α1β1α1 α1β1α2 ...
Table 2: A systematic generation of homotopy class candidates with the BFS algorithm.
Idx Homotopy class 1 α1α2 2 α1β2 3 β1α2 4 β1β2 5 α1α2β2α1β1β2 6 β1β2α2β1α1α2
Table 3: Homotopy classes with their index of generation obtained with the topological graph in Figure 25.
it is required for a path planning algorithm to be modiﬁed to look for the intersections with the desired segments in the reference frame.
During the reference frame construction, each obstacle in the workspace is represented by a bk point without area in order to ensure that each line in the reference frame crosses only one obstacle; and the topological graph is built under this assumption. However, depending on the reference frame construction and the particular shape of the obstacles, it is possible that a line in the reference frame intersects with more than one obstacle. In some cases, there will be homotopy classes that cannot be followed in the workspace. Figure 26 depicts this problem: the homotopy class to follow is β1α2, which is shown as a path (Figure 26.a) in the reference frame with its equivalence in the topological graph (Figure 26.b). However, in Figure 26.c the metric path cannot be followed because obstacle 2 crosses l2 and l1. Notice that this problem would not arise if points c and b1 were more carefully selected to avoid the

3.2 homotopy classes generation 49

g

β2

α1

b2

c

b1

β1 l1

s

α2
l2

a) Reference frame

g

β2

3

α2

α1

4

2

α1

α2

β1
1

s

b) Topological graph

g

β2

α1

b2

c

b1

β1 l1

s

α
l2

2

c) Workspace

Figure 26: Example of a valid homotopy class (β1α2) in the reference frame (a) and in the topological graph (b) that cannot be followed in the workspace (c) because at least one line (l1 or l2) in the reference frame intersects more than one obstacle.

intersection of obstacle 2 with l1. However, this solution cannot be applied in complex scenarios with more obstacles.
3.2 homotopy classes generation
This section describes the generation of homotopy classes for any 2D workspace. The approach presented here is an extension of the method proposed by (Jenkins, 1991) which ensures that all the homotopy classes computed can be followed in the workspace. As stated before, this method ﬁrst builds a reference frame which determines the topological relationships between obstacles in the workspace and is used to name the homotopy classes. The reference frame is then used to build the topological graph which allows the computation of homotopy classes systematically.
3.2.1 Reference Frame
Given a workspace with n obstacles, the reference frame determines, in the metric space, the topological relationships between obstacles and is used to name the homotopy classes. The whole construction process is summarized in three steps:
1. Select a random point inside each obstacle and label it bk, where k = 1..n.
2. Select the central point c of the reference frame. This point cannot be inside an obstacle nor inside the n(n − 1)/2 lines determined by the pairwise choices of distinct bk.
3. Construct n lines lk joining c with each bk. Each line is partitioned into m + 1 segments, where m is the number of obstacles that intersect with lk in the workspace. The segments from bk and away from c are labeled

50 path planning with homotopy class constraints

g

β 21

α1−1

b2

α 20

α10

α10 c α 20 p

β11

b1

l1

s

α 2−1
l2

Figure 27: Topological path represented in the reference frame as p = β11 α10 α20 α10 α20 α20 α10 α1−1

with βks, and the segments in the opposite direction are labeled αks, where s = 0..u with u ∈ Z+ for the segments of lk from c that pass through bk and s = 0..v with v ∈ Z− for the segments in the opposite direction.
Using the reference frame, any path p can be deﬁned topologically by the sequence of labels of the segments crossed in order from the start to the end point. For instance, Figure 27 depicts a reference frame for a scenario with two obstacles. The path p is labeled β11 α10 α20 α10 α20 α20 α10 α1−1 . There are two special cases when deﬁning paths in the reference frame: when p does not cross any rays then p = ∅; and when p crosses through c meaning that all the αk0’s are simultaneously crossed, all αk0 are added in subindex order to the sequence.
Notice that the start and goal points cannot be in lines lk it the reference frame since it would not be possible to determine whether the affected lk lines are crossed or not.

3.2.2 Computation of the Canonical Sequence
As stated in Chapter 2, it is possible to know if the paths that do not follow the same crossing-ray order in the reference frame are homotopic through their canonical sequence. The canonical sequence is the simplest representation of a path without changing its topology. With the extension of the notation used in the reference frame, it is computed according to Algorithm 6. First, the αk0’s substrings are sorted according to the subindex of the path in non-decreasing order. Then, all the elements of the sequence that have the same character by pairs are removed. This process is repeated until no changes are made in the sequence. For instance, once path β11 α10 α20 α10 α20 α20 α10 α1−1 gets its αk0 s substring sorted, it becomes β11 α10 α10 α10 α20 α20 α20 α1−1 . At this point a α10 and a α20 pairs can be canceled β11α10 α10 α10α20 α20 α20 α1−1 obtaining β11α10α20α1−1. Since it cannot be shortened, it represents the canonical se-

3.2 homotopy classes generation 51
quence of the path. Figure 28 depicts one possible solution in the workspace of this canonical sequence.
Algorithm 6 Canonical representation CanonicalRepresentation(p) 1: repeat 2: psorted ← Sortαk0 sSubstrings(p) 3: pcanceled ← CancelEqualPairs(psorted) 4: p ← pcanceled 5: until (pcanceled = psorted) 6: return p

g

β 21

α1−1

b2

α 20

α10

α10 c α 20 p

β11

b1

l1

s

α 2−1
l2

Figure 28: A possible path in the reference frame of the canonical sequence p = β11 α10 α20 α1−1 obtained with the sequence β11 α10 α20 α10 α20 α20 α10 α1−1 .

3.2.3 Topological Graph
The reference frame is used to compute a topological graph G, providing a model to describe the relationships between regions of the metric space. Its construction can be divided into three steps:
1. The lines in the reference frame divide the metric space into regions or wedges and the obstacles that intersect with more than one line at the same time split these wedges into sub-wedges. Each sub-wedge represents a node of G.
2. Each node of G is labeled according to the wedge w and sub-wedge sw using the notation w.sw. w ∈ N is numbered counterclockwise. For each w, its corresponding sw ∈ N is numbered sequentially starting by 1 for the one closest to c.
3. Two nodes of G are interconnected according to the number of segments they share in the reference frame. Each edge of G is labeled with the same label of the segment that crosses it in the reference frame.

52 path planning with homotopy class constraints

In the reference frame, a path is deﬁned according to the segments it crosses, whereas in G it turns into traversing the graph from the start node to the end node. Notice that the start and end nodes of G are those sub-wedges in the reference frame where the start and end points are located. Figure 29 depicts the canonical sequence β11α10α20α1−1 in the topological graph.

g

3.2

β 21

α1−1

b2

3.1

α 20

α10

4.1

c

2.1

α10

α 20

1.1

b1 β11

α 2−1

1.2 s

Figure 29: The path β11 α10 α20 α1−1 represented in the topological graph.

3.2.4 Systematic Homotopy Classes Computation
Once the topological graph is constructed, it is traversed using a modiﬁed version of the BFS algorithm. As stated in Chapter 2, the BFS is a graph search algorithm that begins at the root node and explores all the neighboring nodes. Then, for each of those nearest nodes, it explores their unexplored neighbors. The process is repeated until the goal is found. Unlike the standard BFS, which stops when all vertexes have been visited, the modiﬁed algorithm continues until there are no more homotopy class candidates to explore or the length of the last homotopy class candidate is larger than a given threshold.
3.2.4.1 Restriction Criteria
During the BFS execution, several restriction criteria are applied to avoid the generation of any homotopy classes which either self-intersect or whose canonical sequence is duplicated and has already been considered. All classes that accomplish any of the following restriction criteria are ignored to avoid using them as a root for future homotopy classes:
simple wrap. Any string that contains a substring of the form αks...χkt...αku or βks...χkt...βku where χ = (α, β) with s = u represents a class that wraps around an obstacle and is self-crossing. Figure 30 shows an example of a path that accomplishes the simple wrap criterion.
wrap. Any string that contains a substring of the form χks...χkt...χku where χ = (α, β) with s, t, u 0 and s > t < u or with s, t, u 0 and s < t > u

3.2 homotopy classes generation 53
αk0 c

bk β k1 gs
Figure 30: A simple wrap in path βk1 αk0 βk1 .

represents a class that wraps around an obstacle and is self-crossing.

Figure 31 shows an example of a path that accomplishes the wrap

criterion.

α m0 s

cαk0

bm

α k1 g

β m1

bk βk2

Figure 31: A wrap in path αm0 αk0 βk2 αk1 .

self-crossing. Any string that contains a substring of the form χks...βmt... αmu...χkv where χ = (α, β) with s, v 0 and s < v or with s, v 0 and s > v represents a class that self-crosses. The reversed substring χks...αmt...βmu...χkv with s, v 0 and s > v or with s, v 0 and s < v also represents a class that self-crosses. Figure 32 shows an example of a path that accomplishes the self-crossing criterion.

β m1

βk2 g

bm

β k1

s

α m0 bk

α c

k0

Figure 32: Self-crossing in path βk1 βm1 αm0 βk2 .

54 path planning with homotopy class constraints

duplicated. Duplicated strings are not allowed in the list of homotopy class candidates. If a string is not in its canonical form, it can be simpliﬁed without modifying its topology. Then, it is ensured that the resultant string has already been computed by the BFS algorithm because it would be shorter than the input string. Finally, the algorithm cannot traverse the same edge on two consecutive occasions. By doing that, a string with a repeated pair would be generated. Consequently, the pair would be simpliﬁed and the string discarded for being duplicated.
Table 4 shows the homotopy classes computed for the workspace depicted in Figure 28 applying all the restriction criteria described in this section. Notice that all the homotopy classes can be followed in the workspace with the original obstacles. For a detailed execution of the homotopy class generation in this example see Appendix A.

Idx Homotopy class

1

β11 β21

2

α2−1 α1−1

3

β11 α10 α20 α1−1

4

α2−1 α10 α20 β21

Table 4: Homotopy classes obtained with the extension of the Jenkins method we propose. The ﬁrst column shows their index of generation.

3.3 lower bound estimator
The number of homotopy classes generated by the BFS algorithm highly depends on the number of the nodes in the topological graph. Therefore, in most scenarios it is not possible to compute all the correspondent paths of the homotopy classes in the workspace in real-time. In order to set up a preference order when choosing the homotopy classes to compute their paths, a modiﬁed version of the funnel algorithm (Chazelle, 1982) is used to obtain a quantitative measure for each homotopy class estimating its quality. This algorithm computes the shortest path within a channel, which is a polygon formed by the vertexes of the segments in the reference frame that are traversed in the topological graph. The modiﬁcation consists of accumulating the Euclidean distance between the points while they are being added to the channel’s shortest path. Hence, the result of the funnel algorithm is a lower bound of the optimal path in the workspace of the selected homotopy class.
The lower bound estimator is used to set up a preference order to compute the homotopy classes path in the workspace when operating under time restrictions. Notice that the segments of the reference frame constrain the region where the paths can go through, but do not take into account the whole shape of the obstacles. For that reason, a homotopy class with a smaller lower bound may have a longer path in the workspace than an another homotopy class with a higher lower bound.

3.4 homotopic path planning algorithms 55

β 21

g

α1−1

b2

α10 α 20

β11

b1

s

α 2−1

Figure 33: The channel and lower bound path for the homotopy class β11 α10 α20 α1−1 .

Idx Homotopy class Lower bound

1

β11 β21

2

α2−1 α1−1

3

β11 α10 α20 α1−1

4

α2−1 α10 α20 β21

0.94 0.95 1.04 1.08

Table 5: Lower bounds for each homotopy class normalized according to the cost of the A* solution.

Figure 33 depicts an example where the funnel algorithm computes the lower bound for the homotopy class β11α10α20α1−1. The solid lines represent the channel and the dashed red line is the path after applying the funnel algorithm. It is worth noting that the modiﬁed algorithm takes into account that some subsegments may self-intersect when creating the channel as can be seen with the α10 and α20 segments in the ﬁgure. Table 5 shows the lower bound for each homotopy class obtained in this example. All lower bounds have been normalized according to the cost of the path obtained with the A*, which belongs to class 2 (α2−1α1−1), using an A8 connectivity in a discretized representation of the environment. Some values are lower than 1 since the A* solution takes into account the shape of the obstacles while the computation of the lower bound does not.
3.4 homotopic path planning algorithms
Once the homotopy classes are computed and sorted according to their lower bound, a path planning algorithm has to ﬁnd a path in the workspace that follows a given homotopy class which essentially implies turning a topological path into a metric path. The only link between the workspace and the topological space is the reference frame. It allows checking whether a metric path in the workspace is following a topological path by following the intersections in order from the initial conﬁguration to the current conﬁguration.

56 path planning with homotopy class constraints
This section presents three well known algorithms that have been adapted to compute paths for a single homotopy class. The ﬁrst algorithm is the homotopic version of the A* called Homotopic A* (HA*). It allows the computation of the optimal path according to a homotopy class to follow. The second algorithm is a probabilistic approach based on the RRT called Homotopic RRT (HRRT). Finally, the third algorithm is a Bug-based approach called Homotopic Bug (HBug) which tries to follow the lower bound path until it collides with an obstacle. Then the algorithm surrounds the boundary of the obstacle while the homotopy class is being followed till the point where the lower bound path leaves the obstacle.
3.4.1 Homotopic A*
The Homotopic A* (HA*) works like the A* algorithm, but instead of exploring the entire search space, it only explores the zones in the workspace that satisfy a given homotopy class by checking the intersections with the reference frame before taking into consideration the node as a candidate to be explored.
Given a node n, the algorithm uses a heuristic function f(n) based on the distance to the goal and the cost from the start to set up the order in which the search visits the nodes. The heuristic function is f(n) = g(n) + h(n, ngoal) where:
• g(n) is the path-cost function, which is the cost from the start node to the current node.
• h(n, ngoal) is the heuristic estimation of the distance from the current node to the goal which does not overestimate the distance to the goal.
3.4.1.1 Implementation
The HA* is written in pseudocode in Algorithm 7. The nodes in the algorithm are tuples that contain the conﬁguration of robot q and the topological path from qstart to q. These values are accessible through the functions Q and P respectively. Just like the A*, open nodes are processed according to their position in a priority queue OPEN. Each node in this queue is ordered according to the sum of its current path cost from the start, g(n), and a heuristic estimation of its path cost to the goal, h(n, ngoal). The node with the minimum sum is at the top of the priority queue.
The algorithm receives as input the start conﬁguration qstart, the goal conﬁguration qgoal, a candidate homotopy class to follow H and the reference frame F. The conﬁgurations qstart and qgoal are used to set up the initial node nstart and the goal node ngoal (line 27).
The function ComputePath computes the shortest path that follows H. It starts by adding the nstart into the OPEN queue. As node n with the minimum g(n) + h(n, ngoal) is different from ngoal, the algorithm pops n to the top of the queue. For all the conﬁgurations q reachable from Q(n), the function FindIntersections (line 15) returns the intersections of the segment

3.4 homotopic path planning algorithms 57

β2

g

α1

1

−1

b2

α2

α1

0

0

αα120 0

β2

g

α1

1

−1

b2

α2 0

α1 0

αα120 0

β2 1

g

α1

−1

b2

α2 0

α1 0

αα120 0

b1 ββ111 1

s

α2 −1

b
1

β1β111

s

α2 −1

b
1

β1β111

s

α2 −1

a)

b)

c)

Figure 34: An HA* execution example in a simple workspace with two obstacles for homotopy class β11 β21 .

[Q(n), q ] with F sorted by distance1. Then the UpdateH (line 16) generates the new topological path according to the intersections. No intersections with F means that the explored conﬁguration is in the same sub-wedge of the C-space and the function returns P(n). If there are intersections and these intersections follow H, the function returns P(n) ∪ I in order to create a new node candidate n . Whether n is in the OPEN queue or not is then checked. If not, it is added to the queue with a priority g(n ) plus the heuristic h(n , qgoal) (line 20). If it is, and the cost g(n) plus the cost of traversing from n to n , c(n, n ) is less than its current cost (line 21), g(n ) is set to this new lower value. This process is repeated until the ngoal is found or OPEN has no more nodes to be expanded.
Figure 34 depicts an example of an HA* execution in a discrete version of the workspace shown during the generation of the homotopy classes. The input homotopy class is β11β21. The algorithm explores the environment using A8 connectivity and the Euclidian distance as heuristic estimator. Figures 2.a,b depict the explored states in grey at two different moments of execution. Figure 2.c shows the ﬁnal path obtained with backtracking from the goal to the start with the total number of cells explored. The solution is the shortest homotopic path for the input homotopy class. It is worth noting that cells are explored in only those areas that accomplish the class.

3.4.1.2 Theoretical properties
The HA* inherits several properties from the A* algorithm:
optimal. The algorithm computes the least cost path for a given homotopy class which can be used as a ground truth for other path planning algorithms that follow homotopy classes.
1 Notice that it is possible to intersect more than one segment of the reference frame depending on how close Q(n) and q are to the c point.

58 path planning with homotopy class constraints

Algorithm 7 Homotopic A*

FindIntersections([q, q ], F)

1: r ← ∅

2: for i ← 1 to |F| do

3: if x ← Intersection([q, q ], F[i]) = null then

4:

r ← r ∪ {Edge(i), Distance(q, x)}

5: end if

6: end for

7: r ← SortByDistance(r)

8: return r

ComputePath(nstart, ngoal, F)

9: OPEN ← ∅; V ← ∅

10: OPEN.push(nstart)

11: while minn∈OPEN(n = ngoal) do 12: n ← OPEN.top()

13: OPEN.pop()

14: for all q ∈ Succ(Q(n)) do

15:

I ← FindIntersections([Q(n), q ], F)

16:

if H ← UpdateH(P(n), I) then

17:

n ← {q , H }

18:

if n ∈/ OPEN then

19:

g(n ) ← g(n) + c(n, n )

20:

OPEN.push(n ) with g(n ) + h(n , ngoal)

21:

else if g(n ) > g(n) + c(n, n ) then

22:

g(n ) ← g(n) + c(n, n )

23:

end if

24:

end if

25: end for

26: end while

HA∗(qstart, qgoal, H, F)
27: nstart ← {qstart, ∅}; ngoal ← {qgoal, H} 28: ComputePath(nstart, ngoal, F) 29: if minn∈OPEN(n = ngoal) then 30: publish solution 31: end if

complete. The completeness of the algorithm is ensured because when ngoal is not reachable, the algorithm explores all the nodes in the OPEN priority queue before returning that no path has been found. On the other hand, when ngoal can be reached, the HA* ﬁnds the node that accomplishes the homotopy class to follow in OPEN.
3.4.2 Homotopic Rapidly-exploring Random Tree
The Homotopic RRT (HRRT) is based on the goal-biased RRT algorithm which has been shown to be very efﬁcient in time, even in complex workspaces (LaValle, 1999; Kim and Ostrowski, 2003). The algorithm allows a constrained growing of the tree only in those directions that satisfy a given homotopy

3.4 homotopic path planning algorithms 59
class. Before adding a new node into the tree, the topological path traversed is checked to ensure that it belongs to the homotopy class by computing the intersections of the path with the reference frame.
3.4.2.1 Implementation
The HRRT is detailed in Algorithm 8. It receives as input the start conﬁguration qstart, the goal conﬁguration qgoal, a candidate homotopy class to follow H and the reference frame F. The nodes on tree T are tuples that contain the conﬁguration of the robot q and the topological path from qstart to q. These values are accessible through the functions Q and P respectively. Just like the RRT, the function Extend (line 31) iteratively extends tree T until the distance between the conﬁguration of nnew (Q(nnew)) and ngoal (Q(ngoal)) is lower than a distT hreshold.
The extension of the tree starts by selecting a random conﬁguration qrand from the C-space with the function ComputeQRand. Then, the Nearest− Neighbor function returns the nearest node nnearest regarding a random conﬁguration qrand by looking for the node whose topological path is closer to P(ngoal) (line 4). If there is more than one candidate, the node selected is the closest to the goal according to the Euclidean distance. After qnew is computed using the function ComputeQNew, FindIntersections (line 21) checks whether the segment [Q(nnearest), qnew] intersects with any segment in reference frame F2. The function returns the intersected edges sorted by distance from Q(nnearest). Then, the function UpdateH (line 22) generates the new topological path H according to the intersections. No intersections with F means that the tree grows in the nnearest sub-wedge and hence, the function returns P(nnearest). If there are intersections and these intersections follow the topological path, the function returns P(nnearest) ∪ I in order to create a new candidate node nnew to be added to the tree; otherwise a null path is returned and no node is added to the tree.
Figure 35 depicts an execution example of the HRRT with an exploration tree and the solution obtained with no post-processing. The homotopy class to follow is β11α10α20α1−1. Notice that the algorithm constrains the expansion of the tree only into those zones that accomplish the input homotopy class, thus, in this example, segments α1−1 or β21 in the reference frame do not have to be crossed by the tree.
3.4.2.2 Theoretical Properties
The HRRT has two important theoretical properties:
performance. The HRRT constrains the growing a tree only into those directions that satisfy a given homotopy class. With respect to the RRT, every time a new node is generated, it is checked whether the branch that connects the tree with the new node intersects with any segment of the
2 Notice that it is possible to intersect with more than one segment in the reference frame depending on the step between nnearest and qnew and how close these nodes are to the c point.

60 path planning with homotopy class constraints

Algorithm 8 Homotopic RRT

NearestNeighbor(T , qrand)

1: n ← T ; d ← Distance(Q(n), qrand)

2: for all c ← T .Children() do

3: [n , d ] ← NearestNeigbor(T , qrand) 4: if (|P(n )| > |P(n)|) or (|P(n )| = |P(n)| and d < d) then

5:

n←n ; d←d

6: end if

7: end for

8: return {n, d}

FindIntersections([qnearest, qnew], F)

9: r ← ∅

10: for i ← 1 to |F| do

11: if p ← Intersection([qnearest, qnew], F[i]) = null then

12:

r ← r ∪ {Edge(i), Distance(qnearest, p)}

13: end if

14: end for

15: r ← SortByDistance(r)

16: return r

Extend(T , ngoal, F)
17: nnew ← {∞, null} 18: qrand ← ComputeQRand() 19: nnearest ← NearestNeighbor(T , qrand) 20: qnew ← ComputeQNew(Q(nnearest), qrand) 21: I ← FindIntersections([Q(nnearest), qnew], F) 22: H ← UpdateH(P(nnearest), I} 23: if (H = null) then 24: nnew ← {qnew, H } 25: nnearest.Add(nnew) 26: end if 27: return nnew

HRRT (qstart, qgoal, H, F)
28: nnew ← {qstart, ∅}; ngoal ← {qgoal, H} 29: T .Add(nnew) 30: while Distance(Q(nnew), Q(ngoal)) > distT hreshold do 31: nnew ← Extend(T , ngoal, F) 32: end while

reference frame. This extra computational load, assumed by the function FindIntersections, makes the HRRT no to reach the performance of the RRT, but ensures growth only into those regions that accomplish the homotopy class.
completeness. When the HRRT is used together with the automated generation of the homotopy classes, the algorithm is complete because if the goal is not reachable, no homotopy classes will exist and, consequently, no paths will be generated. On the other hand, when the HRRT is executed to ﬁnd a path of an arbitrary topological sequence, the algorithm

3.4 homotopic path planning algorithms 61

β2

α1

g

−1

1

b2

α2 0

α1 0

b1
β1 1 s

α2 −1

Figure 35: A path computed with the HRRT path planner for the homotopy class β11 α10 α20 α1−1 .

is probabilistically complete because it is not ensured that a path will be found.

3.4.3 Homotopic Bug
The Homotopic Bug (HBug) is the third and last approach of this dissertation to generate paths according to a homotopy class. The algorithm is based on the Bug2. Essentially, it tries to follow directly the lower bound path obtained with the modiﬁed funnel algorithm which ensures that the homotopy class is being accomplished. However, as mentioned in Section 3.3, the segments in the reference frame constrain the regions the paths can go through, but do not take into account the shape of the obstacles. For this reason, the lower bound path may intersect with the obstacles. In such cases, the obstacle boundary is followed in a clockwise or counterclockwise direction according to the homotopy class until the lower bound path leaves the obstacle. This process is repeated for all the obstacles intersected by the lower bound path.
3.4.3.1 Perpendicular Dot Product
The perpendicular dot product is used to compute the direction to surround an obstacle while keeping the homotopy class. Formally, the perpendicular dot product, referred to as perp dot product, v⊥1 · v2 for v1 and v2 vectors in the plane is a modiﬁcation of the two-dimensional dot product in which v1 is replaced by the perpendicular vector rotated 90 degrees to the left, as deﬁned by (Hill, 1994). It satisﬁes the identities:

v⊥1 · v2 = v1 v2 sin(θ)

(3.1)

62 path planning with homotopy class constraints

ccw v
v⊥ 2 1

v 1 v⊥ 1

cw v
1
v 2

a) Counterclockwise direction

b) Clockwise direction

Figure 36: Perpendicular dot product.

(v⊥1 · v2)2 + (v1 · v2)2 = v1 2 v2 2

(3.2)

where θ is the angle from vector v1 to vector v2.
Based on Equation 3.1, the sign of the perpendicular dot product indicates the turning direction from v1 to v2: if v⊥1 · v2 is greater than 0, the direction is counterclockwise (Figure 36.a); if it is less than 0, it is clockwise (Figure 36.b)
and if it is 0, v1 and v2 are parallel.

3.4.3.2 Implementation
The HBug detailed in Algorithm 9 receives as input parameters the lower bound path P, a candidate homotopy class to follow H and the reference frame F. Notice that the ﬁrst and last elements of P are the start (s) and goal (g) nodes respectively.
The algorithm is a three step process. First, the function BoundaryNodes checks the intersections of P with the obstacles in the C-space. Every time that P hits or leaves an obstacle, a boundary node is created. Each node contains the contact point c and the obstacle label k, which is the subindex of the point bk that represents the obstacle in the reference frame. These parameters are accessible through the functions Q and Obst respectively. Then, ObstacleNodes computes the nodes O based on the boundary nodes N previously computed. Each obstacle node contains the ﬁrst boundary node that hits obstacle nh, the last node in its boundary without changing the obstacle nl, and the direction d to surround the obstacle while following H (line 23). Finally, the function BuildPath creates the path P in the workspace by joining the boundary of each obstacle oi ∈ O from nh to nl with the direction d.
The direction d to surround an obstacle is set according to the direction of a hit node nh towards its successor nh+13 with respect to point bk that represents the obstacle in the workspace in the reference frame. Notice that nh and nh+1 are ensured to belong to the same obstacle since for any point that hits an obstacle there has to be another that releases it. The perpendicular dot product between vectors (Q(nh) − bk) and (Q(nh+1) − bk) computes the boundary following the direction (line 15). If the result is less than 0, the
3 When the lower bound path intersects with an obstacle only once, the nh+1 node is also the nl node.

3.4 homotopic path planning algorithms 63

β 21 b2

g

α1−1

n4 :{c4 ,2}

ccw α10 n3 :{c3,2}

α 20 n2 :{c2 ,1}

n1 :{c1,1} β11

b1 cw s

α 2−1

Figure 37: Path computed with the HBug path planner for the homotopy class β11 α10 α20 α1−1 .

direction from nh to nh+1 is counterclockwise; if it is greater than 0, the direction is clockwise.
The result of the perpendicular dot product can be 0 if the vectors (Q(nh) − bk) and (Q(nh+1) − bk) are parallel, which means that nh, nh+1 and bk belong to the same lk in the reference frame (line 16). In such cases, d is obtained according to two conditions: the initial direction selected to cross lk from the start point, and the number of times that lk is crossed until αk or βk, denoted by χk, of the homotopy class, on which nh+1 relies, is reached. The initial direction is obtained with the dot product from the start s to the ﬁrst χk with the same subindex as lk4 (line 17). The number of times that lk is crossed depends on the number of χk found in the homotopy class from the beginning to the index ik, which indicates the position of the χk that contains nh+1 (line 19).
Figure 37 depicts an example scenario where the HBug is applied. The homotopy class to follow is β11α10α20α1−1. The dashed line represents its lower bound path, which intersects the ﬁrst obstacle generating two boundary nodes, n1 and n2, both located on line l1 in the reference frame. The point that represents the obstacle is b1, also on l1, which makes the perpendicular dot product between (Q(n1) − b1) and (Q(n2) − b1) unable to set the direction (d = 0). Therefore, using the start point s and a point of the edge β11, the initial direction is set clockwise (cw). The last edge involved in this situation is α10, located in the second position in the homotopy class. The number of edges with subindex 1 up to this position is 2, thus, the direction is not changed. Then, the lower bound path intersects the second obstacle in n3 and n4. Using the base point b2, the perpendicular dot product sets the direction as counterclockwise (ccw). Finally, the path is composed from s to g with the boundaries of obstacle 1 (from n1 to n2) and obstacle 2 (from n3 to n4) joined by straight lines.

4 Notice that the start point cannot be in line lk in the reference frame since the perpendicular dot product would also be 0.

64 path planning with homotopy class constraints

Algorithm 9 Homotopic Bug

BoundaryNodes(P)

1: N ← ∅

2: for i ← 1 to |P| − 1, pi ∈ P do

3: C ← ContourPoints(pi, pi+1)

4: for all j ← 1 to |C|, cj ∈ C do

5:

k ← Label(cj)

6:

N ← N ∪ {cj, k}

7: end for

8: end for

9: return N

ObstacleNodes(N, H, F)

10: O ← ∅

11: h ← 1

12: while nh ∈ N/h < |N| − 1 do

13: nl ← last nj ∈ N/j > h without changing Obst(nh)

14: bk ← point of Obst(nh) in F 15: d ← (Q(nh) − bk)⊥ · (Q(nh+1) − bk)

16: if d = 0 then {parallel}

17:

d ← (s − bk)⊥ · (point of 1st χk ∈ H − bk)

18:

ik ← index of χk ∈ H where nh+1 relies on

19:

if |χk| ∈ H1..ik is even then

20:

switch d

21:

end if

22: end if

23: O ← O ∪ {nh, nl, d}

24: h ← l + 1

25: end while

26: return O

BuildPath(O)
27: P ← ∅ 28: for i ← 1 to |O|, oi ∈ O do 29: P ← P ∪ Boundary(oi) 30: end for 31: return P

HBug(P, H, F)
32: N ← BoundaryNodes(P) 33: O ← ObstacleNodes(N, H, F) 34: P ← BuildPath(O)

3.4.3.3 Theoretical properties
The HBug algorithm has been designed to be used together with the automated computation of the homotopy classes. Nevertheless, the algorithm itself has several properties:
completeness. As a Bug-based algorithm, when there is a solution path the HBug ﬁnds it. On the other hand, when there is no solution, the function BuildPath tries to follow the boundary of the obstacle that does not allow the solution to exists. However, by doing this, it crosses segments

3.4 homotopic path planning algorithms 65

in the reference frame that do not describe the speciﬁc homotopy class that has to be followed. To avoid checking the intersections with the reference frame, it is also possible to ﬁnd that no solution exists when the algorithm again reaches the hit point after surrounding the whole obstacle. Figure 38 depicts both situations for the homotopy class αk0.

β k1

β k1

g

bk

n2 n1

g

bk

n2 n1

s αk0

s αk0

a) Intersection of the reference frame b) Findind a visited contact point
Figure 38: Two ways to check completeness with HBug algorithm for the homotopy class αk0 .

no optimal. The HBug algorithm does not compute the optimal solution. The cost of the solution for a speciﬁc homotopy class depends on how far the subsegments in the reference frame are from the boundary of the obstacles.
performance. During the path computation, the HBug only considers those nodes of the C-space that belong to the lower bound path, which is already computed, as long as it does not traverse an obstacle. When it does, the algorithm only looks for the free space around the intersected obstacle. Therefore, the number of explored nodes in the C-space is drastically reduced when compared with the HA* and HRRT algorithms. This property has been reported in experimental results shown in Chapter 6.
upper bound. As with the Bug1 and Bug2 algorithms described in Chapter 2, it is possible to establish an upper bound for the path length. The ideal path would be the lower bound path length LB, which can only be achieved when it does not intersect with an obstacle in the C-space. However, most of the homotopy classes require the circumnavigation of the n obstacles in the environment that cross with the lower bound path. Depending on the shape of the obstacles, the worst possible case would be to follow almost the whole perimeter p of the obstacles involved. Thus, the upper bound is

UBHBug

n
LB + pi
i=1

(3.3)

66 path planning with homotopy class constraints
3.5 summary
Given an environment with obstacles, in this chapter we have proposed a method to generate homotopy classes from a start to an end position that can be followed in the C-space. The method starts by constructing a reference frame which establishes the topological relationships between the obstacles in the metric space. This frame allows us to describe any path according to a sequence of intersected segments. The reference frame is used to set up a topological graph that allows the systematic generation of homotopy classes by means of a graph-based search algorithm. In order to contain the number of classes generated, only those that neither self-intersect nor are duplicated are allowed to be generated. The computed homotopy classes are sorted according to a lower bound criterion which estimates their quality before generating a path.
The next step consists of turning the topological information provided by the homotopy classes into metric paths in the C-space. Three path planners from three different approaches have been proposed to achieve this goal. The ﬁrst is the HA*, a graph-based search algorithm based on the A*. This algorithm performs an exhaustive exploration of the C-space according to a heuristic function. When the exploration of a node implies an intersection with the reference frame, it is checked whether the segment has to be crossed according to the input homotopy class. In such cases, it is explored, otherwise it is discarded. The result of the HA* is the optimal path for the input homotopy class.
The second path planner is the HRRT based on the goal-biased RRT algorithm to perform a fast exploration of the C-space. Following the same idea as the HA*, the HRRT constrains the growing of the tree only in those directions that satisfy an input homotopy class. Before adding a new node into the tree, the topological path traversed is checked to ensure that it belongs to the homotopy class by computing the intersections in the path with the reference frame.
The last proposed path planner is a Bug-based algorithm called HBug. This algorithm tries to follow the lower bound path, ensuring the accomplishment of the homotopy class. Since the segments in the reference frame constrain the regions the paths can go through but do not take into account the shape of the obstacles, the lower bound path may intersect with obstacles. In this situation, the obstacle boundary is followed in the direction that accomplishes the homotopy class until the lower bound path leaves the obstacle. This process is repeated for all the obstacles intersected by the lower bound path. As a result, the HBug generates a suboptimal path that follows the homotopy class very quickly because the explored C-space is constrained between the nodes of the lower bound path (already explored) and the partial boundary of the obstacles intersected. Moreover, an intersection check with the reference frame is not required every time a node is explored.

LOCAL MAP BUILDING

4

As stated in Chapter 1, the main goal of our map building algorithm is to compute a map with which the robot can perform path planning to generate safe trajectories while avoiding obstacles. Nevertheless, robot localization and map building is a research discipline by itself. Over the few last years, great efforts have been made to provide a coupled solution to the Simultaneous Localization And Mapping (SLAM) problem (Bailey and Durrant-Whyte, 2006; Durrant-Whyte and Bailey, 2006). In underwater applications, autonomous robot localization and map building is an even harder problem to solve and is beyond the scope of this work. Since this research project focuses on path planning, a simple approach for local map building is adopted as a support for the proposed algorithms. Hence, for the sake of simplicity, an uncoupled approach for the localization and the map building problems is adopted. First, the localization problem is addressed through sonar scan matching (Section 4.1), and then the map, with which the robot can perform path planning is generated using an Occupancy Grid Map (OGM) algorithm (Section 4.2).
4.1 scan matching
In order to generate a local map to perform path planning, the robot has to be localized, which can be easily done by means of dead-reckoning. Then, the exteroceptive robot measurements can be compounded with the robot pose to iteratively map the robot’s surroundings. Even though a local map works as a short term memory, if the dead-reckoning drifts very fast, the map may become distorted even in a very short period of time. Hence, inspired in mobile robotics domain (Mínguez et al., 2004), it is proposed an approach that uses scan matching to improve the dead-reckoning estimate. Scan matching is an interesting method since it does not need an a priori map of the environment, and is able to work in both structured and unstructured environments, the latter being the most common underwater.
Although a large literature exists reporting successful applications of scan matching with mobile robots (Lu and Milios, 1994; Mínguez et al., 2005; Montesano et al., 2005; Burguera et al., 2007), very few attempts have been done to use sonar scan matching in underwater applications. In (Castellani et al., 2004) a non-probabilistic variation of Iterative Closest Point (ICP) (Besl and McKay, 1992) is proposed to achieve on-line performance for registering multiple views captured with a 3D acoustic camera. (Silver et al., 2004) proposed the use of a particle ﬁlter to deal with the sonar noisy data. In (Hernández et al., 2009b) we proposed the MSISpIC to deal with data gathered by an AUV using an Mechanical Scanned Imaging Sonar (MSIS). This algorithm is our scan matching proposal and will be detailed in this chapter. Essentially, it is an extension of

67

68 local map building
the Probabilistic Iterative Correspondance (pIC) algorithm (Montesano et al., 2005) that takes into account the distortions in the acoustic image due to the vehicle’s motion. In (Bülow et al., 2010) a 2D scan matching method based on spectral registration of rendered scan data is presented, which has been recently extended to work with 3D sonar images (Bülow and Birk, 2011).
Scan matching can delay the drift of dead-reckoning estimation. However, it is not able to bound it over time. For this reason, recent studies have been developed to combine SLAM and sonar scan matching underwater. In (Roman and Singh, 2005), an ICP variant is used to register bathymetric sub-maps gathered with a multibeam sonar proﬁler. (Mallios et al., 2010b) used the MSISpIC to develop an algorithm that incorporates point-to-point scan matching in an Augmented State EKF (ASEKF) to bound the drift. The algorithm was tested in a dataset gathered in a man-made marina environment. With the same dataset, (Burguera et al., 2010) proposed an iterated Extended Kalman Filter (EKF) to estimate the trajectory of the AUV.
This section is organized as follows. First, Section 4.1.1 formally describes the scan matching problem. Next, Section 4.1.2 details the scan matching algorithm adopted from the mobile robotics domain to improve AUV localization. Then, Section 4.1.3 descibes the method we propose to gather full scans of the environment with the sonar sensors our vehicles are equipped with. Finally, Section 4.1.4 provides a full description of the MSISpIC, the scan matching algorithm we propose, which takes into account the uncertainties of the sensor and the dead-reckoning estimation.
4.1.1 Problem Deﬁnition
Assuming we have a robot equipped with sensors that provide an estimation of displacement through dead-reckoning as well as with a range and bearing sensor to perceive the environment, the scan matching problem can be deﬁned as follows:
Let
• Sref = {r1, r2, ..., rn} be the reference scan, a set of n measurements, represented by Cartesian points, gathered with a range and bearing sensor at the reference frame {R}.
• Snew = {n1, n2, ..., nm} be the new scan, a set of m measurements, represented by Cartesian points, gathered with a range and bearing sensor at the new reference frame {N}.
• q0 = (x0, y0, θ0) be an initial guess of the robot’s relative displacement between the two consecutive gathered scans Sref and Snew.
The goal of scan matching algorithms is to estimate the robot’s motion that maximizes the overlap between Sref and Snew, using as the initial motion q0 in order to to obtain a better estimation of the real displacement q = (x, y, θ). Figure 39 illustrates this process.

4.1 scan matching 69
+ = Scan matching
Figure 39: The scan matching problem.
4.1.2 Related Work
This section describes the ICP (Besl and McKay, 1992) and the pIC (Montesano et al., 2005) algorithms. The ICP is a well-known scan matching reference which is the base of the pIC, whereas our scan matching algorithm is based on the pIC. Both techniques have been applied with success to mobile robots which are usually equipped with laser-based range sensors that provide fast and accurate measurements. However, underwater robots use sonar-based sensors which usually gather data slower and are not as accurate as laser-based ones. The solution we propose to this problem will be detailed in Section 4.1.3
4.1.2.1 Iterative Closest Point The Iterative Closest Point (ICP) (Besl and McKay, 1992) is an algorithm originally developed for computer vision purposes. It addresses scan matching with a two step iterative process. First, at each iteration, there is an association step in which the correspondences between scans are computed using a rough displacement estimation in terms of the Euclidian distance. Next, a minimization error process is applied in order to compute a new estimation of this displacement. The process is repeated using the prior displacement estimation until convergence.
The algorithm receives as an input a reference scan Sref with points ri (where i = 1..n), a new scan Snew with points nj (where j = 1..m) and a relative displacement estimation q = (x, y, θ) between them. The goal of the ICP is to compute the corrected motion between the two scans qICP by performing the following steps at each iteration k:
1. Transform each point of Snew to the coordinate system of Sref using the current estimation qk. For each nj, compute its correspondence point cj of Sref, which is the closest point among those with a distance lower than a given threshold dmin.
cj = arg minri∈Sref { ri − qk ⊕ nj dmin}

70 local map building
Point cj is the pairing of nj if, and only if, ri − qk ⊕ nj dmin. Otherwise cj does not have a pairing in Snew. At the end of this step, the correspondence set C, compounded of tuples {cj, nj}, is obtained. C is formally deﬁned as:

C = {{cj, nj} ∈ Sref × Snew/cj = arg minri∈Sref { ri − qk ⊕ nj dmin}}
2. Compute the displacement qmin which minimizes the mean square error between C elements:

|C|

qmin = arg minqk

ci − qk ⊕ ni 2

i=1

Convergence is reached when the global alignment error between Sref and Snew for the estimated global displacement is less than a given threshold. Another convergence condition appears when the difference between the displacement estimations in two consecutive iterations is smaller than a certain threshold. If there is convergence, the estimated value qmin is returned as qICP. Otherwise, another iteration with qk+1 = qmin is required.

Although the ICP is a reference within scan matching techniques, it uses the Euclidian distance in the association step and in the minimization process. This represents a limitation since it does not take into account the sensor’s rotation.

4.1.2.2 Probabilistic Iterative Correspondence
The Probabilistic Iterative Correspondance (pIC) algorithm (Montesano et al., 2005) is a statistical extension of the ICP. The ICP does not model the uncertainty of the sensor measurements. Because of this, if the scan data is very noisy, two statistically compatible points could appear far enough, in terms of the Euclidean distance. This situation might prevent a possible association or even generate a wrong one. The pIC algorithm models the relative displacement q as well as the observed points in both scans ri and ni as random Gaussian variables (r.g.vs). Whereas the geometric ICP algorithm uses the closest point rule to ﬁnd the correspondence for a point in the new scan, the pIC algorithm ﬁrst computes the set of compatible points in terms of the Mahalanobis distance, and then the virtual expected compatible point to be used as the correspondence (Figure. 40).
The pIC algorithm is described in pseudocode in Algorithm 10. The inputs are the reference scan Sref with points ri (where i = 1..n), the new scan Snew with points nj (where j = 1..m) and the initial relative displacement estimation q with its covariance Pq. The following procedure is iteratively executed until convergence. First, the points of the new scan nj are compounded with the

4.1 scan matching 71
Y(m)

X(m)
Figure 40: pIC correspondence computation. The large ellipse contains all the statistically compatible points and the squared point represents the correspondence with its uncertainty (small ellipse).
current estimation of the robot’s displacement qk (line 5). The result cj are the points of the new scan referenced to the reference frame. Then, for each point cj, a set Aj of all the compatible points in the reference scan Sref is established using a compatibility test over the squared Mahalanobis distance:

D2M = (ri − cj)P−ij1(ri − cj)T

(4.1)

The next step consists of computing the virtual association point aj as the expectancy over the random variable deﬁned by the set Aj (line 7). To do so, it is necessary to evaluate the probability p(ri = cj) of each ri, for being the correct pairing for cj, whose error is deﬁned as a r.g.v.

eij = ri − qk ⊕ nj eij =∼ N(rˆi − qˆ k ⊕ nˆ j, Peij )

Peij = Pri + J1⊕PqJT1⊕ + J2⊕Pnj JT2⊕ where:

qk ≡ N(qˆ k, Pq)
nj ≡ N(nˆ j, Pnj ) ri ≡ N(rˆi, Pri ) J1⊕ and J2⊕ are the well-known Jacobian matrixes of the compounding operation with respect to the ﬁrst and second arguments respectively (Smith et al., 1990).

72 local map building

then p(ri = cj) = p(eij = 0) can be computed as follows:

p(eij = 0) =

feij (ri − cj) ri∈Aj feij (ri − cj)

(4.2)

where feij is the probability density function of eij r.g.v. Once aˆ j has been computed as the expectance of ri over Aj, a similar procedure can be used to estimate its uncertainty Paj before computing the error covariance Pej of the matching error (aˆ j − cˆj). Then, it is possible to estimate the displacement qˆ min which minimizes the mean square error of the Mahalanobis distance (Bar-Shalom and Fortman, 1998) between aˆ j and cˆj (line 11). This is done through the Least Squares minimization method. If there is convergence, the function returns, otherwise another iteration is required.

Algorithm 10 Probabilistic Iterative Correspondance

pIC(Sref, Snew, qˆ , Pq)

1: k ← 0

2: qˆ k ← qˆ

3: repeat

4: for j ← 1 to |Snew| do

5:

cˆj ← qˆ k ⊕ nˆ j

6:

Aj ← {ri ∈ Sref/D2M(ri, cj) χ22,α}

7:

aˆ j ← ri∈Aj rˆip(ri = cj)

8:

Paj ← ri∈Aj [(rˆi − aˆ j)(rˆi − aˆ j)T ]p(ri = cj)

9:

Pej ← Paj + J1⊕PqJT1⊕ + J2⊕Pnj JT2⊕

10: end for

11: qˆ min ← arg minq j (aˆ j − cˆj)T P−ej1(aˆ j − cˆj)

12: if Convergence() then

13:

qˆ pIC ← qˆ min

14: else

15:

qˆ k+1 ← qˆ min

16:

k++

17: end if

18: until Convergence() or k maxIterations

19: return qˆ pIC

4.1.3 Scans Generation using an MSIS
The pIC algorithm was conceived to be used with a laser range ﬁnder in structured environments. These sensors gather a full range scan of the environment almost instantaneously and thus, the displacement of the vehicle is negligible. However, in underwater robotics, commercially available scan sensors are based on acoustics. Most of these sensors have a mechanical head that rotates at ﬁxed angular steps. At each step, a beam is emitted and received, measuring ranges to the obstacles found in its trajectory. Because of this, getting a complete scan lasts few seconds while the vehicle is moving, generating deformed

4.1 scan matching 73
scans. Therefore, it is necessary to correct them taking into account the vehicle pose when the beam was grabbed.
This section describes the process of gathering a full scan, as the one expected by the pIC algorithm as the input, using the sensors of the experimental platforms used in this work. To perceive the environment an MSIS is used, and a combination of Doppler Velocity Log (DVL) and Motion Reference Unit (MRU) readings to estimate the vehicle’s motion. For a detailed explanation of the vehicles and their sensors see Chapter 5.
4.1.3.1 Perceiving the environment with an MSIS An MSIS returns a polar acoustic image composed of beams. Each beam has a particular bearing angle value and a set of intensity measurements. The angle corresponds to the orientation of the sensor head when the beam was emitted. The beam itself contains an acoustic linear image which corresponds to the intensity levels of beam’s echoes perceived by the sensor at a certain distance. The beam information is returned as an array of acoustic intensities. Figure 41 illustrates an example of the echoes strength intensity levels of one single beam according to the obstacles in its trajectory and Figure 42 shows a full example scan gathered in a water tank environment.
Figure 41: Generation of an acoustic beam. Extracted from (Ribas et al., 2010) Since the pIC algorithm is intended to work with range scans, a segmentation process to obtain range and bearing data is required. Each beam gathered is segmented using a predeﬁned threshold to compute the intensity peaks. Due to the noisy nature of the acoustic data, a minimum distance between peaks criteria is also applied. Therefore, the positions ﬁnally considered are those corresponding to high intensity values above the threshold with a minimum distance between each other. Figure 43 illustrates this process.

