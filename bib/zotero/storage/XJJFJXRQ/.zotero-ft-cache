346

IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 5, NO. 2, APRIL 2020

Motion Planning Explorer: Visualizing Local Minima Using a Local-Minima Tree
Andreas Orthey , Benjamin Frész, and Marc Toussaint

Abstract—Motion planning problems often have many local minima. Those minima are important to visualize to let a user guide, prevent or predict motions. Towards this goal, we develop the motion planning explorer, an algorithm to let users interactively explore a tree of local-minima. Following ideas from Morse theory, we deﬁne local minima as paths invariant under minimization of a cost functional. The local-minima are grouped into a local-minima tree using lower-dimensional projections speciﬁed by a user. The user can then interactively explore the local-minima tree, thereby visualizing the problem structure and guide or prevent motions. We show the motion planning explorer to faithfully capture local minima in four realistic scenarios, both for holonomic and certain non-holonomic robots.
Index Terms—Motion and Path Planning, Nonholonomic Motion Planning, Foundations of Automation.
I. INTRODUCTION
I N MOTION planning, we develop algorithms to move robots from an initial conﬁguration to a desired goal conﬁguration. Such algorithms are essential for manufacturing, autonomous ﬂight, computer animation or protein folding [17].
Most motion planning algorithms are black-box algorithms.1 A user inputs a goal conﬁguration and the algorithm returns a motion. In real-world scenarios, however, black-box algorithms are problematic. Human users cannot interact with the algorithm. There is no way to guide or prevent motions. Humans users cannot visualize the internal mechanism of the algorithm. There is no intuitive way to understand or debug the algorithm. Human users cannot predict the outcome of the algorithm. There is no way for coworkers to avoid or plan around a robot. Black-box algorithms are therefore an obstacle for having robots move in a safe, predictable and controllable way.
In an effort to make robotic algorithms visualizable, predictable and interactive, we develop the motion planning
Manuscript received September 10, 2019; accepted November 23, 2019. Date of publication December 9, 2019; date of current version December 20, 2019. This letter was recommended for publication by Associate Editor D. Halperin and Editor N. Amato upon evaluation of the reviewers’ comments. This work was supported by a grant from the Alexander von Humboldt Foundation. (Corresponding author: Andreas Orthey.)
A. Orthey and B. Frész are with the Institute of Parallel and Distributed Systems, University of Stuttgart, 70174 Stuttgart, Germany (e-mail: andreas. orthey@gmx.de; b.fresz@gmx.de).
M. Toussaint is with the Institute of Parallel and Distributed Systems, University of Stuttgart, 70174 Stuttgart, Germany, and also with the Max Planck Institute for Intelligent Systems, 70569 Stuttgart, Germany (e-mail: marc.toussaint@informatik.uni-stuttgart.de).
Digital Object Identiﬁer 10.1109/LRA.2019.2958524 1We call an algorithm a black-box algorithm whenever the internal mechanism is hidden from the user [1].

explorer. Using the planning explorer, we enumerate and visualize local minima. Using ideas from Morse theory [21], we deﬁne a local minimum as a path which is invariant under minimization of a cost functional. To each local minimum we can associate an equivalence class, the equivalence class of all paths converging to the local minimum.
Using this equivalence relation, we utilize a ﬁber bundle construction—a sequence of admissible lower-dimensional projections [25]—to organize the local-minima into a tree. Since the number of leaves of this tree is usually countable inﬁnite, we do not compute the tree explicitly, but let users interactively explore the tree.
This local-minima tree is primarily a tool to visualize the problem structure. However, we believe it to be more widely applicable. The tree is a visual guide to the (topological) complexity of the problem [31]. The tree visualizes where a deformation algorithm [34] converges to. The tree allows us to interact with the algorithm, useful for factory workers guiding their robot or the control of computer avatars. The tree can be used to give high-level instructions to a robot—crucial when bandwidth is limited. The tree provides alternatives for efﬁcient replanning [5]. Finally, the tree can be a source of symbolic representations [33].
A. Contributions
We make three original contributions 1) We propose a new data structure, the local-minima tree,
to enumerate and organize local minima 2) We propose an algorithm, the motion planning explorer,
which creates a local-minima tree from input by a user 3) We demonstrate the performance of the motion planning
explorer on realistic planning problems and on pathological environments Our algorithm requires, for each robot, the speciﬁcation of a ﬁber bundle by a user. We can then handle any holonomic robotic system [17] and provide a ﬁrst generalization to non-holonomic systems.
II. RELATED WORK
We can visualize a motion planning problem by visualizing its decomposition. However, there is no clear consensus among researchers on the notion of decomposition.
Often the problem is decomposed topologically [9]. In a topological decomposition, we partition the pathspace into homotopy classes, sets of paths continuously deformable into each other [22] (See Fig. 1 Left). We can compute homotopy classes by computing an H-signature of paths [4] which counts, for each obstacle, the number of times a path crosses a line emanating from that obstacle. This can be generalized to higher

2377-3766 © 2019 IEEE. Personal use is permitted, but republication/redistribution requires IEEE permission. See http://www.ieee.org/publications_standards/publications/rights/index.html for more information.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on September 16,2022 at 11:04:03 UTC from IEEE Xplore. Restrictions apply.

ORTHEY et al.: MOTION PLANNING EXPLORER: VISUALIZING LOCAL MINIMA USING A LOCAL-MINIMA TREE

347

Fig. 1. Left: Homotopic paths in 2D. Right: Distinct local minima which are homotopic in 3D.

1) Topological Data Analysis: In topological data analysis [6], we use structures from algebraic topology (e.g. simplicial complices [8]) to model and visualize the topology of high-dimensional data. Our approach differs by computing paths directly (not modelling the topology) and by making the visualization interactive.
2) Inﬁnite-Dimensional Morse Theory: The goal of inﬁnitedimensional Morse theory [21] is studying solution spaces of optimization problems and investigating critical solution paths [20]. Our approach can be seen as applying Morse theory to motion planning while ignoring second-order behavior of the paths.

dimensions, where we measure how often a path passes through holes in conﬁguration space [3]. If the conﬁguration space is not too high-dimensional, we can also compute homotopy classes using simplicial complices [28] or lower-dimensional task projections [29].
Topological decompositions, however, do not adequately capture the intricate geometry of conﬁguration space constraints and are often computationally inefﬁcient. Many alternative definition have been proposed to obtain computationally-efﬁcient homotopy-like decompositions. Examples include digital homotopy relations [30], K-order deformability [12] and convertibility of paths [24].
However, computationally-efﬁcient homotopy decompositions fail to give a proper pathspace partitioning. All previously named efﬁcient decompositions are violating the transitivity relation2 and do not constitute an equivalence relation. This makes it difﬁcult to have clear lines of demarcation between path subsets. It is also unclear how to visualize overlapping path sets.
We believe a more appropriate decomposition is the costfunction decomposition. In a cost-function decomposition, we group paths together whenever they converge under optimization to the same local minimum. With such an approach, we can leverage optimization methods for computational efﬁciency and compute partitions of the pathspace. In Fig. 1 (Right) we show a partition into two local-minima classes (ignoring minima wrapping around the obstacle).
The computation of local minima of cost functions belongs to the topic of optimal motion planning [14]. In optimal motion planning we like to ﬁnd the global cost-function minimum. Recently, several sampling-based algorithms have been proposed which are asymptotically optimal, i.e. we will ﬁnd the global optimum if time goes to inﬁnity [14]. Recent extensions of those algorithms exploit graph sparsity [7], improve upon convergence time [13] and solve kinodynamic problems [19].
However, most optimal planning algorithms will ﬁnd only the global optimal path, but not necessarily all local optimal paths. Our work differs by interactively computing local minima and arranging them into a local-minima tree. To build the tree, we require ﬁber bundle simpliﬁcations of the conﬁguration space [25]. Those simpliﬁcations help us to organize the local-minima of a planning problem and visualize its path space.
Visualization of path spaces is closely related to topological data analysis and Morse theory. We brieﬂy discuss those approaches and how they differ from our approach.
2Transitivity holds for a pathspace decomposition if whenever a path a is equivalent to a path b, and b is equivalent to a path c, then a is equivalent to c.

III. BACKGROUND
Let (X, φ) be the planning space, consisting of the conﬁguration space X of a robot and the constraint function φ : X → {0, 1} which on input x ∈ X outputs zero when x is
constraint-free and one otherwise. We extend φ such that on input of subsets U ⊆ X outputs zero when at least one x ∈ U
is constraint-free and to one otherwise. The constraint function deﬁnes the free conﬁguration space Xf = {x ∈ X | φ(x) = 0}. Given an initial conﬁguration xI ∈ Xf and a goal conﬁguration xG ∈ Xf, we are interested in ﬁnding a path in Xf connecting them. We call (Xf, xI , xG) a motion planning problem [25].
The space of solutions to a planning problem is given by its path space. The path space P is the set of continuous paths p : I → Xf from I = [0, 1] to Xf such that p(0) = xI and p(1) = xG. We equip the pathspace P with a cost functional c : P → R≥0 on P . Examples of cost functionals are minimum-length, minimum-energy, or maximum-clearance.

A. Admissible Fiber Bundles
We can often simplify planning spaces using ﬁber bundles [25]. A ﬁber bundle is a tuple (X, Y, π, πφ) consisting of a mapping

π:X →Y

(1)

which maps open sets to open sets and a mapping πφ : φ → φY , which map a planning space (X, φ) to a lower-dimensional space (Y, φY ). We say that πφ is admissible if the admissibility condition φY (y) ≤ φ(π−1(y)) holds for all y ∈ Y , whereby we call π−1(y) the ﬁber of y in X. We then call π an admissible
lower-dimensional projection, X the bundle space, and Y the
quotient space of X under π [18].
Often it is advantageous to deﬁne chains of K ﬁber bundles (Xk, Xk−1, πk, πφk ) with admissible mappings

{πk : Xk → Xk−1}Kk=1

(2)

such that XK = X and the constraint functions are admissible such that φk−1(xk−1) ≤ φk(πk−1(xk−1)) for all xk−1 ∈ Xk−1. Admissible ﬁber bundles have been shown to be a generalization of constraint relaxation, a source of admissible heuristic and can reduce planning time by up to one order of magnitude [25].
There are multiple ways of simplifying a conﬁguration space to construct a ﬁber bundle. We can often construct simpler robotic system by removing constraints, through nesting lower degree-of-freedom (dof) robots [26], removing links [2] or shrinking obstacles [10].

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on September 16,2022 at 11:04:03 UTC from IEEE Xplore. Restrictions apply.

348

IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 5, NO. 2, APRIL 2020

Fig. 2. Car in 2D with conﬁguration space SE(2). The planning problem can be decomposed into four parts.
If the projection mappings π and πφ are obvious from the context, we will often denote the ﬁber bundle simply as X → Y . As an example, we write SE(2) → R2 for the car in Fig. 2, whereby we mean that the car has been simpliﬁed by a nested disk. The nested disk is an abstraction of the car, removing the orientation. The mapping π in that case maps position and orientation onto position, and φR2 is zero whenever the disk is collision-free.
IV. METHOD
In this section, we describe the local-minima tree. First, we deﬁne local minima as paths which are invariant under minimization of a cost functional. We then associate an equivalence class to each local minimum, consisting of all paths converging to the same local minimum. Using this equivalence relation, we then construct a local-minima space. To visualize the local-minima space, we ﬁnally group local-minima into a tree using the ﬁber bundle construction [25].
A. Assumptions
Let (Xf, xI , xG) be a motion planning problem, P its path space, and c : P → R≥0 be a cost functional on the pathspace. We assume that there exists a path optimization algorithm that we represent as a mapping fc : P → P , which takes any path and transforms the path into a path having a locally minimal cost. We make no further assumptions about the optimizer, such as that the output optimum is close to the initialization. Instead, our notion of path equivalence will be relative to a given fc. Further, we let a user provide an admissible ﬁber bundle XK → XK−1 → · · · → X0 with XK = X, which simpliﬁes the conﬁguration space X. The ﬁber bundle implicitly deﬁnes lower-dimensional projections πK , . . . , π1.

B. Local-Minima Space

The minimization function fc partitions3 the pathspace. The partition is given by an equivalence relation we call path equiva-
lence. Given the path-equivalence, we can construct the quotient
of the pathspace under path-equivalence, which we call the
local-minima space.
Let us start by deﬁning path-equivalence. If two paths converge, under the optimizer fc of the cost c, to the same path, we say they are path-equivalent. Formally, given two paths p, p ∈ P , we say that they are path-equivalent, written as p ∼fc p , if

fc(p) = fc(p )

(3)

It is straightforward to check that path-equivalence is an equivalence relation (i.e. reﬂexive, symmetric, transitive). The optimizer fc therefore partitions the pathspace [22].
To better understand this partition, we construct the localminima space as the quotient space of all equivalence classes of P under fc, denoted as

Q = P/ ∼fc

(4)

Elements of the space Q are equivalence classes of paths. We will, however, represent each equivalence class by the path which is invariant under minimization of the cost. We call those paths local minima.
To simplify matters, we will only consider simple local minima. A simple local minimum is a local minimum without self-intersections. Simple paths are easier to compute and often capture all important local minima in a problem. However, we note that there are certain pathological cases, where non-simple paths are required to solve the problem [26].

C. Sequential Projections of the Local-Minima Space

To efﬁciently represent the local-minima space, we propose
to sequentially partition the space using the ﬁber bundle projec-
tions. This works as follows: Two distinct local minima of Q are projected onto a quotient-space Xk using the mapping πk. We then consider them to be projection-equivalent, when, under
minimization fc, they converge to the same path. More formally, given two local minima q, q ∈ Q, we say that
they are projection-equivalent, written as q ∼{fc,πk} q , if

fc(πk(q)) = fc(πk(q ))

(5)

Projection-equivalence is again an equivalence relation and
therefore partitions the local-minima space. We denote the
quotient of Q under the projection-equivalence as QK−1. We then iterate this process for each projection mapping. Thus, given an admissible ﬁber bundle XK → XK−1 → · · · → X0, we construct a sequence of local-minima spaces QK , . . . , Q0 with QK = Q. In other words, the local-minima space Qk−1 is obtained from Qk as the quotient-space

Qk−1 = Qk/ ∼{fc,πk}

(6)

Elements of Qk−1 are equivalence classes of local minima of Qk. We will, however, represent each equivalence class by the path to which all its elements (after projection) will converge to.

3A partition of a set X is a family of disjoint non-empty sets such that every element of X is in exactly one such set.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on September 16,2022 at 11:04:03 UTC from IEEE Xplore. Restrictions apply.

ORTHEY et al.: MOTION PLANNING EXPLORER: VISUALIZING LOCAL MINIMA USING A LOCAL-MINIMA TREE

349

Algorithm 1: Motion Planning Explorer (xI , xG, X1, . . . ,
XK , N, tmax, δS, ).
1: T = ∅ 2: G1, S1, . . . , GK , SK = INITROADMAPS(X1, . . . , XK ) 3: while True do 4: qk = SELECTLOCALMINIMA(T ) 5: UPDATEMINIMATREE(T, qk, Gk, Gk+1, Sk+1) 6: end while 7: return ∅

Fig. 3. 2D manipulator with environment which can be decomposed into three parts. Note that the three shown paths cannot be deformed into each other.
D. Local-Minima Tree
Finally, we use the sequence of local-minima spaces to construct the local-minima tree. The tree consist of all elements of Q0, . . . , QK as nodes. Two nodes are connected by a directed edge, if the ﬁrst node is a local minimum qk of Qk, the second node is a local minimum qk+1 of Qk+1, and we have fc(πk+1(qk+1)) = qk. Additionally, we add one empty-set root node which is connected to every element of Q0.
Note that a complete description of the local-minima tree is only possible in trivial cases. In any real-world scenario, we can only hope to visualize certain subsets of the tree.
E. Examples
To make the preceding discussion concrete, we visualize the local-minima tree for two examples.
First, we use a free-ﬂoating 3-dof planar car with ﬁber bundle SE(2) → R2, which represents the removal of orientation by projection onto a circular disk. The environment is shown in Fig. 2(c-f) and the ﬁber bundle is shown in Fig. 2(a). The planning problem is to ﬁnd a path to go from the green initial conﬁguration to the red goal conﬁguration. We observe that there are four simple local-minima, depending on if the car is going through the top or bottom slit, and going forward or backward. The two top slit paths are projection equivalent and we group them together. The same for the bottom paths. The local-minima tree is then shown in Fig. 2(b). Note that we ignore non-simple local-minima which would occur when moving the car in a circle around the middle obstacle.
Second, we use a ﬁxed-based 2-dof manipulator robot with ﬁber bundle S1 × R1 → S1 (S1 is the circle space), which represents the removal of the last link. The environment is shown in Fig. 3(c-e) (obstacle in grey) with ﬁber bundle shown in Fig. 3(a). There are three simple local-minima, two going clockwise below (c) and above (d) the obstacle, and one going counterclockwise (e). We group them according to their projection-equivalence as counterclockwise and clockwise, respectively. The localminima tree is shown in Fig. 3(b).

V. ALGORITHM
To compute the local-minima tree, we develop the motion planning explorer (Algorithm 1). The motion planning explorer takes as input a planning problem (Xf, xI , xG), a minimization method fc and a ﬁber bundle represented as a sequence of quotient spaces X0, . . . , XK with XK = X. The explorer depends on four parameters, namely N ∈ N, the maximum number of local-minima to display, tmax ∈ R>0, the maximum time to sample in one iteration, δS ∈ R>0, the fraction of space to be visible for the underlying sparse roadmap and ∈ R≥0, the -neighborhood of a local minimum to sample. Given the input, we return a browsable local-minima tree T . A user can navigate this tree by clicking on local minima and by collapsing or expanding the minimum, similar to how one navigates a unix directory structure.
Our algorithm consists of an alternation of two phases. In phase one (Line 1.4), a human user can navigate the localminima tree and select one local minima. In the beginning the user has only one choice, selecting the root node (the empty-set minimum). In the second phase (Line 1.5), the user presses a button and the algorithm uses the selected local minimum qk on Qk to ﬁnd all local minima on Qk+1 which, when projected, would be equivalent to qk. For each local minimum we ﬁnd, we add a directed edge from qk to the local minimum. Note that we construct the local-minima tree in a top-down fashion, which differs from the bottom-up description in Sec. IV. This construction is more computationally efﬁcient, but we might create spurious local-minima, which are local minima which do not have any children. In other words, there are no local-minima which, when projected, would be equivalent to the spurious local minimum. This second phase is run for a predetermined maximum timelimit tmax, and can be run multiple times until the user has found sufﬁciently many local minima.
For phase one of the explorer, we develop a graphical user interface (GUI). The GUI is shown in Fig. 4, where we show the local minima tree (1), the last button pressed (2), the initial conﬁguration (3), the goal conﬁguration (4), and a conﬁguration along a local minimum (environment is hidden to remove distractions). Pressing the button left or right switches local minima on the same level. Pressing up collapses the current local minimum and displays the local minimum on the next lower-dimensional quotient space, which is obtained by projection and subsequent optimization of the current local minimum. Pressing down expands the current local minimum. Pressing the button u executes the current local minimum path by sending it to the robot and pressing the button w starts the search for more local minima.
In the second phase (Algorithm 2) we update the minima tree by performing two steps. First, we take the selected local

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on September 16,2022 at 11:04:03 UTC from IEEE Xplore. Restrictions apply.

350

IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 5, NO. 2, APRIL 2020

Algorithm 4: GrowRoadmap(Xk+1, qk, Gk, Gk+1).
1: xrand ← SAMPLEFIBER(Xk+1, Gk, qk, ) 2: xnear ← NEAREST(xrand, Gk+1) 3: xnew ← CONNECT(xnear, xrand, Gk+1) 4: Sk+1 ← ADDCONDITIONAL(xnear, Sk+1, δS )

Fig. 4. Motion Planning Explorer GUI: (1) local-minima tree depiction. Columns show ﬁber bundle level, number of nodes on level and nodes of tree, respectively. (2) Last button pressed by user. (3) Initial (green) conﬁguration on quotient-space (non-transparent disk) and on bundle space (transparent). (4) Same for goal (red) conﬁguration. (5) Local minima selected by user and highlighted in tree.

Algorithm 2: UpdateMinimaTree(T, qk, Gk, Gk+1, Sk+1).

1: while ¬PTC(tmax) do 2: GROWROADMAP(Xk+1, qk, Gk, Gk+1, Sk+1)
3: end while

4: {q1, . . . , qM } ← ENUMERATEPATHS(Sk+1)

5: Qnew ← ∅

6: for each q in {q1, . . . , qM } do

7: if ¬ MINIMAEXISTS(q, Qnew) then

8:

Qnew ← Qnew ∪ q

9: end if

10: if SIZE(Qnew) ≥ N then 11: break

12: end if

13: end for

14: ADDMINIMATOTREE(Qnew, T )

Algorithm 3: MinimaExists(q, Qnew).
1: for each q in Qnew do 2: if ISVISIBLE((q, q )) then 3: return True 4: end if 5: end for 6: return False

minimum qk on Qk and grow a sparse graph Sk+1 on the space Xk+1 (or XK if k = K) biased towards qk. Second, we compute up to N local-minima from the sparse graph Sk+1. We ﬁrst describe both steps in the case of a holonomic robot, and then
describe the modiﬁcations in the non-holonomic case.
In the ﬁrst step, we grow the sparse graph Sk+1 on Xk+1 for up to tmax seconds (or some other Planner Terminate Condition (PTC)). The algorithm GrowRoadmap (Line 2.2) is further de-

tailed in Algorithm 4, which closely follows the Quotient-Space roadMap Planner (QMP) algorithm [26]. It differs from QMP by computing both a dense graph Gk+1 and a sparse graph Sk+1. To build the graphs, we ﬁrst sample a conﬁguration on the graph Gk biased towards an -neighborhood of qk. This conﬁguration indexes a ﬁber through the inverse mapping πk−1. We then sample this ﬁber to obtain a conﬁguraton on Xk+1 (Line 4.1), compute the nearest conﬁguration on Gk+1 (Line 4.2) and connect if possible (Line 4.3). The new conﬁguration is then conditionally added to the sparse graph (Line 4.4). Our implementation utilizes previous work from the Sparse Roadmap Spanners (SPARS) algorithm4 [7]. The sparse graph Sk+1 utilizes the parameters δS which determines the maximum visibility radius of a conﬁguration. This method biases sampling towards paths which, when projected onto Xk, will be projection-equivalent to qk. If we ﬁnd a path not projection-equivalent to qk, we ignore the path.
In the second step, we enumerate M ≤ 2N paths on Sk+1 (Line 2.4). Those paths are found using a depth-ﬁrst graph search on Sk+1. For each path found, we use the optimizer fc to let the path converge to the nearest local minimum. We then try to add this path to a set of local minima paths (Line 2.6 to 2.13). The path is added if it is not visible from any path in the set (Line 2.7). We implement the visibility function following the algorithm by [12]. Another option would be to compute a distance between two paths. However, we found this to not work well with the particular minimization method we used in the demonstrations. Note that other minimization methods might require different methods to check convergence.
In the case of a non-holonomic robot, we replace the function GrowRoadmap using an iteration of kinodynamic RRT [15]. We then populate the sparse graph only with the current shortest path to the goal. This allows us to ﬁnd a dynamically feasible path given a geometrically feasible path on the quotient space (using the path bias through qk). However, for this work we did not implement an optimizer for dynamical systems and therefore can only return a single non-optimal path. In future work we need to use a sparse optimal graph spanner for kinodynamic systems like [19] and dynamical optimization functions for nonholonomic systems like [16].
Once all simple paths have been enumerated, and the local minima saved, we stop the phase, add all found local minima to the local-minima tree (Line 2.14 ) and display them to the user in the GUI. Then we return to phase one.
The motion planning explorer has been implemented in C++ and uses the Klampt library [11] for simulation and visualisation, and the Open Motion Planning Library (OMPL) [32] for roadmap computation and ﬁber bundle projection. The implementation is freely available at github.com/aorthey/MotionPlanningExplorerGUI.
4In particular, we add a conﬁguration to the sparse roadmap whenever the conﬁguration increases visibility, increases connectivity or constitutes a useful cycle.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on September 16,2022 at 11:04:03 UTC from IEEE Xplore. Restrictions apply.

ORTHEY et al.: MOTION PLANNING EXPLORER: VISUALIZING LOCAL MINIMA USING A LOCAL-MINIMA TREE

351

Fig. 5. Left: 6-dof Drone Middle: 7-dof KUKA LWR Right: 34-dof PR2.

TABLE I TIME (S) TO GENERATE THE LOCAL-MINIMA TREE IN THE
DEMONSTRATION CASES SHOWN IN VIDEO
VI. DEMONSTRATIONS We demonstrate the motion planning explorer on four realistic and two pathological scenarios, using the following setup. We use a minimal-length cost function and a path optimizer implemented in OMPL.5 For each conﬁguration space, we manually choose an admissible ﬁber bundle. To choose the ﬁber bundle, we use a heuristic considering runtime and meaningfulness of local-minima classes. In each scenario, we have used the parameters N = 7 (the maximum amount of visualized paths), the sparsity parameter δS = 0.1 (the fraction of space visible from a vertex). We further set to 0.1 times the measure of the space, and we have adjusted tmax to be between 1s to 10 s. We perform each visualization on a 4 × 2.50 GHz processor laptop using 8 GB Ram and operating system Ubuntu 16.04. We do not compare to existing methods, because we are not aware of any other algorithm which can (1) visualize local optima for any motion planning problem and (2) let a human user interact with it. For the four scenarios we have summarized the runtimes in Table I. The runtimes show the time to compute the local minima space Q0 (Column 1), and the time to compute the remaining
5See ompl::geometric::PathSimpliﬁer.

local minima spaces Q>0 (Column 2) together with their sum (Column 3). Note that those times do not include the interaction by the user, and might differ depending on which minima have been selected.
The ﬁrst scenario is a drone in a forest. The conﬁguration space is simpliﬁed using a ﬁber bundle SE(3) → R3, corresponding to a sphere nested inside the drone. The outcome is shown in Fig. 5 (Left). The upper Figure shows seven local minima on the quotient space (magenta). Note that the quotient space is topologically trivial, but computing homotopical deformations would be computationally inefﬁcient [12].
The user selects the green path in phase one. We then compute local minima on the conﬁguration space which project onto this path. In this case we ﬁnd one single local-minima on SE(3), which we then execute.
Second, we use a robotic arm (Fig. 5 Middle) in an environment with a large coffee machine which has a visible geometric protrusion. The conﬁguration is simpliﬁed using the ﬁber bundle R7 → R3, obtained by removing the ﬁrst three links of the robotic arm. The explorer ﬁnds two local minima on the quotient space which belong to a motion below the protrusion and above the protrusion, respectively. Finally, the user selects the path going above the protrusion, and the explorer ﬁnds three local minima which belong to different rotations of the manipulator around its axes.
Third, we use the PR2 robot in a navigation scenario. We use a ﬁber bundle SE(2) × R31 → SE(2) × R7 → R2, which corresponds to the removal of arms, and upper torso, respectively. On the lowest-dimensional quotient space, we ﬁnd three local minima (Fig. 5 Right), which correspond to going left or right around the table, and one going underneath the table. Note that the path underneath the table is spurious (see Section V). The computation of the ﬁrst three local minima takes 4.61 s, while the remaining local-minima take together 292 s. This high runtime results from the high-dimensionality of the original conﬁguration space combined with a possible narrow

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on September 16,2022 at 11:04:03 UTC from IEEE Xplore. Restrictions apply.

352

IEEE ROBOTICS AND AUTOMATION LETTERS, VOL. 5, NO. 2, APRIL 2020

Fig. 6. Dubin’s airplane with constant forward velocity of 0.5 ms−1 and bounds on ﬁrst derivative of yaw and pitch of ±0.1 ms−1. The dynamics are modelled as a driftless airplane [27].

conﬁguration. Between the conﬁgurations we place a lattice with openings slightly larger than the radius of the ball. All local minima through the lattice have a neighborhood in pathspace with a vanishingly small measure. Our algorithm, however, rarely detects those minima, because the probability of ﬁnding samples inside an opening is smaller than ﬁnding samples above or below the lattice. Therefore, the algorithm usually ﬁnds minima with a higher cost going around the lattice.
In the second scenario (Fig. 7 Right), we place a spherical obstacle between the initial and goal conﬁguration of the ball (As described by Karaman and Frazzoli [14]). The number of local minima is uncountable inﬁnite. Our algorithm, however, can only ﬁnd a ﬁnite number of local minima and is unable to describe the complete uncountable set.

Fig. 7. Limitations: (A) low-cost small-measure local-minima are often ignored in favor of high-cost but large-measure local-minima. (B) Only a countable number of paths is found from an uncountable number of local minima.
passage occurring when the robot has to traverse the corner of the table.
In the last scenario, we visualize the ﬂight paths of dubin’s airplane [17] through an archway. Dubin’s airplane is a rigid body in 3D with velocity constraints such that it ﬂies at a constant forward velocity of +0.5 ms−1 and has bounds on the ﬁrst derivative of yaw and pitch of ±0.1 ms−1. The ﬁber bundle is SE(3) × R6 → R3, which corresponds to the removal of dynamical constraints and orientation. We see that the algorithm ﬁnds two distinct local minima on the quotient space, which corresponds to going through or around the archway. We then select the local minimum going through the archway and the algorithm ﬁnds a dynamically feasible path (Fig. 6 Right).
This demonstrates that our method can be extended to dynamical systems, even when the shortest path of the geometrical system is neither dynamically feasible nor near to a dynamically feasible path. However, as detailed in Sec. V, we currently do not have an adequate optimization function to compute a dynamically optimal path. The resulting dynamical path is therefore non-optimal.
A. Pathological Scenarios and Limitations
While the motion planning explorer works well on realistic scenarios, it might not work well on pathological cases. To test this, we demonstrate the performance on two scenarios which have been crafted to break the algorithm.
In the ﬁrst scenario (Fig. 7 Left), we need to move a ball with conﬁguration space R3 from an initial (green) to a goal (red)

VII. CONCLUSION
We introduced the motion planning explorer, an algorithm taking a planning problem as input and computing a local-minima tree. Local minima are deﬁned as paths which are invariant under minimization of a cost functional. The local-minima are grouped into a tree, where two paths are grouped together if they are projection-equivalent under a lower-dimensional ﬁber bundle projection. We showed that the resulting local-minima tree faithfully captures the structure of holonomic and certain non-holonomic problems.
The implementation of the local-minima tree has, however, three limitations. First, we restrict computation to N simple paths, which makes the tree non-exhaustive. We could alleviate this by letting the user add additional local-minima and by enumerating non-simple paths. Second, the runtime is sometimes prohibitive for real-time application. We believe this could be addressed by speciﬁcally tailored hardware [23], code optimization and a sampling-bias towards narrow passages. Third, the construction of the tree depends on pre-speciﬁed lower-dimensional projections. We could remove this dependency by enumerating all projections [25] and use a speciﬁc projection only if it will group at least two local minima together.
Most importantly, however, the computation time spent constructing the local-minima tree is negligible compared to having a tool which allows us to visualize, debug and interact with a planning problem.
ACKNOWLEDGMENT
The authors would like to thank the anonymous reviewers for clarifying the connection to Morse theory. They would also like to thank M. Moll and Z. Kingston for independent code reviews of Fiber Bundle Projections and the website TurboSquid for providing three-dimensional models.
REFERENCES
[1] “Black box.” [Online]. Available: https://www.merriam-webster.com/ dictionary/black box. Accessed on: Nov. 23, 2019.
[2] O. B. Bayazit, D. Xie, and N. M. Amato, “Iterative relaxation of constraints: A framework for improving automated motion planning,” in Proc. IEEE Int. Conf. Intell. Robots Syst., 2005, pp. 3433–3440.
[3] S. Bhattacharya and R. Ghrist, “Path homotopy invariants and their application to optimal trajectory planning,” Ann. Math. Artif. Intell., vol. 84, no. 3/4, pp. 139–160, 2018.
[4] S. Bhattacharya, M. Likhachev, and V. Kumar, “Topological constraints in search-based robot path planning,” Auton. Robots, vol. 33, no. 3, pp. 273– 290, 2012.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on September 16,2022 at 11:04:03 UTC from IEEE Xplore. Restrictions apply.

ORTHEY et al.: MOTION PLANNING EXPLORER: VISUALIZING LOCAL MINIMA USING A LOCAL-MINIMA TREE

353

[5] O. Brock and O. Khatib, “Elastic strips: A framework for motion generation in human environments,” Int. J. Robot. Res., vol. 21, pp. 1031–1052, 2002.
[6] G. Carlsson, “Topology and data,” Bull. Amer. Math. Soc., vol. 46, no. 2, pp. 255–308, 2009.
[7] A. Dobson and K. E. Bekris, “Sparse roadmap spanners for asymptotically near-optimal motion planning,” Int. J. Robot. Res., vol. 33, no. 1, pp. 18–47, 2014.
[8] H. Edelsbrunner and J. Harer, Computational Topology: An Introduction. Providence, RI, USA: Amer. Math. Soc., 2010.
[9] M. Farber, “Topology of random linkages,” Algebr. Geometric Topology, vol. 8, pp. 155–171, 2008.
[10] P. Ferbach and J. Barraquand, “A method of progressive constraints for manipulation planning,” Trans. Robot., vol. 13, no. 4, pp. 473–485, 1997.
[11] K. Hauser, “Robust contact generation for robot simulation with unstructured meshes,” in Proc. Int. J. Robot. Res., 2016, pp. 357–373.
[12] L. Jaillet and T. Siméon, “Path deformation roadmaps: Compact graphs with useful cycles for motion planning,” Int. J. Robot. Res., vol. 27, pp. 1175–1188, 2008.
[13] L. Janson, E. Schmerling, A. Clark, and M. Pavone, “Fast marching tree: A fast marching sampling-based method for optimal motion planning in many dimensions,” Int. J. Robot. Res., vol. 34, no. 7, pp. 883–921, 2015.
[14] S. Karaman and E. Frazzoli, “Sampling-based algorithms for optimal motion planning,” Int. J. Robot. Res., vol. 30, no. 7, pp. 846–894, 2011.
[15] J. J. Kuffner and S. M. LaValle, “RRT-connect: An efﬁcient approach to single-query path planning,” in Proc. IEEE Int. Conf. Robot. Autom., 2000, vol. 2, pp. 995–1001.
[16] F. Lamiraux, D. Bonnafous, and O. Lefebvre, “Reactive path deformation for nonholonomic mobile robots,” IEEE Trans. Robot., vol. 20, no. 6, pp. 967–977, Dec. 2004.
[17] S. M. LaValle, Planning Algorithms. Cambridge, U.K.: Cambridge Univ. Press, 2006.
[18] J. Lee, Introduction to Topological Manifolds, vol. 202. Berlin, Germany: Springer, 2010.
[19] Y. Li, Z. Littleﬁeld, and K. E. Bekris, “Asymptotically optimal samplingbased kinodynamic planning,” Int. J. Robot. Res., vol. 35, pp. 528–564, 2016.

[20] J. Milnor, “Morse theory,” Ann. Math. Studies, vol. 51, 1963. [21] M. Morse, The Calculus of Variations in the Large (Colloquium Publica-
tions), vol. 18. Providence, RI, USA: Amer. Math. Soc., 1934. [22] J. Munkres, Topology. London, U.K.: Pearson, 2000. [23] S. Murray, W. Floyd-Jones, Y. Qi, D. J. Sorin, and G. Konidaris, “Robot
motion planning on a chip,” in Proc. Robot.: Sci. Syst., 2016. [Online]. Available: http://www.roboticsproceedings.org/rss12/p04.html [24] D. Nieuwenhuisen and M. H. Overmars, “Useful cycles in probabilistic roadmap graphs,” in Proc. IEEE Int. Conf. Robot. Autom., 2004, vol. 1, pp. 446–452. [25] A. Orthey and M. Toussaint, “Rapidly-exploring quotient-space trees: Motion planning using sequential simpliﬁcations,” in Proc. Int. Symp. Robot. Res., 2019. [26] A. Orthey, A. Escande, and E. Yoshida, “Quotient-space motion planning,” in Proc. IEEE Int. Conf. Intell. Robots Syst., 2018, pp. 8089–8096. [27] A. Orthey, O. Roussel, O. Stasse, and M. Taïx, “Motion planning in irreducible path spaces,” Robot. Auton. Syst., vol. 109, pp. 97–108, 2018. [28] F. T. Pokorny, M. Hawasly, and S. Ramamoorthy, “Topological trajectory classiﬁcation with ﬁltrations of simplicial complexes and persistent homology,” Int. J. Robot. Res., vol. 35, no. 1–3, pp. 204–223, 2016. [29] F. T. Pokorny, D. Kragic, L. E. Kavraki, and K. Goldberg, “Highdimensional winding-augmented motion planning with 2D topological task projections and persistent homology,” in Proc. IEEE Int. Conf. Robot. Autom., 2016, pp. 24–31. [30] E. Schmitzberger, J.-L. Bouchet, M. Dufaut, D. Wolf, and R. Husson, “Capture of homotopy classes with probabilistic road map,” in Proc. IEEE Int. Conf. Intell. Robots Syst., 2002, vol. 3, pp. 2317–2322. [31] S. Smale, “On the topology of algorithms, I,” J. Complexity, vol. 3, pp. 81– 89, 1987. [32] I. A. S¸ ucan, M. Moll, and L. Kavraki, “The open motion planning library,” IEEE Robot. Autom. Mag., vol. 19, no. 4, pp. 72–82, Dec. 2012. [33] M. Toussaint and M. Lopes, “Multi-bound tree search for logic-geometric programming in cooperative manipulation domains,” in Proc. IEEE Int. Conf. Robot. Autom., 2017, pp. 4044–4051. [34] M. Zucker et al., “CHOMP: Covariant Hamiltonian optimization for motion planning,” Int. J. Robot. Res., vol. 32, pp. 1164–1193, 2013.

Authorized licensed use limited to: Technische Hochschule Ingolstadt. Downloaded on September 16,2022 at 11:04:03 UTC from IEEE Xplore. Restrictions apply.

