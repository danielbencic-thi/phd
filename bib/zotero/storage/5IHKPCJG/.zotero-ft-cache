A Homotopy Method for Motion Planning.
Shenyu Liu and Mohamed Ali Belabbas∗∗

arXiv:1901.10094v1 [math.OC] 29 Jan 2019

Abstract
We propose a novel method for motion planning and illustrate its implementation on several canonical examples. The core novel idea underlying the method is to deﬁne a metric for which a path of minimal length is an admissible path, that is path that respects the various constraints imposed by the environment and the physics of the system on its dynamics. To be more precise, our method takes as input a control system with holonomic and non-holonomic constraints, an initial and ﬁnal point in conﬁguration space, a description of obstacles to avoid, and an initial trajectory for the system, called a sketch. This initial trajectory does not need to meet the constraints, except for the obstacle avoidance constraints. The constraints are then encoded in an inner product, which is used to deform (via a homotopy) the initial sketch into an admissible trajectory from which controls realizing the transfer can be obtained. We illustrate the method on various examples, including vehicle motion with obstacles and a two-link manipulator problem.

1 Introduction

A fundamental problem in robotic motion planning is to ﬁnd a trajectory which meets the various constraints stemming from the system’s dynamics, which can be of holonomic or non-holonomic type, and obstacle avoidance constraints, which include constraints on the magnitude of some of the variables describing the system (e.g., a maximal turning radius), or obstacles present in physical space. We propose here a new method to ﬁnd a trajectory which takes into account all the above constraints–we call such a trajectory admissible–and illustrate its performance on several examples. The method is a homotopy method: given an initial state and a ﬁnal desired state, xi and xf respectively, and an arbitrary curve joining xi to xf in state-space, the method deforms the curve into an admissible curve joining xi to xf . We presented a preliminary version of this method, with only non-holonomic constraints, in [1]. In this paper, we restrict the presentation to systems aﬃne in the control, and leave the general case to subsequent work. We also refer the readers to the website1 for slides, sample Matlab code and examples showcasing the method.
The problem of motion planning in robotics and control is a canonical problem, and many methods have been proposed over the years. For this reason, we can only give here a very partial overview of the current state of the ﬁeld, and emphasize that the method we propose is built on a rather diﬀerent set of ideas. A large subset of the methods is focused on non-holonomic dynamics, since this problem is by itself diﬃcult and with a long history [13, 12, 3, 14]. Many of the proposed methods are based on the use of sinusoidal driving signals; the basic relation underlying these methods is the system approximation

x = lim
ω→∞

√ ω

sin(ωt

)

f1(

x)

+

√ ω

cos(ωt)

f2(x

)

⇔ x = [ f1, f2](x),

∗∗Shenyu Liu and Mohamed Ali Belabbas are with the department of Electrical and Computer Engineering and the Coordinated Science Laboratory, University of Illinois, Urbana-Champaign. sliu113,belabbas@illinois.edu
1https://publish.illinois.edu/belabbas/motion-planning/

1

where [ f1, f2] is the Lie bracket [7] of the vector ﬁelds f1, f2. Indeed, this insight is at the basis of the work of Brockett [2], Murray et al. [16], Laferriere and Sussman [11]. Furthermore, interesting recent work shows that some special functions–which can be thought as generalizations of harmonic functions—play a distinguished role in solving under-actuated control problems [8].
For control and veriﬁcation of hybrid systems in general, we refer to [19] and for a recent survey of motion planning for self-driving vehicles in urban environment, we refer to [18]. Other approaches of interest to obtain feasible trajectories for given problems and dynamics including random sampling-based [9] graph-based [10], and optimization-based approaches [6] and approaches based on solvers for nonlinear dynamics.

2 Background and problem set-up

We present some background and notation needed to explain the method. We refer to as vehicle/robot/plant whose motion we desire to plan as the system. The system is assumed to obey the controlled dynamics

p

x = ui fi(x),

(1)

i=1

R where x ∈ M with M a (at least locally) diﬀerentiable manifold called the conﬁguration space, fi(x) the
actuation vector ﬁelds and u := (u1, . . . , up) ∈ p the controls. We refer to as workspace the physical
environment in which the system lives. We denote by spanx {gi } the (real) vector space spanned by the vectors gi ( x ).
We call a curve in conﬁguration space a piecewise diﬀerentiable function x(t) : [0, T] → M, where T > 0, and refer to x(0) and x(T) as start-point and end-point, respectively, of x(t). We refer to them collectively as

end-points. We call the image of a curve a path; a path is thus a geometric object (a collection of ”contiguous

states”) and the times at which each point in a path is visited are not speciﬁed. A ﬁxed end-points homotopy between the two curves x1(t) and x2(t) with the same end-points (i.e.,
x1(0) = x2(0) and x1(T) = x2(T)) is a diﬀerentiable function v(s, t) : [0, ∞) × [0, T] → M with the properties:

v(s, 0) = x1(0) v(s, T) = x1(T)

for all s ≥ 0 for all s ≥ 0

The length of a curve x(t) is deﬁned with respect to an norm on the tangent bundle T M of M. In the
R following, one can assume that M = n and the tangent space of M at x ∈ M, denoted by TxM is also Rn. A Riemannian inner product on M is an given by piecewise diﬀerentiable symmetric positive deﬁnite R bilinear form G(x) : TxM × TxM → .. With a slight abuse of notation, we also denote by G(x) its matrix
representation in coordinates. Hence, we can think of G(x) as an x-dependent positive deﬁnite symmetric
matrix. The length of a curve p(t) is then given by

∫T

L(x) :=

x (t)G(x(t))x(t)dt.

(2)

0

Finally, we introduce the Christoﬀels’ symbols associated to G(x). To this end, denote by gij the i jth entry of the matrix representation G(x), and by gij the i jth entry of the matrix G−1(x). The Christoﬀel’s

symbols are

Γijk (x)

:=

1 2

l

gil

∂gl j ∂ xk

+

∂glk ∂xj

−

∂gjk ∂ xl

(3)

2

Problem deﬁnition. The problem that the method MotionSketch solves is the following: given a conﬁguration space M, a set of holonomic, non-holonomic and obstacle avoidance constraints, an initial state xi and a desired ﬁnal state xf , provide a curve x(t) : [0, T] → M which respects these constraints and so that x(0) = xi, and x(T) = xf , and provide the control u that drive a control system from xi to xf . From now on, we normalize the time T to be equal to one; this is done for simplicity of exposition, and all the results below are easily extended to the case of arbitrary T. We recall that a curve that meets the constraints is an
admissible curve.

Length of a curve. In order to provide an intuitive justiﬁcation of the method, we ﬁrst revisit the deﬁnition of the generalized length of a curve given a Riemannian metric in 2. See also Fig. 1. Since G(x) is positive deﬁnite for all x ∈ M, we can factor it as G(x) = F(x)D(x)F (x), where D(x) is a positive deﬁnite diagonal matrix, and F(x) F(x) = I (i.e., F(x) is an orthogonal matrix.) Let x(t) : [0, 1] → M be a diﬀerentiable curve and let 0 = t0 < t1 < . . . < tl+1 = 1 provide subdivisions of the unit interval. We can then approximate

x(ti )

1 ∆ti

(x(ti+1)

−

x(ti ))

=

1 ∆ti

(∆x(ti )),

where ∆ti = ti+1 − ti, and the second equality deﬁnes ∆x(ti). Using these relations, we can approximate the length of x(t) as

L(x)

l i=1

(

∆x(ti ∆ti

)

)

F(ti

)D(ti

)F(ti

)

∆x(ti ∆ti

)

∆ti

l
(F(ti) ∆x(ti)) D(ti)(F(ti)∆x(ti)),

i=1

where we set D(ti) := D(x(ti)) and F(ti) := F(x(ti)). Since F is an orthogonal matrix, we can think of F ∆x the vector of coordinates describing ∆x in the basis spanned by the column vectors of F; more precisely, if we set fk to be the kth column of F and set ∆xk(ti) = fk ∆x(ti), then we have ∆x(ti) = k fk∆xk(ti). Now denote by dk2 the kth diagonal entry of D (recall that D has positive diagonal entries). We obtain

L(x)

n
∆x(ti)k dk (ti).
i k=1

Hence, by adjusting the di and the fk appropriately, we can adjust which inﬁnitesimal directions for a curve yield a larger length. We show how this can be brought to bear on motion planning problems below.

3 The method MotionSketch
The method contains the three following steps:
1. Encode the constraints of the motion planning problem (obstacles, holonomic, nonholonomic and dynamical constraints) into a Riemannian inner product.
2. Provide a curve in conﬁguration space between the initial and ﬁnal desired states. This curve, which we call the sketch, does not need to meet the holonomic, non-holonomic and dynamical constraints, but is required to avoid obstacles. Numerically solve the geometric heat ﬂow (GHF), deﬁned below, equation with the sketch as initial condition.

3

f1 ∆x f1

∆x

p(t)

f2

Figure 1: Length of a discretized curve.

3. Extract the controls from the solution of the GHF. We now elaborate on the three items.

3.1 Step 1: Encoding the constraints in a Riemannian inner product
We start with holonomic/non-holonomic constraints.

3.1.1 Holonomic and non-holonomic constraints Holonomic constraints can be formulated as a set of equations

qi(x) = 0, i = 1, 2, · · · , mh

For

each

i

and

an

inﬁnitesimally

small

motion

δx,

we

have

the

approximation

qi (x0

+

δx)

≈

qi (x0 )

+

∂qi ∂x

δx.

In order to means that

respect for x(t)

the constraint, δx needs to to be an admissible curve,

satisfy qi(x0 the direction

+ of

δx) = qi(x0) = 0, motion δx needs

thus to be

we

have

∂qi ∂x

δx

=

orthogonal to the

0. This vectors

∂qi ∂x

for

all

i;

in

other

words,

it

means

the

undesirable

directions

of

motion

are

span

∂qi ∂x

.

We now turn our attention to non-holonomic constraints, which we assume are formulated as a set of

constraints on the allowed velocities x when at state x as follows:

x fc, j(x) = 0, j = 1, 2, · · · , mn.

The non-holonomic character of the constraints, which is reﬂected in the fact that they cannot be expressed

as

d dt

qn

(x)

=

0

for

some

function

qn(x),

does

not

play

any

particular

function

insofar

our

local

encoding

of

the constraints is concerned; in fact, the undesirable directions of motion are easily seen to be in this case

span fc, j(x) .

Non-holonomic constraints can be presented as above, e.g. as non-slippage constraints, but they can also

be encoded in the dynamics of the system, which is then called non-holononic. For this latter case, consider

given the system of Eq. (1). We set ff,i = fi and fc, j to be the mn vectors orthogonal (for the Euclidean inner product) to ff,i for all i = 1, · · · , p.

Encoding the constraints We set p¯ := n − mn − mh. We deﬁne the n × (n − p¯) matrix F¯c as the matrix with

ﬁrarnstkmahlmcooslut mevnesrygiwvehnerbeyin∂∂qxMi a, nadndthwe enedxetnmotnectohliusmrannskgibvyenl,bayntdheseftcp, j

. We := n

assume that − l. If mh +

F¯c (x) mn =

is l,

of it

constant is of full

column rank, and we set Fc(x) := F¯c(x). Otherwise mh + mn > l and the constraints are not independent, in

4

the sense that satisfying a subset of the constraints insures that all constraints are met. We set Fc(x) to be a n × l matrix whose column span equals the column span of F¯c(x). Such matrix can be obtained, e.g., via the Gram-Schmidt process. Notice that Fc is of full column rank l = n − p and the column space of Fc contains all the undesirable directions of motion.
R Next, ﬁnd a rank p matrix Ff (x) ∈ n×p such that

Ff (x) Fc(x) = 0,

which again can be found using the Gram-Schmidt process. The column space of Ff (x) contains all the directions in which the system can move when at state x. Note that in the absence of holonomic constraints, we can start with deﬁning Ff with columns fi as in Eq. (1) and choose Fc the satisfy the above relation. Set

|

|

F(x) = Fc(x) Ff (x)

(4)

|

|

R Then F(x) ∈ n×n and we deﬁne

H(x) = F(x)DF (x)

(5)

where D = diag([k · · · k 1 · · · 1]) is a constant matrix. Note that this k is exactly the d2 discussed in the

n−p p
Section II.b. In practice, we take k to be of the order of 10 ∼ 1000. Using the interpretation of the length functional given in the previous section, it is easy to see that if x is a
direction that respects the constraints, it is not multiplied by k in the inner product x H(x)x with H deﬁned via (5), so x H(x)x will not be scaled by k. On the other hand, if x is a direction that violates a constraint, it has some components lying in span Fc(x), and consequently x H(x)x is large.
Finally, we record here that the partial derivative of H is given by

∂ ∂

H xi

(x)

=

2F

D

∂F ∂ xi

(x),

which is needed for the computation of the Christoﬀels symbols.

3.1.2 Obstacle constraints
R R We described obstacles Ωi ⊂ n in conﬁguration space via functions ri : M → according to R Ωi := {x ∈ n : ri(x) ≤ 0}
R The boundary of an obstacle is thus ∂Ωi = {x ∈ n : ri(x) = 0}. We incorporate obstacles in the Riemannian
inner product via a barrier function b(x) = i bi(x) with the following properties:
R 1. Each bi(x) is positive and diﬀerentiable for all x ∈ n\Ωi
2. bi(x) → ∞ as x → ∂Ωi,
3. b(x) = 1 when x is far away from all Ωi.

5

L2

(x, y)

θ2

L1

θ1

(a)

(b)

Figure 2: (a).The length l1 of the path passing near the obstacle is much larger that the length l2 of the path staying far from the obstacles when the metric is scaled with b(x). (b) Two-links articulated arm can be described as a system with

4 degrees of freedom and 2 holonomic constraints relating the position (x, y) of the tip to the joint angles θ1, θ2.

The idea is that we would like bi(x) to be large when x is in the vicinity of Ωi, and becomes inﬁnite if x ∈ ∂Ωi. Thus if we multiply the metric tensor by b(x), the length of a path that is in the vicinity of an
obstacle is much larger than the length of a path that steer well-clear of the obstacle, where quantifying “well-clear” is of course dependent on the choice of bi(x) and how quickly it decays near the boundary of the
obstacle. We illustrate this in Fig. 2a.
R Such functions bi are also known as barrier functions in the optimization literature [17]. In the case when
obstacles are balls, that is, Ω = ∪li=1{x ∈ n : |x − ci | ≤ ri }, one candidate of such b(x) function will be a modiﬁcation of penalty function from avoidance control [15]:

l
b(x) = 1 +
i=1

min

0,

|x − ci |2 − Ri2 |x − ci |2 − ri2

2

(6)

where Ri is such that ri < Ri for all i = 1, 2, · · · , l, and Ri can be thought of as a radius of detection of the obstacle, in the sense that outside this radius, the obstacle does not aﬀect the metric. Notice that b(x) deﬁned
in (6) satisﬁes the 3 properties mentioned earlier. The derivative of b is also not hard to compute. Note that

one can cover any obstacles with balls and use the above barrier function as a default approach.

3.1.3 simultaneous multi-vehicle path planning

Suppose there are l vehicles and each of them has its own state xj = x1j, x2j, · · · xnj ∈ Rn and the

dynamics is xj = Fj(xj)uj. The j-th vehicle is supposed to drive from xj(0) = aj to xj(T) = bj. Denote

x = x1 · · · xl and u = u1 · · · ul , then the system of multi-vehicle has total dimension of lm and

initial and ﬁnal states

a1

b1

xi = ... , xf = ... .

al

bl

and the overall dynamics is

x = diag(F1(x1), · · · , Fl(xl))u := F(x)u.

(7)

While planning the path for all l vehicles, they are also supposed to avoid collision with each other. In case of

planar vehicles where (x1, j, x2, j) represents the x y-coordinate of the j-th vehicle, collision between the j, k-th

vehicles is avoided if

(x1j − x1k )2 + (x2j − x2k )2 ≥ rc2,

(8)

6

where rc is a safety radius guaranteeing collision-free between two vehicles. Thus the (6)-like barrier function

induced from (8) is

bc(x) =
jk

min

0,

( x1 j ( x1 j

− −

x1k )2 x1k )2

+ +

( x2 j ( x2 j

− −

x2k )2 x2k )2

− −

R2 rc2

2

Thus, whenever two vehicles are too close ((x1j − x1k)2 + (x2j − x2k)2 ≤ R2), bc(x) becomes large and the

metric at this state of vehicles is large. Notice that if we perform path planning for each individual vehicle

ﬁrst while treating the other vehicles as obstacles, the avoidance problem becomes dynamic in the sense that

now the obstacles are moving with respect to time. Yet in our method avoidance of collision between vehicles

and avoidance of static obstacles are processed in similar way and the result is promising as one can see later

in our example.

In addition, Because F(x) in (7) is block diagonal, H deﬁned via (5) is also block diagonal and its

j-th

block

only

involves

xj.

As

a

result,

inverse

of

H

is

in

complexity

of O(lm3)

and

computing

∂H ∂xi

for

multi-vehicle has the same complexity as that for single vehicle. As a result, in each iteration of solving the

numerical GHF equation, the complexity of computing all the Christoﬀel symbols is linear in l, the number

of total vehicles.

3.1.4 The inner product with three type of constraints We now formally deﬁne the inner product used in the method: given H(x) as deﬁned above from holonomic and non-holonomic constraints, and b(x) a barrier function for the obstacles, we set

G(x) := b(x)H(x)

With this construction, the partial derivatives of G(x) can be computed using the chain rule:

∂ ∂xi

G(x)

=

∂b ∂xi

(x)H(x)

+

b(x)

∂H ∂xi

(x).

Hence

the

Christoﬀel

symbols

in

(3)

can

be

computed

solely

based

on

the

values

H,

∂H ∂xi

,

b,

∂b ∂xi

at each state x.

3.1.5 Examples

The two-links manipulator In this example we consider a two-links manipulator in the plane, see Fig. 2b.
R The working space, in terms of the position of the tool tip (x, y), is a subset of 2. The conﬁguration space R when the joint angles are also taken into account can be treated as a subset of 4. This system has 2 degrees
of freedom and we can easily obtain the holonomic constraints:

q1(x) = L1 cos(θ1) + L2 cos(θ2) − x = 0 q2(x) = L1 sin(θ1) + L2 sin(θ2) − y = 0

(9)

Taking diﬀerential of the two constraints, we ﬁnd

∂ q1 ∂x

= (−1,

0,

−L1 sin θ1, L2 sin θ2)

,

∂ q2 ∂x

= (0,

−1,

L1 cos θ1,

L2 cos θ2)

Thus we set Fc =

1

0

0

1

sin θ1 − cos θ1

sin θ2 − cos θ2

and we ﬁnd Ff =

− sin θ1 − sin θ2

cos θ1 1

cos θ2 0

. We then set F = (Fc | Ff ).

0

1

7

p(t, 0)

y x (x, y) θ

•

•

x0

p(t, ∞) x1

(a)

(b)

Figure 3: (a) A rolling coin or unicycle. is the side view. (b) In the mean-curvature ﬂow, the curve p(t, 0) is continuously

deformed in the direction of its normal, depicted by the red arrows. The ﬁnal curve is a straight line. In general, the ﬁnal

curve is a length minimizing curve. is the corresponding angles

We do not include obstacles and thus b(x) ≡ 1 and

G = H = F diag([k k 1 1])F =

sin2 θ1+sin2 θ2+k

−

sin

2θ1 2

−

sin

2θ2 2

(k−1) sin θ1 (k−1) sin θ2

−

sin

2θ1 2

−

sin

2θ2 2

cos2 θ1+cos2 θ2+k −(k−1) cos θ1 −(k−1) cos θ2

(k−1) sin θ1

−(k−1) cos θ1

k+1

k cos(θ1−θ2)

(k−1) sin θ2

− cos θ2 k−1 k cos θ1−θ2

k+1

The rolling coin or unicycle The kinematics of a unicycle can be modeled as

x cos θ

0

y = sin θ u1 + 0 u2

(10)

θ

0

1

where (x, y) is the position of the unicycle in the plane and θ is its orientation. Notice that there is only one non-holonomic constraints in this model and the constraint is the direction − sin θ cos θ 0 which
prevents moving sideways and hence prevents slipping. Equivalently, because the model (10) is aﬃne in control, the free directions Ff are simply the ones in (10). Hence

− sin θ cos θ 0

F(x) = cos θ sin θ 0 ,

0

01

from which we obtain

cos2 θ + k sin2 θ (1 − k) cos θ sin θ 0

G(x) = H(x) = F diag([k 1 1])F = (1 − k) cos θ sin θ k cos2 θ + sin2 θ 0 .

0

0

1

3.2 Step 2: Initial sketch and solving the Geometric Heat Flow equation

Our method proceeds with solving the following GHF equation:

∂ ∂s

vi

(s,

t

)

=

∂2 ∂t2

vi

(s,

t

)

+

j, k

Γij

k

∂vj ∂t

∂ vk ∂t

i = 1, 2, . . . , n

(11)

8

where Γijk are the Christoﬀel symbols introduced in (3) for the inner product deﬁned in the previous subsection. We impose the boundary conditions
v(s, 0) = xi, v(s, 1) = xf

and a user deﬁned initial condition,

v(0, t) = x(t)

in order to ﬁnd the solution. The initial curve x(t) is an arbitrary curves satisfying the following 2 conditions:

1. It satisﬁes the boundary conditions: x(0) = xi and x(1) = xf ;

2. It does not pass though any obstacles: r(x(t)) > 0 for all t ∈ [0, 1].

An important point here is that x(t) does not need to satisfy any holonomic or non-holonomic constraints; it

can be simply a curve drawn from xi to xf without touching Ω. Notice that for each s ≥ 0 ﬁxed, the solution v(s, ·) represent a curve connecting xi to xf . As we explain
below, as s increases, v(s, ·) is a curve that uses “less and less of the constrained directions”, said precisely,

Fc

∂ ∂t

v(s,

t)

tends

to

zero.

We

set

smax

to

be

the

simulation

time

for

the PDE

(in

our

examples,

between

1

and

20) and

xsol(·) = v(smax, ·).

Mean-curvature ﬂows We now elaborate on the origin of Eq. (11): it is a type of curve-shortening ﬂow [4], called a mean-curvature ﬂow for a 1-dimensional manifold (i.e. a curve) or geometric heat ﬂow. For an
introduction to mean-curvature ﬂows in arbitrary dimensions, see [5]. For clarity of exposition, we present
ﬁrst the ﬂow in two dimensional plane with the Euclidean inner product. We brieﬂy mention steps that need
to be taken for the general ﬂow below.
R Consider a curve p(t) : [0, 1] → 2 = (p1(t), p2(t)), as depicted in Fig. 3b. The scalar curvature [7] of p
at p(t) is deﬁned as κ(p(t)) = p . Denote by Np(t) the unit normal vector pointing “inward”. The curvature of p at p(t) is then κ(p(t))N(p(t)).
The mean-curvature ﬂow for this curve is deﬁned as follows: consider a family of curves p(t, s), s ≥ 0,
R where for each s0 ﬁxed, p(t, s0) : [0, 1] → 2 is a curve joining x0 to x1, and p(t, 0) is the original curve.
Then the mean-curvature ﬂow is the partial diﬀerential equation

∂p ∂s

=

κ(p(t,

s))N ( p(t,

s)).

Note that it is in fact a system of two PDEs. Looking at Fig. 3b, it is easy to conclude intuitively that lims→∞ p(t, s) converges to a straight line between x0 and x1. This is also the shortest path between x0 and x1 for the usual Euclidean metric. This is no accident, and we can show that in general the solution of this PDE converges to a curve of minimal length. For our purpose, we need to extend this idea in two directions: to (i) curves in higher dimensions and (ii) to a general Riemannian metric (or more precisely, inner product). One
can show, after some extensive algebraic manipulations which we omit here, that the equivalent of the ﬂow
for a general curve in a Riemannian manifold is exactly the geometric heat ﬂow presented in Eq. (11).

3.3 Step 3: Extracting the controls

The control can be directly computed:

u(t) = Ff†(xsol(t))xsol(t)

(12)

9

where xsol (t )

F=f†F=f

v((Ft)f

Ff )−1Ff for some

is the pseudo-inverse control v,

of

Ff .

Notice

that

in

the

case

xsol

is

admissible,

that

is,

if

u = Ff† xsol = (Ff Ff )−1Ff Ff v = v

Thus we have recovered the control and ideally the system should exactly follow the path xsol. Notice that Ff FF† is a minimal square error projection onto the column space of Ff , the control extracted from (12) will drive the system along a path that is close to xsol, even if xsol has small components in the constrained direction.

3.4 On the implementation

As mentioned earlier, the key of our method is to ﬁnd an inner product matrix G and then solve the GHF

equation (11). In our case, this is processed in MATLAB. To be explicit, once we have obtained Fc from the

constraints, we implement them as symbolic vectors in MATLAB and thus ﬁnd Ff (x). Subsequently, both

G(x) in an

and n×

n∂∂GaxrrcaaynGbaendderainvend×synm×bnolaicrarallyypaGn,drethsepescytmivbeolyl.icpsdaerpeethiesnthreenplcaacleldedbywistthattehevablouuesndaanrdytchoenndsittoiorends

and customized initial condition. In each iteration of solving the PDEs, the Christoﬀel symbols are computed

from G and pG according to (3) and then stored in an n × n × n array Chris. Notice that the pdepe solves

PDEs of the general form

c(s, t, x,

∂x ∂t

)

∂x ∂s

=

x−m

∂ ∂t

tm

f

(s,

t,

x,

∂x ∂t

)

+

s(s,

t,

x,

∂x ∂t

)

Compare it to (11) we see that in our case we need to set c=ones(4,1);m=0,f=DxDt and s(i)=DxDt’*Chris(i,:,:)*DxDt. Eventually the numerical solution of pdepe will be in the form of sol(t,s,i),

3.5 Theoretical guarantee

Set

∆(x)

=

span

∂qi ∂x

∩ span

fc, j .

We call the constraints satisﬁable if the distribution ∆ satisﬁes the Lie algebraic rank condition (LARC).

It is easy to see that it is a necessary condition for the existence of a trajectory joining arbitrary xi and xf while

respecting the holonomic and non-holonomic constraints on the system. Under mild assumptions our method

provides controls u¯ (t) so that the solution x∗(t) of x = i u¯ i fi by construction satisﬁes both the holonomic

and non-holonomic constraints. In addition,

R Theorem 3.1 Suppose F(x) deﬁned in (4) is globally Lipschitz with constant L and Fc(x) = 1 for all
x ∈ d. Let E¯ be the inﬁmum of the energy functional

∫1 E(u) = |u(t)|2dt
0
over the space of controls that the corresponding state trajectory satisﬁes both the holonomic and nonholonomic constraints. For any arbitrary k ∈ N, s > 0, deﬁne x to be the part v(·, s) of the solution of (11), u to be the control derived via (12) and x˜ to be the solution of (1) generated by u from x˜(0) = xi. Then for any
> 0, there exists T = T( , k) such that for all s ≥ T,
1. E(u) ≤ E¯ + ;

2. |x˜(t)−x(t)| ≤

2t k

(E¯

+

)

eL2(E¯ + ) for all t ∈ [0, 1]. In particular, |x˜(1)−xf | ≤

2 k

(E¯

+

)

eL2(E¯ + ).

10

θ1 θ2

(a)

(b)

θ1 θ2

(c)

(d)

Figure 4: Vertical motion (a) and circular motion (c) of the two-links articulated arm. The links are in blue and black.

The trajectory of the tip is marked in red. We draw the initial and ﬁnal state and an intermediate state. The joint angles

are given in (b) and (d) respectively.

4 Case study

Articulated arm We ﬁrst study the 2R ro√bot introd√uced earlier. Our goal is to plan the motion of the tip of

the are

arm, (x, y,

from an initial state x(0) = θ1, θ2), to a ﬁnal state x(1)

xi = = xf

( =

2√/2, 1 − ( 2/2, 1

2√/2, π/2, −π/4), where we recall that the coordinates + 2/2, π/2, π/4). We furthermore require the motion

to follow a straight line given by x = constant. The resulting motion planning problem thus contains, in

addition to the two holonomic constraints relating the tip of the arm to the angles given in Eq. (9), the

constraint q3(x) = x − xi

= 0 and the corresponding constrained direction is

∂q3 ∂x

= (1, 0, 0, 0)

.

Given these

constraints, we implement the three steps of the method outlined above show the results in Fig. 4. We then

replaced the constraint of vertical motion by asking that the tip follows an arc of a circle. The corresponding

holonomic constraint is q4(x) = (x − xc)2 + (y − yc)2 − r = 0 for some constants xc, yc, r. The diﬀerential of

this constraint is easily evaluated. We show in Fig. ?? the result obtained. Note that this illustrate the use of

our method to solve inverse kinematic problems numerically.

Unicycle Consider the unicyle described above with coordinates (x, y, θ). We desire to transfer the unicycle from (x(0), y(0), θ(0)) = (−1, 0, 0) to (x(1), y(1), θ(1)) = (1, 0, 0) without slip (a non-holonomic constraint).
In addition, there are two point obstacles located at (−0.7, 0), (0.7, 0) which the unicycle should avoid in the xy-plane. Provided these constraints, we ﬁrst build an inner product G(x) as described earlier. We then
provide an arbitrary curve connecting (−1, 0, 0) and (1, 0, 0) and avoiding the obstacles–we called this curve

11

the initial sketch. We opted simply for a sinusoidal curve in xy-plane and kept θ ≡ 0, as shown in Fig. 5a. As
observed in Fig. 5b, the unicycle certainly cannot follow this curve, as the motion direction is not aligned with
the unicycle orientation or, in other words, the non-slip constraint is not met. Recall that the solution of GHF equations (11) is a curve connecting the initial and ﬁnal states when s
ﬁxed. In Figs. 5c to 5g, we show the gradual deformation of the curve in conﬁguration space as s increases. In the ﬁnal step s = 4, the curve becomes almost admissible and we see that the unicycle can basically follow
such trajectory to reach its ﬁnal state. It is worth noticing that because the obstacles are very close to the initial
and ﬁnal states, the unicycle has to move backward ﬁrst in order to have more room to maneuver around said
obstacles. Similarly, it overshoots the second obstacles before backing up and parking at its ﬁnal destination.

R Car We now illustrate our method for planning the motion of a car with position (x, y) ∈ 2, body

orientation φ and wheel angle θ. A top view of car is illustrated in Fig. 6a and the equations of motion

equation are:

x

cos φ

0

y θ

= u1

sin φ 0

+ u2

0 1

,

(13)

φ

1 d

sin

θ

0

where u1 is the throttle input, u2 is the steering input and d is the distance between front wheels axis and

rear wheels axis. We have studied this example in our paper [1], and we refer the reader to this paper for an

explicit derivation of the corresponding G(x). Our ﬁrst experiment is a 180◦ turn. Our initial sketch for this motion is illustrated in Fig. 6b. It is clear

that, unless equipped with omniwheels or d = 0, the car cannot perform the motion illustrated. Interestingly,

Motionsketch deforms this curve into the well-known 3-points turn path illustrated in Fig. 6c. This corresponds to the most eﬃcient way of 180◦ turning of a car in practice, assuming there are no any other spatial obstacles.

If in addition, we impose add parallel curbs, which are encoded in the barrier function b(x) as described

earlier, the constrained space the car can move in results in additional back-and-forth. The narrower the street,

the more back-and-forth are needed. We provide additional examples in the webpage2.

We conclude with the case of a car turning in a narrow street. The initial curve is simply an L-shaped

curve in xy-plane with φ linear with respect to t and θ ≡ 0, as illustrated in Fig. 7a. With the curbs modeled

as obstacles, our method generates the relatively “optimal” path for this corner turn. Interestingly enough, the

car is able to perform the turn in one shot if the street is relatively wide as shown in Fig. 7b, or may need extra

maneuvering if the street is narrow, as shown in Fig. 7b. We emphasize that both simulation are performed

with the same initial curve provided in Fig. 7a. The only diﬀerence is the street width. Whether one shot or

two is automatically determined by our method without any further speciﬁcation.

Finally, we note that in addition to the curb of the streets which are modeled as obstacles in the xy-plane,

we also put limits on the steering angle θ as an obstacle for the θ variable.

Multi-vehicle path planning We show that multiple vehicles can be path planned simultaneously using our methods. In the ﬁrst simulation two unicycles are initially at states (0, 1, 0), (0, −1, 0); that is, parked at xy-coordinate (0, 1), (0, −1) while both facing east. The task is to swap the position of the two unicycles. The initial sketch is a circle passing through the two unicycles – clearly these two paths are infeasible since the orientation vectors of the unicycles are not tangent to the paths. After running our algorithm, the two initial sketch of paths deform into the two V-shaped paths and now the two unicycles are able to perform the swap of
2https://publish.illinois.edu/belabbas/motion-planning/

12

2

θ

0

−2

2

0

y

−2

x

(a) Initial sketch in (x, y, θ)-space.

(b) Projection of the initial sketch in (x, y)- plane, with snapshots
of the corresponding position of the unicycle. Note that θ = 0 for
each snapshot.

θ

2

0

−2

2

0

y

−2

x

(c) Solution x(s, t) for s = 0.0001

(d) Plane view at s = 0.0001

θ

2

0

−2

2

0

y

−2

x

(e) Solution x(s, t) for s = 0.01.

(f) Solution x(s, t) for s = 0.01

2

θ

0

−2

2

0

y

−2

x

(g) 3D view of the ﬁnal curve

(h) Plan view of the ﬁnal curve

Figure 5: Path planning for a unicycle avoiding two point obstacles. The red dots are the two obstacles, the blue curves are the solution of GHF equations at diﬀerent s. In the plan views of initial curve and ﬁnal curve, unicycle positions are

marked along the curve, with its orientation labeled with red arrows

positions along such paths while avoiding collisions. While readers might think the previous example has no major diﬀerence compared with path planning for single vehicle and hence less challenging, the next example is more interesting and shows the power of our algorithm in multi-vehicle path planning. In this case one unicycle is supposed to move from (−1, 0, π/2) to (1, 0, π/2) while the other one is supposed to move from (0, −1, 0) to (0, 1, 0).

13

θ

φ
(x, y)

(a) Car modelled by Eq. (13). The red arrow is used to indicate the front of the car.

(b) Initial sketch. The car rotates 180 degrees with its center of mass following the black curve with slipping.

(c) 3 points turning when no spatial con-

(d) 5 points turning between walls

straints

Figure 6: Car 180◦ turn experiment.

(a) Initial sketch. Note that the con-(b) Turn in a wide street corner (c) Back-forth behavior at narrow

straints are not met.

street corner

Figure 7: Car street corner turn experiment

14

1
0
−1 −1 0 1
(a)

1

2

1 0
0

−1

−1

−2 −1 0 1 2 −2 −1 0 1 2

(b)

(c)

1

0

−1

−1 0

1

(d) Figure 8: Multi-vehicles motion planning with collision avoidance.

15

5 Summary and discussion
We have provided in this paper a guide to the implementation of the method we termed MotionSketch for solving motion planning problems. We have illustrated the use of the method on examples with holonomic, non-holonomic and obstacle constraints, and have demonstrated that the method yields good practical results.
The salient points of the method were that it encodes all the constraints into a Riemannian inner product, and that it requires an initial sketch of the curve joining a desired ﬁnal state to an initial state. This curve however does not need to meet the holonomic and non-holonomic constraints and is thus often easily obtained. In fact, if the space is convex, a straight line joining the two states most often meets the constraints.
Amongst the problems that are also readily solved using MotionSketch, but that we did not show here, we mention multi-vehicle motion planning with collision avoidance. For example, think of having to plan the trajectory of two non-holonomic cars with the constraints that they should avoid each other. This can be
R done using our method as follows: denote by (xi, yi, θi, φi) the coordinates describing the state of car i, and by
Gi ∈ 4×4 the corresponding Riemannian inner products modeling the constraints for each car (e.g. max turning angle as am obstacle in θ, curbs, etc.). In order to model the two vehicles scenario, we ﬁrst consider
R the cartesian product of the coordinates with metric G¯ ∈ 8×8 a block diagonal matrix with blocks Gi. In
order to avoid collisions between the cars, it suﬃces to place an obstacle around the “diagonal” subspace x1 = x2 and y1 = y2. As we have seen earlier, adding obstacles to a metric only requires multiplying by a barrier function, hence we can set G(x) = b(x)G¯ (x). This procedure generalizes in a straightforward way to the case of more than two vehicles.
On the computational complexity of solving the GHF The numerically intensive part of the method lies in solving the geometric heat ﬂow, which is a system of parabolic partial diﬀerential equations. We point out that solving such a PDE can be done rather eﬃciently, owing to the fact that the complexity scales polynomially with the dimension, and not exponentially, and the fact that there exists parallel algorithms to do so.
To elaborate on the ﬁrst point, the main reason why the PDE we use scales well is that the domain of its solution has a constant dimension of two. For most PDEs encountered in engineering, such as the heat equation, or the Hamilton-Jacobi-Bellman equation, the dimension of the problem aﬀects the dimension of the domain of the solution seeked, whereas is our case, it aﬀects the dimension of the image of the solution. A linear increase in the dimension of the domain yields what is often referred to as the curse of dimensionality, as the number of interpolation points needed to represent a function on a domain of dimension n grows exponentially with n. Note however that the domain of our PDE is always two-dimensional, but the dimension of the image increases linearly, the number of interpolation points grows linearly with the dimension. Hence our PDE does not suﬀer from the curse of dimensionality and thus scales well to higher-dimensional problems. We refer to, e.g., [] for a more detailed discussion on the complexity of solving such PDEs. In practice, using MATLAB on a common laptop computer with non-optimized code (in particular, MATLAB does not solve such PDEs using multiple cores), the computation time was of the order of seconds to minutes, depending on the complexity of the problem. Per our discussion above, we believe however that there is ample room for improvement on this front.
References
[1] Mohamed-Ali Belabbas and Shenyu Liu. New method for motion planning for non-holonomic systems using partial diﬀerential equations. 2017 American Control Conference (ACC), pages 4189–4194, 2017.
16

[2] Roger W Brockett. On the rectiﬁcation of vibratory motion. Sensors and actuators, 20(1-2):91–96, 1989.
[3] H. Choset, K.M. Lynch, S. Hutchinson, G. Kantor, W. Burgard, L. Kavraki, and S. Thrun. Principles of Robot Motion: Theory, Algorithms, and Implementation. A Bradford book. Prentice Hall of India, 2005.
[4] Kai-Seng Chou and Xi-Ping Zhu. The curve shortening problem. CRC Press book, 2001.
[5] Tobias Colding, William Minicozzi, Erik Pedersen, et al. Mean curvature ﬂow. Bulletin of the American Mathematical Society, 52(2):297–333, 2015.
[6] H. Dai, A. Valenzuela, and R. Tedrake. Whole-body motion planning with centroidal dynamics and full kinematics. In 2014 IEEE-RAS International Conference on Humanoid Robots, pages 295–302, Nov 2014.
[7] M.P. do Carmo. Riemannian Geometry. Mathematics (Boston, Mass.). Birkhäuser, 1992.
[8] Jean-Paul Gauthier and Matthias Kawskiz. Minimal complexity sinusoidal controls for path planning. In Decision and Control (CDC), 2014 IEEE 53rd Annual Conference on, pages 3731–3736. IEEE, 2014.
[9] Sertac Karaman and Emilio Frazzoli. Sampling-based algorithms for optimal motion planning. The International Journal of Robotics Research, 30(7):846–894, 2011.
[10] J. Kuﬀner, S. Kagami, K. Nishiwaki, M. Inaba, and H. Inoue. Online footstep planning for humanoid robots. In 2003 IEEE International Conference on Robotics and Automation, volume 1, pages 932–937 vol.1, Sept 2003.
[11] Gerardo Laﬀerriere and Hector J Sussmann. A diﬀerential geometric approach to motion planning. In Nonholonomic motion planning, pages 235–270. Springer, 1993.
[12] Jean-Claude Latombe. Robot motion planning, volume 124. Springer Science & Business Media, 2012.
[13] J.P. Laumond. Robot motion planning and control. Lecture notes in control and information sciences. Springer, 1998.
[14] S. M. LaValle. Planning Algorithms. Cambridge University Press, Cambridge, U.K., 2006. Available at http://planning.cs.uiuc.edu/.
[15] G. Leitmann. Guaranteed avoidance strategies. Journal of Optimization Theory and Applications, 32(4):569–576, Dec 1980.
[16] Richard M Murray, Zexiang Li, S Shankar Sastry, and S Shankara Sastry. A mathematical introduction to robotic manipulation. CRC press, 1994.
[17] Jorge Nocedal and Stephen J. Wright. Numerical optimization, chapter 19. New York : Springer, 1999.
[18] Brian Paden, Michal Čáp, Sze Zheng Yong, Dmitry Yershov, and Emilio Frazzoli. A survey of motion planning and control techniques for self-driving urban vehicles. IEEE Transactions on Intelligent Vehicles, 1(1):33–55, 2016.
[19] Claire J Tomlin, Ian Mitchell, Alexandre M Bayen, and Meeko Oishi. Computational techniques for the veriﬁcation of hybrid systems. Proceedings of the IEEE, 91(7):986–1001, 2003.
17

