IEEE websites place cookies on your device to give you the best user experience. By using our websites, you agree to the placement of these cookies. To learn more, read our Privacy Policy.
Accept & Close
Loading [MathJax]/jax/element/mml/optable/SuppMathOperators.js

Skip to Main Content

    IEEE.org
    IEEE Xplore
    IEEE SA
    IEEE Spectrum
    More Sites 

        Cart 
        Create Account
        Personal Sign In 

IEEE Xplore logo - Link to home

    Browse
    My Settings
    Help

Access provided by:
Technische Hochschule Ingolstadt
Sign Out
IEEE logo - Link to IEEE main site homepage
Access provided by:
Technische Hochschule Ingolstadt
Sign Out
ADVANCED SEARCH
Journals & Magazines > IEEE Transactions on Automati... > Volume: 15 Issue: 2
Homotopy Path Planning for Terrestrial Robots Using Spherical Algorithm
Publisher: IEEE
Cite This
PDF
Gerardo Diaz-Arango ; Héctor Vázquez-Leal ; Luis Hernandez-Martinez ; María Teresa Sanz Pascual ; Mario Sandoval-Hernandez
All Authors
View Document
20
Paper
Citations
1058
Full
Text Views

    Alerts
    Alerts
    Manage Content Alerts
    Add to Citation Alerts

Abstract
Document Sections

    I.
    Introduction
    II.
    Homotopy Continuation Methods
    III.
    Homotopy Path Planning Method
    IV.
    Spherical Path Tracking
    V.
    Predictor-Corrector Algorithm

Show Full Outline
Authors
Figures
References
Citations
Keywords
Metrics
More Like This

    Download PDF
    View References
    Request Permissions
    Save to
    Alerts 

Abstract: Autonomous and semiautonomous mobile robots play an important role in making tasks in environments considered hostile or dangerous for a human being. In order to execute ... View more
Metadata
Abstract:
Autonomous and semiautonomous mobile robots play an important role in making tasks in environments considered hostile or dangerous for a human being. In order to execute many of the required tasks, robots need, in its architecture, a module of navigation with an appropriate path planning algorithm. This paper presents the development and implementation of a methodology for path planning of a mobile robot using a spherical algorithm and homotopy continuation methods (HCMs). The first section is a brief introduction about HCMs. Subsequently, the homotopy path planning method and spherical path tracking algorithm are explained, as well as the upgraded version and its main features. Then, the main contributions of this paper are presented and the effectiveness of the proposed method is proved. Besides, numerical examples, implementation results in multiple platforms including a 32b microcontroller and robot operating system, are displayed. Finally, some favorable results from a comparative between the proposed methodology against sampling-based planners using the open motion planning library are presented.
Published in: IEEE Transactions on Automation Science and Engineering ( Volume: 15 , Issue: 2 , April 2018 )
Page(s): 567 - 585
Date of Publication: 24 January 2017
ISSN Information:
INSPEC Accession Number: 17685430
DOI: 10.1109/TASE.2016.2638208
Publisher: IEEE
Funding Agency:
Contents
SECTION I.
Introduction

Recently, mobile robotics has become an important tool for many applications in areas such as artificial intelligence, robotics exploration, and control and computational systems. The main task of mobile robots is navigating in hostile or difficult access environments for a human being while performing a determinate task. In general, mobile robots can be autonomous or semiautonomous depending on the assigned task. Autonomous robots must have in its architecture a navigation module that allows you to locate it and guide its course in an environment so that the robot can travel from point A to point B as shown in Fig. 1 . The navigation module mainly consists of a map of the environment and a path planning algorithm [1] . For a terrestrial mobile robot, the map of its environment is a top image of the space in which it develops its tasks. This image can be provided by a satellite within the area of exploration or, in some cases, by sensors integrated in the robot. If the environment map is known, then the planning of a path becomes the main problem. An algorithm for planning collision-free paths is responsible for tracing a trajectory that the robot must follow to avoid colliding with obstacles in its way. These obstacles can be static or temporally static in agreement with the application [2] , [3] .

Several works about algorithms for planning collision-free paths have been reported. The algorithm bug and the algorithm of potential artificial fields have been demonstrated to be very effective and of rapid execution. The bug algorithm, for example, consists in exploring a path from the point of origin to the target point avoiding obstacles as insects do [4] , [5] . The artificial potential field algorithm mentioned in [6] – [7] [8] [9] considers the robot and the obstacles as electric charges equal, with the purpose of generating repulsion among them; the final point is a charge of opposite sign, which generates an attraction effect. Nevertheless, neither the bug nor the artificial potential fields’ algorithm guarantees finding a successful path. The bug algorithm may fail to find an optimal path, and the potential fields’ algorithm presents local minimums causing false convergence to the solution [7] , [8] , [10] . There are other algorithms based on visibility graphs; these create a link between all the vertices of each polygonal obstacle, the initial and the goal point. Then, the solution path is formed with the best set of links in terms of length [11] , [12] . Some others are the sampling-based planners, such as rapidly exploring random tree (RRT) algorithm, probabilistic road map (PRM) method, kinodinamic planning by interior-exterior cell exploration (KPIECE), and expansive space trees (ESTs) [13] , [14] . These algorithms can be combined with heuristic optimization methods as genetic algorithms, neural networks, and ant colony optimization algorithms [13] , [15] . The RRT algorithm is the most used in collision-free path planning, and its computing speed makes it an extremely attractive algorithm [16] . However, it provides a tree formed by piecewise linear type paths. The RRT algorithm requires a collision checker strategy and a postprocessing algorithm to smooth the piecewise linear path [13] , [14] , [17] , [18] .
Fig. 1.

Main task for an autonomous mobile robot.

Show All

Both the algorithms based on graph and sampling-based planners have proven their effectiveness in path planning, but are not always successful. Recently, papers have been published in which a new tool based on homotopy continuation methods (HCMs) is able to get collision-free paths. The homotopy path planning method (HPPM) [1] operates similarly to the potential field algorithm, and it is based on a kind of repulsion effect by the obstacles and a strong attraction due to the goal point.

This paper is organized as follows. In Section II , the fundamental concept of the homotopy methods is explained. In Section III , the enhanced version of the HPPM is explained. In Section IV , the hyper-spherical algorithm (SA) used to tracing homotopy curves is presented. The proposed predictor-corrector algorithm is shown in Section V . In Section VI , the technique for reversal effect detection and the proposed method to correct it is presented. Some numerical simulations in multiple platforms are shown in Section VII . A performance comparison between the proposed methodology and SBP algorithms is presented in Section VIII . The results are discussed in Section IX , and finally, the conclusions are drawn in Section X .
SECTION II.
Homotopy Continuation Methods

The HCMs are commonly used to find multiple solutions in nonlinear algebraic equations’ system (NAES) of the form \begin{equation} f(x)=0:\quad \mathbb {R}^{n}\longrightarrow \mathbb {R}^{n}. \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} f(x)=0:\quad \mathbb {R}^{n}\longrightarrow \mathbb {R}^{n}. \end{equation} The HCMs create a perturbation in the system f(x) , adding a function G(x) and a homotopy parameter \lambda . Therefore, the original system becomes a homotopy system that is expressed in this way \begin{equation} H(x,\lambda)= \lambda f(x)+ (1-\lambda)G(x)=0 \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} H(x,\lambda)= \lambda f(x)+ (1-\lambda)G(x)=0 \end{equation} where H(f(x))=H(x,\lambda):\mathbb {R}^{n+1}\longrightarrow \mathbb {R}^{n} , {x} \in \mathbb {R}^{n}~\lambda \in [{0,1}] .

The function G(x) has well-known or trivial solutions of such form that the following conditions hold.

    If \lambda =0 and H(x,\lambda)=0 , then a well-known or trivial solution is obtained.

    If \lambda =1 and H(x,\lambda)= f(x) , then the solution of the original system is obtained.

    The HCM generates a set of solutions H^{-1}(0) for the system f (x) = 0 with 0\leqslant \lambda \leqslant 1 . H^{-1}(0) is represented by a continuous curve \gamma . All the solutions available to solve the homotopy system during the continued deformation from \lambda =0 to \lambda =1 . Form a set of points of n+1 dimension. These solutions can be mapped like a family of curves \gamma [1] , [19] – [20] [21] [22] [23] [24] [25] [26] [27] [28] [29] [30] [31] [32] [33] [34] .

Fig. 2 shows a family of curves \gamma produced by the continuous homotopy deformation of a system of nonlinear equations. \gamma _{1} is a continuous curve from \lambda =0 to \lambda =1 , \gamma _{2} is a closed curve, and \gamma _{3} diverges to infinity without reaching \lambda = 1 . These curves also show turning points. Commonly, the only interest is the set of intersection points with the shaft \lambda =1 .
Fig. 2.

Family of homotopy curves.

Show All

The adequate selection of G(x) determines the specific homotopy. In this paper, we propose to use Newton homotopy method that is defined as G(x)=f(x)- f(x_{0}) [1] , [25] , [26] , [32] , [34] ; now if it is replacing G(x) in (2) \begin{equation} H(f(x),\lambda) = f(x)-(1-\lambda)f(x_{0})=0, \quad x_{} \in \mathbb {R}^{n} \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} H(f(x),\lambda) = f(x)-(1-\lambda)f(x_{0})=0, \quad x_{} \in \mathbb {R}^{n} \end{equation} where x_{0} is the starting point.

On the one side, if \lambda =0 , the homotopy system is reduced to the trivial problem H(f(x),0)=f(x)-f(x_{0})=0 . On the other side, if \lambda =1 , we obtain the original system H(f(x),1)=f(x)=0 .
SECTION III.
Homotopy Path Planning Method

In general terms, HPPM and the potential fields’ algorithm share similar characteristics: 1) there exists a kind of repulsion effect from obstacles and 2) the path tends to reach the target point. Moreover, the method of artificial potential fields is the interpretation of a physical effect, whereas the HPPM considers the contour of obstacles as singularities causing a kind of repulsive effect. The HPPM allows planning a path that avoids obstacles, generating a continuous curve from a starting point to a goal point. In this paper, we use the improved version of this method, called EHPPM [1] . The robot moves only in the plane xy , and hence the EHPPM represents each obstacle as follows: \begin{equation} W(x,y) =\sum _{i=1}^{i=k}\frac {p_{i}}{Ob_{i}(x,y)} \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} W(x,y) =\sum _{i=1}^{i=k}\frac {p_{i}}{Ob_{i}(x,y)} \end{equation} where k is the number of obstacles in the map, p_{i} is the repulsion parameter for the i th obstacle, and Ob_{i} (x,y) is the equation that defines the shape of each obstacle [1] . Two forms of obstacles, circular and rectangular, are defined. The circular obstacles are represented by \begin{equation} C_{i}(x,y) =(x-x_{i})^{2}+(y-y_{i})^{2}-rc_{i}^{2}=0 \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} C_{i}(x,y) =(x-x_{i})^{2}+(y-y_{i})^{2}-rc_{i}^{2}=0 \end{equation} where rc_{i} is the ratio of the circumference and the point (x_{i},y_{i}) represents the center of a circular obstacle. Rectangular-type obstacles are defined using an ellipse approximation \begin{align} R_{i}(x,y)=&\left ({\frac {(x-x_{i})\cos (\psi _{i})+(y-y_{i})\sin (\psi _{i})}{\alpha }}\right)^{2\eta }\notag \\&+\,\left ({\frac {(x-x_{i})\sin (\psi _{i})+(y-y_{i})\cos (\psi _{i})}{\beta }}\right)^{2\eta }\notag \\&-\,1=0 \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} R_{i}(x,y)=&\left ({\frac {(x-x_{i})\cos (\psi _{i})+(y-y_{i})\sin (\psi _{i})}{\alpha }}\right)^{2\eta }\notag \\&+\,\left ({\frac {(x-x_{i})\sin (\psi _{i})+(y-y_{i})\cos (\psi _{i})}{\beta }}\right)^{2\eta }\notag \\&-\,1=0 \end{align} where \eta is the value that defines the sharpness of the corners (in this paper, we use \eta =2 for all case studies) and the point (x_{i},y_{i}) represents the center of a rectangular obstacle with a width of 2\alpha and a height of 2\beta . Finally, \psi _{i} is the angle of rotation with respect to horizontal as shown in Fig. 3(b) . Moreover, the representation of the obstacles must consider the size of the robot [1] . For example, consider the holonomic constraints of a robot with differential drive, where the rotation point can be the same center of the vehicle. The environment map can be modified considering an increase in size of the obstacles as shown in Fig. 3(a) .

Fig. 3.

Representation of obstacles in an environment map. (a) Representation of obstacles considering the robot radius. (b) Obstacle shapes defined in HPPM.

Show All

Fig. 3(a) shows the new size of obstacles considering the robot size with radius r_{\mathrm{ bot}} , where the actual size of objects is represented by the dotted line and the solid line represents the objects with enlarged size. In addition, the workspace of the robot is standardized. If the target point B is (1,1) and the starting point is (0,0) , the obstacles are located in the space x \in [{0,1}] , y \in [{0,1}] as described in Fig. 4(a) . On the other hand, an equation system is necessary with a single solution at the end point B [1] . This can be formulated as \begin{align} f_{1}(x,y)=&0, \quad x,y \in \mathbb {R} \\ f_{2}(x,y)=&0, \quad x,y \in \mathbb {R} \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} f_{1}(x,y)=&0, \quad x,y \in \mathbb {R} \\ f_{2}(x,y)=&0, \quad x,y \in \mathbb {R} \end{align} where f_{1}(1,1)=0 and f_{2}(1,1)=0 .

Fig. 4.

Two-dimensional obstacles’ map normalized. Starting point (0,0) and target point (1,1) . (a) Obstacles map. (b) Intersection of (9) and (10) at target point.

Show All

In this paper, we propose linear equations of the form \begin{align} L_{1}(x,y)=&-y -m_{1} x +(b+m_{1} a)=0 \\ L_{2}(x,y)=&-y -m_{2} x +(b+m_{2} a)=0 \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} L_{1}(x,y)=&-y -m_{1} x +(b+m_{1} a)=0 \\ L_{2}(x,y)=&-y -m_{2} x +(b+m_{2} a)=0 \end{align} where m_{1} and m_{2} are the values of the respective slopes and (a,b) represents the ordered pair of the point of intersection between the straight lines. The lines intersect only at the target point B as depicted in Fig. 4(b) . We use this property to create continuous curves of the homotopy and apply them to the collision-free path planning. The HPPM uses the attraction effect toward the point of intersection of the straight lines and a kind of repulsion effect by the obstacles [1] . This method embeds the contour of the obstacle as a singularity in the system of equations. The singularities are added to the expression of the straight line L_{2} transforming the equations in \begin{align} f_{1}(x,y)=&L_{1}(x,y)=0 \\ f_{2}(x,y)=&L_{2}(x,y)+W(x,y)-Q=0 \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} f_{1}(x,y)=&L_{1}(x,y)=0 \\ f_{2}(x,y)=&L_{2}(x,y)+W(x,y)-Q=0 \end{align} where Q=W(a,b) .

W(x,y) in (12) allows singularizing the function in the outline of the obstacles, whereas Q vanishes this effect at point B . Applying Newton homotopy to (11) and (12) , the homotopy equation system is expressed as \begin{align} H=\begin{cases} H_{1}(f_{1}(x,y),\lambda) =f_{1}(x,y)-(1-\lambda)f_{1}(x_{0},y_{0})=0\\ H_{2}(f_{2}(x,y),\lambda) = f_{2}(x,y)-(1-\lambda)f_{2}(x_{0},y_{0})=0 \end{cases}\!\!\!\!\notag \\ {}\end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} H=\begin{cases} H_{1}(f_{1}(x,y),\lambda) =f_{1}(x,y)-(1-\lambda)f_{1}(x_{0},y_{0})=0\\ H_{2}(f_{2}(x,y),\lambda) = f_{2}(x,y)-(1-\lambda)f_{2}(x_{0},y_{0})=0 \end{cases}\!\!\!\!\notag \\ {}\end{align} where (x_{0},y_{0}) is the starting point A .

Fig. 5 shows a hypothetical example; in this, the contours of the obstacles in solid line and dotted lines represent the \gamma curves. Fig. 5(a) presents a homotopy path without the presence of obstacles, while a family of \gamma curves (internal and external) produced by objects in the environment is presented in Fig. 5(b) .
Fig. 5.

Homotopy paths 2-D representation for different cases. (a) Direct trajectory without obstacles. (b) Internal and external curves generated due the obstacles in the map. (c) Successful trajectory for a map with obstacles.

Show All

In Fig. 5(c) , \gamma _{0} represents a successful trajectory from point A to point B . On the one side, \gamma _{5} and \gamma _{7} are closed internal isolated curves that do not reach at the target point; on the other side, \gamma _{6} and \gamma _{8} are closed external isolated curves that can potentially increase their size to construct connections for new homotopy trajectories. It is important to note that \gamma _{1} and \gamma _{4} joint to create the successful homotopy trajectory \gamma _{0} . In general terms, to each obstacle in the map are associated two \gamma curves, one internal and the other external to its boundary. The external trajectories can joint to conform homotopy paths from A to B . The successful collision-free curve in an environment with the presence of obstacles can be formed by combining two or more external \gamma curves, depending on the parameters of repulsion and proximity of obstacles with the direct path [1] . As depicted in Fig. 5(c) , the existence of multiple \gamma curves implies the requirement of a proper tracking technique to prevent jumps between homotopy paths or branches producing a failure in the method [1] , [24] , [28] , [29] , [35] .
SECTION IV.
Spherical Path Tracking

The HCM methods require a proper path following technique to trace the homotopy curves. In this paper, a modified spherical tracking is proposed. The SA is a tool presented in [24] and [28] – [29] [30] with a clear graphical interpretation and straightforward procedure easy to implement for curve tracing using spheres. In order to explain the procedure with simple figures, we will present the procedure using circles; nonetheless, the same principles can be extended to three dimensions or more. If a circle of radius r and center O_{3} is located on the path, its outline must intersect the homotopy curve at least at two points (O_{2} and O_{4}) as shown in Fig. 6 .

The formulation of a homotopy system has n equations and n+1 variables that means n system variables plus homotopy parameter \lambda [24] , [28] – [29] [30] . It means that we should include an extra equation representing a hypersphere of n+1 dimensions to trace the homotopy path. Moreover, we will consider only x and y displacements for path planning. Therefore, after the homotopy formulation, the new transformed problem will described by three variables ( x, y , and \lambda ). Subsequently, the hypersphere is reduced to three dimensions, resulting in \begin{align} S_{i}(x,y,\lambda) =(x-c_{x})^{2}+(y-c_{y})^{2}+(\lambda -c_\lambda)^{2}-r^{2}=0\notag \\ {}\end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} S_{i}(x,y,\lambda) =(x-c_{x})^{2}+(y-c_{y})^{2}+(\lambda -c_\lambda)^{2}-r^{2}=0\notag \\ {}\end{align} where r is the radius and (c_{x},c_{y},c_\lambda) is the center of the sphere in the homotopy path.

Fig. 6.

Intersection of circle with homotopy curve.

Show All

Using (13) and (14) , we propose \begin{equation} H_{S}=\begin{cases} H_{1}(x,y,\lambda) =0\\ H_{2}(x,y,\lambda) =0\\ S_{i}(x,y,\lambda) =0. \\ \end{cases} \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} H_{S}=\begin{cases} H_{1}(x,y,\lambda) =0\\ H_{2}(x,y,\lambda) =0\\ S_{i}(x,y,\lambda) =0. \\ \end{cases} \end{equation} The curve \gamma is a representation of the family of solutions (13) , i.e., \gamma represents all the points H^{-1}(0) . In the SA, the center of the sphere must be updated in each step of the tracking and resolved for (15) . Spherical tracking is subsequently performed as depicted in Fig. 7 . The solution of this system is found using the Newton-Raphson (N-R) method. Combining a predictor-corrector scheme and the SA, we obtained an appropriate methodology for spherical tracking.

Fig. 7.

Spherical tracking for a homotopy curve.

Show All

SECTION V.
Predictor-Corrector Algorithm

The predictor-corrector scheme allows the SA to perform a correct tracking of the homotopy \gamma curve. Fig. 8 illustrates the behavior of the predictor-corrector scheme. The Euler predictor draws a tangent vector (x_{p},y_{p},\lambda _{p}) at the point (x_{i}, y_{i}, \lambda _ {i}) of the homotopy path. Then, the predictor point is found in the intersection of the sphere S_{i} with the tangent vector. The N-R method is subsequently applied as corrector to find the intersection point (x_{i+1},y_{i+1},\lambda _{i+1}) between the homotopy path and the sphere of radius r .
Fig. 8.

Predictor-corrector algorithm.

Show All

A. Euler Predictor

The Euler predictor algorithm is a powerful tool for homotopy path tracking. This provides a point close to the solution of the homotopy system in the next tracking step. In recent works [27] , [30] , the effectiveness of the Euler tangent predictor in spherical tracking of homotopy curves has been verified. The Euler predictor point used in SA is expressed as \begin{equation} (x_{p},y_{p},\lambda _{p}) = (c_{x},c_{y},c_\lambda)+r\|\vec v_{p}\| \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} (x_{p},y_{p},\lambda _{p}) = (c_{x},c_{y},c_\lambda)+r\|\vec v_{p}\| \end{equation} where (x_{p},y_{p},\lambda _{p}) is the predictor point, (c_{x},c_{y},c_\lambda) is the center of the sphere, r is the radius of the sphere, and \vec {v_{p}} is the tangent vector. Further, in this paper, we will show that the center of the sphere and the i th point in the homotopy path are not always equal. The tangent vector is obtained, as explained in [27] and [30] . In this process, it is proposed the dependence of each of the variables with respect to an arbitrary parameter \rho , i.e., (x (\rho), y(\rho), \lambda (\rho)) and \begin{equation} H(x(\rho),y(\rho),\lambda (\rho))= \begin{cases}H_{1}(x(\rho),y(\rho),\lambda (\rho)) = 0 \\ H_{2}(x(\rho),y(\rho),\lambda (\rho)) =0. \\ \end{cases} \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} H(x(\rho),y(\rho),\lambda (\rho))= \begin{cases}H_{1}(x(\rho),y(\rho),\lambda (\rho)) = 0 \\ H_{2}(x(\rho),y(\rho),\lambda (\rho)) =0. \\ \end{cases} \end{equation} Now, the system of (17) is derived with regard to \rho , using the chain rule \begin{equation} \left ({ \begin{array}{ccc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}} &\quad {\dfrac {\partial {H_{1}}}{\partial {\lambda }}} \\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}} &\quad {\dfrac {\partial {H_{2}}}{\partial {\lambda }}} \\ \end{array} }\right)\left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ {\dfrac {\partial {\lambda }}{\partial \rho }}\\ \end{array} }\right)=\left ({ \begin{array}{c} 0\\ 0 \end{array} }\right) \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \left ({ \begin{array}{ccc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}} &\quad {\dfrac {\partial {H_{1}}}{\partial {\lambda }}} \\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}} &\quad {\dfrac {\partial {H_{2}}}{\partial {\lambda }}} \\ \end{array} }\right)\left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ {\dfrac {\partial {\lambda }}{\partial \rho }}\\ \end{array} }\right)=\left ({ \begin{array}{c} 0\\ 0 \end{array} }\right) \end{equation} where the vector of partial derivatives ({\partial {(x(\rho),y(\rho),\lambda (\rho))}}/{\partial { \rho }}) is the tangent vector \vec {v_{p}} . Rearranging the terms \begin{equation} \left ({ \begin{array}{ccc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)\left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ \end{array} }\right) =- {\frac {\partial {\lambda }}{\partial \rho }} ~\left ({ \begin{array}{c} {\dfrac {\partial {H_{1}}}{\partial {\lambda }}} \\ {\dfrac {\partial {H_{2}}}{\partial {\lambda }}} \\ \end{array} }\right) \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \left ({ \begin{array}{ccc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)\left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ \end{array} }\right) =- {\frac {\partial {\lambda }}{\partial \rho }} ~\left ({ \begin{array}{c} {\dfrac {\partial {H_{1}}}{\partial {\lambda }}} \\ {\dfrac {\partial {H_{2}}}{\partial {\lambda }}} \\ \end{array} }\right) \end{equation} in order to obtain the solution of this system, it is necessary to know the value of \partial \lambda (\rho)/\partial \rho ; in [36] , the next solution was proposed \begin{equation} {\frac {\partial {\lambda }}{\partial \rho }} =s_{g}\left ({(-1)^{n+1}\det \left ({ \begin{array}{ccc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right) }\right) \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} {\frac {\partial {\lambda }}{\partial \rho }} =s_{g}\left ({(-1)^{n+1}\det \left ({ \begin{array}{ccc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right) }\right) \end{equation} where, in this case, n=2 and s_{g} is a parameter that only takes values +1 or −1 and designates the direction of a predictor vector in forward or backward direction; the sign of the s_{g} is linked to the expressions of the auxiliary straight lines. For lines L_{1} and L_{2} considering m_{1} \neq ~m_{2} , we know the relationship among (11) – (13) and m_{1} , m_{2} . To explain this effect, we take the case m_{1}=1 and m_{2}=2 \begin{align} \det \left ({ \begin{array}{cc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\frac {\partial {H_{1}}}{\partial y}}\\[4pt] {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\frac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)=&\delta _{1}-\delta _{2}\notag \\ \delta _{1}=&\left ({{\frac {\partial {H_{1}}}{\partial x}} \quad {\frac {\partial {H_{2}}}{\partial y}}}\right)\notag \\ \delta _{2}=&\left ({{\frac {\partial {H_{1}}}{\partial y}} \quad {\frac {\partial {H_{2}}}{\partial x}}}\right). \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \det \left ({ \begin{array}{cc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\frac {\partial {H_{1}}}{\partial y}}\\[4pt] {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\frac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)=&\delta _{1}-\delta _{2}\notag \\ \delta _{1}=&\left ({{\frac {\partial {H_{1}}}{\partial x}} \quad {\frac {\partial {H_{2}}}{\partial y}}}\right)\notag \\ \delta _{2}=&\left ({{\frac {\partial {H_{1}}}{\partial y}} \quad {\frac {\partial {H_{2}}}{\partial x}}}\right). \end{align}

Assuming \delta _{1}>\delta _{2} in (21) , then the sign of the determinant is “+” but if we exchange the value of slopes, i.e., m_{1}=2 and m_{2}=1, it is similar to changing the rows in the matrix, we have \begin{equation} \det \left ({ \begin{array}{ccc} {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ \end{array} }\right)=\delta _{2}-\delta _{1}. \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \det \left ({ \begin{array}{ccc} {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ \end{array} }\right)=\delta _{2}-\delta _{1}. \end{equation} Then, considering \delta _{1}>\delta _{2} in (22) , the sign of the determinant is “−.” Note that \delta _{1} > \delta _{2} is only an assumption that is used to explain the change in sign of the determinant related to the slopes m_{1} and m_{2} . Thence, if m_{1}>m_{2} , then s_{g}=-1 , and if m_{2}>m_{1} , then s_{g}=+1 .

Equation (19) can be expressed as \begin{equation} \left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ \end{array} }\right) =\left ({ \begin{array}{cc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)^{-1}\left ({\begin{array}{c} {-\dfrac {\partial {H_{1}}}{\partial {\lambda }}}{\dfrac {\partial {\lambda }}{\partial \rho }} \\ {-\dfrac {\partial {H_{2}}}{\partial {\lambda }}}{\dfrac {\partial {\lambda }}{\partial \rho }} \\ \end{array}}\right). \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ \end{array} }\right) =\left ({ \begin{array}{cc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)^{-1}\left ({\begin{array}{c} {-\dfrac {\partial {H_{1}}}{\partial {\lambda }}}{\dfrac {\partial {\lambda }}{\partial \rho }} \\ {-\dfrac {\partial {H_{2}}}{\partial {\lambda }}}{\dfrac {\partial {\lambda }}{\partial \rho }} \\ \end{array}}\right). \end{equation} By placing the tangent vector in (16) , we obtain \begin{equation} (x_{p},y_{p},\lambda _{p}) = (c_{x},c_{y},c_\lambda)+ r\left \Vert{ \frac {\partial {(x(\rho),y(\rho),\lambda (\rho))}}{\partial \rho }}\right \Vert \qquad \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} (x_{p},y_{p},\lambda _{p}) = (c_{x},c_{y},c_\lambda)+ r\left \Vert{ \frac {\partial {(x(\rho),y(\rho),\lambda (\rho))}}{\partial \rho }}\right \Vert \qquad \end{equation} where (x_{p},y_{p},\lambda _{p}) is the predictor point, (c_{x},c_{y},c_\lambda) is the center of the i th sphere, r is the radius of the sphere, and ({\partial {(x(\rho),y(\rho),\lambda (\rho))}}/{\partial \rho }) is the tangent vector constructed using (20) and (23) .

B. Newton-Raphson Method

In this paper, the N-R method is used to correct the predictor point to a point on the homotopy path \gamma [1] , [29] , [30] , [32] , [36] . The N-R method, commonly used to resolve NAES [37] , is an iterative process of local convergence that approximates an initial value to a final value. Because convergence is local, an initial point close to the solution point is required; the predictor point fulfills this condition [37] . The N-R corrector is described by \begin{equation} (x_{j+1},y_{j+1},\lambda _{j+1}) = (x_{j},y_{j},\lambda _{j})-[ J (x_{j},y_{j},\lambda _{j}) ]^{-1} H_{S}\qquad \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} (x_{j+1},y_{j+1},\lambda _{j+1}) = (x_{j},y_{j},\lambda _{j})-[ J (x_{j},y_{j},\lambda _{j}) ]^{-1} H_{S}\qquad \end{equation} where j=0,1,2,\ldots n iteration and (x_{j},y_{j},\lambda _{j}) is the point that is updated in each iteration until arriving to a final value; this final value can be considered to be the solution. [ J(x_{j},y_{j},\lambda _{j})]^{-1} is the inverse Jacobian of H_{S} , and H_{S}(x,y,\lambda) is evaluated in the point (x_{j},y_{j},\lambda _{j}) for each j th iteration. This iterative method requires an appropriate starting point to reach the solution in a minimum of iterations. Therefore, for the first iteration j=0 , (x_{j},y_{j},\lambda _{j})= (x_{p},y_{p},\lambda _{p}) . The N-R method is repeated until it reaches a maximum of iterations j_{\mathrm{ max}} or it converges to a solution (x_{i+1},y_{i+1},\lambda _{i+1}) with a minimum margin of error, as shown in Fig. 9 . The tolerance criterion is given by \begin{equation} \|~H_{S} (x_{j+1},y_{j+1},\lambda _{j+1})\|<\text {err}. \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \|~H_{S} (x_{j+1},y_{j+1},\lambda _{j+1})\|<\text {err}. \end{equation} In this paper, we propose \text {err}=1\times 10^{-6} and j_{\mathrm{ max}}=40 .

Fig. 9.

N-R corrector in spherical tracking.

Show All

Taking as starting point the predictor point (x_{p},y_{p},\lambda _{p}) , the method locates the intersection point (x_{i+1},y_{i+1},\lambda _{i+1}) between the i th sphere S_{i} and the homotopy path after four iterations.
SECTION VI.
Technique to Detect and Correct the Reversal Effect

Each sphere in the tracking procedure must intersect the homotopy path in two points as depicted in Fig. 6 for two dimensions. The sphere intersects at points O_{2} and O_{4} , one in backward direction and the other in forward direction. Nonlinearities in the system H can cause the N-R method to converge to the point O_{2}, although the predictor point is located close to O_{4} . This convergence in the backward direction causes a reversal effect in the tracking [28] – [29] [30] , [36] procedure. To correct the reversal effect, first of all, we must be able to detect when N-R converges to a point in backward direction. A good technique to detect this is to compare the direction of the normal vector at each point of intersection [29] . Subsequently, a technique able to correct this effect is required. This paper proposes to rotate the predictor point in the forward direction to obtain a point (x_{\mathrm{ rot}},y_{\mathrm{ rot}},\lambda _{\mathrm{ rot}}) . Then, the N-R method is applied again taking (x_{\mathrm{ rot}},y_{\mathrm{ rot}},\lambda _{\mathrm{ rot}}) as the starting point.
A. Reversal Effect Detection

A technique to detect the reversal effect is of vital importance for SA. When the radius of the spheres is very small, it is difficult to differentiate between points in the backward or forward that causes false detections. Therefore, a technique that provides more information to differentiate the points is required. The work in [29] proposes a technique that is very efficient to detect reversal in the tracking. This technique compares the angles of the normal vector at each intersection point. Fig. 10 shows the operation of this technique. To obtain the normal vector, we must evaluate the gradient of the equation of the sphere (14) at the points O_{2} and O_{4} \begin{equation} \nabla S_{n} =\left ({ \begin{array}{c} 2(x-c_{x}) \\ 2(y-c_{y}) \\ 2(\lambda -c_\lambda) \\ \end{array} }\right)\!. \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \nabla S_{n} =\left ({ \begin{array}{c} 2(x-c_{x}) \\ 2(y-c_{y}) \\ 2(\lambda -c_\lambda) \\ \end{array} }\right)\!. \end{equation}

Fig. 10.

Strategy for reversal effect detection.

Show All

A reversal effect is detected in the path when \begin{align} \left ({ \begin{array}{c} \arccos \left ({\dfrac {2(x-c_{x})}{\Vert \nabla S_{n}\Vert }}\right) \\ \arccos \left ({ \dfrac {2(y-c_{y})}{\Vert \nabla S_{n} \Vert }}\right) \\ \arccos \left ({\dfrac {2(\lambda -c_\lambda)}{\Vert \nabla S_{n} \Vert }}\right) \\ \end{array} }\right)_{O_{2}}=\left ({ \begin{array}{c} \arccos \left ({\dfrac {2(x-c_{x})}{\Vert \nabla S_{n} \Vert }}\right) \\ \arccos \left ({\dfrac {2(y-c_{y})}{ \Vert \nabla S_{n} \Vert } }\right)\\ \arccos \left ({\dfrac {2(\lambda -c_\lambda)}{\Vert \nabla S_{n} \Vert }}\right) \\ \end{array} }\right)_{O_{4}}\notag \\ {}\end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \left ({ \begin{array}{c} \arccos \left ({\dfrac {2(x-c_{x})}{\Vert \nabla S_{n}\Vert }}\right) \\ \arccos \left ({ \dfrac {2(y-c_{y})}{\Vert \nabla S_{n} \Vert }}\right) \\ \arccos \left ({\dfrac {2(\lambda -c_\lambda)}{\Vert \nabla S_{n} \Vert }}\right) \\ \end{array} }\right)_{O_{2}}=\left ({ \begin{array}{c} \arccos \left ({\dfrac {2(x-c_{x})}{\Vert \nabla S_{n} \Vert }}\right) \\ \arccos \left ({\dfrac {2(y-c_{y})}{ \Vert \nabla S_{n} \Vert } }\right)\\ \arccos \left ({\dfrac {2(\lambda -c_\lambda)}{\Vert \nabla S_{n} \Vert }}\right) \\ \end{array} }\right)_{O_{4}}\notag \\ {}\end{align} where the \arccos function is used to find the angle with respect to each variable for each normal vector [29] . This technique proves to be effective for detecting the reversal effect, because the normal vectors provide more information than the position of the point.

B. Strategy to Correct Reversal Effect

When a reversal in the tracking procedure has been detected, an algorithm able to find a new point in forward direction is required. In [29] , an algorithm was proposed; it increases the radius of the spheres as a technique to correct the reversal effect. However, this technique could cause jumps from the solution curve to a closed curve, if these are very close. In this paper, we propose to place the predictor point closer to the solution point. For this purpose to do so the predictor point should rotate a \theta angle on the surface of the sphere in forward direction. Fig. 11 presents the proposed technique for correcting reversal effect.
Fig. 11.

Technique to correct reversal effect and reduce N-R iterations. (a) Predictor point in the original reference plane. (b) Representation of the predictor point rotated in auxiliary reference plane. (c) Predictor point rotated in original reference plane.

Show All

From (11) and (13) , we can represent H_{1} as \begin{align} H_{1}=-y-m_{1}x+\lambda (b+m_{1}(a-x_{0})-y_{0})(y_{0}+m_{1}x_{0})=0\!\!\notag \\ {}\end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} H_{1}=-y-m_{1}x+\lambda (b+m_{1}(a-x_{0})-y_{0})(y_{0}+m_{1}x_{0})=0\!\!\notag \\ {}\end{align} where (x_{0},y_{0}) is the starting point A , (a,b) is the goal point B , and m_{1} is the slope of L_{1} .

In (29) , the expression H_{1} describes a plane in the 3-D space; therefore, the points that form the set of the homotopy path are a subset of all solution points H_{1} , i.e., H^{-1}(0)\subseteq H_{1}^{-1}(0) . Therefore, if the \gamma curve belongs to the plane described by H_{1} , then the tangent vector at each point of \gamma and the predictor point also belong to this plane. From (29) , we find the expression \begin{equation} \lambda =\frac {y+m_{1}x-(y_{0}+m_{1}x_{0})}{b+m_{1}(a-x_{0})-y_{0}}. \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \lambda =\frac {y+m_{1}x-(y_{0}+m_{1}x_{0})}{b+m_{1}(a-x_{0})-y_{0}}. \end{equation}

Then the rotation of the predictor point becomes a problem of two dimensions. First, a conversion in 2-D should be applied to find the point P'_{p} in the reference plane x'y' , as shown in Fig. 11(b) .

Fig. 11(a) shows the predictor point in the original plane, Fig. 11(b) shows the predictor point rotated an angle \theta in an auxiliary plane, and Fig. 11(c) presents the predictor point rotated an angle \theta in the original plane, where \begin{align} O_{1}=(x_{1},y_{1})\notag \\ O_{2}=(x_{2},y_{2})\notag \\ O_{3}=(x_{3},y_{3})\notag \\ O_{4}=(x_{4},y_{4})\notag \\ P_{p}=(x_{p},y_{p}). \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} O_{1}=(x_{1},y_{1})\notag \\ O_{2}=(x_{2},y_{2})\notag \\ O_{3}=(x_{3},y_{3})\notag \\ O_{4}=(x_{4},y_{4})\notag \\ P_{p}=(x_{p},y_{p}). \end{align} The points O_{3} and P_{p} were projected with respect to the origin, point O_{3} , of the auxiliary plane. Then, O^{\prime }_{3} and P^{\prime }_{p} are calculated and using matrix 2-D rotation P^{\prime }_{\mathrm{ rot}} is set \begin{align}&O_{3}^{\prime }=(x'_{3},y'_{3})=(x_{3},y_{3})-(x_{3},y_{3})=(0,0) \\&\hspace {1.5pc}P^{\prime }_{p}=(x'_{p},y'_{p})=(x_{p},y_{p})-(x_{3},y_{3}) \\&\hspace {4pc}\left ({ \begin{array}{cc} {\cos (\theta)} &\quad {-\sin (\theta)}\\ {\sin (\theta)} &\quad {\cos (\theta)}\\ \end{array}}\right)\!. \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align}&O_{3}^{\prime }=(x'_{3},y'_{3})=(x_{3},y_{3})-(x_{3},y_{3})=(0,0) \\&\hspace {1.5pc}P^{\prime }_{p}=(x'_{p},y'_{p})=(x_{p},y_{p})-(x_{3},y_{3}) \\&\hspace {4pc}\left ({ \begin{array}{cc} {\cos (\theta)} &\quad {-\sin (\theta)}\\ {\sin (\theta)} &\quad {\cos (\theta)}\\ \end{array}}\right)\!. \end{align}

Finally, the point P'_{\mathrm{ rot}} should be projected in the plane xy and expression (30) can be applied to represent the point in the solution plane H_{1} \begin{align} P_{\mathrm{ rot}}=&\left ({\begin{array}{c} x_{\mathrm{ rot}} \\ y_{\mathrm{ rot}} \\ \end{array} }\right)=\left ({\begin{array}{c} x_{3}\\ y_{3}\\ \end{array} }\right)+\left ({\begin{array}{c} x'_{\mathrm{ rot}}\\ y'_{\mathrm{ rot}}\\ \end{array} }\right) \\ \left ({ \begin{array}{c} {x_{\mathrm{ rot}}} \\ {y_{\mathrm{ rot}}}\\ {\lambda _{\mathrm{ rot}}}\\ \end{array} }\right)=&\left ({ \begin{array}{c} {x_{\mathrm{ rot}}} \\ {y_{\mathrm{ rot}}}\\ \frac {y_{\mathrm{ rot}}+m_{1}x_{\mathrm{ rot}}-\left ({y_{0}+m_{1}x_{0}}\right)}{b+m_{1}(a-x_{0})-y_{0}}\\ \end{array} }\right)\notag \\ \left ({\begin{array}{c} x_{\mathrm{ rot}}\\ y_{\mathrm{ rot}}\\ \lambda _{\mathrm{ rot}}\\ \end{array} }\right)\in&H^{-1}_{1}(0). \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} P_{\mathrm{ rot}}=&\left ({\begin{array}{c} x_{\mathrm{ rot}} \\ y_{\mathrm{ rot}} \\ \end{array} }\right)=\left ({\begin{array}{c} x_{3}\\ y_{3}\\ \end{array} }\right)+\left ({\begin{array}{c} x'_{\mathrm{ rot}}\\ y'_{\mathrm{ rot}}\\ \end{array} }\right) \\ \left ({ \begin{array}{c} {x_{\mathrm{ rot}}} \\ {y_{\mathrm{ rot}}}\\ {\lambda _{\mathrm{ rot}}}\\ \end{array} }\right)=&\left ({ \begin{array}{c} {x_{\mathrm{ rot}}} \\ {y_{\mathrm{ rot}}}\\ \frac {y_{\mathrm{ rot}}+m_{1}x_{\mathrm{ rot}}-\left ({y_{0}+m_{1}x_{0}}\right)}{b+m_{1}(a-x_{0})-y_{0}}\\ \end{array} }\right)\notag \\ \left ({\begin{array}{c} x_{\mathrm{ rot}}\\ y_{\mathrm{ rot}}\\ \lambda _{\mathrm{ rot}}\\ \end{array} }\right)\in&H^{-1}_{1}(0). \end{align}

This technique can reduce the number of iterations the N-R method required to converge to the solution in the forward direction. As mentioned above, after the Euler predictor step, the N-R method is applied considering a maximum of 40 iterations. After such iterations, if N-R not fulfills the error criteria, then the rotation scheme comes into operation using an angle \theta = ({\pi }/{4}) in the clockwise direction. If it fails, the rotation is repeated using the same angle but in the other direction. This backup strategy was able to successfully correct all the reversal issues presented in the case studies of this paper. What is more, such technique aids to solve problems of non-convergence and reduce the computation time.
C. Variable Radius

The radius of the sphere affects the number of steps of the spherical tracking and, consequently, the computing time [28] , [30] . In this paper, the method described in [30] is used, which consists in varying the radius in each step of the spherical tracking using \begin{equation} r_{i+1}=r_{0} \left ({1-(1-\Gamma)\exp ^{-\left({\frac {|\mu _{i}|}{| \mu _{i+1}|}}\right)}}\right) \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} r_{i+1}=r_{0} \left ({1-(1-\Gamma)\exp ^{-\left({\frac {|\mu _{i}|}{| \mu _{i+1}|}}\right)}}\right) \end{equation} where r_{i+1} is the radius of the sphere S_{i+1} , r_{0} is the initial radius, \Gamma is the maximum factor by which to multiply r _{0} , and \mu _{i} is the partial derivative of the homotopy parameter with respect to the parameter \rho for the i th step that means \mu _{i}=(\partial \lambda /\partial \rho)_{i} ; in the same way, \mu _{i+1}=(\partial \lambda /\partial \rho)_{i+1} . A variable radius in the methodology involves a modification in the reversal effect detection method. Fig. 12(a) shows the method without variable radius, while Fig. 12(b) presents the problem for detection of the reversal effect when using variable radius. The radius variation causes the intersection point between the sphere S_{i} and the homotopy path \gamma not to match with the center of S_{i-1} ; in this case, the reversal effect detection fails, as shown in Fig. 12(b) . In [28] , it is proposed to move the center of the sphere by a linear interpolation between the points O_{i-1} and O_{i} . Fig. 12(c) clearly presents this methodology, where the intersection point between the sphere S_{i-1} and the curve \gamma matches with point O_{i-1} for i=3 . The center of the sphere S_{i-1}, represented by point \bar O_{i} , is moved \Delta r=r_{i}-r_{i+1} , as depicted in Fig. 12(c) .

Fig. 12.

Detection of reversal effect in spherical tracking. (a) Correct detection for fixed radius. (b) Erroneous detection for variable radius. (c) Correct detection for variable radius.

Show All

The new center is calculated with the expression \begin{align} \bar O_{3}=&(c_{x},c_{y},c_\lambda)\notag \\=&(x_{i+1},y_{i+1},\lambda _{i+1})\notag \\&+\,\Delta r\Vert (x_{i+1},y_{i+1},\lambda _{i+1})- (x_{i},y_{i},\lambda _{i})\Vert \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \bar O_{3}=&(c_{x},c_{y},c_\lambda)\notag \\=&(x_{i+1},y_{i+1},\lambda _{i+1})\notag \\&+\,\Delta r\Vert (x_{i+1},y_{i+1},\lambda _{i+1})- (x_{i},y_{i},\lambda _{i})\Vert \end{align} where \bar O_{3} is the new center and (x_{i},y_{i},\lambda _{i}) and (x_{i+1},y_{i+1},\lambda _{i+1}) are the points O_{2} and O_{3} , respectively, as depicted in Fig. 12(c) .

SECTION VII.
Numerical Simulations

In this section, we first present a numerical example that explains the operation of the methodology. Subsequently, a series of simulations on two software platforms (Maple and C++) and performance of the methodology implemented in a microcontroller are presented. Finally, the methodology is proved in robot operating system (ROS), for a Pioneer 3-DX robot.
A. Three Circular Obstacles With the Same Radius

Let us consider a known map with three circular obstacles represented by the parameters in Table I \begin{align} Ob_{1}(x,y)=&(x-0.2)^{2}+(y-0.2)^{2}-(0.1)^{2}=0\notag \\[4pt] Ob_{2}(x,y)=&(x-0.5)^{2}+(y-0.5)^{2}-(0.1)^{2}=0\notag \\[4pt] Ob_{3}(x,y)=&(x-0.8)^{2}+(y-0.8)^{2}-(0.1)^{2}=0\qquad \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} Ob_{1}(x,y)=&(x-0.2)^{2}+(y-0.2)^{2}-(0.1)^{2}=0\notag \\[4pt] Ob_{2}(x,y)=&(x-0.5)^{2}+(y-0.5)^{2}-(0.1)^{2}=0\notag \\[4pt] Ob_{3}(x,y)=&(x-0.8)^{2}+(y-0.8)^{2}-(0.1)^{2}=0\qquad \end{align} where Ob_{i}(x,y) represents each circular obstacle.

TABLE I Simulation Parameters for Map With Three Circular Obstacles

We propose the system of auxiliary lines L_{1} and L_{2} as \begin{align} L_{1} (x,y)=&-y -4 x +5=0\notag \\[4pt] L_{2} (x,y)=&-y -x +2=0 \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} L_{1} (x,y)=&-y -4 x +5=0\notag \\[4pt] L_{2} (x,y)=&-y -x +2=0 \end{align} where m_{1}=4 and m_{2}=1 .

From (39) and (40) , and applying (11) and (12) , we obtain \begin{align} f_{1} (x,y)=&-y -4 x +5=0\notag \\ f_{2} (x,y)=&-y -x+2+W(x,y) - Q=0\qquad \\ W(x,y)=&\frac {p_{1}}{Ob_{1}(x,y)} +\frac {p_{2}}{Ob_{2}(x,y)}+\frac {p_{3}}{Ob_{3}(x,y)}\qquad \quad \\ Q=W(1,1)=&\frac {p_{1}}{Ob_{1}(1,1)} +\frac {p_{2}}{Ob_{2}(1,1)}+\frac {p_{3}}{Ob_{3}(1,1)}\qquad \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} f_{1} (x,y)=&-y -4 x +5=0\notag \\ f_{2} (x,y)=&-y -x+2+W(x,y) - Q=0\qquad \\ W(x,y)=&\frac {p_{1}}{Ob_{1}(x,y)} +\frac {p_{2}}{Ob_{2}(x,y)}+\frac {p_{3}}{Ob_{3}(x,y)}\qquad \quad \\ Q=W(1,1)=&\frac {p_{1}}{Ob_{1}(1,1)} +\frac {p_{2}}{Ob_{2}(1,1)}+\frac {p_{3}}{Ob_{3}(1,1)}\qquad \end{align} where Q=0.01303 , f_{1}(1,1) =0 , and f_{2}(1,1)=0 .

For this example, the starting point is (x_{0},y_{0})=(0,0) , the goal point is (a,b)=(1,1) , the initial radius for the spheres of the tracking is r_{0}=0.01 , and for the first sphere, r_{1}=r_{0} . From (13) – (15) and (41) , we obtain \begin{align} H_{1}=&f_{1}(x,y)-(1-\lambda)f_{1}(0,0)=0\notag \\ H_{2}=&f_{2}(x,y)-(1-\lambda)f_{2}(0,0)=0\notag \\ S_{1}=&(x-c_{x})^{2}+(y-c_{y})^{2}+(\lambda -c_\lambda)^{2}-(0.01)^{2}\!=0.\qquad \quad \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} H_{1}=&f_{1}(x,y)-(1-\lambda)f_{1}(0,0)=0\notag \\ H_{2}=&f_{2}(x,y)-(1-\lambda)f_{2}(0,0)=0\notag \\ S_{1}=&(x-c_{x})^{2}+(y-c_{y})^{2}+(\lambda -c_\lambda)^{2}-(0.01)^{2}\!=0.\qquad \quad \end{align} Removing and rearranging terms, the following system of equations is obtained: \begin{align} H_{1}=&-y-4x+5\lambda =0\notag \\ H_{2}=&-y -x+W(x,y)+2\lambda +(\lambda -1) W_{0}-\lambda Q+=0\notag \\ S_{1}=&(x-c_{x})^{2}+(y-c_{y})^{2}+(\lambda -c_\lambda)^{2}-(0.01)^{2}=0\notag \\ {}\end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} H_{1}=&-y-4x+5\lambda =0\notag \\ H_{2}=&-y -x+W(x,y)+2\lambda +(\lambda -1) W_{0}-\lambda Q+=0\notag \\ S_{1}=&(x-c_{x})^{2}+(y-c_{y})^{2}+(\lambda -c_\lambda)^{2}-(0.01)^{2}=0\notag \\ {}\end{align} to evaluate the terms W_{0}=W (0,0) = 0.1 .

For the first step, (c_{x}, c_{y}, c_\lambda) = (x_{0}, y_{0}, 0) . Then, the predictor point (x_{p}, y_{p}, \lambda _{p}) is obtained using the Euler vector predictor as aforementioned. For the first step of tracking, i = 1 and O_{1} = (x_{0}, y_{0}, 0) = (0,0,0) .

Using (24) \begin{equation} \mu _{1} ={\frac {\partial {\lambda }}{\partial \rho }} =-1(-1)^{3}\det \left ({ \begin{array}{cc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} & \quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)=2.76462.\qquad \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \mu _{1} ={\frac {\partial {\lambda }}{\partial \rho }} =-1(-1)^{3}\det \left ({ \begin{array}{cc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} & \quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)=2.76462.\qquad \end{equation} Continuing the process of Euler’s method \begin{align} \notag \left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ \end{array} }\right)=&\left ({ \begin{array}{cc} {-4} & {-1}\\ {-0.9215} & {-0.9215}\\ \end{array} }\right)^{-1}\left ({\begin{array}{c} {-13.823}~\\ {-5.5292}~\\ \end{array}}\right)\\=&\left ({\begin{array}{c} {2.60770}~\\ {3.39229}~\\ \end{array}}\right) \\ \vec v_{p}=&\left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ {\dfrac {\partial {\lambda }}{\partial \rho }} \end{array} }\right) =\left ({\begin{array}{c} {2.60770}~\\ {3.39229}~\\ {2.76462} \end{array}}\right) \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \notag \left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ \end{array} }\right)=&\left ({ \begin{array}{cc} {-4} & {-1}\\ {-0.9215} & {-0.9215}\\ \end{array} }\right)^{-1}\left ({\begin{array}{c} {-13.823}~\\ {-5.5292}~\\ \end{array}}\right)\\=&\left ({\begin{array}{c} {2.60770}~\\ {3.39229}~\\ \end{array}}\right) \\ \vec v_{p}=&\left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ {\dfrac {\partial {\lambda }}{\partial \rho }} \end{array} }\right) =\left ({\begin{array}{c} {2.60770}~\\ {3.39229}~\\ {2.76462} \end{array}}\right) \end{align} where \mu _{1}= ({\partial {\lambda }}/{\partial \rho })=2.76462 , and the tangent vector is \begin{equation} \Vert \vec v_{p} \Vert = (0.511895,0.665913,0.542699) \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \Vert \vec v_{p} \Vert = (0.511895,0.665913,0.542699) \end{equation} using tangent vector and r_{1} . The predictor point for the first step is \begin{align} (x_{p},y_{p},\lambda _{p})=&(0,0,0)+ 0.01 (0.5118,0.6659,0.5426)\notag \\=&(0.005118,0.006659,0.005426). \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} (x_{p},y_{p},\lambda _{p})=&(0,0,0)+ 0.01 (0.5118,0.6659,0.5426)\notag \\=&(0.005118,0.006659,0.005426). \end{align}

The representation for the first sphere in the plane H_{1} is shown in Fig. 13(a) .
Fig. 13.

Representation for the first steps of the path tracking homotopy on the plane H_{1} . (a) First predictor point. (b) Correcting of predictor point. (c) Second sphere in the follow.

Show All

Then, we can calculate the intersection point between the first sphere and the \gamma curve; on the plane H_{1} , after three N-R iterations, we have the solution O_{2}=(x_{2},y_{2},\lambda _{2})=(0.005079,0.006707,0.005404) as depicted in Fig. 13(b) . The process continues to the next sphere \begin{equation} \mu _{2}= {\frac {\partial {\lambda }}{\partial \rho }} =-(-1)^{3}\det \left ({ \begin{array}{cc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)=2.764620\qquad \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \mu _{2}= {\frac {\partial {\lambda }}{\partial \rho }} =-(-1)^{3}\det \left ({ \begin{array}{cc} {\dfrac {\partial {H_{1}}}{\partial x}} &\quad {\dfrac {\partial {H_{1}}}{\partial y}}\\ {\dfrac {\partial {H_{2}}}{\partial x}} &\quad {\dfrac {\partial {H_{2}}}{\partial y}}\\ \end{array} }\right)=2.764620\qquad \end{equation} and then \begin{align} \notag \left ({\begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ \end{array} }\right)=&\left ({ \begin{array}{cc} -4 &\quad -1\\ -0.912 &\quad -0.9127\\ \end{array} }\right)^{-1}\left ({\begin{array}{c} {-13.695} \\ {-5.478} \\ \end{array}}\right)\\=&\left ({\begin{array}{c} {2.563971} \\ {3.439780} \\ \end{array}}\right) \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \notag \left ({\begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ \end{array} }\right)=&\left ({ \begin{array}{cc} -4 &\quad -1\\ -0.912 &\quad -0.9127\\ \end{array} }\right)^{-1}\left ({\begin{array}{c} {-13.695} \\ {-5.478} \\ \end{array}}\right)\\=&\left ({\begin{array}{c} {2.563971} \\ {3.439780} \\ \end{array}}\right) \end{align} i.e., the predictor vector is \begin{equation} \vec v_{p}=\left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ {\dfrac {\partial {\lambda }}{\partial \rho }} ~\end{array} }\right) =\left ({\begin{array}{c} {2.563971}~\\ {3.439780}~\\ {2.739132} \end{array}}\right)\!. \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} \vec v_{p}=\left ({ \begin{array}{c} {\dfrac {\partial {x}}{\partial \rho }} \\ {\dfrac {\partial {y}}{\partial \rho }} \\ {\dfrac {\partial {\lambda }}{\partial \rho }} ~\end{array} }\right) =\left ({\begin{array}{c} {2.563971}~\\ {3.439780}~\\ {2.739132} \end{array}}\right)\!. \end{equation} For the first step, it is proposed to set \mu _{1}=2.76462 , \mu _{2}=2.739132 , and \Gamma =2 . The new sphere radius is \begin{equation} r_{2}=0.01 \left ({1-(1-2)e^{-\left({\frac {|2.76462|}{|2.73439|}}\right)}}\right)=0.013644. \end{equation}
View Source Right-click on figure for MathML and additional features. \begin{equation} r_{2}=0.01 \left ({1-(1-2)e^{-\left({\frac {|2.76462|}{|2.73439|}}\right)}}\right)=0.013644. \end{equation}

Fig. 13(c) presents the sphere S_{2} with radius r_{2} .

Then, \Delta r=0.01-0.013644=0.003644 and using (38) , the new center is calculated and is depicted in Fig. 14(a) \begin{align} \bar O_{2}=(c_{x},c_{y},c_\lambda)=&O_{2}+0.003644\left \Vert{ O_{2}-O_{1} }\right \Vert \notag \\=&(0.0069,0.00915,0.00737). \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \bar O_{2}=(c_{x},c_{y},c_\lambda)=&O_{2}+0.003644\left \Vert{ O_{2}-O_{1} }\right \Vert \notag \\=&(0.0069,0.00915,0.00737). \end{align}

Fig. 14.

Representation of the second sphere of the SA on the plane H_{1} . (a) New center for the second sphere. (b) Predictor point for the next step.

Show All

The predictor point is located in the same way as for the previous step and shown in Fig. 14(b) \begin{align} \Vert \vec v_{p} \Vert=&(0.503719,0.675781,0.538131) \\ (x_{p},y_{p},\lambda _{p})=&\bar O_{2}+ 0.0169 (0.5037,0.6757,0.5381) \notag \\=&(0.013803, 0.018373, 0.014717). \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} \Vert \vec v_{p} \Vert=&(0.503719,0.675781,0.538131) \\ (x_{p},y_{p},\lambda _{p})=&\bar O_{2}+ 0.0169 (0.5037,0.6757,0.5381) \notag \\=&(0.013803, 0.018373, 0.014717). \end{align}

In this way, the calculation of the first centers of the spheres is made, and successive centers are found by following the path tracking homotopy. Fig. 15 presents the homotopy path from the initial point A to the target point B .
Fig. 15.

Planned trajectory for three circular obstacles.

Show All

The effect of the negative sign of the parameter p_{2} causes the homotopy path to pass under the obstacle Ob_{2} . This direction change effect in the path is explained in the following section.
B. Several Configurations of Repulsion Parameters and Auxiliary Straights

The EHPPM associates a parameter repulsive to each obstacle Ob_{i} as expressed in (4) . The repulsion parameters determine the distance between the contour of the obstacle and the homotopy path. Fig. 16 shows the effect of the repulsion parameter for a circular object. Fig. 17 shows the variations in the homotopy path when the repulsion parameter of a rectangular obstacle varies.
Fig. 16.

Homotopy paths for tree values of the repulsion parameter p_{0} of the circular obstacle C_{0} . (a) Homotopy path for p_{0}=0.01 and m_{2}> m_{1} . (b) Homotopy path for p_{0}=0.001 and m_{2}> m_{1} . (c) Homotopy path for p_{0}=0.0001 and m_{2}> m_{1} .

Show All
Fig. 17.

Homotopy paths for tree values of the repulsion parameter p_{0} of the rectangular obstacle R_{0} . (a) Homotopy path for p_{0}=100 and m_{2}> m_{1} . (b) Homotopy path for p_{0}=10 and m_{2}> m_{1} . (c) Homotopy path for p_{0}=1 and m_{2}> m_{1} .

Show All

For a rectangular obstacle R_{i} , the repulsion parameter must be greater than that for a circular obstacle. This can be explained if we consider that the rectangular shape is governed by the power 2 \eta , resulting in huge values when the rectangles functions are evaluated far from its perimeter. Moreover, small values of repulsion parameter prevent the robot from deviating from the shortest path; however, very small values produce jumps from the solution path to closed curves [see Fig. 5(c) ]. On the other hand, the sign of the repulsion parameter p_{0} determines whether the homotopy path passes above or below an obstacle Ob_{i} . Fig. 15 shows this effect: for Ob_{1} with p_{1}=+0.001 , the homotopy path passes above, for Ob_{3} with p_{3}=+0.001 , the homotopy path passes above, and for Ob_{2} with p_{2}=-0.001 , the homotopy path passes below. This effect occurs only near the obstacle Ob_{i} . Similarly, modifying the expressions of the auxiliary straights lines can cause changes on the homotopy path. The auxiliary straight lines L_{1} and L_{2} can be modified by changing the value of m_{1} and m_{2} . Fig. 18(a) shows the upper trajectory for m_{1}>m_{2} , and Fig. 18(b) shows the lower trajectory for m_{2}>m_{1} .
Fig. 18.

Upper and lower trajectory with respect to the diagonal line. (a) Collision-free trajectory for m_{1}> m_{2} . (b) Collision-free trajectory for m_{2}> m_{1} .

Show All

For the same scenario, five variants with different values of m_{1} and m_{2} are presented in Fig. 19 .
Fig. 19.

Several collision-free trajectories for the same scenario caused by changes in the auxiliary straights lines. (a) Collision-free trajectory for m_{1}=1 and m_{2}=1.1 . (b) Collision-free trajectory for m_{1}=1 and m_{2}=2 . (c) Collision-free trajectory for m_{1}=1 and m_{2}=4 .

Show All

The number of steps in the tracking largely depends on the appropriate choice of auxiliary lines and the repulsion parameters of each obstacle. For example, in Fig. 19(e) , a trajectory shorter than that of Fig. 19(c) is displayed. The repulsion parameter and position of each obstacle used in Fig. 19 are depicted in Table II .
TABLE II Environment Maps and Simulation Parameters of Fig. 19. C_{i} Represents Circular Obstacles and R_{i} Represents Rectangular Obstacles

Fig. 19 presents a qualitative analysis to select the best values for m_{1} and m_{2} . In this, we can observe that using m_{1}=1 and m_{2}=4 produces a shortest path between two points. For simulations presented in the next sections, these are used as optimal values.
C. Indoor Operation

Now, we apply the method for path planning in a closed environment. Consider a room in which the objects or furniture are represented by rectangles and circumferences. What is more, the robot should not go through the walls, and then the walls are considered as additional obstacles. Fig. 20(a) shows an environment map for a robot confined into a room, where the initial point and target are in the free space.
Fig. 20.

Successful trajectories for a same obstacles map with different auxiliary straight lines. (a) Successful trajectory for m_{1}=1 and m_{2}=4 . (b) Successful trajectory for m_{1}=0.1 and m_{2}=0.01 .

Show All

Fig. 20 shows two different homotopy path configurations for indoor environments. In particular, Fig. 20(b) shows the intersection between the homotopy path and the auxiliary straights, depicting how the methodology is not affected by this type of intersection. Then, we show that the proposed methodology is able to trace a collision-free path between two points in free space inside a closed environment.

Furthermore, Fig. 21 shows two different configurations of collision-free paths produced by varying the repulsion parameter of each obstacle. Such figure is result of two different homotopy path configurations produced by a change in the sign of the repulsion parameters of some obstacles, as shown in Table III . We propose the repulsion parameter for circular obstacles to be p_{i} = 0.0001 and for rectangular obstacles p_{i} = 1 .
Fig. 21.

Successful trajectories for a same obstacles map and slight variations of repulsion parameters. (a) Successful trajectory for C_{1} and C_{4} with positive repulsion parameters. (b) Successful trajectory for C_{1} and C_{4} with negative repulsion parameters.

Show All
TABLE III Environment Maps and Simulation Parameters of Figs. 20(a) and (b) and 21(a) and (b). C_{i} Represents Circular Obstacles and R_{i} Represents Rectangular Obstacles

Fig. 22 shows two successful paths, \gamma _{0,1} and \gamma _{0,2} , generated with different configurations of repulsion parameters of circular and rectangular obstacles. The path \gamma _{0,2} was generated using positive parameters for all obstacles, and \gamma _{0,1} was generated using positive and negative repulsion p_{i} , as shown in Table IV . Variation of sign provides flexibility to create shortest trajectories, as shown in Figs. 21 and 22 .
Fig. 22.

Successful paths for complex indoor environment.

Show All
TABLE IV Environment Maps and Simulation Parameters of Fig. 22

One of the most difficult scenarios for existing path planning algorithms are the maps with corridors, and the next example shows the advantages of the proposed methodology.

Fig. 23 shows the ability of the proposed methodology for finding successful paths in few steps for sceneries with corridors. For this environment map, the proposed methodology takes only 80 steps to reach goal point. The positions and size of the obstacles in the map are presented in Table V .
Fig. 23.

Successful path in sceneries with corridors.

Show All
TABLE V Environment Maps and Simulation Parameters of Fig. 19

D. Performance Simulation and Comparisons for Personal Computer

In order to test the robustness of this method, tests for 20 maps that contained only circular obstacles were performed. Radius and centers of the obstacles are randomly chosen into a normalized space. The maximum radius of the obstacles is 0.05 and the minimum is 0.002. The first 20 maps correspond to 10–200 obstacles with increments of 10 obstacles. For this paper, we have implemented the methodology in a personal computer (PC) (see Table VII ) using C++ and Maple. Table VI shows the simulation parameters used. Fig. 24 shows a graph with computing time obtained versus the number of obstacles in the map for the two programming languages.
Fig. 24.

Computing time of simulations versus number of circular obstacles. (a) PC C++. (b) Maple 13 and ARM.

Show All
TABLE VI Simulation Parameters
TABLE VII Main Features of ARM Development Board and PC Used to Perform Simulations Both Using 32 b

On the one hand, in general terms, Fig. 24 shows a remarkable decrease in computing time for the methodology when implemented in C++. On the other hand, Fig. 24(a) shows that the variable radius exhibits a better performance than the fixed radius strategy. In addition, Fig. 25 shows the homotopy paths obtained on Maple and C++ for a particular scenario composed by 200 circular obstacles. As expected, both trajectories are equal, but the computing time for the C++ code is significantly lower.
Fig. 25.

Collision-free path for a map with 200 circular obstacles. (a) Methodology in Maple. (b) Methodology in C++.

Show All

E. 32-b Microcontroller Test

Considering the implementation of the methodology in small robots, we implemented a version of the methodology in C++. Then, we made tests in a development card that integrates a 32-b ARM microcontroller. The main features of the development card are presented in Table VII . A methodology in ARM platform capable of handling maps with 200 circular obstacles was implemented. Fig. 26 shows the small dimensions of the development card used in the tests. The total time calculation versus the number of obstacles for the methodology with variable radius implemented in Maple 13 and ARM microcontroller embedded system is presented in Fig. 24(b) . In Fig. 24(b) , a significant improvement of calculation time for the ARM microcontroller with respect to the methodology implemented in Maple 13 is shown. This is an interesting result, considering that Maple runs into a PC with high resources and the C++ code was deployed into low-resource embedded system (see Table VII for a comparison).
Fig. 26.

Development card used in the tests.

Show All

Similarly, the methods implemented in Maple 13 and C++ are considered the parameters shown in Table VI . Fig. 27 shows successful homotopy path configuration found by the methodology implemented in a microcontroller for 200 obstacles.
Fig. 27.

Collision-free path for 200 obstacles. Points scored by the methodology implemented in microcontroller.

Show All

The microcontroller was tested using 200 obstacles, resulting in a collision-free path depicted in Fig. 27 . Such a path is the same as the ones obtained using PC test of Maple and C++, depicted in Fig. 25 . Therefore, the microcontroller implementation using C++ is an effective and viable option for embedded systems. Table VII presents the main features of the development card that make this an attractive platform for small robots.
F. Pioneer 3-DX Simulation

In order to prove the effectiveness of methodology for real robots, we developed a series of simulations in MobileSim (robot simulator by Adept MobileRobots) and ROS. MobileSim is a software that considers the holonomic and physics restrictions of a real robot, and the results are very reliable. For this paper, we propose to use a robot Pioneer 3P-DX that is a common robot on academic and research fields. Pioneer 3P-DX is a differential-drive mobile robot, and its displacement depends only on linear velocity v(t) and angular velocity w(t) , as depicted in Fig. 28 . The interesting characteristics of Pioneer 3-DX are depicted in Table VIII .
Fig. 28.

Holonomic restrictions for the robot Pioneer 3-DX. (a) Pioneer 3-DX. (b) Path following by differential-drive mobile robot.

Show All
TABLE VIII Interesting Features of the Robot Pioneer 3-DX

The linear displacement is calculated using the Euclidean distance ( d_{\mathrm{ lin}} ) between two points of the path; in a similar form, we can calculate angular displacement using the difference ( d_{\mathrm{ ang}} ) between two angles with respect to each linear displacement vector, as shown in Fig. 29(a) and (b) , respectively. In general, the linear and angular displacements are calculated as follows: \begin{align} d_{\mathrm{ lin}}=&\sqrt {(x_{i}-x_{i-1})^{2}+(y_{i}-y_{i-1})^{2}} \\ d_{\mathrm{ ang}}=&\phi _{2}-\phi _{1};\quad \phi _{i}=\arctan \left ({\frac {y_{i}-y_{i-1}}{x_{i}-x_{i-1}}}\right) \end{align}
View Source Right-click on figure for MathML and additional features. \begin{align} d_{\mathrm{ lin}}=&\sqrt {(x_{i}-x_{i-1})^{2}+(y_{i}-y_{i-1})^{2}} \\ d_{\mathrm{ ang}}=&\phi _{2}-\phi _{1};\quad \phi _{i}=\arctan \left ({\frac {y_{i}-y_{i-1}}{x_{i}-x_{i-1}}}\right) \end{align} where (x_{i},y_{i}) is a point of the successful path \gamma _{0} .

Fig. 29.

Linear and angular displacements of a differential-drive mobile robot for the first steps. (a) Linear displacement. (b) Angular displacement.

Show All

Fig. 30(a) and (b) shows the simulations from MobileSim using the parameters of Pioneer 3-DX. For these simulations, we created a ROS package that is responsible for reading the points from the path and interpreting the data for the robot considering the holonomic restrictions.
Fig. 30.

Pioneer 3-DX simulations using MobileSim and ROS for indoor and open environments. (a) Pioneer 3-DX simulation for indoor environment. (b) Pioneer 3-DX simulation for an open environment with 200 obstacles.

Show All

Fig. 30(a) shows the same trajectory for the path \lambda _{0,2} in Fig. 22 . For this simulation, we consider the radius robot in the dimensions of each obstacle in the map and the indoor scenario is a square room of 20 m per side. The straight lines are the same, but the start point is A=(6,2) and goal point is B=(19,13) ; the units are in meters. In the other side, Fig. 30(b) shows the same trajectory for the successful path in Fig. 25 . The normalized area represents a square field of 20 m per side with A=(0,0) and B=(20,20) ; also the dimensions of the robot were considered for each obstacle.
SECTION VIII.
Comparative Performance Against Existing Algorithms

In order to show the advantages of the proposed methodology against SBP and BUG2 algorithms, we have proposed two case studies. For these cases, we used a PC whose characteristics are described in Table VII under Linux OS. The sampling-based planner algorithms were performed using the open motion library presented in [38] , and planner arena (presented in [39] ) was used to analyze the benchmark data. The Bug2 algorithm was tested using the Robotics Toolbox and MATLAB 2014b reported in [40] . On the other hand, the proposed methodology was tested using our C++ implementation. In order to unify the conditions for different simulation tools, the robot was considered as holonomic and the work space was normalized.

Fig. 31 shows the successful solution paths for each algorithm for two indoor environment maps. Both maps have been designed in order to test the robustness and efficiency of each algorithm. Fig. 31 shows the successful solution paths for each algorithm for two indoor environment maps. We can conclude in both maps that the KPIECE1 and EST are inefficient to obtain a shortest path. On the other hand, HPPM, RRTstar, and PRM show a better performance, being the RRTstar the best in terms of shortest path. The Bug2 algorithm obtains a good solution for map 2, but for map 1, it is inefficient. A fuller analysis of the performance of the algorithms is presented in the following comparative graphs to which 100 runs for each BSP algorithms are performed. Because EHPPM and Bug2 are deterministic nature, it was not necessary to make the same number of runs. For BSP algorithms, we use the default parameter configuration and 10 s of time limit.
Fig. 31.

Comparison of solution paths for sampling-based algorithms, BUG2, and EHPPM for two environment maps. (a) Indoor environment map 1. (b) Indoor environment map 2.

Show All

The minimum and maximum values in Figs. 32 and 33 for computing time and solution length are located at the ends of the thin line. On the one hand, Figs. 32(a) and 33(a) show the computing time for the eight algorithms. Note that for Bug2 algorithm, the spend computing time is lower (approximately 200 ms) for two study cases. For the BSPs, the minimum computing time is obtained by KPIECE1, 0.4821 and 1.0334 s for map 1 and map 2, respectively. However, for the most of BSP algorithms, the computing time is located between 1 and 10 s. RRTstar consumes all the time due to the process of optimizing the path length it contains, whereas for EHPPM, the computing time for map 1 is 27.3 ms and for map 2 is 28.4 ms. That indicates that the EHPPM implementation is dozens of times faster than the best time of BSP and hundreds of times faster than the normal time of a BSP algorithm. Figs. 32(b) and 33(b) present the path length for each planner. For EHPPM and Bug2, the length is constant unlike some of SBPs. The most inefficient are the EST and KPIECE1, and the shortest path was found by RRTstar algorithm. In this graphs, we can observe that the length of the EHPPM path is close to the shortest and is the second shortest. On the other hand, Figs. 32(c) and 33(c) represent the total of successful solution paths from initial to goal points for each algorithm in the limit time. During the EHPPM simulations, ten reversal problems were detected and solved for map 1 and 18 for map 2, i.e., the strategy to correct reversal guaranteed the success of the EHPPM.
Fig. 32.

Comparative results for map 1 after 100 runs for each BSP algorithm. (a) Computing time. (b) Path length. (c) Successful paths.

Show All
Fig. 33.

Comparative results for map 2 after 100 runs for each BSP algorithm. (a) Computing time. (b) Path length. (c) Successful paths.

Show All

SECTION IX.
Discussion and Future Work

The main results of this paper can be described as follows.

    It is possible to modify the homotopy trajectory by changing the value and sign of the repulsion parameters and the slope of the auxiliary straight lines. On the one side, we present the use of negative and positive obstacle repulsion parameters to construct homotopy curves that cross between two neighboring obstacles. This characteristic was not presented in the original method in which the homotopy curve is restricted only to cross under or lower a neighboring obstacles’ set [1] . This characteristic allows the EHPPM to be successful to environment maps with narrow corridors. On the other side, we experimentally presented the relationship among the value of the slopes of the straight lines and the shape of the trajectory, which performs better in terms of length for m_{1}=1 and m_{2}=4 .

    In general terms, we presented a modified hypersphere technique to trace the homotopy paths from EHPPM. The performance tests for C++ and Maple in PC and C++ for a microcontroller exhibit the power of the proposed methodology. On the one side, the C++ for PC presented a high performance in the order of milliseconds even for 200 obstacles. On the other side, the C++ for ARM platform presents low to moderate simulation times for even 200 obstacles. However, for local maps with less than 20 obstacles, the ARM implementation shows a good performance in terms of time, less than 1 s of execution time, i.e., it is proper for real applications despite its low computational resources. Considering the results, the Maple implementation is a poor implementation that can be discarded for practical implementations.

    We presented a new strategy to avoid the reversion phenomenon that is based on a rotation scheme using an auxiliary plane related to H_{1} . Such strategy proves to be efficient and reliable through all the case studies of this paper.

    For the first time, we presented the EHPPM methodology as path planner for indoor environments, which is used to solve local maps.

    The simulations for a Pioneer 3-DX show the potential of this methodology for real applications in academic and research activities.

    As expected, the simulation allows us to conclude that the total computation time is affected by the complexity of the environment map. In fact, the computation time for each iteration of the N-R method during the correction step depends on the number of obstacles in the environment. This can be understood if we remember that the N-R method needs the calculation of the Jacobian of the system, which increases its size depending on the number of obstacles. The dependence of each N-R iteration with respect to the number of obstacles is shown in Fig. 34(a) and (b) . For the methodology in C++ language and implemented in PC and ARM microcontroller, the graph shows a linear dependence. Such linear dependency is not clear for Maple 13 mainly due to the complexity of its internal symbolic/numeric motor and JAVA performance issues. However, it can be said that the proposed methodology in C++ language has a linear dependence with respect to the number of obstacles.

    Comparative graphs in the previous section show that our proposed methodology is hundreds of times faster than the BSP algorithms and also the length of the path found is the second shortest path. Besides, the EHPPM computing time tends to grow linearly according to the number of obstacles, whereas BSP algorithms grow according to the number of nodes. In the same way, BSP uses smoothing and collision checker schemes, which implies a greater computing time. On the other hand, we can deduce that the correction reversal technique and SA make HPPM a very useful troubleshooting tool for route planning without greatly affecting the computing time.

    Further work is necessary to optimize the Jacobian matrix inverse calculation using numerical and iterative strategies like lower and upper triangular matrix decomposition (LU) and iterative LU.

Fig. 34.

Computation time for each iteration of N-R for each map of obstacles. (a) Computing time per N-R iteration versus number of circular obstacles for PC C++ language. (b) Computing time per N-R iteration versus number of circular obstacles for methodology in Maple 13 and ARM microcontroller.

Show All

Further work is required to improve the reliability and speed of the proposed tracking algorithm for the EHPPM method. Among the main roads to follow, we can mention the following.

    Obtaining optimal paths also depends on the value of the repulsion parameters of each obstacle. Then, a preplanning stage could designate if the path must pass over or under the obstacle. This algorithm should be capable of assigning a sign to each repulsion parameter depending on the size, position with respect to a straight line from A to B , and proximity with the neighboring obstacles.

    The optimal path is sometimes the shortest. However, it is important to correlate the shape of the path with the holonomic restrictions of real robots. It means that a given path can or cannot be followed by a real robot depending on its mechanical constraints.

    In some cases, as the one in Fig. 35(a) , it is not efficient to follow the behavior of the direct path and a more relaxed curve is required, as shown in Fig. 35(b) . To do this, it is necessary to develop an algorithm that allows choosing the slope values of the auxiliary straight lines.

    The computation times in the microcontroller are insufficient for real-time environments. Furthermore, as future work, the implementation of a simultaneous localization and mapping (SLAM) algorithm is proposed to improve the computing time in the EHPPM. Having a preplanned path A to B , the SLAM algorithm could build a map of obstacles while the robot moves to the target point B [41] .

    It is important to propose improved methods for the predictor step and variable radius, in order to reduce the number of steps even more during the tracking without causing jumps to isolated curves/branches. This can lead to reduction in the computation time.

Fig. 35.

Influence of the straight lines in the successful trajectory. (a) Successful trajectory for m_{1}=1 and m_{2}=4 . (b) Successful trajectory for m_{1}=0.1 and m_{2}=0.01 .

Show All

SECTION X.
Conclusion

In this paper, a modified hyperspherical path following technique was presented to track the homotopy curves of an HPPM. The results show that this implementation is fast enough to be used in real-time applications (milliseconds) using PC of relative low resources. In addition, an implementation into an embedded system exhibits the great potential to construct hardware modules for path planning in reduced spaces. An empirical study of each parameter that affects the behavior of the homotopy path was presented, and an optimal value for them is proposed. An effective strategy to solve the reversal effect and to reduce the number of iterations in the corrector scheme was also proposed. We report the results obtained in multiple software platforms that validate the effectiveness of the methodology. Finally, the comparative results shows that the proposed methodology is faster than some SBP algorithms and the solution path is close to the shortest.
SECTION XI.
Disclosure Policy

The authors declare that there is no conflict of interests regarding the publication of this paper.

Authors
Figures
References
Citations
Keywords
Metrics
More Like This
A review on indoor human aware autonomous mobile robot navigation through a dynamic environment survey of different path planning algorithm and methods

2015 International Conference on Industrial Instrumentation and Control (ICIC)

Published: 2015
Global path planning and navigation of an omnidirectional Mecanum mobile robot

2013 CACS International Automatic Control Conference (CACS)

Published: 2013
Show More
References
References is not available for this document.
IEEE Personal Account

    Change username/password 

Purchase Details

    Payment Options
    View Purchased Documents 

Profile Information

    Communications Preferences
    Profession and Education
    Technical interests 

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support 

Follow

About IEEE Xplore | Contact Us | Help | Accessibility | Terms of Use | Nondiscrimination Policy | IEEE Ethics Reporting | Sitemap | Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.

© Copyright 2022 IEEE - All rights reserved.
IEEE Account

    Change Username/Password
    Update Address

Purchase Details

    Payment Options
    Order History
    View Purchased Documents

Profile Information

    Communications Preferences
    Profession and Education
    Technical Interests

Need Help?

    US & Canada: +1 800 678 4333
    Worldwide: +1 732 981 0060
    Contact & Support

    About IEEE Xplore
    Contact Us
    Help
    Accessibility
    Terms of Use
    Nondiscrimination Policy
    Sitemap
    Privacy & Opting Out of Cookies

A not-for-profit organization, IEEE is the world's largest technical professional organization dedicated to advancing technology for the benefit of humanity.
© Copyright 2022 IEEE - All rights reserved. Use of this web site signifies your agreement to the terms and conditions.
